//
// Copyright (c) 2017 Joey <majunjiev@gmail.com>.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package ovirtsdk

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

//
//
type followService struct {
	baseService
}

func NewFollowService(connection *Connection, path string) *followService {
	var result followService
	result.connection = connection
	result.path = path
	return &result
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *followService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *followService) String() string {
	return fmt.Sprintf("followService:%s", op.path)
}

//
// A service to manage jobs.
//
type jobsService struct {
	baseService
}

func NewJobsService(connection *Connection, path string) *jobsService {
	var result jobsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add an external job.
// For example, to add a job with the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs
// ----
// With the following request body:
// [source,xml]
// ----
// <job>
//   <description>Doing some work</description>
//   <auto_cleared>true</auto_cleared>
// </job>
// ----
// The response should look like:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Doing some work</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <external>true</external>
//   <last_updated>2016-12-13T02:15:42.130+02:00</last_updated>
//   <start_time>2016-12-13T02:15:42.130+02:00</start_time>
//   <status>started</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
type jobsServiceAddRequest struct {
	jobsService *jobsService
	header      map[string]string
	query       map[string]string
	job         *Job
}

func (p *jobsServiceAddRequest) Header(key, value string) *jobsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *jobsServiceAddRequest) Query(key, value string) *jobsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *jobsServiceAddRequest) Job(job *Job) *jobsServiceAddRequest {
	p.job = job
	return p
}

func (p *jobsServiceAddRequest) Send() (*jobsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.jobsService.connection.URL(), p.jobsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLJobWriteOne(writer, p.job, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.jobsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.jobsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLJobReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &jobsServiceAddResponse{job: result}, nil
}

func (p *jobsServiceAddRequest) MustSend() *jobsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.jobsService.connection.URL(), p.jobsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLJobWriteOne(writer, p.job, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.jobsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.jobsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLJobReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &jobsServiceAddResponse{job: result}
}

//
// Add an external job.
// For example, to add a job with the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs
// ----
// With the following request body:
// [source,xml]
// ----
// <job>
//   <description>Doing some work</description>
//   <auto_cleared>true</auto_cleared>
// </job>
// ----
// The response should look like:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Doing some work</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <external>true</external>
//   <last_updated>2016-12-13T02:15:42.130+02:00</last_updated>
//   <start_time>2016-12-13T02:15:42.130+02:00</start_time>
//   <status>started</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
type jobsServiceAddResponse struct {
	job *Job
}

func (p *jobsServiceAddResponse) Job() (*Job, bool) {
	if p.job != nil {
		return p.job, true
	}
	return nil, false
}

func (p *jobsServiceAddResponse) MustJob() *Job {
	if p.job == nil {
		panic("job in response does not exist")
	}
	return p.job
}

//
// Add an external job.
// For example, to add a job with the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs
// ----
// With the following request body:
// [source,xml]
// ----
// <job>
//   <description>Doing some work</description>
//   <auto_cleared>true</auto_cleared>
// </job>
// ----
// The response should look like:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Doing some work</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <external>true</external>
//   <last_updated>2016-12-13T02:15:42.130+02:00</last_updated>
//   <start_time>2016-12-13T02:15:42.130+02:00</start_time>
//   <status>started</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
func (p *jobsService) Add() *jobsServiceAddRequest {
	return &jobsServiceAddRequest{jobsService: p}
}

//
// Retrieves the representation of the jobs.
// [source]
// ----
// GET /ovirt-engine/api/jobs
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <jobs>
//   <job href="/ovirt-engine/api/jobs/123" id="123">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//       <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//     </actions>
//     <description>Adding Disk</description>
//     <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//     <auto_cleared>true</auto_cleared>
//     <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//     <external>false</external>
//     <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//     <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//     <status>failed</status>
//     <owner href="/ovirt-engine/api/users/456" id="456"/>
//   </job>
//   ...
// </jobs>
// ----
// The order of the returned list of jobs isn't guaranteed.
//
type jobsServiceListRequest struct {
	jobsService   *jobsService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	follow        *string
	max           *int64
	search        *string
}

func (p *jobsServiceListRequest) Header(key, value string) *jobsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *jobsServiceListRequest) Query(key, value string) *jobsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *jobsServiceListRequest) CaseSensitive(caseSensitive bool) *jobsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *jobsServiceListRequest) Follow(follow string) *jobsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *jobsServiceListRequest) Max(max int64) *jobsServiceListRequest {
	p.max = &max
	return p
}

func (p *jobsServiceListRequest) Search(search string) *jobsServiceListRequest {
	p.search = &search
	return p
}

func (p *jobsServiceListRequest) Send() (*jobsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.jobsService.connection.URL(), p.jobsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.jobsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.jobsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLJobReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &jobsServiceListResponse{jobs: result}, nil
}

func (p *jobsServiceListRequest) MustSend() *jobsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.jobsService.connection.URL(), p.jobsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.jobsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.jobsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLJobReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &jobsServiceListResponse{jobs: result}
}

//
// Retrieves the representation of the jobs.
// [source]
// ----
// GET /ovirt-engine/api/jobs
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <jobs>
//   <job href="/ovirt-engine/api/jobs/123" id="123">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//       <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//     </actions>
//     <description>Adding Disk</description>
//     <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//     <auto_cleared>true</auto_cleared>
//     <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//     <external>false</external>
//     <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//     <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//     <status>failed</status>
//     <owner href="/ovirt-engine/api/users/456" id="456"/>
//   </job>
//   ...
// </jobs>
// ----
// The order of the returned list of jobs isn't guaranteed.
//
type jobsServiceListResponse struct {
	jobs *JobSlice
}

func (p *jobsServiceListResponse) Jobs() (*JobSlice, bool) {
	if p.jobs != nil {
		return p.jobs, true
	}
	return nil, false
}

func (p *jobsServiceListResponse) MustJobs() *JobSlice {
	if p.jobs == nil {
		panic("jobs in response does not exist")
	}
	return p.jobs
}

//
// Retrieves the representation of the jobs.
// [source]
// ----
// GET /ovirt-engine/api/jobs
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <jobs>
//   <job href="/ovirt-engine/api/jobs/123" id="123">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//       <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//     </actions>
//     <description>Adding Disk</description>
//     <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//     <auto_cleared>true</auto_cleared>
//     <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//     <external>false</external>
//     <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//     <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//     <status>failed</status>
//     <owner href="/ovirt-engine/api/users/456" id="456"/>
//   </job>
//   ...
// </jobs>
// ----
// The order of the returned list of jobs isn't guaranteed.
//
func (p *jobsService) List() *jobsServiceListRequest {
	return &jobsServiceListRequest{jobsService: p}
}

//
// Reference to the job service.
//
func (op *jobsService) JobService(id string) *jobService {
	return NewJobService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *jobsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.JobService(path), nil
	}
	return op.JobService(path[:index]).Service(path[index+1:])
}

func (op *jobsService) String() string {
	return fmt.Sprintf("jobsService:%s", op.path)
}

//
// A service to manage data centers.
//
type dataCentersService struct {
	baseService
}

func NewDataCentersService(connection *Connection, path string) *dataCentersService {
	var result dataCentersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new data center.
// Creation of a new data center requires the `name` and `local` elements. For example, to create a data center
// named `mydc` that uses shared storage (NFS, iSCSI or fibre channel) send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>mydc</name>
//   <local>false</local>
// </data_center>
// ----
//
type dataCentersServiceAddRequest struct {
	dataCentersService *dataCentersService
	header             map[string]string
	query              map[string]string
	dataCenter         *DataCenter
}

func (p *dataCentersServiceAddRequest) Header(key, value string) *dataCentersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *dataCentersServiceAddRequest) Query(key, value string) *dataCentersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *dataCentersServiceAddRequest) DataCenter(dataCenter *DataCenter) *dataCentersServiceAddRequest {
	p.dataCenter = dataCenter
	return p
}

func (p *dataCentersServiceAddRequest) Send() (*dataCentersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCentersService.connection.URL(), p.dataCentersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDataCenterWriteOne(writer, p.dataCenter, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCentersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCentersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDataCenterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &dataCentersServiceAddResponse{dataCenter: result}, nil
}

func (p *dataCentersServiceAddRequest) MustSend() *dataCentersServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.dataCentersService.connection.URL(), p.dataCentersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDataCenterWriteOne(writer, p.dataCenter, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCentersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCentersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDataCenterReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &dataCentersServiceAddResponse{dataCenter: result}
}

//
// Creates a new data center.
// Creation of a new data center requires the `name` and `local` elements. For example, to create a data center
// named `mydc` that uses shared storage (NFS, iSCSI or fibre channel) send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>mydc</name>
//   <local>false</local>
// </data_center>
// ----
//
type dataCentersServiceAddResponse struct {
	dataCenter *DataCenter
}

func (p *dataCentersServiceAddResponse) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *dataCentersServiceAddResponse) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("dataCenter in response does not exist")
	}
	return p.dataCenter
}

//
// Creates a new data center.
// Creation of a new data center requires the `name` and `local` elements. For example, to create a data center
// named `mydc` that uses shared storage (NFS, iSCSI or fibre channel) send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>mydc</name>
//   <local>false</local>
// </data_center>
// ----
//
func (p *dataCentersService) Add() *dataCentersServiceAddRequest {
	return &dataCentersServiceAddRequest{dataCentersService: p}
}

//
// Lists the data centers.
// The following request retrieves a representation of the data centers:
// [source]
// ----
// GET /ovirt-engine/api/datacenters
// ----
// The above request performed with `curl`:
// [source,bash]
// ----
// curl \
// --request GET \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --header "Version: 4" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// https://myengine.example.com/ovirt-engine/api/datacenters
// ----
// This is what an example response could look like:
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//     </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
// </data_center>
// ----
// Note the `id` code of your `Default` data center. This code identifies this data center in relation to other
// resources of your virtual environment.
// The data center also contains a link to the storage domains collection. The data center uses this collection to
// attach storage domains from the storage domains main collection.
// The order of the returned list of data centers is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type dataCentersServiceListRequest struct {
	dataCentersService *dataCentersService
	header             map[string]string
	query              map[string]string
	caseSensitive      *bool
	filter             *bool
	follow             *string
	max                *int64
	search             *string
}

func (p *dataCentersServiceListRequest) Header(key, value string) *dataCentersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *dataCentersServiceListRequest) Query(key, value string) *dataCentersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *dataCentersServiceListRequest) CaseSensitive(caseSensitive bool) *dataCentersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *dataCentersServiceListRequest) Filter(filter bool) *dataCentersServiceListRequest {
	p.filter = &filter
	return p
}

func (p *dataCentersServiceListRequest) Follow(follow string) *dataCentersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *dataCentersServiceListRequest) Max(max int64) *dataCentersServiceListRequest {
	p.max = &max
	return p
}

func (p *dataCentersServiceListRequest) Search(search string) *dataCentersServiceListRequest {
	p.search = &search
	return p
}

func (p *dataCentersServiceListRequest) Send() (*dataCentersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCentersService.connection.URL(), p.dataCentersService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCentersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCentersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDataCenterReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &dataCentersServiceListResponse{dataCenters: result}, nil
}

func (p *dataCentersServiceListRequest) MustSend() *dataCentersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.dataCentersService.connection.URL(), p.dataCentersService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCentersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCentersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDataCenterReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &dataCentersServiceListResponse{dataCenters: result}
}

//
// Lists the data centers.
// The following request retrieves a representation of the data centers:
// [source]
// ----
// GET /ovirt-engine/api/datacenters
// ----
// The above request performed with `curl`:
// [source,bash]
// ----
// curl \
// --request GET \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --header "Version: 4" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// https://myengine.example.com/ovirt-engine/api/datacenters
// ----
// This is what an example response could look like:
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//     </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
// </data_center>
// ----
// Note the `id` code of your `Default` data center. This code identifies this data center in relation to other
// resources of your virtual environment.
// The data center also contains a link to the storage domains collection. The data center uses this collection to
// attach storage domains from the storage domains main collection.
// The order of the returned list of data centers is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type dataCentersServiceListResponse struct {
	dataCenters *DataCenterSlice
}

func (p *dataCentersServiceListResponse) DataCenters() (*DataCenterSlice, bool) {
	if p.dataCenters != nil {
		return p.dataCenters, true
	}
	return nil, false
}

func (p *dataCentersServiceListResponse) MustDataCenters() *DataCenterSlice {
	if p.dataCenters == nil {
		panic("dataCenters in response does not exist")
	}
	return p.dataCenters
}

//
// Lists the data centers.
// The following request retrieves a representation of the data centers:
// [source]
// ----
// GET /ovirt-engine/api/datacenters
// ----
// The above request performed with `curl`:
// [source,bash]
// ----
// curl \
// --request GET \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --header "Version: 4" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// https://myengine.example.com/ovirt-engine/api/datacenters
// ----
// This is what an example response could look like:
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//     </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
// </data_center>
// ----
// Note the `id` code of your `Default` data center. This code identifies this data center in relation to other
// resources of your virtual environment.
// The data center also contains a link to the storage domains collection. The data center uses this collection to
// attach storage domains from the storage domains main collection.
// The order of the returned list of data centers is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
func (p *dataCentersService) List() *dataCentersServiceListRequest {
	return &dataCentersServiceListRequest{dataCentersService: p}
}

//
// Reference to the service that manages a specific data center.
//
func (op *dataCentersService) DataCenterService(id string) *dataCenterService {
	return NewDataCenterService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *dataCentersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DataCenterService(path), nil
	}
	return op.DataCenterService(path[:index]).Service(path[index+1:])
}

func (op *dataCentersService) String() string {
	return fmt.Sprintf("dataCentersService:%s", op.path)
}

//
//
type permissionService struct {
	baseService
}

func NewPermissionService(connection *Connection, path string) *permissionService {
	var result permissionService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type permissionServiceGetRequest struct {
	permissionService *permissionService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *permissionServiceGetRequest) Header(key, value string) *permissionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *permissionServiceGetRequest) Query(key, value string) *permissionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *permissionServiceGetRequest) Follow(follow string) *permissionServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *permissionServiceGetRequest) Send() (*permissionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permissionService.connection.URL(), p.permissionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.permissionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.permissionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &permissionServiceGetResponse{permission: result}, nil
}

func (p *permissionServiceGetRequest) MustSend() *permissionServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.permissionService.connection.URL(), p.permissionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.permissionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.permissionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &permissionServiceGetResponse{permission: result}
}

//
//
type permissionServiceGetResponse struct {
	permission *Permission
}

func (p *permissionServiceGetResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *permissionServiceGetResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
//
func (p *permissionService) Get() *permissionServiceGetRequest {
	return &permissionServiceGetRequest{permissionService: p}
}

//
//
type permissionServiceRemoveRequest struct {
	permissionService *permissionService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *permissionServiceRemoveRequest) Header(key, value string) *permissionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *permissionServiceRemoveRequest) Query(key, value string) *permissionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *permissionServiceRemoveRequest) Async(async bool) *permissionServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *permissionServiceRemoveRequest) Send() (*permissionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permissionService.connection.URL(), p.permissionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.permissionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.permissionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(permissionServiceRemoveResponse), nil
}

func (p *permissionServiceRemoveRequest) MustSend() *permissionServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.permissionService.connection.URL(), p.permissionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.permissionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.permissionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(permissionServiceRemoveResponse)
}

//
//
type permissionServiceRemoveResponse struct {
}

//
//
func (p *permissionService) Remove() *permissionServiceRemoveRequest {
	return &permissionServiceRemoveRequest{permissionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *permissionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *permissionService) String() string {
	return fmt.Sprintf("permissionService:%s", op.path)
}

//
//
type storageService struct {
	baseService
}

func NewStorageService(connection *Connection, path string) *storageService {
	var result storageService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type storageServiceGetRequest struct {
	storageService *storageService
	header         map[string]string
	query          map[string]string
	follow         *string
	reportStatus   *bool
}

func (p *storageServiceGetRequest) Header(key, value string) *storageServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServiceGetRequest) Query(key, value string) *storageServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServiceGetRequest) Follow(follow string) *storageServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *storageServiceGetRequest) ReportStatus(reportStatus bool) *storageServiceGetRequest {
	p.reportStatus = &reportStatus
	return p
}

func (p *storageServiceGetRequest) Send() (*storageServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageService.connection.URL(), p.storageService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.reportStatus != nil {
		values["report_status"] = []string{fmt.Sprintf("%v", *p.reportStatus)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostStorageReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageServiceGetResponse{storage: result}, nil
}

func (p *storageServiceGetRequest) MustSend() *storageServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageService.connection.URL(), p.storageService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.reportStatus != nil {
		values["report_status"] = []string{fmt.Sprintf("%v", *p.reportStatus)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostStorageReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageServiceGetResponse{storage: result}
}

//
//
type storageServiceGetResponse struct {
	storage *HostStorage
}

func (p *storageServiceGetResponse) Storage() (*HostStorage, bool) {
	if p.storage != nil {
		return p.storage, true
	}
	return nil, false
}

func (p *storageServiceGetResponse) MustStorage() *HostStorage {
	if p.storage == nil {
		panic("storage in response does not exist")
	}
	return p.storage
}

//
//
func (p *storageService) Get() *storageServiceGetRequest {
	return &storageServiceGetRequest{storageService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *storageService) String() string {
	return fmt.Sprintf("storageService:%s", op.path)
}

//
// A service to manage collection of assignment of tags to specific entities in system.
//
type assignedTagsService struct {
	baseService
}

func NewAssignedTagsService(connection *Connection, path string) *assignedTagsService {
	var result assignedTagsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Assign tag to specific entity in the system.
// For example to assign tag `mytag` to virtual machine with the id `123` send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
//
type assignedTagsServiceAddRequest struct {
	assignedTagsService *assignedTagsService
	header              map[string]string
	query               map[string]string
	tag                 *Tag
}

func (p *assignedTagsServiceAddRequest) Header(key, value string) *assignedTagsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedTagsServiceAddRequest) Query(key, value string) *assignedTagsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedTagsServiceAddRequest) Tag(tag *Tag) *assignedTagsServiceAddRequest {
	p.tag = tag
	return p
}

func (p *assignedTagsServiceAddRequest) Send() (*assignedTagsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagsService.connection.URL(), p.assignedTagsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTagWriteOne(writer, p.tag, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedTagsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedTagsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &assignedTagsServiceAddResponse{tag: result}, nil
}

func (p *assignedTagsServiceAddRequest) MustSend() *assignedTagsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagsService.connection.URL(), p.assignedTagsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTagWriteOne(writer, p.tag, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedTagsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedTagsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &assignedTagsServiceAddResponse{tag: result}
}

//
// Assign tag to specific entity in the system.
// For example to assign tag `mytag` to virtual machine with the id `123` send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
//
type assignedTagsServiceAddResponse struct {
	tag *Tag
}

func (p *assignedTagsServiceAddResponse) Tag() (*Tag, bool) {
	if p.tag != nil {
		return p.tag, true
	}
	return nil, false
}

func (p *assignedTagsServiceAddResponse) MustTag() *Tag {
	if p.tag == nil {
		panic("tag in response does not exist")
	}
	return p.tag
}

//
// Assign tag to specific entity in the system.
// For example to assign tag `mytag` to virtual machine with the id `123` send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
//
func (p *assignedTagsService) Add() *assignedTagsServiceAddRequest {
	return &assignedTagsServiceAddRequest{assignedTagsService: p}
}

//
// List all tags assigned to the specific entity.
// For example to list all the tags of the virtual machine with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>mytag</name>
//     <description>mytag</description>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </tag>
// </tags>
// ----
// The order of the returned tags isn't guaranteed.
//
type assignedTagsServiceListRequest struct {
	assignedTagsService *assignedTagsService
	header              map[string]string
	query               map[string]string
	follow              *string
	max                 *int64
}

func (p *assignedTagsServiceListRequest) Header(key, value string) *assignedTagsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedTagsServiceListRequest) Query(key, value string) *assignedTagsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedTagsServiceListRequest) Follow(follow string) *assignedTagsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *assignedTagsServiceListRequest) Max(max int64) *assignedTagsServiceListRequest {
	p.max = &max
	return p
}

func (p *assignedTagsServiceListRequest) Send() (*assignedTagsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagsService.connection.URL(), p.assignedTagsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedTagsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedTagsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &assignedTagsServiceListResponse{tags: result}, nil
}

func (p *assignedTagsServiceListRequest) MustSend() *assignedTagsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagsService.connection.URL(), p.assignedTagsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedTagsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedTagsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &assignedTagsServiceListResponse{tags: result}
}

//
// List all tags assigned to the specific entity.
// For example to list all the tags of the virtual machine with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>mytag</name>
//     <description>mytag</description>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </tag>
// </tags>
// ----
// The order of the returned tags isn't guaranteed.
//
type assignedTagsServiceListResponse struct {
	tags *TagSlice
}

func (p *assignedTagsServiceListResponse) Tags() (*TagSlice, bool) {
	if p.tags != nil {
		return p.tags, true
	}
	return nil, false
}

func (p *assignedTagsServiceListResponse) MustTags() *TagSlice {
	if p.tags == nil {
		panic("tags in response does not exist")
	}
	return p.tags
}

//
// List all tags assigned to the specific entity.
// For example to list all the tags of the virtual machine with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>mytag</name>
//     <description>mytag</description>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </tag>
// </tags>
// ----
// The order of the returned tags isn't guaranteed.
//
func (p *assignedTagsService) List() *assignedTagsServiceListRequest {
	return &assignedTagsServiceListRequest{assignedTagsService: p}
}

//
// Reference to the service that manages assignment of specific tag.
//
func (op *assignedTagsService) TagService(id string) *assignedTagService {
	return NewAssignedTagService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *assignedTagsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.TagService(path), nil
	}
	return op.TagService(path[:index]).Service(path[index+1:])
}

func (op *assignedTagsService) String() string {
	return fmt.Sprintf("assignedTagsService:%s", op.path)
}

//
// A service to fetch information elements received by Link Layer Discovery Protocol (LLDP).
//
type linkLayerDiscoveryProtocolService struct {
	baseService
}

func NewLinkLayerDiscoveryProtocolService(connection *Connection, path string) *linkLayerDiscoveryProtocolService {
	var result linkLayerDiscoveryProtocolService
	result.connection = connection
	result.path = path
	return &result
}

//
// Fetches information elements received by LLDP.
//
type linkLayerDiscoveryProtocolServiceListRequest struct {
	linkLayerDiscoveryProtocolService *linkLayerDiscoveryProtocolService
	header                            map[string]string
	query                             map[string]string
	follow                            *string
}

func (p *linkLayerDiscoveryProtocolServiceListRequest) Header(key, value string) *linkLayerDiscoveryProtocolServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *linkLayerDiscoveryProtocolServiceListRequest) Query(key, value string) *linkLayerDiscoveryProtocolServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *linkLayerDiscoveryProtocolServiceListRequest) Follow(follow string) *linkLayerDiscoveryProtocolServiceListRequest {
	p.follow = &follow
	return p
}

func (p *linkLayerDiscoveryProtocolServiceListRequest) Send() (*linkLayerDiscoveryProtocolServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.linkLayerDiscoveryProtocolService.connection.URL(), p.linkLayerDiscoveryProtocolService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.linkLayerDiscoveryProtocolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.linkLayerDiscoveryProtocolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLLinkLayerDiscoveryProtocolElementReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &linkLayerDiscoveryProtocolServiceListResponse{elements: result}, nil
}

func (p *linkLayerDiscoveryProtocolServiceListRequest) MustSend() *linkLayerDiscoveryProtocolServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.linkLayerDiscoveryProtocolService.connection.URL(), p.linkLayerDiscoveryProtocolService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.linkLayerDiscoveryProtocolService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.linkLayerDiscoveryProtocolService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLLinkLayerDiscoveryProtocolElementReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &linkLayerDiscoveryProtocolServiceListResponse{elements: result}
}

//
// Fetches information elements received by LLDP.
//
type linkLayerDiscoveryProtocolServiceListResponse struct {
	elements *LinkLayerDiscoveryProtocolElementSlice
}

func (p *linkLayerDiscoveryProtocolServiceListResponse) Elements() (*LinkLayerDiscoveryProtocolElementSlice, bool) {
	if p.elements != nil {
		return p.elements, true
	}
	return nil, false
}

func (p *linkLayerDiscoveryProtocolServiceListResponse) MustElements() *LinkLayerDiscoveryProtocolElementSlice {
	if p.elements == nil {
		panic("elements in response does not exist")
	}
	return p.elements
}

//
// Fetches information elements received by LLDP.
//
func (p *linkLayerDiscoveryProtocolService) List() *linkLayerDiscoveryProtocolServiceListRequest {
	return &linkLayerDiscoveryProtocolServiceListRequest{linkLayerDiscoveryProtocolService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *linkLayerDiscoveryProtocolService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *linkLayerDiscoveryProtocolService) String() string {
	return fmt.Sprintf("linkLayerDiscoveryProtocolService:%s", op.path)
}

//
// This service doesn't add any new methods, it is just a placeholder for the annotation that specifies the path of the
// resource that manages the permissions assigned to the system object.
//
type systemPermissionsService struct {
	baseService
}

func NewSystemPermissionsService(connection *Connection, path string) *systemPermissionsService {
	var result systemPermissionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
//
type systemPermissionsServiceAddRequest struct {
	systemPermissionsService *systemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *systemPermissionsServiceAddRequest) Header(key, value string) *systemPermissionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemPermissionsServiceAddRequest) Query(key, value string) *systemPermissionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemPermissionsServiceAddRequest) Permission(permission *Permission) *systemPermissionsServiceAddRequest {
	p.permission = permission
	return p
}

func (p *systemPermissionsServiceAddRequest) Send() (*systemPermissionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLPermissionWriteOne(writer, p.permission, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &systemPermissionsServiceAddResponse{permission: result}, nil
}

func (p *systemPermissionsServiceAddRequest) MustSend() *systemPermissionsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLPermissionWriteOne(writer, p.permission, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &systemPermissionsServiceAddResponse{permission: result}
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
//
type systemPermissionsServiceAddResponse struct {
	permission *Permission
}

func (p *systemPermissionsServiceAddResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *systemPermissionsServiceAddResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
//
func (p *systemPermissionsService) Add() *systemPermissionsServiceAddRequest {
	return &systemPermissionsServiceAddRequest{systemPermissionsService: p}
}

//
// Add a new permission on the cluster to the group in the system.
//
type systemPermissionsServiceAddClusterPermissionRequest struct {
	systemPermissionsService *systemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *systemPermissionsServiceAddClusterPermissionRequest) Header(key, value string) *systemPermissionsServiceAddClusterPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemPermissionsServiceAddClusterPermissionRequest) Query(key, value string) *systemPermissionsServiceAddClusterPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemPermissionsServiceAddClusterPermissionRequest) Permission(permission *Permission) *systemPermissionsServiceAddClusterPermissionRequest {
	p.permission = permission
	return p
}

func (p *systemPermissionsServiceAddClusterPermissionRequest) Send() (*systemPermissionsServiceAddClusterPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/clusterpermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddClusterPermissionResponse{permission: result}, nil
}

func (p *systemPermissionsServiceAddClusterPermissionRequest) MustSend() *systemPermissionsServiceAddClusterPermissionResponse {
	rawURL := fmt.Sprintf("%s%s/clusterpermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddClusterPermissionResponse{permission: result}
}

//
// Add a new permission on the cluster to the group in the system.
//
type systemPermissionsServiceAddClusterPermissionResponse struct {
	permission *Permission
}

func (p *systemPermissionsServiceAddClusterPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *systemPermissionsServiceAddClusterPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the cluster to the group in the system.
//
func (p *systemPermissionsService) AddClusterPermission() *systemPermissionsServiceAddClusterPermissionRequest {
	return &systemPermissionsServiceAddClusterPermissionRequest{systemPermissionsService: p}
}

//
// Add a new permission on the data center to the group in the system.
//
type systemPermissionsServiceAddDataCenterPermissionRequest struct {
	systemPermissionsService *systemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *systemPermissionsServiceAddDataCenterPermissionRequest) Header(key, value string) *systemPermissionsServiceAddDataCenterPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemPermissionsServiceAddDataCenterPermissionRequest) Query(key, value string) *systemPermissionsServiceAddDataCenterPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemPermissionsServiceAddDataCenterPermissionRequest) Permission(permission *Permission) *systemPermissionsServiceAddDataCenterPermissionRequest {
	p.permission = permission
	return p
}

func (p *systemPermissionsServiceAddDataCenterPermissionRequest) Send() (*systemPermissionsServiceAddDataCenterPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/datacenterpermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddDataCenterPermissionResponse{permission: result}, nil
}

func (p *systemPermissionsServiceAddDataCenterPermissionRequest) MustSend() *systemPermissionsServiceAddDataCenterPermissionResponse {
	rawURL := fmt.Sprintf("%s%s/datacenterpermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddDataCenterPermissionResponse{permission: result}
}

//
// Add a new permission on the data center to the group in the system.
//
type systemPermissionsServiceAddDataCenterPermissionResponse struct {
	permission *Permission
}

func (p *systemPermissionsServiceAddDataCenterPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *systemPermissionsServiceAddDataCenterPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the data center to the group in the system.
//
func (p *systemPermissionsService) AddDataCenterPermission() *systemPermissionsServiceAddDataCenterPermissionRequest {
	return &systemPermissionsServiceAddDataCenterPermissionRequest{systemPermissionsService: p}
}

//
// Add a new group level permission for a given virtual machine.
//
type systemPermissionsServiceAddGroupLevelRequest struct {
	systemPermissionsService *systemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *systemPermissionsServiceAddGroupLevelRequest) Header(key, value string) *systemPermissionsServiceAddGroupLevelRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemPermissionsServiceAddGroupLevelRequest) Query(key, value string) *systemPermissionsServiceAddGroupLevelRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemPermissionsServiceAddGroupLevelRequest) Permission(permission *Permission) *systemPermissionsServiceAddGroupLevelRequest {
	p.permission = permission
	return p
}

func (p *systemPermissionsServiceAddGroupLevelRequest) Send() (*systemPermissionsServiceAddGroupLevelResponse, error) {
	rawURL := fmt.Sprintf("%s%s/grouplevel", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddGroupLevelResponse{permission: result}, nil
}

func (p *systemPermissionsServiceAddGroupLevelRequest) MustSend() *systemPermissionsServiceAddGroupLevelResponse {
	rawURL := fmt.Sprintf("%s%s/grouplevel", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddGroupLevelResponse{permission: result}
}

//
// Add a new group level permission for a given virtual machine.
//
type systemPermissionsServiceAddGroupLevelResponse struct {
	permission *Permission
}

func (p *systemPermissionsServiceAddGroupLevelResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *systemPermissionsServiceAddGroupLevelResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new group level permission for a given virtual machine.
//
func (p *systemPermissionsService) AddGroupLevel() *systemPermissionsServiceAddGroupLevelRequest {
	return &systemPermissionsServiceAddGroupLevelRequest{systemPermissionsService: p}
}

//
// Add a new permission on the host to the group in the system.
//
type systemPermissionsServiceAddHostPermissionRequest struct {
	systemPermissionsService *systemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *systemPermissionsServiceAddHostPermissionRequest) Header(key, value string) *systemPermissionsServiceAddHostPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemPermissionsServiceAddHostPermissionRequest) Query(key, value string) *systemPermissionsServiceAddHostPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemPermissionsServiceAddHostPermissionRequest) Permission(permission *Permission) *systemPermissionsServiceAddHostPermissionRequest {
	p.permission = permission
	return p
}

func (p *systemPermissionsServiceAddHostPermissionRequest) Send() (*systemPermissionsServiceAddHostPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/hostpermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddHostPermissionResponse{permission: result}, nil
}

func (p *systemPermissionsServiceAddHostPermissionRequest) MustSend() *systemPermissionsServiceAddHostPermissionResponse {
	rawURL := fmt.Sprintf("%s%s/hostpermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddHostPermissionResponse{permission: result}
}

//
// Add a new permission on the host to the group in the system.
//
type systemPermissionsServiceAddHostPermissionResponse struct {
	permission *Permission
}

func (p *systemPermissionsServiceAddHostPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *systemPermissionsServiceAddHostPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the host to the group in the system.
//
func (p *systemPermissionsService) AddHostPermission() *systemPermissionsServiceAddHostPermissionRequest {
	return &systemPermissionsServiceAddHostPermissionRequest{systemPermissionsService: p}
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
// The order of the returned permissions isn't guaranteed.
//
type systemPermissionsServiceListRequest struct {
	systemPermissionsService *systemPermissionsService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *systemPermissionsServiceListRequest) Header(key, value string) *systemPermissionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemPermissionsServiceListRequest) Query(key, value string) *systemPermissionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemPermissionsServiceListRequest) Follow(follow string) *systemPermissionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *systemPermissionsServiceListRequest) Send() (*systemPermissionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &systemPermissionsServiceListResponse{permissions: result}, nil
}

func (p *systemPermissionsServiceListRequest) MustSend() *systemPermissionsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &systemPermissionsServiceListResponse{permissions: result}
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
// The order of the returned permissions isn't guaranteed.
//
type systemPermissionsServiceListResponse struct {
	permissions *PermissionSlice
}

func (p *systemPermissionsServiceListResponse) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *systemPermissionsServiceListResponse) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("permissions in response does not exist")
	}
	return p.permissions
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
// The order of the returned permissions isn't guaranteed.
//
func (p *systemPermissionsService) List() *systemPermissionsServiceListRequest {
	return &systemPermissionsServiceListRequest{systemPermissionsService: p}
}

//
// Add a new permission on the storage domain to the group in the system.
//
type systemPermissionsServiceAddStorageDomainPermissionRequest struct {
	systemPermissionsService *systemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *systemPermissionsServiceAddStorageDomainPermissionRequest) Header(key, value string) *systemPermissionsServiceAddStorageDomainPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemPermissionsServiceAddStorageDomainPermissionRequest) Query(key, value string) *systemPermissionsServiceAddStorageDomainPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemPermissionsServiceAddStorageDomainPermissionRequest) Permission(permission *Permission) *systemPermissionsServiceAddStorageDomainPermissionRequest {
	p.permission = permission
	return p
}

func (p *systemPermissionsServiceAddStorageDomainPermissionRequest) Send() (*systemPermissionsServiceAddStorageDomainPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/storagedomainpermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddStorageDomainPermissionResponse{permission: result}, nil
}

func (p *systemPermissionsServiceAddStorageDomainPermissionRequest) MustSend() *systemPermissionsServiceAddStorageDomainPermissionResponse {
	rawURL := fmt.Sprintf("%s%s/storagedomainpermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddStorageDomainPermissionResponse{permission: result}
}

//
// Add a new permission on the storage domain to the group in the system.
//
type systemPermissionsServiceAddStorageDomainPermissionResponse struct {
	permission *Permission
}

func (p *systemPermissionsServiceAddStorageDomainPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *systemPermissionsServiceAddStorageDomainPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the storage domain to the group in the system.
//
func (p *systemPermissionsService) AddStorageDomainPermission() *systemPermissionsServiceAddStorageDomainPermissionRequest {
	return &systemPermissionsServiceAddStorageDomainPermissionRequest{systemPermissionsService: p}
}

//
// Add a new permission on the template to the group in the system.
//
type systemPermissionsServiceAddTemplatePermissionRequest struct {
	systemPermissionsService *systemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *systemPermissionsServiceAddTemplatePermissionRequest) Header(key, value string) *systemPermissionsServiceAddTemplatePermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemPermissionsServiceAddTemplatePermissionRequest) Query(key, value string) *systemPermissionsServiceAddTemplatePermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemPermissionsServiceAddTemplatePermissionRequest) Permission(permission *Permission) *systemPermissionsServiceAddTemplatePermissionRequest {
	p.permission = permission
	return p
}

func (p *systemPermissionsServiceAddTemplatePermissionRequest) Send() (*systemPermissionsServiceAddTemplatePermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/templatepermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddTemplatePermissionResponse{permission: result}, nil
}

func (p *systemPermissionsServiceAddTemplatePermissionRequest) MustSend() *systemPermissionsServiceAddTemplatePermissionResponse {
	rawURL := fmt.Sprintf("%s%s/templatepermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddTemplatePermissionResponse{permission: result}
}

//
// Add a new permission on the template to the group in the system.
//
type systemPermissionsServiceAddTemplatePermissionResponse struct {
	permission *Permission
}

func (p *systemPermissionsServiceAddTemplatePermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *systemPermissionsServiceAddTemplatePermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the template to the group in the system.
//
func (p *systemPermissionsService) AddTemplatePermission() *systemPermissionsServiceAddTemplatePermissionRequest {
	return &systemPermissionsServiceAddTemplatePermissionRequest{systemPermissionsService: p}
}

//
// Add a new user level permission for a given virtual machine.
//
type systemPermissionsServiceAddUserLevelRequest struct {
	systemPermissionsService *systemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *systemPermissionsServiceAddUserLevelRequest) Header(key, value string) *systemPermissionsServiceAddUserLevelRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemPermissionsServiceAddUserLevelRequest) Query(key, value string) *systemPermissionsServiceAddUserLevelRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemPermissionsServiceAddUserLevelRequest) Permission(permission *Permission) *systemPermissionsServiceAddUserLevelRequest {
	p.permission = permission
	return p
}

func (p *systemPermissionsServiceAddUserLevelRequest) Send() (*systemPermissionsServiceAddUserLevelResponse, error) {
	rawURL := fmt.Sprintf("%s%s/userlevel", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddUserLevelResponse{permission: result}, nil
}

func (p *systemPermissionsServiceAddUserLevelRequest) MustSend() *systemPermissionsServiceAddUserLevelResponse {
	rawURL := fmt.Sprintf("%s%s/userlevel", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddUserLevelResponse{permission: result}
}

//
// Add a new user level permission for a given virtual machine.
//
type systemPermissionsServiceAddUserLevelResponse struct {
	permission *Permission
}

func (p *systemPermissionsServiceAddUserLevelResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *systemPermissionsServiceAddUserLevelResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new user level permission for a given virtual machine.
//
func (p *systemPermissionsService) AddUserLevel() *systemPermissionsServiceAddUserLevelRequest {
	return &systemPermissionsServiceAddUserLevelRequest{systemPermissionsService: p}
}

//
// Add a new permission on the vm to the group in the system.
//
type systemPermissionsServiceAddVmPermissionRequest struct {
	systemPermissionsService *systemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *systemPermissionsServiceAddVmPermissionRequest) Header(key, value string) *systemPermissionsServiceAddVmPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemPermissionsServiceAddVmPermissionRequest) Query(key, value string) *systemPermissionsServiceAddVmPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemPermissionsServiceAddVmPermissionRequest) Permission(permission *Permission) *systemPermissionsServiceAddVmPermissionRequest {
	p.permission = permission
	return p
}

func (p *systemPermissionsServiceAddVmPermissionRequest) Send() (*systemPermissionsServiceAddVmPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/vmpermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddVmPermissionResponse{permission: result}, nil
}

func (p *systemPermissionsServiceAddVmPermissionRequest) MustSend() *systemPermissionsServiceAddVmPermissionResponse {
	rawURL := fmt.Sprintf("%s%s/vmpermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddVmPermissionResponse{permission: result}
}

//
// Add a new permission on the vm to the group in the system.
//
type systemPermissionsServiceAddVmPermissionResponse struct {
	permission *Permission
}

func (p *systemPermissionsServiceAddVmPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *systemPermissionsServiceAddVmPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the vm to the group in the system.
//
func (p *systemPermissionsService) AddVmPermission() *systemPermissionsServiceAddVmPermissionRequest {
	return &systemPermissionsServiceAddVmPermissionRequest{systemPermissionsService: p}
}

//
// Add a new permission on the vm pool to the group in the system.
//
type systemPermissionsServiceAddVmPoolPermissionRequest struct {
	systemPermissionsService *systemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *systemPermissionsServiceAddVmPoolPermissionRequest) Header(key, value string) *systemPermissionsServiceAddVmPoolPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemPermissionsServiceAddVmPoolPermissionRequest) Query(key, value string) *systemPermissionsServiceAddVmPoolPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemPermissionsServiceAddVmPoolPermissionRequest) Permission(permission *Permission) *systemPermissionsServiceAddVmPoolPermissionRequest {
	p.permission = permission
	return p
}

func (p *systemPermissionsServiceAddVmPoolPermissionRequest) Send() (*systemPermissionsServiceAddVmPoolPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/vmpoolpermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddVmPoolPermissionResponse{permission: result}, nil
}

func (p *systemPermissionsServiceAddVmPoolPermissionRequest) MustSend() *systemPermissionsServiceAddVmPoolPermissionResponse {
	rawURL := fmt.Sprintf("%s%s/vmpoolpermission", p.systemPermissionsService.connection.URL(), p.systemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &systemPermissionsServiceAddVmPoolPermissionResponse{permission: result}
}

//
// Add a new permission on the vm pool to the group in the system.
//
type systemPermissionsServiceAddVmPoolPermissionResponse struct {
	permission *Permission
}

func (p *systemPermissionsServiceAddVmPoolPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *systemPermissionsServiceAddVmPoolPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the vm pool to the group in the system.
//
func (p *systemPermissionsService) AddVmPoolPermission() *systemPermissionsServiceAddVmPoolPermissionRequest {
	return &systemPermissionsServiceAddVmPoolPermissionRequest{systemPermissionsService: p}
}

//
// Sub-resource locator method, returns individual permission resource on which the remainder of the URI is
// dispatched.
//
func (op *systemPermissionsService) PermissionService(id string) *permissionService {
	return NewPermissionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *systemPermissionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.PermissionService(path), nil
	}
	return op.PermissionService(path[:index]).Service(path[index+1:])
}

func (op *systemPermissionsService) String() string {
	return fmt.Sprintf("systemPermissionsService:%s", op.path)
}

//
// Manages the set of scheduling policies available in the system.
//
type schedulingPoliciesService struct {
	baseService
}

func NewSchedulingPoliciesService(connection *Connection, path string) *schedulingPoliciesService {
	var result schedulingPoliciesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new scheduling policy to the system.
//
type schedulingPoliciesServiceAddRequest struct {
	schedulingPoliciesService *schedulingPoliciesService
	header                    map[string]string
	query                     map[string]string
	policy                    *SchedulingPolicy
}

func (p *schedulingPoliciesServiceAddRequest) Header(key, value string) *schedulingPoliciesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *schedulingPoliciesServiceAddRequest) Query(key, value string) *schedulingPoliciesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *schedulingPoliciesServiceAddRequest) Policy(policy *SchedulingPolicy) *schedulingPoliciesServiceAddRequest {
	p.policy = policy
	return p
}

func (p *schedulingPoliciesServiceAddRequest) Send() (*schedulingPoliciesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPoliciesService.connection.URL(), p.schedulingPoliciesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSchedulingPolicyWriteOne(writer, p.policy, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPoliciesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPoliciesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &schedulingPoliciesServiceAddResponse{policy: result}, nil
}

func (p *schedulingPoliciesServiceAddRequest) MustSend() *schedulingPoliciesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPoliciesService.connection.URL(), p.schedulingPoliciesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSchedulingPolicyWriteOne(writer, p.policy, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPoliciesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPoliciesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &schedulingPoliciesServiceAddResponse{policy: result}
}

//
// Add a new scheduling policy to the system.
//
type schedulingPoliciesServiceAddResponse struct {
	policy *SchedulingPolicy
}

func (p *schedulingPoliciesServiceAddResponse) Policy() (*SchedulingPolicy, bool) {
	if p.policy != nil {
		return p.policy, true
	}
	return nil, false
}

func (p *schedulingPoliciesServiceAddResponse) MustPolicy() *SchedulingPolicy {
	if p.policy == nil {
		panic("policy in response does not exist")
	}
	return p.policy
}

//
// Add a new scheduling policy to the system.
//
func (p *schedulingPoliciesService) Add() *schedulingPoliciesServiceAddRequest {
	return &schedulingPoliciesServiceAddRequest{schedulingPoliciesService: p}
}

//
// Returns the list of scheduling policies available in the system.
// The order of the returned list of scheduling policies isn't guaranteed.
//
type schedulingPoliciesServiceListRequest struct {
	schedulingPoliciesService *schedulingPoliciesService
	header                    map[string]string
	query                     map[string]string
	filter                    *bool
	follow                    *string
	max                       *int64
}

func (p *schedulingPoliciesServiceListRequest) Header(key, value string) *schedulingPoliciesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *schedulingPoliciesServiceListRequest) Query(key, value string) *schedulingPoliciesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *schedulingPoliciesServiceListRequest) Filter(filter bool) *schedulingPoliciesServiceListRequest {
	p.filter = &filter
	return p
}

func (p *schedulingPoliciesServiceListRequest) Follow(follow string) *schedulingPoliciesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *schedulingPoliciesServiceListRequest) Max(max int64) *schedulingPoliciesServiceListRequest {
	p.max = &max
	return p
}

func (p *schedulingPoliciesServiceListRequest) Send() (*schedulingPoliciesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPoliciesService.connection.URL(), p.schedulingPoliciesService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPoliciesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPoliciesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &schedulingPoliciesServiceListResponse{policies: result}, nil
}

func (p *schedulingPoliciesServiceListRequest) MustSend() *schedulingPoliciesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPoliciesService.connection.URL(), p.schedulingPoliciesService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPoliciesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPoliciesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &schedulingPoliciesServiceListResponse{policies: result}
}

//
// Returns the list of scheduling policies available in the system.
// The order of the returned list of scheduling policies isn't guaranteed.
//
type schedulingPoliciesServiceListResponse struct {
	policies *SchedulingPolicySlice
}

func (p *schedulingPoliciesServiceListResponse) Policies() (*SchedulingPolicySlice, bool) {
	if p.policies != nil {
		return p.policies, true
	}
	return nil, false
}

func (p *schedulingPoliciesServiceListResponse) MustPolicies() *SchedulingPolicySlice {
	if p.policies == nil {
		panic("policies in response does not exist")
	}
	return p.policies
}

//
// Returns the list of scheduling policies available in the system.
// The order of the returned list of scheduling policies isn't guaranteed.
//
func (p *schedulingPoliciesService) List() *schedulingPoliciesServiceListRequest {
	return &schedulingPoliciesServiceListRequest{schedulingPoliciesService: p}
}

//
//
func (op *schedulingPoliciesService) PolicyService(id string) *schedulingPolicyService {
	return NewSchedulingPolicyService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *schedulingPoliciesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.PolicyService(path), nil
	}
	return op.PolicyService(path[:index]).Service(path[index+1:])
}

func (op *schedulingPoliciesService) String() string {
	return fmt.Sprintf("schedulingPoliciesService:%s", op.path)
}

//
// A service to manage a specific cluster network.
//
type clusterNetworkService struct {
	baseService
}

func NewClusterNetworkService(connection *Connection, path string) *clusterNetworkService {
	var result clusterNetworkService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the cluster network details.
//
type clusterNetworkServiceGetRequest struct {
	clusterNetworkService *clusterNetworkService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *clusterNetworkServiceGetRequest) Header(key, value string) *clusterNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterNetworkServiceGetRequest) Query(key, value string) *clusterNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterNetworkServiceGetRequest) Follow(follow string) *clusterNetworkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *clusterNetworkServiceGetRequest) Send() (*clusterNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterNetworkService.connection.URL(), p.clusterNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &clusterNetworkServiceGetResponse{network: result}, nil
}

func (p *clusterNetworkServiceGetRequest) MustSend() *clusterNetworkServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterNetworkService.connection.URL(), p.clusterNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterNetworkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterNetworkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &clusterNetworkServiceGetResponse{network: result}
}

//
// Retrieves the cluster network details.
//
type clusterNetworkServiceGetResponse struct {
	network *Network
}

func (p *clusterNetworkServiceGetResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *clusterNetworkServiceGetResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Retrieves the cluster network details.
//
func (p *clusterNetworkService) Get() *clusterNetworkServiceGetRequest {
	return &clusterNetworkServiceGetRequest{clusterNetworkService: p}
}

//
// Unassigns the network from a cluster.
//
type clusterNetworkServiceRemoveRequest struct {
	clusterNetworkService *clusterNetworkService
	header                map[string]string
	query                 map[string]string
}

func (p *clusterNetworkServiceRemoveRequest) Header(key, value string) *clusterNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterNetworkServiceRemoveRequest) Query(key, value string) *clusterNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterNetworkServiceRemoveRequest) Send() (*clusterNetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterNetworkService.connection.URL(), p.clusterNetworkService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(clusterNetworkServiceRemoveResponse), nil
}

func (p *clusterNetworkServiceRemoveRequest) MustSend() *clusterNetworkServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterNetworkService.connection.URL(), p.clusterNetworkService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterNetworkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterNetworkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(clusterNetworkServiceRemoveResponse)
}

//
// Unassigns the network from a cluster.
//
type clusterNetworkServiceRemoveResponse struct {
}

//
// Unassigns the network from a cluster.
//
func (p *clusterNetworkService) Remove() *clusterNetworkServiceRemoveRequest {
	return &clusterNetworkServiceRemoveRequest{clusterNetworkService: p}
}

//
// Updates the network in the cluster.
//
type clusterNetworkServiceUpdateRequest struct {
	clusterNetworkService *clusterNetworkService
	header                map[string]string
	query                 map[string]string
	network               *Network
}

func (p *clusterNetworkServiceUpdateRequest) Header(key, value string) *clusterNetworkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterNetworkServiceUpdateRequest) Query(key, value string) *clusterNetworkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterNetworkServiceUpdateRequest) Network(network *Network) *clusterNetworkServiceUpdateRequest {
	p.network = network
	return p
}

func (p *clusterNetworkServiceUpdateRequest) Send() (*clusterNetworkServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterNetworkService.connection.URL(), p.clusterNetworkService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &clusterNetworkServiceUpdateResponse{network: result}, nil
}

func (p *clusterNetworkServiceUpdateRequest) MustSend() *clusterNetworkServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterNetworkService.connection.URL(), p.clusterNetworkService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterNetworkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterNetworkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &clusterNetworkServiceUpdateResponse{network: result}
}

//
// Updates the network in the cluster.
//
type clusterNetworkServiceUpdateResponse struct {
	network *Network
}

func (p *clusterNetworkServiceUpdateResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *clusterNetworkServiceUpdateResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Updates the network in the cluster.
//
func (p *clusterNetworkService) Update() *clusterNetworkServiceUpdateRequest {
	return &clusterNetworkServiceUpdateRequest{clusterNetworkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *clusterNetworkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *clusterNetworkService) String() string {
	return fmt.Sprintf("clusterNetworkService:%s", op.path)
}

//
// A service managing a CD-ROM device on templates.
//
type templateCdromService struct {
	baseService
}

func NewTemplateCdromService(connection *Connection, path string) *templateCdromService {
	var result templateCdromService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the information about this CD-ROM device.
// For example, to get information about the CD-ROM device of template `123` send a request like:
// [source]
// ----
// GET /ovirt-engine/api/templates/123/cdroms/
// ----
//
type templateCdromServiceGetRequest struct {
	templateCdromService *templateCdromService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *templateCdromServiceGetRequest) Header(key, value string) *templateCdromServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateCdromServiceGetRequest) Query(key, value string) *templateCdromServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateCdromServiceGetRequest) Follow(follow string) *templateCdromServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *templateCdromServiceGetRequest) Send() (*templateCdromServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateCdromService.connection.URL(), p.templateCdromService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateCdromService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateCdromService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateCdromServiceGetResponse{cdrom: result}, nil
}

func (p *templateCdromServiceGetRequest) MustSend() *templateCdromServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateCdromService.connection.URL(), p.templateCdromService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateCdromService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateCdromService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateCdromServiceGetResponse{cdrom: result}
}

//
// Returns the information about this CD-ROM device.
// For example, to get information about the CD-ROM device of template `123` send a request like:
// [source]
// ----
// GET /ovirt-engine/api/templates/123/cdroms/
// ----
//
type templateCdromServiceGetResponse struct {
	cdrom *Cdrom
}

func (p *templateCdromServiceGetResponse) Cdrom() (*Cdrom, bool) {
	if p.cdrom != nil {
		return p.cdrom, true
	}
	return nil, false
}

func (p *templateCdromServiceGetResponse) MustCdrom() *Cdrom {
	if p.cdrom == nil {
		panic("cdrom in response does not exist")
	}
	return p.cdrom
}

//
// Returns the information about this CD-ROM device.
// For example, to get information about the CD-ROM device of template `123` send a request like:
// [source]
// ----
// GET /ovirt-engine/api/templates/123/cdroms/
// ----
//
func (p *templateCdromService) Get() *templateCdromServiceGetRequest {
	return &templateCdromServiceGetRequest{templateCdromService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateCdromService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *templateCdromService) String() string {
	return fmt.Sprintf("templateCdromService:%s", op.path)
}

//
// Manages the set of network attachments of a host or host NIC.
//
type networkAttachmentsService struct {
	baseService
}

func NewNetworkAttachmentsService(connection *Connection, path string) *networkAttachmentsService {
	var result networkAttachmentsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new network attachment to the network interface.
//
type networkAttachmentsServiceAddRequest struct {
	networkAttachmentsService *networkAttachmentsService
	header                    map[string]string
	query                     map[string]string
	attachment                *NetworkAttachment
}

func (p *networkAttachmentsServiceAddRequest) Header(key, value string) *networkAttachmentsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkAttachmentsServiceAddRequest) Query(key, value string) *networkAttachmentsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkAttachmentsServiceAddRequest) Attachment(attachment *NetworkAttachment) *networkAttachmentsServiceAddRequest {
	p.attachment = attachment
	return p
}

func (p *networkAttachmentsServiceAddRequest) Send() (*networkAttachmentsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentsService.connection.URL(), p.networkAttachmentsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkAttachmentWriteOne(writer, p.attachment, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &networkAttachmentsServiceAddResponse{attachment: result}, nil
}

func (p *networkAttachmentsServiceAddRequest) MustSend() *networkAttachmentsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentsService.connection.URL(), p.networkAttachmentsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkAttachmentWriteOne(writer, p.attachment, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkAttachmentsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkAttachmentsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkAttachmentReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &networkAttachmentsServiceAddResponse{attachment: result}
}

//
// Add a new network attachment to the network interface.
//
type networkAttachmentsServiceAddResponse struct {
	attachment *NetworkAttachment
}

func (p *networkAttachmentsServiceAddResponse) Attachment() (*NetworkAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *networkAttachmentsServiceAddResponse) MustAttachment() *NetworkAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
// Add a new network attachment to the network interface.
//
func (p *networkAttachmentsService) Add() *networkAttachmentsServiceAddRequest {
	return &networkAttachmentsServiceAddRequest{networkAttachmentsService: p}
}

//
// Returns the list of network attachments of the host or host NIC.
// The order of the returned list of network attachments isn't guaranteed.
//
type networkAttachmentsServiceListRequest struct {
	networkAttachmentsService *networkAttachmentsService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
}

func (p *networkAttachmentsServiceListRequest) Header(key, value string) *networkAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkAttachmentsServiceListRequest) Query(key, value string) *networkAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkAttachmentsServiceListRequest) Follow(follow string) *networkAttachmentsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *networkAttachmentsServiceListRequest) Max(max int64) *networkAttachmentsServiceListRequest {
	p.max = &max
	return p
}

func (p *networkAttachmentsServiceListRequest) Send() (*networkAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentsService.connection.URL(), p.networkAttachmentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkAttachmentReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &networkAttachmentsServiceListResponse{attachments: result}, nil
}

func (p *networkAttachmentsServiceListRequest) MustSend() *networkAttachmentsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentsService.connection.URL(), p.networkAttachmentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkAttachmentsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkAttachmentsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkAttachmentReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &networkAttachmentsServiceListResponse{attachments: result}
}

//
// Returns the list of network attachments of the host or host NIC.
// The order of the returned list of network attachments isn't guaranteed.
//
type networkAttachmentsServiceListResponse struct {
	attachments *NetworkAttachmentSlice
}

func (p *networkAttachmentsServiceListResponse) Attachments() (*NetworkAttachmentSlice, bool) {
	if p.attachments != nil {
		return p.attachments, true
	}
	return nil, false
}

func (p *networkAttachmentsServiceListResponse) MustAttachments() *NetworkAttachmentSlice {
	if p.attachments == nil {
		panic("attachments in response does not exist")
	}
	return p.attachments
}

//
// Returns the list of network attachments of the host or host NIC.
// The order of the returned list of network attachments isn't guaranteed.
//
func (p *networkAttachmentsService) List() *networkAttachmentsServiceListRequest {
	return &networkAttachmentsServiceListRequest{networkAttachmentsService: p}
}

//
//
func (op *networkAttachmentsService) AttachmentService(id string) *networkAttachmentService {
	return NewNetworkAttachmentService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *networkAttachmentsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.AttachmentService(path), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *networkAttachmentsService) String() string {
	return fmt.Sprintf("networkAttachmentsService:%s", op.path)
}

//
//
type unmanagedNetworkService struct {
	baseService
}

func NewUnmanagedNetworkService(connection *Connection, path string) *unmanagedNetworkService {
	var result unmanagedNetworkService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type unmanagedNetworkServiceGetRequest struct {
	unmanagedNetworkService *unmanagedNetworkService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
}

func (p *unmanagedNetworkServiceGetRequest) Header(key, value string) *unmanagedNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *unmanagedNetworkServiceGetRequest) Query(key, value string) *unmanagedNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *unmanagedNetworkServiceGetRequest) Follow(follow string) *unmanagedNetworkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *unmanagedNetworkServiceGetRequest) Send() (*unmanagedNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.unmanagedNetworkService.connection.URL(), p.unmanagedNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.unmanagedNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.unmanagedNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUnmanagedNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &unmanagedNetworkServiceGetResponse{network: result}, nil
}

func (p *unmanagedNetworkServiceGetRequest) MustSend() *unmanagedNetworkServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.unmanagedNetworkService.connection.URL(), p.unmanagedNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.unmanagedNetworkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.unmanagedNetworkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUnmanagedNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &unmanagedNetworkServiceGetResponse{network: result}
}

//
//
type unmanagedNetworkServiceGetResponse struct {
	network *UnmanagedNetwork
}

func (p *unmanagedNetworkServiceGetResponse) Network() (*UnmanagedNetwork, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *unmanagedNetworkServiceGetResponse) MustNetwork() *UnmanagedNetwork {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
//
func (p *unmanagedNetworkService) Get() *unmanagedNetworkServiceGetRequest {
	return &unmanagedNetworkServiceGetRequest{unmanagedNetworkService: p}
}

//
//
type unmanagedNetworkServiceRemoveRequest struct {
	unmanagedNetworkService *unmanagedNetworkService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *unmanagedNetworkServiceRemoveRequest) Header(key, value string) *unmanagedNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *unmanagedNetworkServiceRemoveRequest) Query(key, value string) *unmanagedNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *unmanagedNetworkServiceRemoveRequest) Async(async bool) *unmanagedNetworkServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *unmanagedNetworkServiceRemoveRequest) Send() (*unmanagedNetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.unmanagedNetworkService.connection.URL(), p.unmanagedNetworkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.unmanagedNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.unmanagedNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(unmanagedNetworkServiceRemoveResponse), nil
}

func (p *unmanagedNetworkServiceRemoveRequest) MustSend() *unmanagedNetworkServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.unmanagedNetworkService.connection.URL(), p.unmanagedNetworkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.unmanagedNetworkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.unmanagedNetworkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(unmanagedNetworkServiceRemoveResponse)
}

//
//
type unmanagedNetworkServiceRemoveResponse struct {
}

//
//
func (p *unmanagedNetworkService) Remove() *unmanagedNetworkServiceRemoveRequest {
	return &unmanagedNetworkServiceRemoveRequest{unmanagedNetworkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *unmanagedNetworkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *unmanagedNetworkService) String() string {
	return fmt.Sprintf("unmanagedNetworkService:%s", op.path)
}

//
// Manages the set of NICs of an snapshot.
//
type snapshotNicsService struct {
	baseService
}

func NewSnapshotNicsService(connection *Connection, path string) *snapshotNicsService {
	var result snapshotNicsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of NICs of the snapshot.
// The order of the returned list of NICs isn't guaranteed.
//
type snapshotNicsServiceListRequest struct {
	snapshotNicsService *snapshotNicsService
	header              map[string]string
	query               map[string]string
	follow              *string
	max                 *int64
}

func (p *snapshotNicsServiceListRequest) Header(key, value string) *snapshotNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *snapshotNicsServiceListRequest) Query(key, value string) *snapshotNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *snapshotNicsServiceListRequest) Follow(follow string) *snapshotNicsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *snapshotNicsServiceListRequest) Max(max int64) *snapshotNicsServiceListRequest {
	p.max = &max
	return p
}

func (p *snapshotNicsServiceListRequest) Send() (*snapshotNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotNicsService.connection.URL(), p.snapshotNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &snapshotNicsServiceListResponse{nics: result}, nil
}

func (p *snapshotNicsServiceListRequest) MustSend() *snapshotNicsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.snapshotNicsService.connection.URL(), p.snapshotNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotNicsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotNicsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &snapshotNicsServiceListResponse{nics: result}
}

//
// Returns the list of NICs of the snapshot.
// The order of the returned list of NICs isn't guaranteed.
//
type snapshotNicsServiceListResponse struct {
	nics *NicSlice
}

func (p *snapshotNicsServiceListResponse) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *snapshotNicsServiceListResponse) MustNics() *NicSlice {
	if p.nics == nil {
		panic("nics in response does not exist")
	}
	return p.nics
}

//
// Returns the list of NICs of the snapshot.
// The order of the returned list of NICs isn't guaranteed.
//
func (p *snapshotNicsService) List() *snapshotNicsServiceListRequest {
	return &snapshotNicsServiceListRequest{snapshotNicsService: p}
}

//
//
func (op *snapshotNicsService) NicService(id string) *snapshotNicService {
	return NewSnapshotNicService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *snapshotNicsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NicService(path), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *snapshotNicsService) String() string {
	return fmt.Sprintf("snapshotNicsService:%s", op.path)
}

//
// A service to manage host storages.
//
type hostStorageService struct {
	baseService
}

func NewHostStorageService(connection *Connection, path string) *hostStorageService {
	var result hostStorageService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get list of storages.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/storage
// ----
// The XML response you get will be like this one:
// [source,xml]
// ----
// <host_storages>
//   <host_storage id="123">
//     ...
//   </host_storage>
//   ...
// </host_storages>
// ----
// The order of the returned list of storages isn't guaranteed.
//
type hostStorageServiceListRequest struct {
	hostStorageService *hostStorageService
	header             map[string]string
	query              map[string]string
	follow             *string
	reportStatus       *bool
}

func (p *hostStorageServiceListRequest) Header(key, value string) *hostStorageServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostStorageServiceListRequest) Query(key, value string) *hostStorageServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostStorageServiceListRequest) Follow(follow string) *hostStorageServiceListRequest {
	p.follow = &follow
	return p
}

func (p *hostStorageServiceListRequest) ReportStatus(reportStatus bool) *hostStorageServiceListRequest {
	p.reportStatus = &reportStatus
	return p
}

func (p *hostStorageServiceListRequest) Send() (*hostStorageServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostStorageService.connection.URL(), p.hostStorageService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.reportStatus != nil {
		values["report_status"] = []string{fmt.Sprintf("%v", *p.reportStatus)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostStorageService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostStorageService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostStorageReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &hostStorageServiceListResponse{storages: result}, nil
}

func (p *hostStorageServiceListRequest) MustSend() *hostStorageServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostStorageService.connection.URL(), p.hostStorageService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.reportStatus != nil {
		values["report_status"] = []string{fmt.Sprintf("%v", *p.reportStatus)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostStorageService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostStorageService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostStorageReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &hostStorageServiceListResponse{storages: result}
}

//
// Get list of storages.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/storage
// ----
// The XML response you get will be like this one:
// [source,xml]
// ----
// <host_storages>
//   <host_storage id="123">
//     ...
//   </host_storage>
//   ...
// </host_storages>
// ----
// The order of the returned list of storages isn't guaranteed.
//
type hostStorageServiceListResponse struct {
	storages *HostStorageSlice
}

func (p *hostStorageServiceListResponse) Storages() (*HostStorageSlice, bool) {
	if p.storages != nil {
		return p.storages, true
	}
	return nil, false
}

func (p *hostStorageServiceListResponse) MustStorages() *HostStorageSlice {
	if p.storages == nil {
		panic("storages in response does not exist")
	}
	return p.storages
}

//
// Get list of storages.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/storage
// ----
// The XML response you get will be like this one:
// [source,xml]
// ----
// <host_storages>
//   <host_storage id="123">
//     ...
//   </host_storage>
//   ...
// </host_storages>
// ----
// The order of the returned list of storages isn't guaranteed.
//
func (p *hostStorageService) List() *hostStorageServiceListRequest {
	return &hostStorageServiceListRequest{hostStorageService: p}
}

//
// Reference to a service managing the storage.
//
func (op *hostStorageService) StorageService(id string) *storageService {
	return NewStorageService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *hostStorageService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StorageService(path), nil
	}
	return op.StorageService(path[:index]).Service(path[index+1:])
}

func (op *hostStorageService) String() string {
	return fmt.Sprintf("hostStorageService:%s", op.path)
}

//
// Represents a service to manage collection of the tags in the system.
//
type tagsService struct {
	baseService
}

func NewTagsService(connection *Connection, path string) *tagsService {
	var result tagsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new tag to the system.
// For example, to add new tag with name `mytag` to the system send a request like this:
// ....
// POST /ovirt-engine/api/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
// NOTE: The root tag is a special pseudo-tag assumed as the default parent tag if no parent tag is specified.
// The root tag cannot be deleted nor assigned a parent tag.
// To create new tag with specific parent tag send a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
//   <parent>
//     <name>myparenttag</name>
//   </parent>
// </tag>
// ----
//
type tagsServiceAddRequest struct {
	tagsService *tagsService
	header      map[string]string
	query       map[string]string
	tag         *Tag
}

func (p *tagsServiceAddRequest) Header(key, value string) *tagsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *tagsServiceAddRequest) Query(key, value string) *tagsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *tagsServiceAddRequest) Tag(tag *Tag) *tagsServiceAddRequest {
	p.tag = tag
	return p
}

func (p *tagsServiceAddRequest) Send() (*tagsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagsService.connection.URL(), p.tagsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTagWriteOne(writer, p.tag, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.tagsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.tagsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &tagsServiceAddResponse{tag: result}, nil
}

func (p *tagsServiceAddRequest) MustSend() *tagsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.tagsService.connection.URL(), p.tagsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTagWriteOne(writer, p.tag, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.tagsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.tagsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &tagsServiceAddResponse{tag: result}
}

//
// Add a new tag to the system.
// For example, to add new tag with name `mytag` to the system send a request like this:
// ....
// POST /ovirt-engine/api/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
// NOTE: The root tag is a special pseudo-tag assumed as the default parent tag if no parent tag is specified.
// The root tag cannot be deleted nor assigned a parent tag.
// To create new tag with specific parent tag send a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
//   <parent>
//     <name>myparenttag</name>
//   </parent>
// </tag>
// ----
//
type tagsServiceAddResponse struct {
	tag *Tag
}

func (p *tagsServiceAddResponse) Tag() (*Tag, bool) {
	if p.tag != nil {
		return p.tag, true
	}
	return nil, false
}

func (p *tagsServiceAddResponse) MustTag() *Tag {
	if p.tag == nil {
		panic("tag in response does not exist")
	}
	return p.tag
}

//
// Add a new tag to the system.
// For example, to add new tag with name `mytag` to the system send a request like this:
// ....
// POST /ovirt-engine/api/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
// NOTE: The root tag is a special pseudo-tag assumed as the default parent tag if no parent tag is specified.
// The root tag cannot be deleted nor assigned a parent tag.
// To create new tag with specific parent tag send a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
//   <parent>
//     <name>myparenttag</name>
//   </parent>
// </tag>
// ----
//
func (p *tagsService) Add() *tagsServiceAddRequest {
	return &tagsServiceAddRequest{tagsService: p}
}

//
// List the tags in the system.
// For example to list the full hierarchy of the tags in the system send a request like this:
// ....
// GET /ovirt-engine/api/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>root2</name>
//     <description>root2</description>
//     <parent href="/ovirt-engine/api/tags/111" id="111"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/333" id="333">
//     <name>root3</name>
//     <description>root3</description>
//     <parent href="/ovirt-engine/api/tags/222" id="222"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/111" id="111">
//     <name>root</name>
//     <description>root</description>
//   </tag>
// </tags>
// ----
// In the previous XML output you can see the following hierarchy of the tags:
// ....
// root:        (id: 111)
//   - root2    (id: 222)
//     - root3  (id: 333)
// ....
// The order of the returned list of tags isn't guaranteed.
//
type tagsServiceListRequest struct {
	tagsService *tagsService
	header      map[string]string
	query       map[string]string
	follow      *string
	max         *int64
}

func (p *tagsServiceListRequest) Header(key, value string) *tagsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *tagsServiceListRequest) Query(key, value string) *tagsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *tagsServiceListRequest) Follow(follow string) *tagsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *tagsServiceListRequest) Max(max int64) *tagsServiceListRequest {
	p.max = &max
	return p
}

func (p *tagsServiceListRequest) Send() (*tagsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagsService.connection.URL(), p.tagsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.tagsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.tagsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &tagsServiceListResponse{tags: result}, nil
}

func (p *tagsServiceListRequest) MustSend() *tagsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.tagsService.connection.URL(), p.tagsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.tagsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.tagsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &tagsServiceListResponse{tags: result}
}

//
// List the tags in the system.
// For example to list the full hierarchy of the tags in the system send a request like this:
// ....
// GET /ovirt-engine/api/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>root2</name>
//     <description>root2</description>
//     <parent href="/ovirt-engine/api/tags/111" id="111"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/333" id="333">
//     <name>root3</name>
//     <description>root3</description>
//     <parent href="/ovirt-engine/api/tags/222" id="222"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/111" id="111">
//     <name>root</name>
//     <description>root</description>
//   </tag>
// </tags>
// ----
// In the previous XML output you can see the following hierarchy of the tags:
// ....
// root:        (id: 111)
//   - root2    (id: 222)
//     - root3  (id: 333)
// ....
// The order of the returned list of tags isn't guaranteed.
//
type tagsServiceListResponse struct {
	tags *TagSlice
}

func (p *tagsServiceListResponse) Tags() (*TagSlice, bool) {
	if p.tags != nil {
		return p.tags, true
	}
	return nil, false
}

func (p *tagsServiceListResponse) MustTags() *TagSlice {
	if p.tags == nil {
		panic("tags in response does not exist")
	}
	return p.tags
}

//
// List the tags in the system.
// For example to list the full hierarchy of the tags in the system send a request like this:
// ....
// GET /ovirt-engine/api/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>root2</name>
//     <description>root2</description>
//     <parent href="/ovirt-engine/api/tags/111" id="111"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/333" id="333">
//     <name>root3</name>
//     <description>root3</description>
//     <parent href="/ovirt-engine/api/tags/222" id="222"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/111" id="111">
//     <name>root</name>
//     <description>root</description>
//   </tag>
// </tags>
// ----
// In the previous XML output you can see the following hierarchy of the tags:
// ....
// root:        (id: 111)
//   - root2    (id: 222)
//     - root3  (id: 333)
// ....
// The order of the returned list of tags isn't guaranteed.
//
func (p *tagsService) List() *tagsServiceListRequest {
	return &tagsServiceListRequest{tagsService: p}
}

//
// Reference to the service that manages a specific tag.
//
func (op *tagsService) TagService(id string) *tagService {
	return NewTagService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *tagsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.TagService(path), nil
	}
	return op.TagService(path[:index]).Service(path[index+1:])
}

func (op *tagsService) String() string {
	return fmt.Sprintf("tagsService:%s", op.path)
}

//
// A service that manages hosts.
//
type hostsService struct {
	baseService
}

func NewHostsService(connection *Connection, path string) *hostsService {
	var result hostsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new host.
// The host is created based on the attributes of the `host` parameter. The `name`, `address` and `root_password`
// properties are required.
// For example, to add a host send the following request:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With the following request body:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>myrootpassword</root_password>
// </host>
// ----
// NOTE: The `root_password` element is only included in the client-provided initial representation and is not
// exposed in the representations returned from subsequent requests.
// IMPORTANT: Since version 4.1.2 of the engine when a host is newly added we override the host firewall
// definitions by default.
// To add a hosted engine host, use the optional `deploy_hosted_engine` parameter:
// [source]
// ----
// POST /ovirt-engine/api/hosts?deploy_hosted_engine=true
// ----
// If the cluster has a default external network provider which is supported for automatic deployment,
// the external network provider is deployed when adding the host.
// Only external network providers for OVN are supported for the automatic deployment.
// To deploy an external network provider that differs to what is defined in the clusters, overwrite the external
// network provider when adding hosts by sending a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With a request body that contains a reference to the desired provider in the
// `external_network_provider_configuration`:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>123456</root_password>
//   <external_network_provider_configurations>
//     <external_network_provider_configuration>
//       <external_network_provider name="ovirt-provider-ovn"/>
//     </external_network_provider_configuration>
//   </external_network_provider_configurations>
// </host>
// ----
//
type hostsServiceAddRequest struct {
	hostsService         *hostsService
	header               map[string]string
	query                map[string]string
	deployHostedEngine   *bool
	host                 *Host
	undeployHostedEngine *bool
}

func (p *hostsServiceAddRequest) Header(key, value string) *hostsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostsServiceAddRequest) Query(key, value string) *hostsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostsServiceAddRequest) DeployHostedEngine(deployHostedEngine bool) *hostsServiceAddRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}

func (p *hostsServiceAddRequest) Host(host *Host) *hostsServiceAddRequest {
	p.host = host
	return p
}

func (p *hostsServiceAddRequest) UndeployHostedEngine(undeployHostedEngine bool) *hostsServiceAddRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}

func (p *hostsServiceAddRequest) Send() (*hostsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostsService.connection.URL(), p.hostsService.path)
	values := make(url.Values)
	if p.deployHostedEngine != nil {
		values["deploy_hosted_engine"] = []string{fmt.Sprintf("%v", *p.deployHostedEngine)}
	}

	if p.undeployHostedEngine != nil {
		values["undeploy_hosted_engine"] = []string{fmt.Sprintf("%v", *p.undeployHostedEngine)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostWriteOne(writer, p.host, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &hostsServiceAddResponse{host: result}, nil
}

func (p *hostsServiceAddRequest) MustSend() *hostsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostsService.connection.URL(), p.hostsService.path)
	values := make(url.Values)
	if p.deployHostedEngine != nil {
		values["deploy_hosted_engine"] = []string{fmt.Sprintf("%v", *p.deployHostedEngine)}
	}

	if p.undeployHostedEngine != nil {
		values["undeploy_hosted_engine"] = []string{fmt.Sprintf("%v", *p.undeployHostedEngine)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostWriteOne(writer, p.host, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &hostsServiceAddResponse{host: result}
}

//
// Creates a new host.
// The host is created based on the attributes of the `host` parameter. The `name`, `address` and `root_password`
// properties are required.
// For example, to add a host send the following request:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With the following request body:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>myrootpassword</root_password>
// </host>
// ----
// NOTE: The `root_password` element is only included in the client-provided initial representation and is not
// exposed in the representations returned from subsequent requests.
// IMPORTANT: Since version 4.1.2 of the engine when a host is newly added we override the host firewall
// definitions by default.
// To add a hosted engine host, use the optional `deploy_hosted_engine` parameter:
// [source]
// ----
// POST /ovirt-engine/api/hosts?deploy_hosted_engine=true
// ----
// If the cluster has a default external network provider which is supported for automatic deployment,
// the external network provider is deployed when adding the host.
// Only external network providers for OVN are supported for the automatic deployment.
// To deploy an external network provider that differs to what is defined in the clusters, overwrite the external
// network provider when adding hosts by sending a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With a request body that contains a reference to the desired provider in the
// `external_network_provider_configuration`:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>123456</root_password>
//   <external_network_provider_configurations>
//     <external_network_provider_configuration>
//       <external_network_provider name="ovirt-provider-ovn"/>
//     </external_network_provider_configuration>
//   </external_network_provider_configurations>
// </host>
// ----
//
type hostsServiceAddResponse struct {
	host *Host
}

func (p *hostsServiceAddResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *hostsServiceAddResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Creates a new host.
// The host is created based on the attributes of the `host` parameter. The `name`, `address` and `root_password`
// properties are required.
// For example, to add a host send the following request:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With the following request body:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>myrootpassword</root_password>
// </host>
// ----
// NOTE: The `root_password` element is only included in the client-provided initial representation and is not
// exposed in the representations returned from subsequent requests.
// IMPORTANT: Since version 4.1.2 of the engine when a host is newly added we override the host firewall
// definitions by default.
// To add a hosted engine host, use the optional `deploy_hosted_engine` parameter:
// [source]
// ----
// POST /ovirt-engine/api/hosts?deploy_hosted_engine=true
// ----
// If the cluster has a default external network provider which is supported for automatic deployment,
// the external network provider is deployed when adding the host.
// Only external network providers for OVN are supported for the automatic deployment.
// To deploy an external network provider that differs to what is defined in the clusters, overwrite the external
// network provider when adding hosts by sending a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With a request body that contains a reference to the desired provider in the
// `external_network_provider_configuration`:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>123456</root_password>
//   <external_network_provider_configurations>
//     <external_network_provider_configuration>
//       <external_network_provider name="ovirt-provider-ovn"/>
//     </external_network_provider_configuration>
//   </external_network_provider_configurations>
// </host>
// ----
//
func (p *hostsService) Add() *hostsServiceAddRequest {
	return &hostsServiceAddRequest{hostsService: p}
}

//
// Get a list of all available hosts.
// For example, to list the hosts send the following request:
// ....
// GET /ovirt-engine/api/hosts
// ....
// The response body will be something like this:
// [source,xml]
// ----
// <hosts>
//   <host href="/ovirt-engine/api/hosts/123" id="123">
//     ...
//   </host>
//   <host href="/ovirt-engine/api/hosts/456" id="456">
//     ...
//   </host>
//   ...
// </host>
// ----
// The order of the returned list of hosts is guaranteed only if the `sortby` clause is included in
// the `search` parameter.
//
type hostsServiceListRequest struct {
	hostsService  *hostsService
	header        map[string]string
	query         map[string]string
	allContent    *bool
	caseSensitive *bool
	filter        *bool
	follow        *string
	max           *int64
	search        *string
}

func (p *hostsServiceListRequest) Header(key, value string) *hostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostsServiceListRequest) Query(key, value string) *hostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostsServiceListRequest) AllContent(allContent bool) *hostsServiceListRequest {
	p.allContent = &allContent
	return p
}

func (p *hostsServiceListRequest) CaseSensitive(caseSensitive bool) *hostsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *hostsServiceListRequest) Filter(filter bool) *hostsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *hostsServiceListRequest) Follow(follow string) *hostsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *hostsServiceListRequest) Max(max int64) *hostsServiceListRequest {
	p.max = &max
	return p
}

func (p *hostsServiceListRequest) Search(search string) *hostsServiceListRequest {
	p.search = &search
	return p
}

func (p *hostsServiceListRequest) Send() (*hostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostsService.connection.URL(), p.hostsService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &hostsServiceListResponse{hosts: result}, nil
}

func (p *hostsServiceListRequest) MustSend() *hostsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostsService.connection.URL(), p.hostsService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &hostsServiceListResponse{hosts: result}
}

//
// Get a list of all available hosts.
// For example, to list the hosts send the following request:
// ....
// GET /ovirt-engine/api/hosts
// ....
// The response body will be something like this:
// [source,xml]
// ----
// <hosts>
//   <host href="/ovirt-engine/api/hosts/123" id="123">
//     ...
//   </host>
//   <host href="/ovirt-engine/api/hosts/456" id="456">
//     ...
//   </host>
//   ...
// </host>
// ----
// The order of the returned list of hosts is guaranteed only if the `sortby` clause is included in
// the `search` parameter.
//
type hostsServiceListResponse struct {
	hosts *HostSlice
}

func (p *hostsServiceListResponse) Hosts() (*HostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *hostsServiceListResponse) MustHosts() *HostSlice {
	if p.hosts == nil {
		panic("hosts in response does not exist")
	}
	return p.hosts
}

//
// Get a list of all available hosts.
// For example, to list the hosts send the following request:
// ....
// GET /ovirt-engine/api/hosts
// ....
// The response body will be something like this:
// [source,xml]
// ----
// <hosts>
//   <host href="/ovirt-engine/api/hosts/123" id="123">
//     ...
//   </host>
//   <host href="/ovirt-engine/api/hosts/456" id="456">
//     ...
//   </host>
//   ...
// </host>
// ----
// The order of the returned list of hosts is guaranteed only if the `sortby` clause is included in
// the `search` parameter.
//
func (p *hostsService) List() *hostsServiceListRequest {
	return &hostsServiceListRequest{hostsService: p}
}

//
// Add a new host to the system providing the host root password. This has been deprecated and provided for backwards compatibility.
//
type hostsServiceAddUsingRootPasswordRequest struct {
	hostsService         *hostsService
	header               map[string]string
	query                map[string]string
	deployHostedEngine   *bool
	host                 *Host
	undeployHostedEngine *bool
}

func (p *hostsServiceAddUsingRootPasswordRequest) Header(key, value string) *hostsServiceAddUsingRootPasswordRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostsServiceAddUsingRootPasswordRequest) Query(key, value string) *hostsServiceAddUsingRootPasswordRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostsServiceAddUsingRootPasswordRequest) DeployHostedEngine(deployHostedEngine bool) *hostsServiceAddUsingRootPasswordRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}

func (p *hostsServiceAddUsingRootPasswordRequest) Host(host *Host) *hostsServiceAddUsingRootPasswordRequest {
	p.host = host
	return p
}

func (p *hostsServiceAddUsingRootPasswordRequest) UndeployHostedEngine(undeployHostedEngine bool) *hostsServiceAddUsingRootPasswordRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}

func (p *hostsServiceAddUsingRootPasswordRequest) Send() (*hostsServiceAddUsingRootPasswordResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingrootpassword", p.hostsService.connection.URL(), p.hostsService.path)
	actionBuilder := NewActionBuilder()
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustHost()
	return &hostsServiceAddUsingRootPasswordResponse{host: result}, nil
}

func (p *hostsServiceAddUsingRootPasswordRequest) MustSend() *hostsServiceAddUsingRootPasswordResponse {
	rawURL := fmt.Sprintf("%s%s/usingrootpassword", p.hostsService.connection.URL(), p.hostsService.path)
	actionBuilder := NewActionBuilder()
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustHost()
	return &hostsServiceAddUsingRootPasswordResponse{host: result}
}

//
// Add a new host to the system providing the host root password. This has been deprecated and provided for backwards compatibility.
//
type hostsServiceAddUsingRootPasswordResponse struct {
	host *Host
}

func (p *hostsServiceAddUsingRootPasswordResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *hostsServiceAddUsingRootPasswordResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Add a new host to the system providing the host root password. This has been deprecated and provided for backwards compatibility.
//
func (p *hostsService) AddUsingRootPassword() *hostsServiceAddUsingRootPasswordRequest {
	return &hostsServiceAddUsingRootPasswordRequest{hostsService: p}
}

//
// Add a new host to the system providing the ssh password or fingerprint.
//
type hostsServiceAddUsingSshRequest struct {
	hostsService         *hostsService
	header               map[string]string
	query                map[string]string
	deployHostedEngine   *bool
	host                 *Host
	undeployHostedEngine *bool
}

func (p *hostsServiceAddUsingSshRequest) Header(key, value string) *hostsServiceAddUsingSshRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostsServiceAddUsingSshRequest) Query(key, value string) *hostsServiceAddUsingSshRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostsServiceAddUsingSshRequest) DeployHostedEngine(deployHostedEngine bool) *hostsServiceAddUsingSshRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}

func (p *hostsServiceAddUsingSshRequest) Host(host *Host) *hostsServiceAddUsingSshRequest {
	p.host = host
	return p
}

func (p *hostsServiceAddUsingSshRequest) UndeployHostedEngine(undeployHostedEngine bool) *hostsServiceAddUsingSshRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}

func (p *hostsServiceAddUsingSshRequest) Send() (*hostsServiceAddUsingSshResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingssh", p.hostsService.connection.URL(), p.hostsService.path)
	actionBuilder := NewActionBuilder()
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustHost()
	return &hostsServiceAddUsingSshResponse{host: result}, nil
}

func (p *hostsServiceAddUsingSshRequest) MustSend() *hostsServiceAddUsingSshResponse {
	rawURL := fmt.Sprintf("%s%s/usingssh", p.hostsService.connection.URL(), p.hostsService.path)
	actionBuilder := NewActionBuilder()
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustHost()
	return &hostsServiceAddUsingSshResponse{host: result}
}

//
// Add a new host to the system providing the ssh password or fingerprint.
//
type hostsServiceAddUsingSshResponse struct {
	host *Host
}

func (p *hostsServiceAddUsingSshResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *hostsServiceAddUsingSshResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Add a new host to the system providing the ssh password or fingerprint.
//
func (p *hostsService) AddUsingSsh() *hostsServiceAddUsingSshRequest {
	return &hostsServiceAddUsingSshRequest{hostsService: p}
}

//
// A Reference to service managing a specific host.
//
func (op *hostsService) HostService(id string) *hostService {
	return NewHostService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *hostsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HostService(path), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *hostsService) String() string {
	return fmt.Sprintf("hostsService:%s", op.path)
}

//
//
type balancesService struct {
	baseService
}

func NewBalancesService(connection *Connection, path string) *balancesService {
	var result balancesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a balance module to a specified user defined scheduling policy.
//
type balancesServiceAddRequest struct {
	balancesService *balancesService
	header          map[string]string
	query           map[string]string
	balance         *Balance
}

func (p *balancesServiceAddRequest) Header(key, value string) *balancesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *balancesServiceAddRequest) Query(key, value string) *balancesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *balancesServiceAddRequest) Balance(balance *Balance) *balancesServiceAddRequest {
	p.balance = balance
	return p
}

func (p *balancesServiceAddRequest) Send() (*balancesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.balancesService.connection.URL(), p.balancesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLBalanceWriteOne(writer, p.balance, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.balancesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.balancesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBalanceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &balancesServiceAddResponse{balance: result}, nil
}

func (p *balancesServiceAddRequest) MustSend() *balancesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.balancesService.connection.URL(), p.balancesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLBalanceWriteOne(writer, p.balance, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.balancesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.balancesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBalanceReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &balancesServiceAddResponse{balance: result}
}

//
// Add a balance module to a specified user defined scheduling policy.
//
type balancesServiceAddResponse struct {
	balance *Balance
}

func (p *balancesServiceAddResponse) Balance() (*Balance, bool) {
	if p.balance != nil {
		return p.balance, true
	}
	return nil, false
}

func (p *balancesServiceAddResponse) MustBalance() *Balance {
	if p.balance == nil {
		panic("balance in response does not exist")
	}
	return p.balance
}

//
// Add a balance module to a specified user defined scheduling policy.
//
func (p *balancesService) Add() *balancesServiceAddRequest {
	return &balancesServiceAddRequest{balancesService: p}
}

//
// Returns the list of balance modules used by the scheduling policy.
// The order of the returned balance modules isn't guaranteed.
//
type balancesServiceListRequest struct {
	balancesService *balancesService
	header          map[string]string
	query           map[string]string
	filter          *bool
	follow          *string
	max             *int64
}

func (p *balancesServiceListRequest) Header(key, value string) *balancesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *balancesServiceListRequest) Query(key, value string) *balancesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *balancesServiceListRequest) Filter(filter bool) *balancesServiceListRequest {
	p.filter = &filter
	return p
}

func (p *balancesServiceListRequest) Follow(follow string) *balancesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *balancesServiceListRequest) Max(max int64) *balancesServiceListRequest {
	p.max = &max
	return p
}

func (p *balancesServiceListRequest) Send() (*balancesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.balancesService.connection.URL(), p.balancesService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.balancesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.balancesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBalanceReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &balancesServiceListResponse{balances: result}, nil
}

func (p *balancesServiceListRequest) MustSend() *balancesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.balancesService.connection.URL(), p.balancesService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.balancesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.balancesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBalanceReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &balancesServiceListResponse{balances: result}
}

//
// Returns the list of balance modules used by the scheduling policy.
// The order of the returned balance modules isn't guaranteed.
//
type balancesServiceListResponse struct {
	balances *BalanceSlice
}

func (p *balancesServiceListResponse) Balances() (*BalanceSlice, bool) {
	if p.balances != nil {
		return p.balances, true
	}
	return nil, false
}

func (p *balancesServiceListResponse) MustBalances() *BalanceSlice {
	if p.balances == nil {
		panic("balances in response does not exist")
	}
	return p.balances
}

//
// Returns the list of balance modules used by the scheduling policy.
// The order of the returned balance modules isn't guaranteed.
//
func (p *balancesService) List() *balancesServiceListRequest {
	return &balancesServiceListRequest{balancesService: p}
}

//
//
func (op *balancesService) BalanceService(id string) *balanceService {
	return NewBalanceService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *balancesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.BalanceService(path), nil
	}
	return op.BalanceService(path[:index]).Service(path[index+1:])
}

func (op *balancesService) String() string {
	return fmt.Sprintf("balancesService:%s", op.path)
}

//
//
type diskSnapshotService struct {
	baseService
}

func NewDiskSnapshotService(connection *Connection, path string) *diskSnapshotService {
	var result diskSnapshotService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type diskSnapshotServiceGetRequest struct {
	diskSnapshotService *diskSnapshotService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *diskSnapshotServiceGetRequest) Header(key, value string) *diskSnapshotServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskSnapshotServiceGetRequest) Query(key, value string) *diskSnapshotServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskSnapshotServiceGetRequest) Follow(follow string) *diskSnapshotServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *diskSnapshotServiceGetRequest) Send() (*diskSnapshotServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskSnapshotService.connection.URL(), p.diskSnapshotService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskSnapshotService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskSnapshotService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskSnapshotReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &diskSnapshotServiceGetResponse{snapshot: result}, nil
}

func (p *diskSnapshotServiceGetRequest) MustSend() *diskSnapshotServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskSnapshotService.connection.URL(), p.diskSnapshotService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskSnapshotService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskSnapshotService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskSnapshotReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &diskSnapshotServiceGetResponse{snapshot: result}
}

//
//
type diskSnapshotServiceGetResponse struct {
	snapshot *DiskSnapshot
}

func (p *diskSnapshotServiceGetResponse) Snapshot() (*DiskSnapshot, bool) {
	if p.snapshot != nil {
		return p.snapshot, true
	}
	return nil, false
}

func (p *diskSnapshotServiceGetResponse) MustSnapshot() *DiskSnapshot {
	if p.snapshot == nil {
		panic("snapshot in response does not exist")
	}
	return p.snapshot
}

//
//
func (p *diskSnapshotService) Get() *diskSnapshotServiceGetRequest {
	return &diskSnapshotServiceGetRequest{diskSnapshotService: p}
}

//
//
type diskSnapshotServiceRemoveRequest struct {
	diskSnapshotService *diskSnapshotService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *diskSnapshotServiceRemoveRequest) Header(key, value string) *diskSnapshotServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskSnapshotServiceRemoveRequest) Query(key, value string) *diskSnapshotServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskSnapshotServiceRemoveRequest) Async(async bool) *diskSnapshotServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *diskSnapshotServiceRemoveRequest) Send() (*diskSnapshotServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskSnapshotService.connection.URL(), p.diskSnapshotService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskSnapshotService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskSnapshotService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(diskSnapshotServiceRemoveResponse), nil
}

func (p *diskSnapshotServiceRemoveRequest) MustSend() *diskSnapshotServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskSnapshotService.connection.URL(), p.diskSnapshotService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskSnapshotService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskSnapshotService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(diskSnapshotServiceRemoveResponse)
}

//
//
type diskSnapshotServiceRemoveResponse struct {
}

//
//
func (p *diskSnapshotService) Remove() *diskSnapshotServiceRemoveRequest {
	return &diskSnapshotServiceRemoveRequest{diskSnapshotService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *diskSnapshotService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *diskSnapshotService) String() string {
	return fmt.Sprintf("diskSnapshotService:%s", op.path)
}

//
//
type storageDomainServerConnectionService struct {
	baseService
}

func NewStorageDomainServerConnectionService(connection *Connection, path string) *storageDomainServerConnectionService {
	var result storageDomainServerConnectionService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type storageDomainServerConnectionServiceGetRequest struct {
	storageDomainServerConnectionService *storageDomainServerConnectionService
	header                               map[string]string
	query                                map[string]string
	follow                               *string
}

func (p *storageDomainServerConnectionServiceGetRequest) Header(key, value string) *storageDomainServerConnectionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainServerConnectionServiceGetRequest) Query(key, value string) *storageDomainServerConnectionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainServerConnectionServiceGetRequest) Follow(follow string) *storageDomainServerConnectionServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainServerConnectionServiceGetRequest) Send() (*storageDomainServerConnectionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionService.connection.URL(), p.storageDomainServerConnectionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageDomainServerConnectionServiceGetResponse{connection: result}, nil
}

func (p *storageDomainServerConnectionServiceGetRequest) MustSend() *storageDomainServerConnectionServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionService.connection.URL(), p.storageDomainServerConnectionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainServerConnectionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageDomainServerConnectionServiceGetResponse{connection: result}
}

//
//
type storageDomainServerConnectionServiceGetResponse struct {
	connection *StorageConnection
}

func (p *storageDomainServerConnectionServiceGetResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *storageDomainServerConnectionServiceGetResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
//
func (p *storageDomainServerConnectionService) Get() *storageDomainServerConnectionServiceGetRequest {
	return &storageDomainServerConnectionServiceGetRequest{storageDomainServerConnectionService: p}
}

//
// Detaches a storage connection from storage.
//
type storageDomainServerConnectionServiceRemoveRequest struct {
	storageDomainServerConnectionService *storageDomainServerConnectionService
	header                               map[string]string
	query                                map[string]string
	async                                *bool
}

func (p *storageDomainServerConnectionServiceRemoveRequest) Header(key, value string) *storageDomainServerConnectionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainServerConnectionServiceRemoveRequest) Query(key, value string) *storageDomainServerConnectionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainServerConnectionServiceRemoveRequest) Async(async bool) *storageDomainServerConnectionServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *storageDomainServerConnectionServiceRemoveRequest) Send() (*storageDomainServerConnectionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionService.connection.URL(), p.storageDomainServerConnectionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(storageDomainServerConnectionServiceRemoveResponse), nil
}

func (p *storageDomainServerConnectionServiceRemoveRequest) MustSend() *storageDomainServerConnectionServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionService.connection.URL(), p.storageDomainServerConnectionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainServerConnectionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(storageDomainServerConnectionServiceRemoveResponse)
}

//
// Detaches a storage connection from storage.
//
type storageDomainServerConnectionServiceRemoveResponse struct {
}

//
// Detaches a storage connection from storage.
//
func (p *storageDomainServerConnectionService) Remove() *storageDomainServerConnectionServiceRemoveRequest {
	return &storageDomainServerConnectionServiceRemoveRequest{storageDomainServerConnectionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainServerConnectionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *storageDomainServerConnectionService) String() string {
	return fmt.Sprintf("storageDomainServerConnectionService:%s", op.path)
}

//
//
type openstackSubnetsService struct {
	baseService
}

func NewOpenstackSubnetsService(connection *Connection, path string) *openstackSubnetsService {
	var result openstackSubnetsService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type openstackSubnetsServiceAddRequest struct {
	openstackSubnetsService *openstackSubnetsService
	header                  map[string]string
	query                   map[string]string
	subnet                  *OpenStackSubnet
}

func (p *openstackSubnetsServiceAddRequest) Header(key, value string) *openstackSubnetsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackSubnetsServiceAddRequest) Query(key, value string) *openstackSubnetsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackSubnetsServiceAddRequest) Subnet(subnet *OpenStackSubnet) *openstackSubnetsServiceAddRequest {
	p.subnet = subnet
	return p
}

func (p *openstackSubnetsServiceAddRequest) Send() (*openstackSubnetsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetsService.connection.URL(), p.openstackSubnetsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackSubnetWriteOne(writer, p.subnet, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackSubnetsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackSubnetsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackSubnetReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackSubnetsServiceAddResponse{subnet: result}, nil
}

func (p *openstackSubnetsServiceAddRequest) MustSend() *openstackSubnetsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetsService.connection.URL(), p.openstackSubnetsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackSubnetWriteOne(writer, p.subnet, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackSubnetsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackSubnetsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackSubnetReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackSubnetsServiceAddResponse{subnet: result}
}

//
//
type openstackSubnetsServiceAddResponse struct {
	subnet *OpenStackSubnet
}

func (p *openstackSubnetsServiceAddResponse) Subnet() (*OpenStackSubnet, bool) {
	if p.subnet != nil {
		return p.subnet, true
	}
	return nil, false
}

func (p *openstackSubnetsServiceAddResponse) MustSubnet() *OpenStackSubnet {
	if p.subnet == nil {
		panic("subnet in response does not exist")
	}
	return p.subnet
}

//
//
func (p *openstackSubnetsService) Add() *openstackSubnetsServiceAddRequest {
	return &openstackSubnetsServiceAddRequest{openstackSubnetsService: p}
}

//
// Returns the list of sub-networks.
// The order of the returned list of sub-networks isn't guaranteed.
//
type openstackSubnetsServiceListRequest struct {
	openstackSubnetsService *openstackSubnetsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
	max                     *int64
}

func (p *openstackSubnetsServiceListRequest) Header(key, value string) *openstackSubnetsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackSubnetsServiceListRequest) Query(key, value string) *openstackSubnetsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackSubnetsServiceListRequest) Follow(follow string) *openstackSubnetsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *openstackSubnetsServiceListRequest) Max(max int64) *openstackSubnetsServiceListRequest {
	p.max = &max
	return p
}

func (p *openstackSubnetsServiceListRequest) Send() (*openstackSubnetsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetsService.connection.URL(), p.openstackSubnetsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackSubnetsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackSubnetsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackSubnetReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &openstackSubnetsServiceListResponse{subnets: result}, nil
}

func (p *openstackSubnetsServiceListRequest) MustSend() *openstackSubnetsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetsService.connection.URL(), p.openstackSubnetsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackSubnetsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackSubnetsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackSubnetReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &openstackSubnetsServiceListResponse{subnets: result}
}

//
// Returns the list of sub-networks.
// The order of the returned list of sub-networks isn't guaranteed.
//
type openstackSubnetsServiceListResponse struct {
	subnets *OpenStackSubnetSlice
}

func (p *openstackSubnetsServiceListResponse) Subnets() (*OpenStackSubnetSlice, bool) {
	if p.subnets != nil {
		return p.subnets, true
	}
	return nil, false
}

func (p *openstackSubnetsServiceListResponse) MustSubnets() *OpenStackSubnetSlice {
	if p.subnets == nil {
		panic("subnets in response does not exist")
	}
	return p.subnets
}

//
// Returns the list of sub-networks.
// The order of the returned list of sub-networks isn't guaranteed.
//
func (p *openstackSubnetsService) List() *openstackSubnetsServiceListRequest {
	return &openstackSubnetsServiceListRequest{openstackSubnetsService: p}
}

//
//
func (op *openstackSubnetsService) SubnetService(id string) *openstackSubnetService {
	return NewOpenstackSubnetService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackSubnetsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.SubnetService(path), nil
	}
	return op.SubnetService(path[:index]).Service(path[index+1:])
}

func (op *openstackSubnetsService) String() string {
	return fmt.Sprintf("openstackSubnetsService:%s", op.path)
}

//
//
type openstackVolumeTypeService struct {
	baseService
}

func NewOpenstackVolumeTypeService(connection *Connection, path string) *openstackVolumeTypeService {
	var result openstackVolumeTypeService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type openstackVolumeTypeServiceGetRequest struct {
	openstackVolumeTypeService *openstackVolumeTypeService
	header                     map[string]string
	query                      map[string]string
	follow                     *string
}

func (p *openstackVolumeTypeServiceGetRequest) Header(key, value string) *openstackVolumeTypeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeTypeServiceGetRequest) Query(key, value string) *openstackVolumeTypeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeTypeServiceGetRequest) Follow(follow string) *openstackVolumeTypeServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *openstackVolumeTypeServiceGetRequest) Send() (*openstackVolumeTypeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeTypeService.connection.URL(), p.openstackVolumeTypeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeTypeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeTypeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeTypeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackVolumeTypeServiceGetResponse{type_: result}, nil
}

func (p *openstackVolumeTypeServiceGetRequest) MustSend() *openstackVolumeTypeServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeTypeService.connection.URL(), p.openstackVolumeTypeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeTypeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeTypeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeTypeReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackVolumeTypeServiceGetResponse{type_: result}
}

//
//
type openstackVolumeTypeServiceGetResponse struct {
	type_ *OpenStackVolumeType
}

func (p *openstackVolumeTypeServiceGetResponse) Type() (*OpenStackVolumeType, bool) {
	if p.type_ != nil {
		return p.type_, true
	}
	return nil, false
}

func (p *openstackVolumeTypeServiceGetResponse) MustType() *OpenStackVolumeType {
	if p.type_ == nil {
		panic("type_ in response does not exist")
	}
	return p.type_
}

//
//
func (p *openstackVolumeTypeService) Get() *openstackVolumeTypeServiceGetRequest {
	return &openstackVolumeTypeServiceGetRequest{openstackVolumeTypeService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackVolumeTypeService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *openstackVolumeTypeService) String() string {
	return fmt.Sprintf("openstackVolumeTypeService:%s", op.path)
}

//
//
type openstackVolumeAuthenticationKeyService struct {
	baseService
}

func NewOpenstackVolumeAuthenticationKeyService(connection *Connection, path string) *openstackVolumeAuthenticationKeyService {
	var result openstackVolumeAuthenticationKeyService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type openstackVolumeAuthenticationKeyServiceGetRequest struct {
	openstackVolumeAuthenticationKeyService *openstackVolumeAuthenticationKeyService
	header                                  map[string]string
	query                                   map[string]string
	follow                                  *string
}

func (p *openstackVolumeAuthenticationKeyServiceGetRequest) Header(key, value string) *openstackVolumeAuthenticationKeyServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeAuthenticationKeyServiceGetRequest) Query(key, value string) *openstackVolumeAuthenticationKeyServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeAuthenticationKeyServiceGetRequest) Follow(follow string) *openstackVolumeAuthenticationKeyServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *openstackVolumeAuthenticationKeyServiceGetRequest) Send() (*openstackVolumeAuthenticationKeyServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeyService.connection.URL(), p.openstackVolumeAuthenticationKeyService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeAuthenticationKeyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenstackVolumeAuthenticationKeyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackVolumeAuthenticationKeyServiceGetResponse{key: result}, nil
}

func (p *openstackVolumeAuthenticationKeyServiceGetRequest) MustSend() *openstackVolumeAuthenticationKeyServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeyService.connection.URL(), p.openstackVolumeAuthenticationKeyService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeAuthenticationKeyService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeyService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenstackVolumeAuthenticationKeyReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackVolumeAuthenticationKeyServiceGetResponse{key: result}
}

//
//
type openstackVolumeAuthenticationKeyServiceGetResponse struct {
	key *OpenstackVolumeAuthenticationKey
}

func (p *openstackVolumeAuthenticationKeyServiceGetResponse) Key() (*OpenstackVolumeAuthenticationKey, bool) {
	if p.key != nil {
		return p.key, true
	}
	return nil, false
}

func (p *openstackVolumeAuthenticationKeyServiceGetResponse) MustKey() *OpenstackVolumeAuthenticationKey {
	if p.key == nil {
		panic("key in response does not exist")
	}
	return p.key
}

//
//
func (p *openstackVolumeAuthenticationKeyService) Get() *openstackVolumeAuthenticationKeyServiceGetRequest {
	return &openstackVolumeAuthenticationKeyServiceGetRequest{openstackVolumeAuthenticationKeyService: p}
}

//
//
type openstackVolumeAuthenticationKeyServiceRemoveRequest struct {
	openstackVolumeAuthenticationKeyService *openstackVolumeAuthenticationKeyService
	header                                  map[string]string
	query                                   map[string]string
	async                                   *bool
}

func (p *openstackVolumeAuthenticationKeyServiceRemoveRequest) Header(key, value string) *openstackVolumeAuthenticationKeyServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeAuthenticationKeyServiceRemoveRequest) Query(key, value string) *openstackVolumeAuthenticationKeyServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeAuthenticationKeyServiceRemoveRequest) Async(async bool) *openstackVolumeAuthenticationKeyServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *openstackVolumeAuthenticationKeyServiceRemoveRequest) Send() (*openstackVolumeAuthenticationKeyServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeyService.connection.URL(), p.openstackVolumeAuthenticationKeyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeAuthenticationKeyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(openstackVolumeAuthenticationKeyServiceRemoveResponse), nil
}

func (p *openstackVolumeAuthenticationKeyServiceRemoveRequest) MustSend() *openstackVolumeAuthenticationKeyServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeyService.connection.URL(), p.openstackVolumeAuthenticationKeyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeAuthenticationKeyService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeyService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(openstackVolumeAuthenticationKeyServiceRemoveResponse)
}

//
//
type openstackVolumeAuthenticationKeyServiceRemoveResponse struct {
}

//
//
func (p *openstackVolumeAuthenticationKeyService) Remove() *openstackVolumeAuthenticationKeyServiceRemoveRequest {
	return &openstackVolumeAuthenticationKeyServiceRemoveRequest{openstackVolumeAuthenticationKeyService: p}
}

//
// Update the specified authentication key.
//
type openstackVolumeAuthenticationKeyServiceUpdateRequest struct {
	openstackVolumeAuthenticationKeyService *openstackVolumeAuthenticationKeyService
	header                                  map[string]string
	query                                   map[string]string
	key                                     *OpenstackVolumeAuthenticationKey
}

func (p *openstackVolumeAuthenticationKeyServiceUpdateRequest) Header(key, value string) *openstackVolumeAuthenticationKeyServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeAuthenticationKeyServiceUpdateRequest) Query(key, value string) *openstackVolumeAuthenticationKeyServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeAuthenticationKeyServiceUpdateRequest) Key(key *OpenstackVolumeAuthenticationKey) *openstackVolumeAuthenticationKeyServiceUpdateRequest {
	p.key = key
	return p
}

func (p *openstackVolumeAuthenticationKeyServiceUpdateRequest) Send() (*openstackVolumeAuthenticationKeyServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeyService.connection.URL(), p.openstackVolumeAuthenticationKeyService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenstackVolumeAuthenticationKeyWriteOne(writer, p.key, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeAuthenticationKeyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenstackVolumeAuthenticationKeyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackVolumeAuthenticationKeyServiceUpdateResponse{key: result}, nil
}

func (p *openstackVolumeAuthenticationKeyServiceUpdateRequest) MustSend() *openstackVolumeAuthenticationKeyServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeyService.connection.URL(), p.openstackVolumeAuthenticationKeyService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenstackVolumeAuthenticationKeyWriteOne(writer, p.key, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeAuthenticationKeyService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeyService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenstackVolumeAuthenticationKeyReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackVolumeAuthenticationKeyServiceUpdateResponse{key: result}
}

//
// Update the specified authentication key.
//
type openstackVolumeAuthenticationKeyServiceUpdateResponse struct {
	key *OpenstackVolumeAuthenticationKey
}

func (p *openstackVolumeAuthenticationKeyServiceUpdateResponse) Key() (*OpenstackVolumeAuthenticationKey, bool) {
	if p.key != nil {
		return p.key, true
	}
	return nil, false
}

func (p *openstackVolumeAuthenticationKeyServiceUpdateResponse) MustKey() *OpenstackVolumeAuthenticationKey {
	if p.key == nil {
		panic("key in response does not exist")
	}
	return p.key
}

//
// Update the specified authentication key.
//
func (p *openstackVolumeAuthenticationKeyService) Update() *openstackVolumeAuthenticationKeyServiceUpdateRequest {
	return &openstackVolumeAuthenticationKeyServiceUpdateRequest{openstackVolumeAuthenticationKeyService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackVolumeAuthenticationKeyService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *openstackVolumeAuthenticationKeyService) String() string {
	return fmt.Sprintf("openstackVolumeAuthenticationKeyService:%s", op.path)
}

//
//
type openstackImageProvidersService struct {
	baseService
}

func NewOpenstackImageProvidersService(connection *Connection, path string) *openstackImageProvidersService {
	var result openstackImageProvidersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new OpenStack image provider to the system.
//
type openstackImageProvidersServiceAddRequest struct {
	openstackImageProvidersService *openstackImageProvidersService
	header                         map[string]string
	query                          map[string]string
	provider                       *OpenStackImageProvider
}

func (p *openstackImageProvidersServiceAddRequest) Header(key, value string) *openstackImageProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackImageProvidersServiceAddRequest) Query(key, value string) *openstackImageProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackImageProvidersServiceAddRequest) Provider(provider *OpenStackImageProvider) *openstackImageProvidersServiceAddRequest {
	p.provider = provider
	return p
}

func (p *openstackImageProvidersServiceAddRequest) Send() (*openstackImageProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProvidersService.connection.URL(), p.openstackImageProvidersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackImageProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackImageProvidersServiceAddResponse{provider: result}, nil
}

func (p *openstackImageProvidersServiceAddRequest) MustSend() *openstackImageProvidersServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProvidersService.connection.URL(), p.openstackImageProvidersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackImageProviderWriteOne(writer, p.provider, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProvidersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProvidersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageProviderReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackImageProvidersServiceAddResponse{provider: result}
}

//
// Add a new OpenStack image provider to the system.
//
type openstackImageProvidersServiceAddResponse struct {
	provider *OpenStackImageProvider
}

func (p *openstackImageProvidersServiceAddResponse) Provider() (*OpenStackImageProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *openstackImageProvidersServiceAddResponse) MustProvider() *OpenStackImageProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Add a new OpenStack image provider to the system.
//
func (p *openstackImageProvidersService) Add() *openstackImageProvidersServiceAddRequest {
	return &openstackImageProvidersServiceAddRequest{openstackImageProvidersService: p}
}

//
// Returns the list of providers.
// The order of the returned list of providers isn't guaranteed.
//
type openstackImageProvidersServiceListRequest struct {
	openstackImageProvidersService *openstackImageProvidersService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
	max                            *int64
}

func (p *openstackImageProvidersServiceListRequest) Header(key, value string) *openstackImageProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackImageProvidersServiceListRequest) Query(key, value string) *openstackImageProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackImageProvidersServiceListRequest) Follow(follow string) *openstackImageProvidersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *openstackImageProvidersServiceListRequest) Max(max int64) *openstackImageProvidersServiceListRequest {
	p.max = &max
	return p
}

func (p *openstackImageProvidersServiceListRequest) Send() (*openstackImageProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProvidersService.connection.URL(), p.openstackImageProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageProviderReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &openstackImageProvidersServiceListResponse{providers: result}, nil
}

func (p *openstackImageProvidersServiceListRequest) MustSend() *openstackImageProvidersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProvidersService.connection.URL(), p.openstackImageProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProvidersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProvidersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageProviderReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &openstackImageProvidersServiceListResponse{providers: result}
}

//
// Returns the list of providers.
// The order of the returned list of providers isn't guaranteed.
//
type openstackImageProvidersServiceListResponse struct {
	providers *OpenStackImageProviderSlice
}

func (p *openstackImageProvidersServiceListResponse) Providers() (*OpenStackImageProviderSlice, bool) {
	if p.providers != nil {
		return p.providers, true
	}
	return nil, false
}

func (p *openstackImageProvidersServiceListResponse) MustProviders() *OpenStackImageProviderSlice {
	if p.providers == nil {
		panic("providers in response does not exist")
	}
	return p.providers
}

//
// Returns the list of providers.
// The order of the returned list of providers isn't guaranteed.
//
func (p *openstackImageProvidersService) List() *openstackImageProvidersServiceListRequest {
	return &openstackImageProvidersServiceListRequest{openstackImageProvidersService: p}
}

//
//
func (op *openstackImageProvidersService) ProviderService(id string) *openstackImageProviderService {
	return NewOpenstackImageProviderService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackImageProvidersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProviderService(path), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *openstackImageProvidersService) String() string {
	return fmt.Sprintf("openstackImageProvidersService:%s", op.path)
}

//
//
type openstackImageProviderService struct {
	baseService
}

func NewOpenstackImageProviderService(connection *Connection, path string) *openstackImageProviderService {
	var result openstackImageProviderService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type openstackImageProviderServiceGetRequest struct {
	openstackImageProviderService *openstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
}

func (p *openstackImageProviderServiceGetRequest) Header(key, value string) *openstackImageProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackImageProviderServiceGetRequest) Query(key, value string) *openstackImageProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackImageProviderServiceGetRequest) Follow(follow string) *openstackImageProviderServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *openstackImageProviderServiceGetRequest) Send() (*openstackImageProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProviderService.connection.URL(), p.openstackImageProviderService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackImageProviderServiceGetResponse{provider: result}, nil
}

func (p *openstackImageProviderServiceGetRequest) MustSend() *openstackImageProviderServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProviderService.connection.URL(), p.openstackImageProviderService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageProviderReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackImageProviderServiceGetResponse{provider: result}
}

//
//
type openstackImageProviderServiceGetResponse struct {
	provider *OpenStackImageProvider
}

func (p *openstackImageProviderServiceGetResponse) Provider() (*OpenStackImageProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *openstackImageProviderServiceGetResponse) MustProvider() *OpenStackImageProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
//
func (p *openstackImageProviderService) Get() *openstackImageProviderServiceGetRequest {
	return &openstackImageProviderServiceGetRequest{openstackImageProviderService: p}
}

//
// Import the SSL certificates of the external host provider.
//
type openstackImageProviderServiceImportCertificatesRequest struct {
	openstackImageProviderService *openstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	certificates                  *CertificateSlice
}

func (p *openstackImageProviderServiceImportCertificatesRequest) Header(key, value string) *openstackImageProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackImageProviderServiceImportCertificatesRequest) Query(key, value string) *openstackImageProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackImageProviderServiceImportCertificatesRequest) Certificates(certificates *CertificateSlice) *openstackImageProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}

func (p *openstackImageProviderServiceImportCertificatesRequest) CertificatesOfAny(anys ...*Certificate) *openstackImageProviderServiceImportCertificatesRequest {
	if p.certificates == nil {
		p.certificates = new(CertificateSlice)
	}
	p.certificates.slice = append(p.certificates.slice, anys...)
	return p
}

func (p *openstackImageProviderServiceImportCertificatesRequest) Send() (*openstackImageProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.openstackImageProviderService.connection.URL(), p.openstackImageProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(openstackImageProviderServiceImportCertificatesResponse), nil
}

func (p *openstackImageProviderServiceImportCertificatesRequest) MustSend() *openstackImageProviderServiceImportCertificatesResponse {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.openstackImageProviderService.connection.URL(), p.openstackImageProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(openstackImageProviderServiceImportCertificatesResponse)
}

//
// Import the SSL certificates of the external host provider.
//
type openstackImageProviderServiceImportCertificatesResponse struct {
}

//
// Import the SSL certificates of the external host provider.
//
func (p *openstackImageProviderService) ImportCertificates() *openstackImageProviderServiceImportCertificatesRequest {
	return &openstackImageProviderServiceImportCertificatesRequest{openstackImageProviderService: p}
}

//
//
type openstackImageProviderServiceRemoveRequest struct {
	openstackImageProviderService *openstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
}

func (p *openstackImageProviderServiceRemoveRequest) Header(key, value string) *openstackImageProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackImageProviderServiceRemoveRequest) Query(key, value string) *openstackImageProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackImageProviderServiceRemoveRequest) Async(async bool) *openstackImageProviderServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *openstackImageProviderServiceRemoveRequest) Send() (*openstackImageProviderServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProviderService.connection.URL(), p.openstackImageProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(openstackImageProviderServiceRemoveResponse), nil
}

func (p *openstackImageProviderServiceRemoveRequest) MustSend() *openstackImageProviderServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProviderService.connection.URL(), p.openstackImageProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(openstackImageProviderServiceRemoveResponse)
}

//
//
type openstackImageProviderServiceRemoveResponse struct {
}

//
//
func (p *openstackImageProviderService) Remove() *openstackImageProviderServiceRemoveRequest {
	return &openstackImageProviderServiceRemoveRequest{openstackImageProviderService: p}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type openstackImageProviderServiceTestConnectivityRequest struct {
	openstackImageProviderService *openstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
}

func (p *openstackImageProviderServiceTestConnectivityRequest) Header(key, value string) *openstackImageProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackImageProviderServiceTestConnectivityRequest) Query(key, value string) *openstackImageProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackImageProviderServiceTestConnectivityRequest) Async(async bool) *openstackImageProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}

func (p *openstackImageProviderServiceTestConnectivityRequest) Send() (*openstackImageProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.openstackImageProviderService.connection.URL(), p.openstackImageProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(openstackImageProviderServiceTestConnectivityResponse), nil
}

func (p *openstackImageProviderServiceTestConnectivityRequest) MustSend() *openstackImageProviderServiceTestConnectivityResponse {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.openstackImageProviderService.connection.URL(), p.openstackImageProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(openstackImageProviderServiceTestConnectivityResponse)
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type openstackImageProviderServiceTestConnectivityResponse struct {
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
func (p *openstackImageProviderService) TestConnectivity() *openstackImageProviderServiceTestConnectivityRequest {
	return &openstackImageProviderServiceTestConnectivityRequest{openstackImageProviderService: p}
}

//
// Update the specified OpenStack image provider in the system.
//
type openstackImageProviderServiceUpdateRequest struct {
	openstackImageProviderService *openstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
	provider                      *OpenStackImageProvider
}

func (p *openstackImageProviderServiceUpdateRequest) Header(key, value string) *openstackImageProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackImageProviderServiceUpdateRequest) Query(key, value string) *openstackImageProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackImageProviderServiceUpdateRequest) Async(async bool) *openstackImageProviderServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *openstackImageProviderServiceUpdateRequest) Provider(provider *OpenStackImageProvider) *openstackImageProviderServiceUpdateRequest {
	p.provider = provider
	return p
}

func (p *openstackImageProviderServiceUpdateRequest) Send() (*openstackImageProviderServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProviderService.connection.URL(), p.openstackImageProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackImageProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackImageProviderServiceUpdateResponse{provider: result}, nil
}

func (p *openstackImageProviderServiceUpdateRequest) MustSend() *openstackImageProviderServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageProviderService.connection.URL(), p.openstackImageProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackImageProviderWriteOne(writer, p.provider, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageProviderReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackImageProviderServiceUpdateResponse{provider: result}
}

//
// Update the specified OpenStack image provider in the system.
//
type openstackImageProviderServiceUpdateResponse struct {
	provider *OpenStackImageProvider
}

func (p *openstackImageProviderServiceUpdateResponse) Provider() (*OpenStackImageProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *openstackImageProviderServiceUpdateResponse) MustProvider() *OpenStackImageProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Update the specified OpenStack image provider in the system.
//
func (p *openstackImageProviderService) Update() *openstackImageProviderServiceUpdateRequest {
	return &openstackImageProviderServiceUpdateRequest{openstackImageProviderService: p}
}

//
// A service to view certificates for this external provider.
//
func (op *openstackImageProviderService) CertificatesService() *externalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.connection, fmt.Sprintf("%s/certificates", op.path))
}

//
//
func (op *openstackImageProviderService) ImagesService() *openstackImagesService {
	return NewOpenstackImagesService(op.connection, fmt.Sprintf("%s/images", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackImageProviderService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "images" {
		return op.ImagesService(), nil
	}
	if strings.HasPrefix(path, "images/") {
		return op.ImagesService().Service(path[7:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *openstackImageProviderService) String() string {
	return fmt.Sprintf("openstackImageProviderService:%s", op.path)
}

//
//
type openstackImageService struct {
	baseService
}

func NewOpenstackImageService(connection *Connection, path string) *openstackImageService {
	var result openstackImageService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type openstackImageServiceGetRequest struct {
	openstackImageService *openstackImageService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *openstackImageServiceGetRequest) Header(key, value string) *openstackImageServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackImageServiceGetRequest) Query(key, value string) *openstackImageServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackImageServiceGetRequest) Follow(follow string) *openstackImageServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *openstackImageServiceGetRequest) Send() (*openstackImageServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageService.connection.URL(), p.openstackImageService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackImageServiceGetResponse{image: result}, nil
}

func (p *openstackImageServiceGetRequest) MustSend() *openstackImageServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackImageService.connection.URL(), p.openstackImageService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackImageServiceGetResponse{image: result}
}

//
//
type openstackImageServiceGetResponse struct {
	image *OpenStackImage
}

func (p *openstackImageServiceGetResponse) Image() (*OpenStackImage, bool) {
	if p.image != nil {
		return p.image, true
	}
	return nil, false
}

func (p *openstackImageServiceGetResponse) MustImage() *OpenStackImage {
	if p.image == nil {
		panic("image in response does not exist")
	}
	return p.image
}

//
//
func (p *openstackImageService) Get() *openstackImageServiceGetRequest {
	return &openstackImageServiceGetRequest{openstackImageService: p}
}

//
// Imports a virtual machine from a Glance image storage domain.
// For example, to import the image with identifier `456` from the
// storage domain with identifier `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/openstackimageproviders/123/images/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>images0</name>
//   </storage_domain>
//   <cluster>
//     <name>images0</name>
//   </cluster>
// </action>
// ----
//
type openstackImageServiceImportRequest struct {
	openstackImageService *openstackImageService
	header                map[string]string
	query                 map[string]string
	async                 *bool
	cluster               *Cluster
	disk                  *Disk
	importAsTemplate      *bool
	storageDomain         *StorageDomain
	template              *Template
}

func (p *openstackImageServiceImportRequest) Header(key, value string) *openstackImageServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackImageServiceImportRequest) Query(key, value string) *openstackImageServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackImageServiceImportRequest) Async(async bool) *openstackImageServiceImportRequest {
	p.async = &async
	return p
}

func (p *openstackImageServiceImportRequest) Cluster(cluster *Cluster) *openstackImageServiceImportRequest {
	p.cluster = cluster
	return p
}

func (p *openstackImageServiceImportRequest) Disk(disk *Disk) *openstackImageServiceImportRequest {
	p.disk = disk
	return p
}

func (p *openstackImageServiceImportRequest) ImportAsTemplate(importAsTemplate bool) *openstackImageServiceImportRequest {
	p.importAsTemplate = &importAsTemplate
	return p
}

func (p *openstackImageServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *openstackImageServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *openstackImageServiceImportRequest) Template(template *Template) *openstackImageServiceImportRequest {
	p.template = template
	return p
}

func (p *openstackImageServiceImportRequest) Send() (*openstackImageServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.openstackImageService.connection.URL(), p.openstackImageService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Disk(p.disk)
	if p.importAsTemplate != nil {
		actionBuilder.ImportAsTemplate(*p.importAsTemplate)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Template(p.template)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(openstackImageServiceImportResponse), nil
}

func (p *openstackImageServiceImportRequest) MustSend() *openstackImageServiceImportResponse {
	rawURL := fmt.Sprintf("%s%s/import", p.openstackImageService.connection.URL(), p.openstackImageService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Disk(p.disk)
	if p.importAsTemplate != nil {
		actionBuilder.ImportAsTemplate(*p.importAsTemplate)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Template(p.template)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImageService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImageService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(openstackImageServiceImportResponse)
}

//
// Imports a virtual machine from a Glance image storage domain.
// For example, to import the image with identifier `456` from the
// storage domain with identifier `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/openstackimageproviders/123/images/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>images0</name>
//   </storage_domain>
//   <cluster>
//     <name>images0</name>
//   </cluster>
// </action>
// ----
//
type openstackImageServiceImportResponse struct {
}

//
// Imports a virtual machine from a Glance image storage domain.
// For example, to import the image with identifier `456` from the
// storage domain with identifier `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/openstackimageproviders/123/images/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>images0</name>
//   </storage_domain>
//   <cluster>
//     <name>images0</name>
//   </cluster>
// </action>
// ----
//
func (p *openstackImageService) Import() *openstackImageServiceImportRequest {
	return &openstackImageServiceImportRequest{openstackImageService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackImageService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *openstackImageService) String() string {
	return fmt.Sprintf("openstackImageService:%s", op.path)
}

//
//
type openstackVolumeTypesService struct {
	baseService
}

func NewOpenstackVolumeTypesService(connection *Connection, path string) *openstackVolumeTypesService {
	var result openstackVolumeTypesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of volume types.
// The order of the returned list of volume types isn't guaranteed.
//
type openstackVolumeTypesServiceListRequest struct {
	openstackVolumeTypesService *openstackVolumeTypesService
	header                      map[string]string
	query                       map[string]string
	follow                      *string
	max                         *int64
}

func (p *openstackVolumeTypesServiceListRequest) Header(key, value string) *openstackVolumeTypesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeTypesServiceListRequest) Query(key, value string) *openstackVolumeTypesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeTypesServiceListRequest) Follow(follow string) *openstackVolumeTypesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *openstackVolumeTypesServiceListRequest) Max(max int64) *openstackVolumeTypesServiceListRequest {
	p.max = &max
	return p
}

func (p *openstackVolumeTypesServiceListRequest) Send() (*openstackVolumeTypesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeTypesService.connection.URL(), p.openstackVolumeTypesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeTypesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeTypesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeTypeReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &openstackVolumeTypesServiceListResponse{types: result}, nil
}

func (p *openstackVolumeTypesServiceListRequest) MustSend() *openstackVolumeTypesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeTypesService.connection.URL(), p.openstackVolumeTypesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeTypesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeTypesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeTypeReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &openstackVolumeTypesServiceListResponse{types: result}
}

//
// Returns the list of volume types.
// The order of the returned list of volume types isn't guaranteed.
//
type openstackVolumeTypesServiceListResponse struct {
	types *OpenStackVolumeTypeSlice
}

func (p *openstackVolumeTypesServiceListResponse) Types() (*OpenStackVolumeTypeSlice, bool) {
	if p.types != nil {
		return p.types, true
	}
	return nil, false
}

func (p *openstackVolumeTypesServiceListResponse) MustTypes() *OpenStackVolumeTypeSlice {
	if p.types == nil {
		panic("types in response does not exist")
	}
	return p.types
}

//
// Returns the list of volume types.
// The order of the returned list of volume types isn't guaranteed.
//
func (p *openstackVolumeTypesService) List() *openstackVolumeTypesServiceListRequest {
	return &openstackVolumeTypesServiceListRequest{openstackVolumeTypesService: p}
}

//
//
func (op *openstackVolumeTypesService) TypeService(id string) *openstackVolumeTypeService {
	return NewOpenstackVolumeTypeService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackVolumeTypesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.TypeService(path), nil
	}
	return op.TypeService(path[:index]).Service(path[index+1:])
}

func (op *openstackVolumeTypesService) String() string {
	return fmt.Sprintf("openstackVolumeTypesService:%s", op.path)
}

//
//
type openstackSubnetService struct {
	baseService
}

func NewOpenstackSubnetService(connection *Connection, path string) *openstackSubnetService {
	var result openstackSubnetService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type openstackSubnetServiceGetRequest struct {
	openstackSubnetService *openstackSubnetService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *openstackSubnetServiceGetRequest) Header(key, value string) *openstackSubnetServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackSubnetServiceGetRequest) Query(key, value string) *openstackSubnetServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackSubnetServiceGetRequest) Follow(follow string) *openstackSubnetServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *openstackSubnetServiceGetRequest) Send() (*openstackSubnetServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetService.connection.URL(), p.openstackSubnetService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackSubnetService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackSubnetService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackSubnetReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackSubnetServiceGetResponse{subnet: result}, nil
}

func (p *openstackSubnetServiceGetRequest) MustSend() *openstackSubnetServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetService.connection.URL(), p.openstackSubnetService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackSubnetService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackSubnetService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackSubnetReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackSubnetServiceGetResponse{subnet: result}
}

//
//
type openstackSubnetServiceGetResponse struct {
	subnet *OpenStackSubnet
}

func (p *openstackSubnetServiceGetResponse) Subnet() (*OpenStackSubnet, bool) {
	if p.subnet != nil {
		return p.subnet, true
	}
	return nil, false
}

func (p *openstackSubnetServiceGetResponse) MustSubnet() *OpenStackSubnet {
	if p.subnet == nil {
		panic("subnet in response does not exist")
	}
	return p.subnet
}

//
//
func (p *openstackSubnetService) Get() *openstackSubnetServiceGetRequest {
	return &openstackSubnetServiceGetRequest{openstackSubnetService: p}
}

//
//
type openstackSubnetServiceRemoveRequest struct {
	openstackSubnetService *openstackSubnetService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *openstackSubnetServiceRemoveRequest) Header(key, value string) *openstackSubnetServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackSubnetServiceRemoveRequest) Query(key, value string) *openstackSubnetServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackSubnetServiceRemoveRequest) Async(async bool) *openstackSubnetServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *openstackSubnetServiceRemoveRequest) Send() (*openstackSubnetServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetService.connection.URL(), p.openstackSubnetService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackSubnetService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackSubnetService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(openstackSubnetServiceRemoveResponse), nil
}

func (p *openstackSubnetServiceRemoveRequest) MustSend() *openstackSubnetServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackSubnetService.connection.URL(), p.openstackSubnetService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackSubnetService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackSubnetService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(openstackSubnetServiceRemoveResponse)
}

//
//
type openstackSubnetServiceRemoveResponse struct {
}

//
//
func (p *openstackSubnetService) Remove() *openstackSubnetServiceRemoveRequest {
	return &openstackSubnetServiceRemoveRequest{openstackSubnetService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackSubnetService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *openstackSubnetService) String() string {
	return fmt.Sprintf("openstackSubnetService:%s", op.path)
}

//
//
type openstackNetworksService struct {
	baseService
}

func NewOpenstackNetworksService(connection *Connection, path string) *openstackNetworksService {
	var result openstackNetworksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of networks.
// The order of the returned list of networks isn't guaranteed.
//
type openstackNetworksServiceListRequest struct {
	openstackNetworksService *openstackNetworksService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
	max                      *int64
}

func (p *openstackNetworksServiceListRequest) Header(key, value string) *openstackNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackNetworksServiceListRequest) Query(key, value string) *openstackNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackNetworksServiceListRequest) Follow(follow string) *openstackNetworksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *openstackNetworksServiceListRequest) Max(max int64) *openstackNetworksServiceListRequest {
	p.max = &max
	return p
}

func (p *openstackNetworksServiceListRequest) Send() (*openstackNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworksService.connection.URL(), p.openstackNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &openstackNetworksServiceListResponse{networks: result}, nil
}

func (p *openstackNetworksServiceListRequest) MustSend() *openstackNetworksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworksService.connection.URL(), p.openstackNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &openstackNetworksServiceListResponse{networks: result}
}

//
// Returns the list of networks.
// The order of the returned list of networks isn't guaranteed.
//
type openstackNetworksServiceListResponse struct {
	networks *OpenStackNetworkSlice
}

func (p *openstackNetworksServiceListResponse) Networks() (*OpenStackNetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *openstackNetworksServiceListResponse) MustNetworks() *OpenStackNetworkSlice {
	if p.networks == nil {
		panic("networks in response does not exist")
	}
	return p.networks
}

//
// Returns the list of networks.
// The order of the returned list of networks isn't guaranteed.
//
func (p *openstackNetworksService) List() *openstackNetworksServiceListRequest {
	return &openstackNetworksServiceListRequest{openstackNetworksService: p}
}

//
//
func (op *openstackNetworksService) NetworkService(id string) *openstackNetworkService {
	return NewOpenstackNetworkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackNetworksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NetworkService(path), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *openstackNetworksService) String() string {
	return fmt.Sprintf("openstackNetworksService:%s", op.path)
}

//
//
type openstackVolumeProviderService struct {
	baseService
}

func NewOpenstackVolumeProviderService(connection *Connection, path string) *openstackVolumeProviderService {
	var result openstackVolumeProviderService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type openstackVolumeProviderServiceGetRequest struct {
	openstackVolumeProviderService *openstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
}

func (p *openstackVolumeProviderServiceGetRequest) Header(key, value string) *openstackVolumeProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeProviderServiceGetRequest) Query(key, value string) *openstackVolumeProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeProviderServiceGetRequest) Follow(follow string) *openstackVolumeProviderServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *openstackVolumeProviderServiceGetRequest) Send() (*openstackVolumeProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProviderService.connection.URL(), p.openstackVolumeProviderService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackVolumeProviderServiceGetResponse{provider: result}, nil
}

func (p *openstackVolumeProviderServiceGetRequest) MustSend() *openstackVolumeProviderServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProviderService.connection.URL(), p.openstackVolumeProviderService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeProviderReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackVolumeProviderServiceGetResponse{provider: result}
}

//
//
type openstackVolumeProviderServiceGetResponse struct {
	provider *OpenStackVolumeProvider
}

func (p *openstackVolumeProviderServiceGetResponse) Provider() (*OpenStackVolumeProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *openstackVolumeProviderServiceGetResponse) MustProvider() *OpenStackVolumeProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
//
func (p *openstackVolumeProviderService) Get() *openstackVolumeProviderServiceGetRequest {
	return &openstackVolumeProviderServiceGetRequest{openstackVolumeProviderService: p}
}

//
// Import the SSL certificates of the external host provider.
//
type openstackVolumeProviderServiceImportCertificatesRequest struct {
	openstackVolumeProviderService *openstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	certificates                   *CertificateSlice
}

func (p *openstackVolumeProviderServiceImportCertificatesRequest) Header(key, value string) *openstackVolumeProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeProviderServiceImportCertificatesRequest) Query(key, value string) *openstackVolumeProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeProviderServiceImportCertificatesRequest) Certificates(certificates *CertificateSlice) *openstackVolumeProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}

func (p *openstackVolumeProviderServiceImportCertificatesRequest) CertificatesOfAny(anys ...*Certificate) *openstackVolumeProviderServiceImportCertificatesRequest {
	if p.certificates == nil {
		p.certificates = new(CertificateSlice)
	}
	p.certificates.slice = append(p.certificates.slice, anys...)
	return p
}

func (p *openstackVolumeProviderServiceImportCertificatesRequest) Send() (*openstackVolumeProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.openstackVolumeProviderService.connection.URL(), p.openstackVolumeProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(openstackVolumeProviderServiceImportCertificatesResponse), nil
}

func (p *openstackVolumeProviderServiceImportCertificatesRequest) MustSend() *openstackVolumeProviderServiceImportCertificatesResponse {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.openstackVolumeProviderService.connection.URL(), p.openstackVolumeProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(openstackVolumeProviderServiceImportCertificatesResponse)
}

//
// Import the SSL certificates of the external host provider.
//
type openstackVolumeProviderServiceImportCertificatesResponse struct {
}

//
// Import the SSL certificates of the external host provider.
//
func (p *openstackVolumeProviderService) ImportCertificates() *openstackVolumeProviderServiceImportCertificatesRequest {
	return &openstackVolumeProviderServiceImportCertificatesRequest{openstackVolumeProviderService: p}
}

//
//
type openstackVolumeProviderServiceRemoveRequest struct {
	openstackVolumeProviderService *openstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	force                          *bool
}

func (p *openstackVolumeProviderServiceRemoveRequest) Header(key, value string) *openstackVolumeProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeProviderServiceRemoveRequest) Query(key, value string) *openstackVolumeProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeProviderServiceRemoveRequest) Async(async bool) *openstackVolumeProviderServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *openstackVolumeProviderServiceRemoveRequest) Force(force bool) *openstackVolumeProviderServiceRemoveRequest {
	p.force = &force
	return p
}

func (p *openstackVolumeProviderServiceRemoveRequest) Send() (*openstackVolumeProviderServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProviderService.connection.URL(), p.openstackVolumeProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(openstackVolumeProviderServiceRemoveResponse), nil
}

func (p *openstackVolumeProviderServiceRemoveRequest) MustSend() *openstackVolumeProviderServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProviderService.connection.URL(), p.openstackVolumeProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(openstackVolumeProviderServiceRemoveResponse)
}

//
//
type openstackVolumeProviderServiceRemoveResponse struct {
}

//
//
func (p *openstackVolumeProviderService) Remove() *openstackVolumeProviderServiceRemoveRequest {
	return &openstackVolumeProviderServiceRemoveRequest{openstackVolumeProviderService: p}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type openstackVolumeProviderServiceTestConnectivityRequest struct {
	openstackVolumeProviderService *openstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
}

func (p *openstackVolumeProviderServiceTestConnectivityRequest) Header(key, value string) *openstackVolumeProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeProviderServiceTestConnectivityRequest) Query(key, value string) *openstackVolumeProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeProviderServiceTestConnectivityRequest) Async(async bool) *openstackVolumeProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}

func (p *openstackVolumeProviderServiceTestConnectivityRequest) Send() (*openstackVolumeProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.openstackVolumeProviderService.connection.URL(), p.openstackVolumeProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(openstackVolumeProviderServiceTestConnectivityResponse), nil
}

func (p *openstackVolumeProviderServiceTestConnectivityRequest) MustSend() *openstackVolumeProviderServiceTestConnectivityResponse {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.openstackVolumeProviderService.connection.URL(), p.openstackVolumeProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(openstackVolumeProviderServiceTestConnectivityResponse)
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type openstackVolumeProviderServiceTestConnectivityResponse struct {
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
func (p *openstackVolumeProviderService) TestConnectivity() *openstackVolumeProviderServiceTestConnectivityRequest {
	return &openstackVolumeProviderServiceTestConnectivityRequest{openstackVolumeProviderService: p}
}

//
// Update the specified OpenStack volume provider in the system.
//
type openstackVolumeProviderServiceUpdateRequest struct {
	openstackVolumeProviderService *openstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	provider                       *OpenStackVolumeProvider
}

func (p *openstackVolumeProviderServiceUpdateRequest) Header(key, value string) *openstackVolumeProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeProviderServiceUpdateRequest) Query(key, value string) *openstackVolumeProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeProviderServiceUpdateRequest) Async(async bool) *openstackVolumeProviderServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *openstackVolumeProviderServiceUpdateRequest) Provider(provider *OpenStackVolumeProvider) *openstackVolumeProviderServiceUpdateRequest {
	p.provider = provider
	return p
}

func (p *openstackVolumeProviderServiceUpdateRequest) Send() (*openstackVolumeProviderServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProviderService.connection.URL(), p.openstackVolumeProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackVolumeProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackVolumeProviderServiceUpdateResponse{provider: result}, nil
}

func (p *openstackVolumeProviderServiceUpdateRequest) MustSend() *openstackVolumeProviderServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProviderService.connection.URL(), p.openstackVolumeProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackVolumeProviderWriteOne(writer, p.provider, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeProviderReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackVolumeProviderServiceUpdateResponse{provider: result}
}

//
// Update the specified OpenStack volume provider in the system.
//
type openstackVolumeProviderServiceUpdateResponse struct {
	provider *OpenStackVolumeProvider
}

func (p *openstackVolumeProviderServiceUpdateResponse) Provider() (*OpenStackVolumeProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *openstackVolumeProviderServiceUpdateResponse) MustProvider() *OpenStackVolumeProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Update the specified OpenStack volume provider in the system.
//
func (p *openstackVolumeProviderService) Update() *openstackVolumeProviderServiceUpdateRequest {
	return &openstackVolumeProviderServiceUpdateRequest{openstackVolumeProviderService: p}
}

//
//
func (op *openstackVolumeProviderService) AuthenticationKeysService() *openstackVolumeAuthenticationKeysService {
	return NewOpenstackVolumeAuthenticationKeysService(op.connection, fmt.Sprintf("%s/authenticationkeys", op.path))
}

//
// A service to view certificates for this external provider.
//
func (op *openstackVolumeProviderService) CertificatesService() *externalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.connection, fmt.Sprintf("%s/certificates", op.path))
}

//
//
func (op *openstackVolumeProviderService) VolumeTypesService() *openstackVolumeTypesService {
	return NewOpenstackVolumeTypesService(op.connection, fmt.Sprintf("%s/volumetypes", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackVolumeProviderService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "authenticationkeys" {
		return op.AuthenticationKeysService(), nil
	}
	if strings.HasPrefix(path, "authenticationkeys/") {
		return op.AuthenticationKeysService().Service(path[19:])
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "volumetypes" {
		return op.VolumeTypesService(), nil
	}
	if strings.HasPrefix(path, "volumetypes/") {
		return op.VolumeTypesService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *openstackVolumeProviderService) String() string {
	return fmt.Sprintf("openstackVolumeProviderService:%s", op.path)
}

//
//
type openstackImagesService struct {
	baseService
}

func NewOpenstackImagesService(connection *Connection, path string) *openstackImagesService {
	var result openstackImagesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Lists the images of a Glance image storage domain.
// The order of the returned list of images isn't guaranteed.
//
type openstackImagesServiceListRequest struct {
	openstackImagesService *openstackImagesService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
	max                    *int64
}

func (p *openstackImagesServiceListRequest) Header(key, value string) *openstackImagesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackImagesServiceListRequest) Query(key, value string) *openstackImagesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackImagesServiceListRequest) Follow(follow string) *openstackImagesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *openstackImagesServiceListRequest) Max(max int64) *openstackImagesServiceListRequest {
	p.max = &max
	return p
}

func (p *openstackImagesServiceListRequest) Send() (*openstackImagesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackImagesService.connection.URL(), p.openstackImagesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImagesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImagesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &openstackImagesServiceListResponse{images: result}, nil
}

func (p *openstackImagesServiceListRequest) MustSend() *openstackImagesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackImagesService.connection.URL(), p.openstackImagesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackImagesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackImagesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &openstackImagesServiceListResponse{images: result}
}

//
// Lists the images of a Glance image storage domain.
// The order of the returned list of images isn't guaranteed.
//
type openstackImagesServiceListResponse struct {
	images *OpenStackImageSlice
}

func (p *openstackImagesServiceListResponse) Images() (*OpenStackImageSlice, bool) {
	if p.images != nil {
		return p.images, true
	}
	return nil, false
}

func (p *openstackImagesServiceListResponse) MustImages() *OpenStackImageSlice {
	if p.images == nil {
		panic("images in response does not exist")
	}
	return p.images
}

//
// Lists the images of a Glance image storage domain.
// The order of the returned list of images isn't guaranteed.
//
func (p *openstackImagesService) List() *openstackImagesServiceListRequest {
	return &openstackImagesServiceListRequest{openstackImagesService: p}
}

//
// Returns a reference to the service that manages a specific image.
//
func (op *openstackImagesService) ImageService(id string) *openstackImageService {
	return NewOpenstackImageService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackImagesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ImageService(path), nil
	}
	return op.ImageService(path[:index]).Service(path[index+1:])
}

func (op *openstackImagesService) String() string {
	return fmt.Sprintf("openstackImagesService:%s", op.path)
}

//
//
type openstackVolumeAuthenticationKeysService struct {
	baseService
}

func NewOpenstackVolumeAuthenticationKeysService(connection *Connection, path string) *openstackVolumeAuthenticationKeysService {
	var result openstackVolumeAuthenticationKeysService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new authentication key to the OpenStack volume provider.
//
type openstackVolumeAuthenticationKeysServiceAddRequest struct {
	openstackVolumeAuthenticationKeysService *openstackVolumeAuthenticationKeysService
	header                                   map[string]string
	query                                    map[string]string
	key                                      *OpenstackVolumeAuthenticationKey
}

func (p *openstackVolumeAuthenticationKeysServiceAddRequest) Header(key, value string) *openstackVolumeAuthenticationKeysServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeAuthenticationKeysServiceAddRequest) Query(key, value string) *openstackVolumeAuthenticationKeysServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeAuthenticationKeysServiceAddRequest) Key(key *OpenstackVolumeAuthenticationKey) *openstackVolumeAuthenticationKeysServiceAddRequest {
	p.key = key
	return p
}

func (p *openstackVolumeAuthenticationKeysServiceAddRequest) Send() (*openstackVolumeAuthenticationKeysServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeysService.connection.URL(), p.openstackVolumeAuthenticationKeysService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenstackVolumeAuthenticationKeyWriteOne(writer, p.key, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeAuthenticationKeysService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeysService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenstackVolumeAuthenticationKeyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackVolumeAuthenticationKeysServiceAddResponse{key: result}, nil
}

func (p *openstackVolumeAuthenticationKeysServiceAddRequest) MustSend() *openstackVolumeAuthenticationKeysServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeysService.connection.URL(), p.openstackVolumeAuthenticationKeysService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenstackVolumeAuthenticationKeyWriteOne(writer, p.key, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeAuthenticationKeysService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeysService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenstackVolumeAuthenticationKeyReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackVolumeAuthenticationKeysServiceAddResponse{key: result}
}

//
// Add a new authentication key to the OpenStack volume provider.
//
type openstackVolumeAuthenticationKeysServiceAddResponse struct {
	key *OpenstackVolumeAuthenticationKey
}

func (p *openstackVolumeAuthenticationKeysServiceAddResponse) Key() (*OpenstackVolumeAuthenticationKey, bool) {
	if p.key != nil {
		return p.key, true
	}
	return nil, false
}

func (p *openstackVolumeAuthenticationKeysServiceAddResponse) MustKey() *OpenstackVolumeAuthenticationKey {
	if p.key == nil {
		panic("key in response does not exist")
	}
	return p.key
}

//
// Add a new authentication key to the OpenStack volume provider.
//
func (p *openstackVolumeAuthenticationKeysService) Add() *openstackVolumeAuthenticationKeysServiceAddRequest {
	return &openstackVolumeAuthenticationKeysServiceAddRequest{openstackVolumeAuthenticationKeysService: p}
}

//
// Returns the list of authentication keys.
// The order of the returned list of authentication keys isn't guaranteed.
//
type openstackVolumeAuthenticationKeysServiceListRequest struct {
	openstackVolumeAuthenticationKeysService *openstackVolumeAuthenticationKeysService
	header                                   map[string]string
	query                                    map[string]string
	follow                                   *string
	max                                      *int64
}

func (p *openstackVolumeAuthenticationKeysServiceListRequest) Header(key, value string) *openstackVolumeAuthenticationKeysServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeAuthenticationKeysServiceListRequest) Query(key, value string) *openstackVolumeAuthenticationKeysServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeAuthenticationKeysServiceListRequest) Follow(follow string) *openstackVolumeAuthenticationKeysServiceListRequest {
	p.follow = &follow
	return p
}

func (p *openstackVolumeAuthenticationKeysServiceListRequest) Max(max int64) *openstackVolumeAuthenticationKeysServiceListRequest {
	p.max = &max
	return p
}

func (p *openstackVolumeAuthenticationKeysServiceListRequest) Send() (*openstackVolumeAuthenticationKeysServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeysService.connection.URL(), p.openstackVolumeAuthenticationKeysService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeAuthenticationKeysService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeysService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenstackVolumeAuthenticationKeyReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &openstackVolumeAuthenticationKeysServiceListResponse{keys: result}, nil
}

func (p *openstackVolumeAuthenticationKeysServiceListRequest) MustSend() *openstackVolumeAuthenticationKeysServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeAuthenticationKeysService.connection.URL(), p.openstackVolumeAuthenticationKeysService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeAuthenticationKeysService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeAuthenticationKeysService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenstackVolumeAuthenticationKeyReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &openstackVolumeAuthenticationKeysServiceListResponse{keys: result}
}

//
// Returns the list of authentication keys.
// The order of the returned list of authentication keys isn't guaranteed.
//
type openstackVolumeAuthenticationKeysServiceListResponse struct {
	keys *OpenstackVolumeAuthenticationKeySlice
}

func (p *openstackVolumeAuthenticationKeysServiceListResponse) Keys() (*OpenstackVolumeAuthenticationKeySlice, bool) {
	if p.keys != nil {
		return p.keys, true
	}
	return nil, false
}

func (p *openstackVolumeAuthenticationKeysServiceListResponse) MustKeys() *OpenstackVolumeAuthenticationKeySlice {
	if p.keys == nil {
		panic("keys in response does not exist")
	}
	return p.keys
}

//
// Returns the list of authentication keys.
// The order of the returned list of authentication keys isn't guaranteed.
//
func (p *openstackVolumeAuthenticationKeysService) List() *openstackVolumeAuthenticationKeysServiceListRequest {
	return &openstackVolumeAuthenticationKeysServiceListRequest{openstackVolumeAuthenticationKeysService: p}
}

//
//
func (op *openstackVolumeAuthenticationKeysService) KeyService(id string) *openstackVolumeAuthenticationKeyService {
	return NewOpenstackVolumeAuthenticationKeyService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackVolumeAuthenticationKeysService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.KeyService(path), nil
	}
	return op.KeyService(path[:index]).Service(path[index+1:])
}

func (op *openstackVolumeAuthenticationKeysService) String() string {
	return fmt.Sprintf("openstackVolumeAuthenticationKeysService:%s", op.path)
}

//
// This service manages OpenStack network providers.
//
type openstackNetworkProvidersService struct {
	baseService
}

func NewOpenstackNetworkProvidersService(connection *Connection, path string) *openstackNetworkProvidersService {
	var result openstackNetworkProvidersService
	result.connection = connection
	result.path = path
	return &result
}

//
// The operation adds a new network provider to the system.
// If the `type` property is not present, a default value of `NEUTRON` will be used.
//
type openstackNetworkProvidersServiceAddRequest struct {
	openstackNetworkProvidersService *openstackNetworkProvidersService
	header                           map[string]string
	query                            map[string]string
	provider                         *OpenStackNetworkProvider
}

func (p *openstackNetworkProvidersServiceAddRequest) Header(key, value string) *openstackNetworkProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackNetworkProvidersServiceAddRequest) Query(key, value string) *openstackNetworkProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackNetworkProvidersServiceAddRequest) Provider(provider *OpenStackNetworkProvider) *openstackNetworkProvidersServiceAddRequest {
	p.provider = provider
	return p
}

func (p *openstackNetworkProvidersServiceAddRequest) Send() (*openstackNetworkProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProvidersService.connection.URL(), p.openstackNetworkProvidersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackNetworkProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackNetworkProvidersServiceAddResponse{provider: result}, nil
}

func (p *openstackNetworkProvidersServiceAddRequest) MustSend() *openstackNetworkProvidersServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProvidersService.connection.URL(), p.openstackNetworkProvidersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackNetworkProviderWriteOne(writer, p.provider, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProvidersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProvidersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkProviderReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackNetworkProvidersServiceAddResponse{provider: result}
}

//
// The operation adds a new network provider to the system.
// If the `type` property is not present, a default value of `NEUTRON` will be used.
//
type openstackNetworkProvidersServiceAddResponse struct {
	provider *OpenStackNetworkProvider
}

func (p *openstackNetworkProvidersServiceAddResponse) Provider() (*OpenStackNetworkProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *openstackNetworkProvidersServiceAddResponse) MustProvider() *OpenStackNetworkProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// The operation adds a new network provider to the system.
// If the `type` property is not present, a default value of `NEUTRON` will be used.
//
func (p *openstackNetworkProvidersService) Add() *openstackNetworkProvidersServiceAddRequest {
	return &openstackNetworkProvidersServiceAddRequest{openstackNetworkProvidersService: p}
}

//
// Returns the list of providers.
// The order of the returned list of providers isn't guaranteed.
//
type openstackNetworkProvidersServiceListRequest struct {
	openstackNetworkProvidersService *openstackNetworkProvidersService
	header                           map[string]string
	query                            map[string]string
	follow                           *string
	max                              *int64
}

func (p *openstackNetworkProvidersServiceListRequest) Header(key, value string) *openstackNetworkProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackNetworkProvidersServiceListRequest) Query(key, value string) *openstackNetworkProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackNetworkProvidersServiceListRequest) Follow(follow string) *openstackNetworkProvidersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *openstackNetworkProvidersServiceListRequest) Max(max int64) *openstackNetworkProvidersServiceListRequest {
	p.max = &max
	return p
}

func (p *openstackNetworkProvidersServiceListRequest) Send() (*openstackNetworkProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProvidersService.connection.URL(), p.openstackNetworkProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkProviderReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &openstackNetworkProvidersServiceListResponse{providers: result}, nil
}

func (p *openstackNetworkProvidersServiceListRequest) MustSend() *openstackNetworkProvidersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProvidersService.connection.URL(), p.openstackNetworkProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProvidersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProvidersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkProviderReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &openstackNetworkProvidersServiceListResponse{providers: result}
}

//
// Returns the list of providers.
// The order of the returned list of providers isn't guaranteed.
//
type openstackNetworkProvidersServiceListResponse struct {
	providers *OpenStackNetworkProviderSlice
}

func (p *openstackNetworkProvidersServiceListResponse) Providers() (*OpenStackNetworkProviderSlice, bool) {
	if p.providers != nil {
		return p.providers, true
	}
	return nil, false
}

func (p *openstackNetworkProvidersServiceListResponse) MustProviders() *OpenStackNetworkProviderSlice {
	if p.providers == nil {
		panic("providers in response does not exist")
	}
	return p.providers
}

//
// Returns the list of providers.
// The order of the returned list of providers isn't guaranteed.
//
func (p *openstackNetworkProvidersService) List() *openstackNetworkProvidersServiceListRequest {
	return &openstackNetworkProvidersServiceListRequest{openstackNetworkProvidersService: p}
}

//
// Reference to OpenStack network provider service.
//
func (op *openstackNetworkProvidersService) ProviderService(id string) *openstackNetworkProviderService {
	return NewOpenstackNetworkProviderService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackNetworkProvidersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProviderService(path), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *openstackNetworkProvidersService) String() string {
	return fmt.Sprintf("openstackNetworkProvidersService:%s", op.path)
}

//
//
type openstackNetworkService struct {
	baseService
}

func NewOpenstackNetworkService(connection *Connection, path string) *openstackNetworkService {
	var result openstackNetworkService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type openstackNetworkServiceGetRequest struct {
	openstackNetworkService *openstackNetworkService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
}

func (p *openstackNetworkServiceGetRequest) Header(key, value string) *openstackNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackNetworkServiceGetRequest) Query(key, value string) *openstackNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackNetworkServiceGetRequest) Follow(follow string) *openstackNetworkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *openstackNetworkServiceGetRequest) Send() (*openstackNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkService.connection.URL(), p.openstackNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackNetworkServiceGetResponse{network: result}, nil
}

func (p *openstackNetworkServiceGetRequest) MustSend() *openstackNetworkServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkService.connection.URL(), p.openstackNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackNetworkServiceGetResponse{network: result}
}

//
//
type openstackNetworkServiceGetResponse struct {
	network *OpenStackNetwork
}

func (p *openstackNetworkServiceGetResponse) Network() (*OpenStackNetwork, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *openstackNetworkServiceGetResponse) MustNetwork() *OpenStackNetwork {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
//
func (p *openstackNetworkService) Get() *openstackNetworkServiceGetRequest {
	return &openstackNetworkServiceGetRequest{openstackNetworkService: p}
}

//
// This operation imports an external network into oVirt.
// The network will be added to the data center specified.
//
type openstackNetworkServiceImportRequest struct {
	openstackNetworkService *openstackNetworkService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	dataCenter              *DataCenter
}

func (p *openstackNetworkServiceImportRequest) Header(key, value string) *openstackNetworkServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackNetworkServiceImportRequest) Query(key, value string) *openstackNetworkServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackNetworkServiceImportRequest) Async(async bool) *openstackNetworkServiceImportRequest {
	p.async = &async
	return p
}

func (p *openstackNetworkServiceImportRequest) DataCenter(dataCenter *DataCenter) *openstackNetworkServiceImportRequest {
	p.dataCenter = dataCenter
	return p
}

func (p *openstackNetworkServiceImportRequest) Send() (*openstackNetworkServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.openstackNetworkService.connection.URL(), p.openstackNetworkService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.DataCenter(p.dataCenter)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(openstackNetworkServiceImportResponse), nil
}

func (p *openstackNetworkServiceImportRequest) MustSend() *openstackNetworkServiceImportResponse {
	rawURL := fmt.Sprintf("%s%s/import", p.openstackNetworkService.connection.URL(), p.openstackNetworkService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.DataCenter(p.dataCenter)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(openstackNetworkServiceImportResponse)
}

//
// This operation imports an external network into oVirt.
// The network will be added to the data center specified.
//
type openstackNetworkServiceImportResponse struct {
}

//
// This operation imports an external network into oVirt.
// The network will be added to the data center specified.
//
func (p *openstackNetworkService) Import() *openstackNetworkServiceImportRequest {
	return &openstackNetworkServiceImportRequest{openstackNetworkService: p}
}

//
//
func (op *openstackNetworkService) SubnetsService() *openstackSubnetsService {
	return NewOpenstackSubnetsService(op.connection, fmt.Sprintf("%s/subnets", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackNetworkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "subnets" {
		return op.SubnetsService(), nil
	}
	if strings.HasPrefix(path, "subnets/") {
		return op.SubnetsService().Service(path[8:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *openstackNetworkService) String() string {
	return fmt.Sprintf("openstackNetworkService:%s", op.path)
}

//
//
type openstackVolumeProvidersService struct {
	baseService
}

func NewOpenstackVolumeProvidersService(connection *Connection, path string) *openstackVolumeProvidersService {
	var result openstackVolumeProvidersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a new volume provider.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/openstackvolumeproviders
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_volume_provider>
//   <name>mycinder</name>
//   <url>https://mycinder.example.com:8776</url>
//   <data_center>
//     <name>mydc</name>
//   </data_center>
//   <requires_authentication>true</requires_authentication>
//   <username>admin</username>
//   <password>mypassword</password>
//   <tenant_name>mytenant</tenant_name>
// </openstack_volume_provider>
// ----
//
type openstackVolumeProvidersServiceAddRequest struct {
	openstackVolumeProvidersService *openstackVolumeProvidersService
	header                          map[string]string
	query                           map[string]string
	provider                        *OpenStackVolumeProvider
}

func (p *openstackVolumeProvidersServiceAddRequest) Header(key, value string) *openstackVolumeProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeProvidersServiceAddRequest) Query(key, value string) *openstackVolumeProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeProvidersServiceAddRequest) Provider(provider *OpenStackVolumeProvider) *openstackVolumeProvidersServiceAddRequest {
	p.provider = provider
	return p
}

func (p *openstackVolumeProvidersServiceAddRequest) Send() (*openstackVolumeProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProvidersService.connection.URL(), p.openstackVolumeProvidersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackVolumeProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackVolumeProvidersServiceAddResponse{provider: result}, nil
}

func (p *openstackVolumeProvidersServiceAddRequest) MustSend() *openstackVolumeProvidersServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProvidersService.connection.URL(), p.openstackVolumeProvidersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackVolumeProviderWriteOne(writer, p.provider, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProvidersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProvidersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeProviderReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackVolumeProvidersServiceAddResponse{provider: result}
}

//
// Adds a new volume provider.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/openstackvolumeproviders
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_volume_provider>
//   <name>mycinder</name>
//   <url>https://mycinder.example.com:8776</url>
//   <data_center>
//     <name>mydc</name>
//   </data_center>
//   <requires_authentication>true</requires_authentication>
//   <username>admin</username>
//   <password>mypassword</password>
//   <tenant_name>mytenant</tenant_name>
// </openstack_volume_provider>
// ----
//
type openstackVolumeProvidersServiceAddResponse struct {
	provider *OpenStackVolumeProvider
}

func (p *openstackVolumeProvidersServiceAddResponse) Provider() (*OpenStackVolumeProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *openstackVolumeProvidersServiceAddResponse) MustProvider() *OpenStackVolumeProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Adds a new volume provider.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/openstackvolumeproviders
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_volume_provider>
//   <name>mycinder</name>
//   <url>https://mycinder.example.com:8776</url>
//   <data_center>
//     <name>mydc</name>
//   </data_center>
//   <requires_authentication>true</requires_authentication>
//   <username>admin</username>
//   <password>mypassword</password>
//   <tenant_name>mytenant</tenant_name>
// </openstack_volume_provider>
// ----
//
func (p *openstackVolumeProvidersService) Add() *openstackVolumeProvidersServiceAddRequest {
	return &openstackVolumeProvidersServiceAddRequest{openstackVolumeProvidersService: p}
}

//
// Retrieves the list of volume providers.
// The order of the returned list of volume providers isn't guaranteed.
//
type openstackVolumeProvidersServiceListRequest struct {
	openstackVolumeProvidersService *openstackVolumeProvidersService
	header                          map[string]string
	query                           map[string]string
	follow                          *string
	max                             *int64
}

func (p *openstackVolumeProvidersServiceListRequest) Header(key, value string) *openstackVolumeProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackVolumeProvidersServiceListRequest) Query(key, value string) *openstackVolumeProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackVolumeProvidersServiceListRequest) Follow(follow string) *openstackVolumeProvidersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *openstackVolumeProvidersServiceListRequest) Max(max int64) *openstackVolumeProvidersServiceListRequest {
	p.max = &max
	return p
}

func (p *openstackVolumeProvidersServiceListRequest) Send() (*openstackVolumeProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProvidersService.connection.URL(), p.openstackVolumeProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeProviderReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &openstackVolumeProvidersServiceListResponse{providers: result}, nil
}

func (p *openstackVolumeProvidersServiceListRequest) MustSend() *openstackVolumeProvidersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackVolumeProvidersService.connection.URL(), p.openstackVolumeProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackVolumeProvidersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackVolumeProvidersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeProviderReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &openstackVolumeProvidersServiceListResponse{providers: result}
}

//
// Retrieves the list of volume providers.
// The order of the returned list of volume providers isn't guaranteed.
//
type openstackVolumeProvidersServiceListResponse struct {
	providers *OpenStackVolumeProviderSlice
}

func (p *openstackVolumeProvidersServiceListResponse) Providers() (*OpenStackVolumeProviderSlice, bool) {
	if p.providers != nil {
		return p.providers, true
	}
	return nil, false
}

func (p *openstackVolumeProvidersServiceListResponse) MustProviders() *OpenStackVolumeProviderSlice {
	if p.providers == nil {
		panic("providers in response does not exist")
	}
	return p.providers
}

//
// Retrieves the list of volume providers.
// The order of the returned list of volume providers isn't guaranteed.
//
func (p *openstackVolumeProvidersService) List() *openstackVolumeProvidersServiceListRequest {
	return &openstackVolumeProvidersServiceListRequest{openstackVolumeProvidersService: p}
}

//
//
func (op *openstackVolumeProvidersService) ProviderService(id string) *openstackVolumeProviderService {
	return NewOpenstackVolumeProviderService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackVolumeProvidersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProviderService(path), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *openstackVolumeProvidersService) String() string {
	return fmt.Sprintf("openstackVolumeProvidersService:%s", op.path)
}

//
// This service manages the OpenStack network provider.
//
type openstackNetworkProviderService struct {
	baseService
}

func NewOpenstackNetworkProviderService(connection *Connection, path string) *openstackNetworkProviderService {
	var result openstackNetworkProviderService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the representation of the object managed by this service.
// For example, to get the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
type openstackNetworkProviderServiceGetRequest struct {
	openstackNetworkProviderService *openstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	follow                          *string
}

func (p *openstackNetworkProviderServiceGetRequest) Header(key, value string) *openstackNetworkProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackNetworkProviderServiceGetRequest) Query(key, value string) *openstackNetworkProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackNetworkProviderServiceGetRequest) Follow(follow string) *openstackNetworkProviderServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *openstackNetworkProviderServiceGetRequest) Send() (*openstackNetworkProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProviderService.connection.URL(), p.openstackNetworkProviderService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackNetworkProviderServiceGetResponse{provider: result}, nil
}

func (p *openstackNetworkProviderServiceGetRequest) MustSend() *openstackNetworkProviderServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProviderService.connection.URL(), p.openstackNetworkProviderService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkProviderReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackNetworkProviderServiceGetResponse{provider: result}
}

//
// Returns the representation of the object managed by this service.
// For example, to get the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
type openstackNetworkProviderServiceGetResponse struct {
	provider *OpenStackNetworkProvider
}

func (p *openstackNetworkProviderServiceGetResponse) Provider() (*OpenStackNetworkProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *openstackNetworkProviderServiceGetResponse) MustProvider() *OpenStackNetworkProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Returns the representation of the object managed by this service.
// For example, to get the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
func (p *openstackNetworkProviderService) Get() *openstackNetworkProviderServiceGetRequest {
	return &openstackNetworkProviderServiceGetRequest{openstackNetworkProviderService: p}
}

//
// Import the SSL certificates of the external host provider.
//
type openstackNetworkProviderServiceImportCertificatesRequest struct {
	openstackNetworkProviderService *openstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	certificates                    *CertificateSlice
}

func (p *openstackNetworkProviderServiceImportCertificatesRequest) Header(key, value string) *openstackNetworkProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackNetworkProviderServiceImportCertificatesRequest) Query(key, value string) *openstackNetworkProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackNetworkProviderServiceImportCertificatesRequest) Certificates(certificates *CertificateSlice) *openstackNetworkProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}

func (p *openstackNetworkProviderServiceImportCertificatesRequest) CertificatesOfAny(anys ...*Certificate) *openstackNetworkProviderServiceImportCertificatesRequest {
	if p.certificates == nil {
		p.certificates = new(CertificateSlice)
	}
	p.certificates.slice = append(p.certificates.slice, anys...)
	return p
}

func (p *openstackNetworkProviderServiceImportCertificatesRequest) Send() (*openstackNetworkProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.openstackNetworkProviderService.connection.URL(), p.openstackNetworkProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(openstackNetworkProviderServiceImportCertificatesResponse), nil
}

func (p *openstackNetworkProviderServiceImportCertificatesRequest) MustSend() *openstackNetworkProviderServiceImportCertificatesResponse {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.openstackNetworkProviderService.connection.URL(), p.openstackNetworkProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(openstackNetworkProviderServiceImportCertificatesResponse)
}

//
// Import the SSL certificates of the external host provider.
//
type openstackNetworkProviderServiceImportCertificatesResponse struct {
}

//
// Import the SSL certificates of the external host provider.
//
func (p *openstackNetworkProviderService) ImportCertificates() *openstackNetworkProviderServiceImportCertificatesRequest {
	return &openstackNetworkProviderServiceImportCertificatesRequest{openstackNetworkProviderService: p}
}

//
// Removes the provider.
// For example, to remove the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
type openstackNetworkProviderServiceRemoveRequest struct {
	openstackNetworkProviderService *openstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	async                           *bool
}

func (p *openstackNetworkProviderServiceRemoveRequest) Header(key, value string) *openstackNetworkProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackNetworkProviderServiceRemoveRequest) Query(key, value string) *openstackNetworkProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackNetworkProviderServiceRemoveRequest) Async(async bool) *openstackNetworkProviderServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *openstackNetworkProviderServiceRemoveRequest) Send() (*openstackNetworkProviderServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProviderService.connection.URL(), p.openstackNetworkProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(openstackNetworkProviderServiceRemoveResponse), nil
}

func (p *openstackNetworkProviderServiceRemoveRequest) MustSend() *openstackNetworkProviderServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProviderService.connection.URL(), p.openstackNetworkProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(openstackNetworkProviderServiceRemoveResponse)
}

//
// Removes the provider.
// For example, to remove the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
type openstackNetworkProviderServiceRemoveResponse struct {
}

//
// Removes the provider.
// For example, to remove the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
func (p *openstackNetworkProviderService) Remove() *openstackNetworkProviderServiceRemoveRequest {
	return &openstackNetworkProviderServiceRemoveRequest{openstackNetworkProviderService: p}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type openstackNetworkProviderServiceTestConnectivityRequest struct {
	openstackNetworkProviderService *openstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	async                           *bool
}

func (p *openstackNetworkProviderServiceTestConnectivityRequest) Header(key, value string) *openstackNetworkProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackNetworkProviderServiceTestConnectivityRequest) Query(key, value string) *openstackNetworkProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackNetworkProviderServiceTestConnectivityRequest) Async(async bool) *openstackNetworkProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}

func (p *openstackNetworkProviderServiceTestConnectivityRequest) Send() (*openstackNetworkProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.openstackNetworkProviderService.connection.URL(), p.openstackNetworkProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(openstackNetworkProviderServiceTestConnectivityResponse), nil
}

func (p *openstackNetworkProviderServiceTestConnectivityRequest) MustSend() *openstackNetworkProviderServiceTestConnectivityResponse {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.openstackNetworkProviderService.connection.URL(), p.openstackNetworkProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(openstackNetworkProviderServiceTestConnectivityResponse)
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type openstackNetworkProviderServiceTestConnectivityResponse struct {
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
func (p *openstackNetworkProviderService) TestConnectivity() *openstackNetworkProviderServiceTestConnectivityRequest {
	return &openstackNetworkProviderServiceTestConnectivityRequest{openstackNetworkProviderService: p}
}

//
// Updates the provider.
// For example, to update `provider_name`, `requires_authentication`, `url`, `tenant_name` and `type` properties,
// for the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/openstacknetworkproviders/1234
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_network_provider>
//   <name>ovn-network-provider</name>
//   <requires_authentication>false</requires_authentication>
//   <url>http://some_server_url.domain.com:9696</url>
//   <tenant_name>oVirt</tenant_name>
//   <type>external</type>
// </openstack_network_provider>
// ----
//
type openstackNetworkProviderServiceUpdateRequest struct {
	openstackNetworkProviderService *openstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	async                           *bool
	provider                        *OpenStackNetworkProvider
}

func (p *openstackNetworkProviderServiceUpdateRequest) Header(key, value string) *openstackNetworkProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *openstackNetworkProviderServiceUpdateRequest) Query(key, value string) *openstackNetworkProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *openstackNetworkProviderServiceUpdateRequest) Async(async bool) *openstackNetworkProviderServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *openstackNetworkProviderServiceUpdateRequest) Provider(provider *OpenStackNetworkProvider) *openstackNetworkProviderServiceUpdateRequest {
	p.provider = provider
	return p
}

func (p *openstackNetworkProviderServiceUpdateRequest) Send() (*openstackNetworkProviderServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProviderService.connection.URL(), p.openstackNetworkProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackNetworkProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &openstackNetworkProviderServiceUpdateResponse{provider: result}, nil
}

func (p *openstackNetworkProviderServiceUpdateRequest) MustSend() *openstackNetworkProviderServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.openstackNetworkProviderService.connection.URL(), p.openstackNetworkProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackNetworkProviderWriteOne(writer, p.provider, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.openstackNetworkProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.openstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkProviderReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &openstackNetworkProviderServiceUpdateResponse{provider: result}
}

//
// Updates the provider.
// For example, to update `provider_name`, `requires_authentication`, `url`, `tenant_name` and `type` properties,
// for the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/openstacknetworkproviders/1234
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_network_provider>
//   <name>ovn-network-provider</name>
//   <requires_authentication>false</requires_authentication>
//   <url>http://some_server_url.domain.com:9696</url>
//   <tenant_name>oVirt</tenant_name>
//   <type>external</type>
// </openstack_network_provider>
// ----
//
type openstackNetworkProviderServiceUpdateResponse struct {
	provider *OpenStackNetworkProvider
}

func (p *openstackNetworkProviderServiceUpdateResponse) Provider() (*OpenStackNetworkProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *openstackNetworkProviderServiceUpdateResponse) MustProvider() *OpenStackNetworkProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Updates the provider.
// For example, to update `provider_name`, `requires_authentication`, `url`, `tenant_name` and `type` properties,
// for the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/openstacknetworkproviders/1234
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_network_provider>
//   <name>ovn-network-provider</name>
//   <requires_authentication>false</requires_authentication>
//   <url>http://some_server_url.domain.com:9696</url>
//   <tenant_name>oVirt</tenant_name>
//   <type>external</type>
// </openstack_network_provider>
// ----
//
func (p *openstackNetworkProviderService) Update() *openstackNetworkProviderServiceUpdateRequest {
	return &openstackNetworkProviderServiceUpdateRequest{openstackNetworkProviderService: p}
}

//
// A service to view certificates for this external provider.
//
func (op *openstackNetworkProviderService) CertificatesService() *externalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.connection, fmt.Sprintf("%s/certificates", op.path))
}

//
// Reference to OpenStack networks service.
//
func (op *openstackNetworkProviderService) NetworksService() *openstackNetworksService {
	return NewOpenstackNetworksService(op.connection, fmt.Sprintf("%s/networks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *openstackNetworkProviderService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *openstackNetworkProviderService) String() string {
	return fmt.Sprintf("openstackNetworkProviderService:%s", op.path)
}

//
//
type assignedCpuProfileService struct {
	baseService
}

func NewAssignedCpuProfileService(connection *Connection, path string) *assignedCpuProfileService {
	var result assignedCpuProfileService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type assignedCpuProfileServiceGetRequest struct {
	assignedCpuProfileService *assignedCpuProfileService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
}

func (p *assignedCpuProfileServiceGetRequest) Header(key, value string) *assignedCpuProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedCpuProfileServiceGetRequest) Query(key, value string) *assignedCpuProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedCpuProfileServiceGetRequest) Follow(follow string) *assignedCpuProfileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *assignedCpuProfileServiceGetRequest) Send() (*assignedCpuProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfileService.connection.URL(), p.assignedCpuProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedCpuProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &assignedCpuProfileServiceGetResponse{profile: result}, nil
}

func (p *assignedCpuProfileServiceGetRequest) MustSend() *assignedCpuProfileServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfileService.connection.URL(), p.assignedCpuProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedCpuProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &assignedCpuProfileServiceGetResponse{profile: result}
}

//
//
type assignedCpuProfileServiceGetResponse struct {
	profile *CpuProfile
}

func (p *assignedCpuProfileServiceGetResponse) Profile() (*CpuProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *assignedCpuProfileServiceGetResponse) MustProfile() *CpuProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
//
func (p *assignedCpuProfileService) Get() *assignedCpuProfileServiceGetRequest {
	return &assignedCpuProfileServiceGetRequest{assignedCpuProfileService: p}
}

//
//
type assignedCpuProfileServiceRemoveRequest struct {
	assignedCpuProfileService *assignedCpuProfileService
	header                    map[string]string
	query                     map[string]string
	async                     *bool
}

func (p *assignedCpuProfileServiceRemoveRequest) Header(key, value string) *assignedCpuProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedCpuProfileServiceRemoveRequest) Query(key, value string) *assignedCpuProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedCpuProfileServiceRemoveRequest) Async(async bool) *assignedCpuProfileServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *assignedCpuProfileServiceRemoveRequest) Send() (*assignedCpuProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfileService.connection.URL(), p.assignedCpuProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedCpuProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(assignedCpuProfileServiceRemoveResponse), nil
}

func (p *assignedCpuProfileServiceRemoveRequest) MustSend() *assignedCpuProfileServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfileService.connection.URL(), p.assignedCpuProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedCpuProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(assignedCpuProfileServiceRemoveResponse)
}

//
//
type assignedCpuProfileServiceRemoveResponse struct {
}

//
//
func (p *assignedCpuProfileService) Remove() *assignedCpuProfileServiceRemoveRequest {
	return &assignedCpuProfileServiceRemoveRequest{assignedCpuProfileService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *assignedCpuProfileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *assignedCpuProfileService) String() string {
	return fmt.Sprintf("assignedCpuProfileService:%s", op.path)
}

//
//
type storageServerConnectionsService struct {
	baseService
}

func NewStorageServerConnectionsService(connection *Connection, path string) *storageServerConnectionsService {
	var result storageServerConnectionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new storage connection.
// For example, to create a new storage connection for the NFS server `mynfs.example.com` and NFS share
// `/export/mydata` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageconnections
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <type>nfs</type>
//   <address>mynfs.example.com</address>
//   <path>/export/mydata</path>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_connection>
// ----
//
type storageServerConnectionsServiceAddRequest struct {
	storageServerConnectionsService *storageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *storageServerConnectionsServiceAddRequest) Header(key, value string) *storageServerConnectionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionsServiceAddRequest) Query(key, value string) *storageServerConnectionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionsServiceAddRequest) Connection(connection *StorageConnection) *storageServerConnectionsServiceAddRequest {
	p.connection = connection
	return p
}

func (p *storageServerConnectionsServiceAddRequest) Send() (*storageServerConnectionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionsService.connection.URL(), p.storageServerConnectionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionWriteOne(writer, p.connection, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageServerConnectionsServiceAddResponse{connection: result}, nil
}

func (p *storageServerConnectionsServiceAddRequest) MustSend() *storageServerConnectionsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionsService.connection.URL(), p.storageServerConnectionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionWriteOne(writer, p.connection, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageServerConnectionsServiceAddResponse{connection: result}
}

//
// Creates a new storage connection.
// For example, to create a new storage connection for the NFS server `mynfs.example.com` and NFS share
// `/export/mydata` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageconnections
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <type>nfs</type>
//   <address>mynfs.example.com</address>
//   <path>/export/mydata</path>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_connection>
// ----
//
type storageServerConnectionsServiceAddResponse struct {
	connection *StorageConnection
}

func (p *storageServerConnectionsServiceAddResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *storageServerConnectionsServiceAddResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Creates a new storage connection.
// For example, to create a new storage connection for the NFS server `mynfs.example.com` and NFS share
// `/export/mydata` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageconnections
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <type>nfs</type>
//   <address>mynfs.example.com</address>
//   <path>/export/mydata</path>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_connection>
// ----
//
func (p *storageServerConnectionsService) Add() *storageServerConnectionsServiceAddRequest {
	return &storageServerConnectionsServiceAddRequest{storageServerConnectionsService: p}
}

//
// Add a iSCSI storage connection to the system.
//
type storageServerConnectionsServiceAddIscsiRequest struct {
	storageServerConnectionsService *storageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *storageServerConnectionsServiceAddIscsiRequest) Header(key, value string) *storageServerConnectionsServiceAddIscsiRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionsServiceAddIscsiRequest) Query(key, value string) *storageServerConnectionsServiceAddIscsiRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionsServiceAddIscsiRequest) Connection(connection *StorageConnection) *storageServerConnectionsServiceAddIscsiRequest {
	p.connection = connection
	return p
}

func (p *storageServerConnectionsServiceAddIscsiRequest) Send() (*storageServerConnectionsServiceAddIscsiResponse, error) {
	rawURL := fmt.Sprintf("%s%s/iscsi", p.storageServerConnectionsService.connection.URL(), p.storageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &storageServerConnectionsServiceAddIscsiResponse{connection: result}, nil
}

func (p *storageServerConnectionsServiceAddIscsiRequest) MustSend() *storageServerConnectionsServiceAddIscsiResponse {
	rawURL := fmt.Sprintf("%s%s/iscsi", p.storageServerConnectionsService.connection.URL(), p.storageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustConnection()
	return &storageServerConnectionsServiceAddIscsiResponse{connection: result}
}

//
// Add a iSCSI storage connection to the system.
//
type storageServerConnectionsServiceAddIscsiResponse struct {
	connection *StorageConnection
}

func (p *storageServerConnectionsServiceAddIscsiResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *storageServerConnectionsServiceAddIscsiResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Add a iSCSI storage connection to the system.
//
func (p *storageServerConnectionsService) AddIscsi() *storageServerConnectionsServiceAddIscsiRequest {
	return &storageServerConnectionsServiceAddIscsiRequest{storageServerConnectionsService: p}
}

//
// Returns the list of storage connections.
// The order of the returned list of connections isn't guaranteed.
//
type storageServerConnectionsServiceListRequest struct {
	storageServerConnectionsService *storageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	follow                          *string
	max                             *int64
}

func (p *storageServerConnectionsServiceListRequest) Header(key, value string) *storageServerConnectionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionsServiceListRequest) Query(key, value string) *storageServerConnectionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionsServiceListRequest) Follow(follow string) *storageServerConnectionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *storageServerConnectionsServiceListRequest) Max(max int64) *storageServerConnectionsServiceListRequest {
	p.max = &max
	return p
}

func (p *storageServerConnectionsServiceListRequest) Send() (*storageServerConnectionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionsService.connection.URL(), p.storageServerConnectionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &storageServerConnectionsServiceListResponse{connections: result}, nil
}

func (p *storageServerConnectionsServiceListRequest) MustSend() *storageServerConnectionsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionsService.connection.URL(), p.storageServerConnectionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &storageServerConnectionsServiceListResponse{connections: result}
}

//
// Returns the list of storage connections.
// The order of the returned list of connections isn't guaranteed.
//
type storageServerConnectionsServiceListResponse struct {
	connections *StorageConnectionSlice
}

func (p *storageServerConnectionsServiceListResponse) Connections() (*StorageConnectionSlice, bool) {
	if p.connections != nil {
		return p.connections, true
	}
	return nil, false
}

func (p *storageServerConnectionsServiceListResponse) MustConnections() *StorageConnectionSlice {
	if p.connections == nil {
		panic("connections in response does not exist")
	}
	return p.connections
}

//
// Returns the list of storage connections.
// The order of the returned list of connections isn't guaranteed.
//
func (p *storageServerConnectionsService) List() *storageServerConnectionsServiceListRequest {
	return &storageServerConnectionsServiceListRequest{storageServerConnectionsService: p}
}

//
// Add a local storage connection to the system.
//
type storageServerConnectionsServiceAddLocalRequest struct {
	storageServerConnectionsService *storageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *storageServerConnectionsServiceAddLocalRequest) Header(key, value string) *storageServerConnectionsServiceAddLocalRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionsServiceAddLocalRequest) Query(key, value string) *storageServerConnectionsServiceAddLocalRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionsServiceAddLocalRequest) Connection(connection *StorageConnection) *storageServerConnectionsServiceAddLocalRequest {
	p.connection = connection
	return p
}

func (p *storageServerConnectionsServiceAddLocalRequest) Send() (*storageServerConnectionsServiceAddLocalResponse, error) {
	rawURL := fmt.Sprintf("%s%s/local", p.storageServerConnectionsService.connection.URL(), p.storageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &storageServerConnectionsServiceAddLocalResponse{connection: result}, nil
}

func (p *storageServerConnectionsServiceAddLocalRequest) MustSend() *storageServerConnectionsServiceAddLocalResponse {
	rawURL := fmt.Sprintf("%s%s/local", p.storageServerConnectionsService.connection.URL(), p.storageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustConnection()
	return &storageServerConnectionsServiceAddLocalResponse{connection: result}
}

//
// Add a local storage connection to the system.
//
type storageServerConnectionsServiceAddLocalResponse struct {
	connection *StorageConnection
}

func (p *storageServerConnectionsServiceAddLocalResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *storageServerConnectionsServiceAddLocalResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Add a local storage connection to the system.
//
func (p *storageServerConnectionsService) AddLocal() *storageServerConnectionsServiceAddLocalRequest {
	return &storageServerConnectionsServiceAddLocalRequest{storageServerConnectionsService: p}
}

//
// Add a nfs storage connection to the system.
//
type storageServerConnectionsServiceAddNfsRequest struct {
	storageServerConnectionsService *storageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *storageServerConnectionsServiceAddNfsRequest) Header(key, value string) *storageServerConnectionsServiceAddNfsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionsServiceAddNfsRequest) Query(key, value string) *storageServerConnectionsServiceAddNfsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionsServiceAddNfsRequest) Connection(connection *StorageConnection) *storageServerConnectionsServiceAddNfsRequest {
	p.connection = connection
	return p
}

func (p *storageServerConnectionsServiceAddNfsRequest) Send() (*storageServerConnectionsServiceAddNfsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/nfs", p.storageServerConnectionsService.connection.URL(), p.storageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &storageServerConnectionsServiceAddNfsResponse{connection: result}, nil
}

func (p *storageServerConnectionsServiceAddNfsRequest) MustSend() *storageServerConnectionsServiceAddNfsResponse {
	rawURL := fmt.Sprintf("%s%s/nfs", p.storageServerConnectionsService.connection.URL(), p.storageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustConnection()
	return &storageServerConnectionsServiceAddNfsResponse{connection: result}
}

//
// Add a nfs storage connection to the system.
//
type storageServerConnectionsServiceAddNfsResponse struct {
	connection *StorageConnection
}

func (p *storageServerConnectionsServiceAddNfsResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *storageServerConnectionsServiceAddNfsResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Add a nfs storage connection to the system.
//
func (p *storageServerConnectionsService) AddNfs() *storageServerConnectionsServiceAddNfsRequest {
	return &storageServerConnectionsServiceAddNfsRequest{storageServerConnectionsService: p}
}

//
// Add a vfs storage connection to the system.
//
type storageServerConnectionsServiceAddVfsRequest struct {
	storageServerConnectionsService *storageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *storageServerConnectionsServiceAddVfsRequest) Header(key, value string) *storageServerConnectionsServiceAddVfsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionsServiceAddVfsRequest) Query(key, value string) *storageServerConnectionsServiceAddVfsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionsServiceAddVfsRequest) Connection(connection *StorageConnection) *storageServerConnectionsServiceAddVfsRequest {
	p.connection = connection
	return p
}

func (p *storageServerConnectionsServiceAddVfsRequest) Send() (*storageServerConnectionsServiceAddVfsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/vfs", p.storageServerConnectionsService.connection.URL(), p.storageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &storageServerConnectionsServiceAddVfsResponse{connection: result}, nil
}

func (p *storageServerConnectionsServiceAddVfsRequest) MustSend() *storageServerConnectionsServiceAddVfsResponse {
	rawURL := fmt.Sprintf("%s%s/vfs", p.storageServerConnectionsService.connection.URL(), p.storageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustConnection()
	return &storageServerConnectionsServiceAddVfsResponse{connection: result}
}

//
// Add a vfs storage connection to the system.
//
type storageServerConnectionsServiceAddVfsResponse struct {
	connection *StorageConnection
}

func (p *storageServerConnectionsServiceAddVfsResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *storageServerConnectionsServiceAddVfsResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Add a vfs storage connection to the system.
//
func (p *storageServerConnectionsService) AddVfs() *storageServerConnectionsServiceAddVfsRequest {
	return &storageServerConnectionsServiceAddVfsRequest{storageServerConnectionsService: p}
}

//
//
func (op *storageServerConnectionsService) StorageConnectionService(id string) *storageServerConnectionService {
	return NewStorageServerConnectionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageServerConnectionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StorageConnectionService(path), nil
	}
	return op.StorageConnectionService(path[:index]).Service(path[index+1:])
}

func (op *storageServerConnectionsService) String() string {
	return fmt.Sprintf("storageServerConnectionsService:%s", op.path)
}

//
//
type copyableService struct {
	baseService
}

func NewCopyableService(connection *Connection, path string) *copyableService {
	var result copyableService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type copyableServiceCopyRequest struct {
	copyableService *copyableService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *copyableServiceCopyRequest) Header(key, value string) *copyableServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *copyableServiceCopyRequest) Query(key, value string) *copyableServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *copyableServiceCopyRequest) Async(async bool) *copyableServiceCopyRequest {
	p.async = &async
	return p
}

func (p *copyableServiceCopyRequest) Send() (*copyableServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.copyableService.connection.URL(), p.copyableService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.copyableService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.copyableService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(copyableServiceCopyResponse), nil
}

func (p *copyableServiceCopyRequest) MustSend() *copyableServiceCopyResponse {
	rawURL := fmt.Sprintf("%s%s/copy", p.copyableService.connection.URL(), p.copyableService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.copyableService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.copyableService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(copyableServiceCopyResponse)
}

//
//
type copyableServiceCopyResponse struct {
}

//
//
func (p *copyableService) Copy() *copyableServiceCopyRequest {
	return &copyableServiceCopyRequest{copyableService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *copyableService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *copyableService) String() string {
	return fmt.Sprintf("copyableService:%s", op.path)
}

//
// Provides information about virtual machine user sessions.
//
type vmSessionsService struct {
	baseService
}

func NewVmSessionsService(connection *Connection, path string) *vmSessionsService {
	var result vmSessionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Lists all user sessions for this virtual machine.
// For example, to retrieve the session information for virtual machine `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/sessions
// ----
// The response body will contain something like this:
// [source,xml]
// ----
// <sessions>
//   <session href="/ovirt-engine/api/vms/123/sessions/456" id="456">
//     <console_user>true</console_user>
//     <ip>
//       <address>192.168.122.1</address>
//     </ip>
//     <user href="/ovirt-engine/api/users/789" id="789"/>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </session>
//   ...
// </sessions>
// ----
// The order of the returned list of sessions isn't guaranteed.
//
type vmSessionsServiceListRequest struct {
	vmSessionsService *vmSessionsService
	header            map[string]string
	query             map[string]string
	follow            *string
	max               *int64
}

func (p *vmSessionsServiceListRequest) Header(key, value string) *vmSessionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmSessionsServiceListRequest) Query(key, value string) *vmSessionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmSessionsServiceListRequest) Follow(follow string) *vmSessionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vmSessionsServiceListRequest) Max(max int64) *vmSessionsServiceListRequest {
	p.max = &max
	return p
}

func (p *vmSessionsServiceListRequest) Send() (*vmSessionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmSessionsService.connection.URL(), p.vmSessionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmSessionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmSessionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSessionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vmSessionsServiceListResponse{sessions: result}, nil
}

func (p *vmSessionsServiceListRequest) MustSend() *vmSessionsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmSessionsService.connection.URL(), p.vmSessionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmSessionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmSessionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSessionReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vmSessionsServiceListResponse{sessions: result}
}

//
// Lists all user sessions for this virtual machine.
// For example, to retrieve the session information for virtual machine `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/sessions
// ----
// The response body will contain something like this:
// [source,xml]
// ----
// <sessions>
//   <session href="/ovirt-engine/api/vms/123/sessions/456" id="456">
//     <console_user>true</console_user>
//     <ip>
//       <address>192.168.122.1</address>
//     </ip>
//     <user href="/ovirt-engine/api/users/789" id="789"/>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </session>
//   ...
// </sessions>
// ----
// The order of the returned list of sessions isn't guaranteed.
//
type vmSessionsServiceListResponse struct {
	sessions *SessionSlice
}

func (p *vmSessionsServiceListResponse) Sessions() (*SessionSlice, bool) {
	if p.sessions != nil {
		return p.sessions, true
	}
	return nil, false
}

func (p *vmSessionsServiceListResponse) MustSessions() *SessionSlice {
	if p.sessions == nil {
		panic("sessions in response does not exist")
	}
	return p.sessions
}

//
// Lists all user sessions for this virtual machine.
// For example, to retrieve the session information for virtual machine `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/sessions
// ----
// The response body will contain something like this:
// [source,xml]
// ----
// <sessions>
//   <session href="/ovirt-engine/api/vms/123/sessions/456" id="456">
//     <console_user>true</console_user>
//     <ip>
//       <address>192.168.122.1</address>
//     </ip>
//     <user href="/ovirt-engine/api/users/789" id="789"/>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </session>
//   ...
// </sessions>
// ----
// The order of the returned list of sessions isn't guaranteed.
//
func (p *vmSessionsService) List() *vmSessionsServiceListRequest {
	return &vmSessionsServiceListRequest{vmSessionsService: p}
}

//
// Reference to the service that manages a specific session.
//
func (op *vmSessionsService) SessionService(id string) *vmSessionService {
	return NewVmSessionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmSessionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.SessionService(path), nil
	}
	return op.SessionService(path[:index]).Service(path[index+1:])
}

func (op *vmSessionsService) String() string {
	return fmt.Sprintf("vmSessionsService:%s", op.path)
}

//
//
type vmDiskService struct {
	baseService
}

func NewVmDiskService(connection *Connection, path string) *vmDiskService {
	var result vmDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type vmDiskServiceActivateRequest struct {
	vmDiskService *vmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *vmDiskServiceActivateRequest) Header(key, value string) *vmDiskServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmDiskServiceActivateRequest) Query(key, value string) *vmDiskServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmDiskServiceActivateRequest) Async(async bool) *vmDiskServiceActivateRequest {
	p.async = &async
	return p
}

func (p *vmDiskServiceActivateRequest) Send() (*vmDiskServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmDiskServiceActivateResponse), nil
}

func (p *vmDiskServiceActivateRequest) MustSend() *vmDiskServiceActivateResponse {
	rawURL := fmt.Sprintf("%s%s/activate", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmDiskServiceActivateResponse)
}

//
//
type vmDiskServiceActivateResponse struct {
}

//
//
func (p *vmDiskService) Activate() *vmDiskServiceActivateRequest {
	return &vmDiskServiceActivateRequest{vmDiskService: p}
}

//
//
type vmDiskServiceDeactivateRequest struct {
	vmDiskService *vmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *vmDiskServiceDeactivateRequest) Header(key, value string) *vmDiskServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmDiskServiceDeactivateRequest) Query(key, value string) *vmDiskServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmDiskServiceDeactivateRequest) Async(async bool) *vmDiskServiceDeactivateRequest {
	p.async = &async
	return p
}

func (p *vmDiskServiceDeactivateRequest) Send() (*vmDiskServiceDeactivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmDiskServiceDeactivateResponse), nil
}

func (p *vmDiskServiceDeactivateRequest) MustSend() *vmDiskServiceDeactivateResponse {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmDiskServiceDeactivateResponse)
}

//
//
type vmDiskServiceDeactivateResponse struct {
}

//
//
func (p *vmDiskService) Deactivate() *vmDiskServiceDeactivateRequest {
	return &vmDiskServiceDeactivateRequest{vmDiskService: p}
}

//
//
type vmDiskServiceExportRequest struct {
	vmDiskService *vmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
}

func (p *vmDiskServiceExportRequest) Header(key, value string) *vmDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmDiskServiceExportRequest) Query(key, value string) *vmDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmDiskServiceExportRequest) Async(async bool) *vmDiskServiceExportRequest {
	p.async = &async
	return p
}

func (p *vmDiskServiceExportRequest) Filter(filter bool) *vmDiskServiceExportRequest {
	p.filter = &filter
	return p
}

func (p *vmDiskServiceExportRequest) Send() (*vmDiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmDiskServiceExportResponse), nil
}

func (p *vmDiskServiceExportRequest) MustSend() *vmDiskServiceExportResponse {
	rawURL := fmt.Sprintf("%s%s/export", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmDiskServiceExportResponse)
}

//
//
type vmDiskServiceExportResponse struct {
}

//
//
func (p *vmDiskService) Export() *vmDiskServiceExportRequest {
	return &vmDiskServiceExportRequest{vmDiskService: p}
}

//
//
type vmDiskServiceGetRequest struct {
	vmDiskService *vmDiskService
	header        map[string]string
	query         map[string]string
	follow        *string
}

func (p *vmDiskServiceGetRequest) Header(key, value string) *vmDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmDiskServiceGetRequest) Query(key, value string) *vmDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmDiskServiceGetRequest) Follow(follow string) *vmDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vmDiskServiceGetRequest) Send() (*vmDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmDiskServiceGetResponse{disk: result}, nil
}

func (p *vmDiskServiceGetRequest) MustSend() *vmDiskServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmDiskServiceGetResponse{disk: result}
}

//
//
type vmDiskServiceGetResponse struct {
	disk *Disk
}

func (p *vmDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *vmDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
//
func (p *vmDiskService) Get() *vmDiskServiceGetRequest {
	return &vmDiskServiceGetRequest{vmDiskService: p}
}

//
//
type vmDiskServiceMoveRequest struct {
	vmDiskService *vmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
}

func (p *vmDiskServiceMoveRequest) Header(key, value string) *vmDiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmDiskServiceMoveRequest) Query(key, value string) *vmDiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmDiskServiceMoveRequest) Async(async bool) *vmDiskServiceMoveRequest {
	p.async = &async
	return p
}

func (p *vmDiskServiceMoveRequest) Filter(filter bool) *vmDiskServiceMoveRequest {
	p.filter = &filter
	return p
}

func (p *vmDiskServiceMoveRequest) Send() (*vmDiskServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmDiskServiceMoveResponse), nil
}

func (p *vmDiskServiceMoveRequest) MustSend() *vmDiskServiceMoveResponse {
	rawURL := fmt.Sprintf("%s%s/move", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmDiskServiceMoveResponse)
}

//
//
type vmDiskServiceMoveResponse struct {
}

//
//
func (p *vmDiskService) Move() *vmDiskServiceMoveRequest {
	return &vmDiskServiceMoveRequest{vmDiskService: p}
}

//
// Detach the disk from the virtual machine.
// NOTE: In version 3 of the API this used to also remove the disk completely from the system, but starting with
// version 4 it doesn't. If you need to remove it completely use the <<services/disk/methods/remove,remove
// method of the top level disk service>>.
//
type vmDiskServiceRemoveRequest struct {
	vmDiskService *vmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *vmDiskServiceRemoveRequest) Header(key, value string) *vmDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmDiskServiceRemoveRequest) Query(key, value string) *vmDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmDiskServiceRemoveRequest) Async(async bool) *vmDiskServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *vmDiskServiceRemoveRequest) Send() (*vmDiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(vmDiskServiceRemoveResponse), nil
}

func (p *vmDiskServiceRemoveRequest) MustSend() *vmDiskServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(vmDiskServiceRemoveResponse)
}

//
// Detach the disk from the virtual machine.
// NOTE: In version 3 of the API this used to also remove the disk completely from the system, but starting with
// version 4 it doesn't. If you need to remove it completely use the <<services/disk/methods/remove,remove
// method of the top level disk service>>.
//
type vmDiskServiceRemoveResponse struct {
}

//
// Detach the disk from the virtual machine.
// NOTE: In version 3 of the API this used to also remove the disk completely from the system, but starting with
// version 4 it doesn't. If you need to remove it completely use the <<services/disk/methods/remove,remove
// method of the top level disk service>>.
//
func (p *vmDiskService) Remove() *vmDiskServiceRemoveRequest {
	return &vmDiskServiceRemoveRequest{vmDiskService: p}
}

//
//
type vmDiskServiceUpdateRequest struct {
	vmDiskService *vmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	disk          *Disk
}

func (p *vmDiskServiceUpdateRequest) Header(key, value string) *vmDiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmDiskServiceUpdateRequest) Query(key, value string) *vmDiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmDiskServiceUpdateRequest) Async(async bool) *vmDiskServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *vmDiskServiceUpdateRequest) Disk(disk *Disk) *vmDiskServiceUpdateRequest {
	p.disk = disk
	return p
}

func (p *vmDiskServiceUpdateRequest) Send() (*vmDiskServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmDiskServiceUpdateResponse{disk: result}, nil
}

func (p *vmDiskServiceUpdateRequest) MustSend() *vmDiskServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmDiskService.connection.URL(), p.vmDiskService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmDiskServiceUpdateResponse{disk: result}
}

//
//
type vmDiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *vmDiskServiceUpdateResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *vmDiskServiceUpdateResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
//
func (p *vmDiskService) Update() *vmDiskServiceUpdateRequest {
	return &vmDiskServiceUpdateRequest{vmDiskService: p}
}

//
//
func (op *vmDiskService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *vmDiskService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vmDiskService) String() string {
	return fmt.Sprintf("vmDiskService:%s", op.path)
}

//
// A service to access a particular device of a host.
//
type hostDeviceService struct {
	baseService
}

func NewHostDeviceService(connection *Connection, path string) *hostDeviceService {
	var result hostDeviceService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieve information about a particular host's device.
// An example of getting a host device:
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/devices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/123/devices/456" id="456">
//   <name>usb_1_9_1_1_0</name>
//   <capability>usb</capability>
//   <host href="/ovirt-engine/api/hosts/123" id="123"/>
//   <parent_device href="/ovirt-engine/api/hosts/123/devices/789" id="789">
//     <name>usb_1_9_1</name>
//   </parent_device>
// </host_device>
// ----
//
type hostDeviceServiceGetRequest struct {
	hostDeviceService *hostDeviceService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *hostDeviceServiceGetRequest) Header(key, value string) *hostDeviceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostDeviceServiceGetRequest) Query(key, value string) *hostDeviceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostDeviceServiceGetRequest) Follow(follow string) *hostDeviceServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *hostDeviceServiceGetRequest) Send() (*hostDeviceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostDeviceService.connection.URL(), p.hostDeviceService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostDeviceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostDeviceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &hostDeviceServiceGetResponse{device: result}, nil
}

func (p *hostDeviceServiceGetRequest) MustSend() *hostDeviceServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostDeviceService.connection.URL(), p.hostDeviceService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostDeviceService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostDeviceService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &hostDeviceServiceGetResponse{device: result}
}

//
// Retrieve information about a particular host's device.
// An example of getting a host device:
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/devices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/123/devices/456" id="456">
//   <name>usb_1_9_1_1_0</name>
//   <capability>usb</capability>
//   <host href="/ovirt-engine/api/hosts/123" id="123"/>
//   <parent_device href="/ovirt-engine/api/hosts/123/devices/789" id="789">
//     <name>usb_1_9_1</name>
//   </parent_device>
// </host_device>
// ----
//
type hostDeviceServiceGetResponse struct {
	device *HostDevice
}

func (p *hostDeviceServiceGetResponse) Device() (*HostDevice, bool) {
	if p.device != nil {
		return p.device, true
	}
	return nil, false
}

func (p *hostDeviceServiceGetResponse) MustDevice() *HostDevice {
	if p.device == nil {
		panic("device in response does not exist")
	}
	return p.device
}

//
// Retrieve information about a particular host's device.
// An example of getting a host device:
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/devices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/123/devices/456" id="456">
//   <name>usb_1_9_1_1_0</name>
//   <capability>usb</capability>
//   <host href="/ovirt-engine/api/hosts/123" id="123"/>
//   <parent_device href="/ovirt-engine/api/hosts/123/devices/789" id="789">
//     <name>usb_1_9_1</name>
//   </parent_device>
// </host_device>
// ----
//
func (p *hostDeviceService) Get() *hostDeviceServiceGetRequest {
	return &hostDeviceServiceGetRequest{hostDeviceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *hostDeviceService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *hostDeviceService) String() string {
	return fmt.Sprintf("hostDeviceService:%s", op.path)
}

//
//
type assignedVnicProfileService struct {
	baseService
}

func NewAssignedVnicProfileService(connection *Connection, path string) *assignedVnicProfileService {
	var result assignedVnicProfileService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type assignedVnicProfileServiceGetRequest struct {
	assignedVnicProfileService *assignedVnicProfileService
	header                     map[string]string
	query                      map[string]string
	follow                     *string
}

func (p *assignedVnicProfileServiceGetRequest) Header(key, value string) *assignedVnicProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedVnicProfileServiceGetRequest) Query(key, value string) *assignedVnicProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedVnicProfileServiceGetRequest) Follow(follow string) *assignedVnicProfileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *assignedVnicProfileServiceGetRequest) Send() (*assignedVnicProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfileService.connection.URL(), p.assignedVnicProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedVnicProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &assignedVnicProfileServiceGetResponse{profile: result}, nil
}

func (p *assignedVnicProfileServiceGetRequest) MustSend() *assignedVnicProfileServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfileService.connection.URL(), p.assignedVnicProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedVnicProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &assignedVnicProfileServiceGetResponse{profile: result}
}

//
//
type assignedVnicProfileServiceGetResponse struct {
	profile *VnicProfile
}

func (p *assignedVnicProfileServiceGetResponse) Profile() (*VnicProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *assignedVnicProfileServiceGetResponse) MustProfile() *VnicProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
//
func (p *assignedVnicProfileService) Get() *assignedVnicProfileServiceGetRequest {
	return &assignedVnicProfileServiceGetRequest{assignedVnicProfileService: p}
}

//
//
type assignedVnicProfileServiceRemoveRequest struct {
	assignedVnicProfileService *assignedVnicProfileService
	header                     map[string]string
	query                      map[string]string
	async                      *bool
}

func (p *assignedVnicProfileServiceRemoveRequest) Header(key, value string) *assignedVnicProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedVnicProfileServiceRemoveRequest) Query(key, value string) *assignedVnicProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedVnicProfileServiceRemoveRequest) Async(async bool) *assignedVnicProfileServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *assignedVnicProfileServiceRemoveRequest) Send() (*assignedVnicProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfileService.connection.URL(), p.assignedVnicProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedVnicProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(assignedVnicProfileServiceRemoveResponse), nil
}

func (p *assignedVnicProfileServiceRemoveRequest) MustSend() *assignedVnicProfileServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfileService.connection.URL(), p.assignedVnicProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedVnicProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(assignedVnicProfileServiceRemoveResponse)
}

//
//
type assignedVnicProfileServiceRemoveResponse struct {
}

//
//
func (p *assignedVnicProfileService) Remove() *assignedVnicProfileServiceRemoveRequest {
	return &assignedVnicProfileServiceRemoveRequest{assignedVnicProfileService: p}
}

//
//
func (op *assignedVnicProfileService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *assignedVnicProfileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *assignedVnicProfileService) String() string {
	return fmt.Sprintf("assignedVnicProfileService:%s", op.path)
}

//
//
type cpuProfileService struct {
	baseService
}

func NewCpuProfileService(connection *Connection, path string) *cpuProfileService {
	var result cpuProfileService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type cpuProfileServiceGetRequest struct {
	cpuProfileService *cpuProfileService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *cpuProfileServiceGetRequest) Header(key, value string) *cpuProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *cpuProfileServiceGetRequest) Query(key, value string) *cpuProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *cpuProfileServiceGetRequest) Follow(follow string) *cpuProfileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *cpuProfileServiceGetRequest) Send() (*cpuProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfileService.connection.URL(), p.cpuProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.cpuProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.cpuProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &cpuProfileServiceGetResponse{profile: result}, nil
}

func (p *cpuProfileServiceGetRequest) MustSend() *cpuProfileServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfileService.connection.URL(), p.cpuProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.cpuProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.cpuProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &cpuProfileServiceGetResponse{profile: result}
}

//
//
type cpuProfileServiceGetResponse struct {
	profile *CpuProfile
}

func (p *cpuProfileServiceGetResponse) Profile() (*CpuProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *cpuProfileServiceGetResponse) MustProfile() *CpuProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
//
func (p *cpuProfileService) Get() *cpuProfileServiceGetRequest {
	return &cpuProfileServiceGetRequest{cpuProfileService: p}
}

//
//
type cpuProfileServiceRemoveRequest struct {
	cpuProfileService *cpuProfileService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *cpuProfileServiceRemoveRequest) Header(key, value string) *cpuProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *cpuProfileServiceRemoveRequest) Query(key, value string) *cpuProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *cpuProfileServiceRemoveRequest) Async(async bool) *cpuProfileServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *cpuProfileServiceRemoveRequest) Send() (*cpuProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfileService.connection.URL(), p.cpuProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.cpuProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.cpuProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(cpuProfileServiceRemoveResponse), nil
}

func (p *cpuProfileServiceRemoveRequest) MustSend() *cpuProfileServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfileService.connection.URL(), p.cpuProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.cpuProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.cpuProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(cpuProfileServiceRemoveResponse)
}

//
//
type cpuProfileServiceRemoveResponse struct {
}

//
//
func (p *cpuProfileService) Remove() *cpuProfileServiceRemoveRequest {
	return &cpuProfileServiceRemoveRequest{cpuProfileService: p}
}

//
// Update the specified cpu profile in the system.
//
type cpuProfileServiceUpdateRequest struct {
	cpuProfileService *cpuProfileService
	header            map[string]string
	query             map[string]string
	async             *bool
	profile           *CpuProfile
}

func (p *cpuProfileServiceUpdateRequest) Header(key, value string) *cpuProfileServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *cpuProfileServiceUpdateRequest) Query(key, value string) *cpuProfileServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *cpuProfileServiceUpdateRequest) Async(async bool) *cpuProfileServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *cpuProfileServiceUpdateRequest) Profile(profile *CpuProfile) *cpuProfileServiceUpdateRequest {
	p.profile = profile
	return p
}

func (p *cpuProfileServiceUpdateRequest) Send() (*cpuProfileServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfileService.connection.URL(), p.cpuProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCpuProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.cpuProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.cpuProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &cpuProfileServiceUpdateResponse{profile: result}, nil
}

func (p *cpuProfileServiceUpdateRequest) MustSend() *cpuProfileServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfileService.connection.URL(), p.cpuProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCpuProfileWriteOne(writer, p.profile, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.cpuProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.cpuProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &cpuProfileServiceUpdateResponse{profile: result}
}

//
// Update the specified cpu profile in the system.
//
type cpuProfileServiceUpdateResponse struct {
	profile *CpuProfile
}

func (p *cpuProfileServiceUpdateResponse) Profile() (*CpuProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *cpuProfileServiceUpdateResponse) MustProfile() *CpuProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Update the specified cpu profile in the system.
//
func (p *cpuProfileService) Update() *cpuProfileServiceUpdateRequest {
	return &cpuProfileServiceUpdateRequest{cpuProfileService: p}
}

//
//
func (op *cpuProfileService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *cpuProfileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *cpuProfileService) String() string {
	return fmt.Sprintf("cpuProfileService:%s", op.path)
}

//
// A service to manage a specific data center network.
//
type dataCenterNetworkService struct {
	baseService
}

func NewDataCenterNetworkService(connection *Connection, path string) *dataCenterNetworkService {
	var result dataCenterNetworkService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the data center network details.
//
type dataCenterNetworkServiceGetRequest struct {
	dataCenterNetworkService *dataCenterNetworkService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *dataCenterNetworkServiceGetRequest) Header(key, value string) *dataCenterNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *dataCenterNetworkServiceGetRequest) Query(key, value string) *dataCenterNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *dataCenterNetworkServiceGetRequest) Follow(follow string) *dataCenterNetworkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *dataCenterNetworkServiceGetRequest) Send() (*dataCenterNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterNetworkService.connection.URL(), p.dataCenterNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &dataCenterNetworkServiceGetResponse{network: result}, nil
}

func (p *dataCenterNetworkServiceGetRequest) MustSend() *dataCenterNetworkServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterNetworkService.connection.URL(), p.dataCenterNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterNetworkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterNetworkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &dataCenterNetworkServiceGetResponse{network: result}
}

//
// Retrieves the data center network details.
//
type dataCenterNetworkServiceGetResponse struct {
	network *Network
}

func (p *dataCenterNetworkServiceGetResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *dataCenterNetworkServiceGetResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Retrieves the data center network details.
//
func (p *dataCenterNetworkService) Get() *dataCenterNetworkServiceGetRequest {
	return &dataCenterNetworkServiceGetRequest{dataCenterNetworkService: p}
}

//
// Removes the network.
//
type dataCenterNetworkServiceRemoveRequest struct {
	dataCenterNetworkService *dataCenterNetworkService
	header                   map[string]string
	query                    map[string]string
}

func (p *dataCenterNetworkServiceRemoveRequest) Header(key, value string) *dataCenterNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *dataCenterNetworkServiceRemoveRequest) Query(key, value string) *dataCenterNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *dataCenterNetworkServiceRemoveRequest) Send() (*dataCenterNetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterNetworkService.connection.URL(), p.dataCenterNetworkService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(dataCenterNetworkServiceRemoveResponse), nil
}

func (p *dataCenterNetworkServiceRemoveRequest) MustSend() *dataCenterNetworkServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterNetworkService.connection.URL(), p.dataCenterNetworkService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterNetworkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterNetworkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(dataCenterNetworkServiceRemoveResponse)
}

//
// Removes the network.
//
type dataCenterNetworkServiceRemoveResponse struct {
}

//
// Removes the network.
//
func (p *dataCenterNetworkService) Remove() *dataCenterNetworkServiceRemoveRequest {
	return &dataCenterNetworkServiceRemoveRequest{dataCenterNetworkService: p}
}

//
// Updates the network in the data center.
//
type dataCenterNetworkServiceUpdateRequest struct {
	dataCenterNetworkService *dataCenterNetworkService
	header                   map[string]string
	query                    map[string]string
	network                  *Network
}

func (p *dataCenterNetworkServiceUpdateRequest) Header(key, value string) *dataCenterNetworkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *dataCenterNetworkServiceUpdateRequest) Query(key, value string) *dataCenterNetworkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *dataCenterNetworkServiceUpdateRequest) Network(network *Network) *dataCenterNetworkServiceUpdateRequest {
	p.network = network
	return p
}

func (p *dataCenterNetworkServiceUpdateRequest) Send() (*dataCenterNetworkServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterNetworkService.connection.URL(), p.dataCenterNetworkService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &dataCenterNetworkServiceUpdateResponse{network: result}, nil
}

func (p *dataCenterNetworkServiceUpdateRequest) MustSend() *dataCenterNetworkServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterNetworkService.connection.URL(), p.dataCenterNetworkService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterNetworkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterNetworkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &dataCenterNetworkServiceUpdateResponse{network: result}
}

//
// Updates the network in the data center.
//
type dataCenterNetworkServiceUpdateResponse struct {
	network *Network
}

func (p *dataCenterNetworkServiceUpdateResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *dataCenterNetworkServiceUpdateResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Updates the network in the data center.
//
func (p *dataCenterNetworkService) Update() *dataCenterNetworkServiceUpdateRequest {
	return &dataCenterNetworkServiceUpdateRequest{dataCenterNetworkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *dataCenterNetworkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *dataCenterNetworkService) String() string {
	return fmt.Sprintf("dataCenterNetworkService:%s", op.path)
}

//
// Represents a readonly network filters sub-collection.
// The network filter enables to filter packets send to/from the VM's nic according to defined rules.
// For more information please refer to <<services/network_filter,NetworkFilter>> service documentation
// Network filters are supported in different versions, starting from version 3.0.
// A network filter is defined for each vnic profile.
// A vnic profile is defined for a specific network.
// A network can be assigned to several different clusters. In the future, each network will be defined in
// cluster level.
// Currently, each network is being defined at data center level. Potential network filters for each network
// are determined by the network's data center compatibility version V.
// V must be >= the network filter version in order to configure this network filter for a specific network.
// Please note, that if a network is assigned to cluster with a version supporting a network filter, the filter
// may not be available due to the data center version being smaller then the network filter's version.
// Example of listing all of the supported network filters for a specific cluster:
// [source]
// ----
// GET http://localhost:8080/ovirt-engine/api/clusters/{cluster:id}/networkfilters
// ----
// Output:
// [source,xml]
// ----
// <network_filters>
//   <network_filter id="00000019-0019-0019-0019-00000000026c">
//     <name>example-network-filter-a</name>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//       <build>-1</build>
//       <revision>-1</revision>
//     </version>
//   </network_filter>
//   <network_filter id="00000019-0019-0019-0019-00000000026b">
//     <name>example-network-filter-b</name>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//       <build>-1</build>
//       <revision>-1</revision>
//     </version>
//   </network_filter>
//   <network_filter id="00000019-0019-0019-0019-00000000026a">
//     <name>example-network-filter-a</name>
//     <version>
//       <major>3</major>
//       <minor>0</minor>
//       <build>-1</build>
//       <revision>-1</revision>
//     </version>
//   </network_filter>
// </network_filters>
// ----
//
type networkFiltersService struct {
	baseService
}

func NewNetworkFiltersService(connection *Connection, path string) *networkFiltersService {
	var result networkFiltersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the representations of the network filters.
// The order of the returned list of network filters isn't guaranteed.
//
type networkFiltersServiceListRequest struct {
	networkFiltersService *networkFiltersService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *networkFiltersServiceListRequest) Header(key, value string) *networkFiltersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkFiltersServiceListRequest) Query(key, value string) *networkFiltersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkFiltersServiceListRequest) Follow(follow string) *networkFiltersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *networkFiltersServiceListRequest) Send() (*networkFiltersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFiltersService.connection.URL(), p.networkFiltersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkFiltersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkFiltersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &networkFiltersServiceListResponse{filters: result}, nil
}

func (p *networkFiltersServiceListRequest) MustSend() *networkFiltersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkFiltersService.connection.URL(), p.networkFiltersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkFiltersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkFiltersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &networkFiltersServiceListResponse{filters: result}
}

//
// Retrieves the representations of the network filters.
// The order of the returned list of network filters isn't guaranteed.
//
type networkFiltersServiceListResponse struct {
	filters *NetworkFilterSlice
}

func (p *networkFiltersServiceListResponse) Filters() (*NetworkFilterSlice, bool) {
	if p.filters != nil {
		return p.filters, true
	}
	return nil, false
}

func (p *networkFiltersServiceListResponse) MustFilters() *NetworkFilterSlice {
	if p.filters == nil {
		panic("filters in response does not exist")
	}
	return p.filters
}

//
// Retrieves the representations of the network filters.
// The order of the returned list of network filters isn't guaranteed.
//
func (p *networkFiltersService) List() *networkFiltersServiceListRequest {
	return &networkFiltersServiceListRequest{networkFiltersService: p}
}

//
//
func (op *networkFiltersService) NetworkFilterService(id string) *networkFilterService {
	return NewNetworkFilterService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *networkFiltersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NetworkFilterService(path), nil
	}
	return op.NetworkFilterService(path[:index]).Service(path[index+1:])
}

func (op *networkFiltersService) String() string {
	return fmt.Sprintf("networkFiltersService:%s", op.path)
}

//
//
type schedulingPolicyUnitService struct {
	baseService
}

func NewSchedulingPolicyUnitService(connection *Connection, path string) *schedulingPolicyUnitService {
	var result schedulingPolicyUnitService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type schedulingPolicyUnitServiceGetRequest struct {
	schedulingPolicyUnitService *schedulingPolicyUnitService
	header                      map[string]string
	query                       map[string]string
	filter                      *bool
	follow                      *string
}

func (p *schedulingPolicyUnitServiceGetRequest) Header(key, value string) *schedulingPolicyUnitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *schedulingPolicyUnitServiceGetRequest) Query(key, value string) *schedulingPolicyUnitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *schedulingPolicyUnitServiceGetRequest) Filter(filter bool) *schedulingPolicyUnitServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *schedulingPolicyUnitServiceGetRequest) Follow(follow string) *schedulingPolicyUnitServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *schedulingPolicyUnitServiceGetRequest) Send() (*schedulingPolicyUnitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyUnitService.connection.URL(), p.schedulingPolicyUnitService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPolicyUnitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyUnitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyUnitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &schedulingPolicyUnitServiceGetResponse{unit: result}, nil
}

func (p *schedulingPolicyUnitServiceGetRequest) MustSend() *schedulingPolicyUnitServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyUnitService.connection.URL(), p.schedulingPolicyUnitService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPolicyUnitService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyUnitService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyUnitReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &schedulingPolicyUnitServiceGetResponse{unit: result}
}

//
//
type schedulingPolicyUnitServiceGetResponse struct {
	unit *SchedulingPolicyUnit
}

func (p *schedulingPolicyUnitServiceGetResponse) Unit() (*SchedulingPolicyUnit, bool) {
	if p.unit != nil {
		return p.unit, true
	}
	return nil, false
}

func (p *schedulingPolicyUnitServiceGetResponse) MustUnit() *SchedulingPolicyUnit {
	if p.unit == nil {
		panic("unit in response does not exist")
	}
	return p.unit
}

//
//
func (p *schedulingPolicyUnitService) Get() *schedulingPolicyUnitServiceGetRequest {
	return &schedulingPolicyUnitServiceGetRequest{schedulingPolicyUnitService: p}
}

//
//
type schedulingPolicyUnitServiceRemoveRequest struct {
	schedulingPolicyUnitService *schedulingPolicyUnitService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *schedulingPolicyUnitServiceRemoveRequest) Header(key, value string) *schedulingPolicyUnitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *schedulingPolicyUnitServiceRemoveRequest) Query(key, value string) *schedulingPolicyUnitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *schedulingPolicyUnitServiceRemoveRequest) Async(async bool) *schedulingPolicyUnitServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *schedulingPolicyUnitServiceRemoveRequest) Send() (*schedulingPolicyUnitServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyUnitService.connection.URL(), p.schedulingPolicyUnitService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPolicyUnitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyUnitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(schedulingPolicyUnitServiceRemoveResponse), nil
}

func (p *schedulingPolicyUnitServiceRemoveRequest) MustSend() *schedulingPolicyUnitServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyUnitService.connection.URL(), p.schedulingPolicyUnitService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPolicyUnitService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyUnitService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(schedulingPolicyUnitServiceRemoveResponse)
}

//
//
type schedulingPolicyUnitServiceRemoveResponse struct {
}

//
//
func (p *schedulingPolicyUnitService) Remove() *schedulingPolicyUnitServiceRemoveRequest {
	return &schedulingPolicyUnitServiceRemoveRequest{schedulingPolicyUnitService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *schedulingPolicyUnitService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *schedulingPolicyUnitService) String() string {
	return fmt.Sprintf("schedulingPolicyUnitService:%s", op.path)
}

//
// Describes how an external network provider is provisioned by the system on the host.
//
type externalNetworkProviderConfigurationService struct {
	baseService
}

func NewExternalNetworkProviderConfigurationService(connection *Connection, path string) *externalNetworkProviderConfigurationService {
	var result externalNetworkProviderConfigurationService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the information about an external network provider on the host.
//
type externalNetworkProviderConfigurationServiceGetRequest struct {
	externalNetworkProviderConfigurationService *externalNetworkProviderConfigurationService
	header                                      map[string]string
	query                                       map[string]string
	follow                                      *string
}

func (p *externalNetworkProviderConfigurationServiceGetRequest) Header(key, value string) *externalNetworkProviderConfigurationServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalNetworkProviderConfigurationServiceGetRequest) Query(key, value string) *externalNetworkProviderConfigurationServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalNetworkProviderConfigurationServiceGetRequest) Follow(follow string) *externalNetworkProviderConfigurationServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *externalNetworkProviderConfigurationServiceGetRequest) Send() (*externalNetworkProviderConfigurationServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalNetworkProviderConfigurationService.connection.URL(), p.externalNetworkProviderConfigurationService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalNetworkProviderConfigurationService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalNetworkProviderConfigurationService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalNetworkProviderConfigurationReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &externalNetworkProviderConfigurationServiceGetResponse{configuration: result}, nil
}

func (p *externalNetworkProviderConfigurationServiceGetRequest) MustSend() *externalNetworkProviderConfigurationServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalNetworkProviderConfigurationService.connection.URL(), p.externalNetworkProviderConfigurationService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalNetworkProviderConfigurationService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalNetworkProviderConfigurationService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalNetworkProviderConfigurationReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &externalNetworkProviderConfigurationServiceGetResponse{configuration: result}
}

//
// Returns the information about an external network provider on the host.
//
type externalNetworkProviderConfigurationServiceGetResponse struct {
	configuration *ExternalNetworkProviderConfiguration
}

func (p *externalNetworkProviderConfigurationServiceGetResponse) Configuration() (*ExternalNetworkProviderConfiguration, bool) {
	if p.configuration != nil {
		return p.configuration, true
	}
	return nil, false
}

func (p *externalNetworkProviderConfigurationServiceGetResponse) MustConfiguration() *ExternalNetworkProviderConfiguration {
	if p.configuration == nil {
		panic("configuration in response does not exist")
	}
	return p.configuration
}

//
// Returns the information about an external network provider on the host.
//
func (p *externalNetworkProviderConfigurationService) Get() *externalNetworkProviderConfigurationServiceGetRequest {
	return &externalNetworkProviderConfigurationServiceGetRequest{externalNetworkProviderConfigurationService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalNetworkProviderConfigurationService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *externalNetworkProviderConfigurationService) String() string {
	return fmt.Sprintf("externalNetworkProviderConfigurationService:%s", op.path)
}

//
// This service manages the collection of all vNIC profiles.
//
type vnicProfilesService struct {
	baseService
}

func NewVnicProfilesService(connection *Connection, path string) *vnicProfilesService {
	var result vnicProfilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a vNIC profile.
// For example to add vNIC profile `123` to network `456` send a request to:
// [source]
// ----
// POST /ovirt-engine/api/networks/456/vnicprofiles
// ----
// With the following body:
// [source,xml]
// ----
// <vnic_profile id="123">
//   <name>new_vNIC_name</name>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
// </vnic_profile>
// ----
// Please note that there is a default network filter to each VNIC profile.
// For more details of how the default network filter is calculated please refer to
// the documentation in <<services/network_filters,NetworkFilters>>.
// The output of creating a new VNIC profile depends in the  body  arguments that were given.
// In case no network filter was given, the default network filter will be configured. For example:
// [source,xml]
// ----
// <vnic_profile href="/ovirt-engine/api/vnicprofiles/123" id="123">
//   <name>new_vNIC_name</name>
//   <link href="/ovirt-engine/api/vnicprofiles/123/permissions" rel="permissions"/>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
//   <network href="/ovirt-engine/api/networks/456" id="456"/>
//   <network_filter href="/ovirt-engine/api/networkfilters/789" id="789"/>
// </vnic_profile>
// ----
// In case an empty network filter was given, no network filter will be configured for the specific VNIC profile
// regardless of the VNIC profile's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>no_network_filter</name>
//   <network_filter/>
// </vnic_profile>
// ----
// In case that a specific valid network filter id was given, the VNIC profile will be configured with the given
// network filter regardless of the VNIC profiles's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>user_choice_network_filter</name>
//   <network_filter id= "0000001b-001b-001b-001b-0000000001d5"/>
// </vnic_profile>
// ----
//
type vnicProfilesServiceAddRequest struct {
	vnicProfilesService *vnicProfilesService
	header              map[string]string
	query               map[string]string
	profile             *VnicProfile
}

func (p *vnicProfilesServiceAddRequest) Header(key, value string) *vnicProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vnicProfilesServiceAddRequest) Query(key, value string) *vnicProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vnicProfilesServiceAddRequest) Profile(profile *VnicProfile) *vnicProfilesServiceAddRequest {
	p.profile = profile
	return p
}

func (p *vnicProfilesServiceAddRequest) Send() (*vnicProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfilesService.connection.URL(), p.vnicProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVnicProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vnicProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vnicProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vnicProfilesServiceAddResponse{profile: result}, nil
}

func (p *vnicProfilesServiceAddRequest) MustSend() *vnicProfilesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfilesService.connection.URL(), p.vnicProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVnicProfileWriteOne(writer, p.profile, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vnicProfilesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vnicProfilesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vnicProfilesServiceAddResponse{profile: result}
}

//
// Add a vNIC profile.
// For example to add vNIC profile `123` to network `456` send a request to:
// [source]
// ----
// POST /ovirt-engine/api/networks/456/vnicprofiles
// ----
// With the following body:
// [source,xml]
// ----
// <vnic_profile id="123">
//   <name>new_vNIC_name</name>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
// </vnic_profile>
// ----
// Please note that there is a default network filter to each VNIC profile.
// For more details of how the default network filter is calculated please refer to
// the documentation in <<services/network_filters,NetworkFilters>>.
// The output of creating a new VNIC profile depends in the  body  arguments that were given.
// In case no network filter was given, the default network filter will be configured. For example:
// [source,xml]
// ----
// <vnic_profile href="/ovirt-engine/api/vnicprofiles/123" id="123">
//   <name>new_vNIC_name</name>
//   <link href="/ovirt-engine/api/vnicprofiles/123/permissions" rel="permissions"/>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
//   <network href="/ovirt-engine/api/networks/456" id="456"/>
//   <network_filter href="/ovirt-engine/api/networkfilters/789" id="789"/>
// </vnic_profile>
// ----
// In case an empty network filter was given, no network filter will be configured for the specific VNIC profile
// regardless of the VNIC profile's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>no_network_filter</name>
//   <network_filter/>
// </vnic_profile>
// ----
// In case that a specific valid network filter id was given, the VNIC profile will be configured with the given
// network filter regardless of the VNIC profiles's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>user_choice_network_filter</name>
//   <network_filter id= "0000001b-001b-001b-001b-0000000001d5"/>
// </vnic_profile>
// ----
//
type vnicProfilesServiceAddResponse struct {
	profile *VnicProfile
}

func (p *vnicProfilesServiceAddResponse) Profile() (*VnicProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *vnicProfilesServiceAddResponse) MustProfile() *VnicProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Add a vNIC profile.
// For example to add vNIC profile `123` to network `456` send a request to:
// [source]
// ----
// POST /ovirt-engine/api/networks/456/vnicprofiles
// ----
// With the following body:
// [source,xml]
// ----
// <vnic_profile id="123">
//   <name>new_vNIC_name</name>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
// </vnic_profile>
// ----
// Please note that there is a default network filter to each VNIC profile.
// For more details of how the default network filter is calculated please refer to
// the documentation in <<services/network_filters,NetworkFilters>>.
// The output of creating a new VNIC profile depends in the  body  arguments that were given.
// In case no network filter was given, the default network filter will be configured. For example:
// [source,xml]
// ----
// <vnic_profile href="/ovirt-engine/api/vnicprofiles/123" id="123">
//   <name>new_vNIC_name</name>
//   <link href="/ovirt-engine/api/vnicprofiles/123/permissions" rel="permissions"/>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
//   <network href="/ovirt-engine/api/networks/456" id="456"/>
//   <network_filter href="/ovirt-engine/api/networkfilters/789" id="789"/>
// </vnic_profile>
// ----
// In case an empty network filter was given, no network filter will be configured for the specific VNIC profile
// regardless of the VNIC profile's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>no_network_filter</name>
//   <network_filter/>
// </vnic_profile>
// ----
// In case that a specific valid network filter id was given, the VNIC profile will be configured with the given
// network filter regardless of the VNIC profiles's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>user_choice_network_filter</name>
//   <network_filter id= "0000001b-001b-001b-001b-0000000001d5"/>
// </vnic_profile>
// ----
//
func (p *vnicProfilesService) Add() *vnicProfilesServiceAddRequest {
	return &vnicProfilesServiceAddRequest{vnicProfilesService: p}
}

//
// List all vNIC profiles.
// The order of the returned list of vNIC profiles isn't guaranteed.
//
type vnicProfilesServiceListRequest struct {
	vnicProfilesService *vnicProfilesService
	header              map[string]string
	query               map[string]string
	follow              *string
	max                 *int64
}

func (p *vnicProfilesServiceListRequest) Header(key, value string) *vnicProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vnicProfilesServiceListRequest) Query(key, value string) *vnicProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vnicProfilesServiceListRequest) Follow(follow string) *vnicProfilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vnicProfilesServiceListRequest) Max(max int64) *vnicProfilesServiceListRequest {
	p.max = &max
	return p
}

func (p *vnicProfilesServiceListRequest) Send() (*vnicProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfilesService.connection.URL(), p.vnicProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vnicProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vnicProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vnicProfilesServiceListResponse{profiles: result}, nil
}

func (p *vnicProfilesServiceListRequest) MustSend() *vnicProfilesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfilesService.connection.URL(), p.vnicProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vnicProfilesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vnicProfilesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vnicProfilesServiceListResponse{profiles: result}
}

//
// List all vNIC profiles.
// The order of the returned list of vNIC profiles isn't guaranteed.
//
type vnicProfilesServiceListResponse struct {
	profiles *VnicProfileSlice
}

func (p *vnicProfilesServiceListResponse) Profiles() (*VnicProfileSlice, bool) {
	if p.profiles != nil {
		return p.profiles, true
	}
	return nil, false
}

func (p *vnicProfilesServiceListResponse) MustProfiles() *VnicProfileSlice {
	if p.profiles == nil {
		panic("profiles in response does not exist")
	}
	return p.profiles
}

//
// List all vNIC profiles.
// The order of the returned list of vNIC profiles isn't guaranteed.
//
func (p *vnicProfilesService) List() *vnicProfilesServiceListRequest {
	return &vnicProfilesServiceListRequest{vnicProfilesService: p}
}

//
//
func (op *vnicProfilesService) ProfileService(id string) *vnicProfileService {
	return NewVnicProfileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vnicProfilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProfileService(path), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *vnicProfilesService) String() string {
	return fmt.Sprintf("vnicProfilesService:%s", op.path)
}

//
// This service is used to list and manipulate affinity labels that are
// assigned to supported entities when accessed using entities/affinitylabels.
//
type assignedAffinityLabelsService struct {
	baseService
}

func NewAssignedAffinityLabelsService(connection *Connection, path string) *assignedAffinityLabelsService {
	var result assignedAffinityLabelsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Attaches a label to an entity.
//
type assignedAffinityLabelsServiceAddRequest struct {
	assignedAffinityLabelsService *assignedAffinityLabelsService
	header                        map[string]string
	query                         map[string]string
	label                         *AffinityLabel
}

func (p *assignedAffinityLabelsServiceAddRequest) Header(key, value string) *assignedAffinityLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedAffinityLabelsServiceAddRequest) Query(key, value string) *assignedAffinityLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedAffinityLabelsServiceAddRequest) Label(label *AffinityLabel) *assignedAffinityLabelsServiceAddRequest {
	p.label = label
	return p
}

func (p *assignedAffinityLabelsServiceAddRequest) Send() (*assignedAffinityLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelsService.connection.URL(), p.assignedAffinityLabelsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityLabelWriteOne(writer, p.label, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedAffinityLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &assignedAffinityLabelsServiceAddResponse{label: result}, nil
}

func (p *assignedAffinityLabelsServiceAddRequest) MustSend() *assignedAffinityLabelsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelsService.connection.URL(), p.assignedAffinityLabelsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityLabelWriteOne(writer, p.label, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedAffinityLabelsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &assignedAffinityLabelsServiceAddResponse{label: result}
}

//
// Attaches a label to an entity.
//
type assignedAffinityLabelsServiceAddResponse struct {
	label *AffinityLabel
}

func (p *assignedAffinityLabelsServiceAddResponse) Label() (*AffinityLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *assignedAffinityLabelsServiceAddResponse) MustLabel() *AffinityLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Attaches a label to an entity.
//
func (p *assignedAffinityLabelsService) Add() *assignedAffinityLabelsServiceAddRequest {
	return &assignedAffinityLabelsServiceAddRequest{assignedAffinityLabelsService: p}
}

//
// Lists all labels that are attached to an entity.
// The order of the returned entities isn't guaranteed.
//
type assignedAffinityLabelsServiceListRequest struct {
	assignedAffinityLabelsService *assignedAffinityLabelsService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
}

func (p *assignedAffinityLabelsServiceListRequest) Header(key, value string) *assignedAffinityLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedAffinityLabelsServiceListRequest) Query(key, value string) *assignedAffinityLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedAffinityLabelsServiceListRequest) Follow(follow string) *assignedAffinityLabelsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *assignedAffinityLabelsServiceListRequest) Send() (*assignedAffinityLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelsService.connection.URL(), p.assignedAffinityLabelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedAffinityLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &assignedAffinityLabelsServiceListResponse{label: result}, nil
}

func (p *assignedAffinityLabelsServiceListRequest) MustSend() *assignedAffinityLabelsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelsService.connection.URL(), p.assignedAffinityLabelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedAffinityLabelsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &assignedAffinityLabelsServiceListResponse{label: result}
}

//
// Lists all labels that are attached to an entity.
// The order of the returned entities isn't guaranteed.
//
type assignedAffinityLabelsServiceListResponse struct {
	label *AffinityLabelSlice
}

func (p *assignedAffinityLabelsServiceListResponse) Label() (*AffinityLabelSlice, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *assignedAffinityLabelsServiceListResponse) MustLabel() *AffinityLabelSlice {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Lists all labels that are attached to an entity.
// The order of the returned entities isn't guaranteed.
//
func (p *assignedAffinityLabelsService) List() *assignedAffinityLabelsServiceListRequest {
	return &assignedAffinityLabelsServiceListRequest{assignedAffinityLabelsService: p}
}

//
// Link to the specific entity-label assignment to allow
// removal.
//
func (op *assignedAffinityLabelsService) LabelService(id string) *assignedAffinityLabelService {
	return NewAssignedAffinityLabelService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *assignedAffinityLabelsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LabelService(path), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *assignedAffinityLabelsService) String() string {
	return fmt.Sprintf("assignedAffinityLabelsService:%s", op.path)
}

//
//
type iscsiBondService struct {
	baseService
}

func NewIscsiBondService(connection *Connection, path string) *iscsiBondService {
	var result iscsiBondService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type iscsiBondServiceGetRequest struct {
	iscsiBondService *iscsiBondService
	header           map[string]string
	query            map[string]string
	follow           *string
}

func (p *iscsiBondServiceGetRequest) Header(key, value string) *iscsiBondServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *iscsiBondServiceGetRequest) Query(key, value string) *iscsiBondServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *iscsiBondServiceGetRequest) Follow(follow string) *iscsiBondServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *iscsiBondServiceGetRequest) Send() (*iscsiBondServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondService.connection.URL(), p.iscsiBondService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iscsiBondService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iscsiBondService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIscsiBondReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &iscsiBondServiceGetResponse{bond: result}, nil
}

func (p *iscsiBondServiceGetRequest) MustSend() *iscsiBondServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondService.connection.URL(), p.iscsiBondService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iscsiBondService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iscsiBondService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIscsiBondReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &iscsiBondServiceGetResponse{bond: result}
}

//
//
type iscsiBondServiceGetResponse struct {
	bond *IscsiBond
}

func (p *iscsiBondServiceGetResponse) Bond() (*IscsiBond, bool) {
	if p.bond != nil {
		return p.bond, true
	}
	return nil, false
}

func (p *iscsiBondServiceGetResponse) MustBond() *IscsiBond {
	if p.bond == nil {
		panic("bond in response does not exist")
	}
	return p.bond
}

//
//
func (p *iscsiBondService) Get() *iscsiBondServiceGetRequest {
	return &iscsiBondServiceGetRequest{iscsiBondService: p}
}

//
// Removes of an existing iSCSI bond.
// For example, to remove the iSCSI bond `456` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/iscsibonds/456
// ----
//
type iscsiBondServiceRemoveRequest struct {
	iscsiBondService *iscsiBondService
	header           map[string]string
	query            map[string]string
	async            *bool
}

func (p *iscsiBondServiceRemoveRequest) Header(key, value string) *iscsiBondServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *iscsiBondServiceRemoveRequest) Query(key, value string) *iscsiBondServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *iscsiBondServiceRemoveRequest) Async(async bool) *iscsiBondServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *iscsiBondServiceRemoveRequest) Send() (*iscsiBondServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondService.connection.URL(), p.iscsiBondService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iscsiBondService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iscsiBondService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(iscsiBondServiceRemoveResponse), nil
}

func (p *iscsiBondServiceRemoveRequest) MustSend() *iscsiBondServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondService.connection.URL(), p.iscsiBondService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iscsiBondService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iscsiBondService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(iscsiBondServiceRemoveResponse)
}

//
// Removes of an existing iSCSI bond.
// For example, to remove the iSCSI bond `456` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/iscsibonds/456
// ----
//
type iscsiBondServiceRemoveResponse struct {
}

//
// Removes of an existing iSCSI bond.
// For example, to remove the iSCSI bond `456` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/iscsibonds/456
// ----
//
func (p *iscsiBondService) Remove() *iscsiBondServiceRemoveRequest {
	return &iscsiBondServiceRemoveRequest{iscsiBondService: p}
}

//
// Updates an iSCSI bond.
// Updating of an iSCSI bond can be done on the `name` and the `description` attributes only. For example, to
// update the iSCSI bond `456` of data center `123`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/iscsibonds/1234
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//    <name>mybond</name>
//    <description>My iSCSI bond</description>
// </iscsi_bond>
// ----
//
type iscsiBondServiceUpdateRequest struct {
	iscsiBondService *iscsiBondService
	header           map[string]string
	query            map[string]string
	async            *bool
	bond             *IscsiBond
}

func (p *iscsiBondServiceUpdateRequest) Header(key, value string) *iscsiBondServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *iscsiBondServiceUpdateRequest) Query(key, value string) *iscsiBondServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *iscsiBondServiceUpdateRequest) Async(async bool) *iscsiBondServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *iscsiBondServiceUpdateRequest) Bond(bond *IscsiBond) *iscsiBondServiceUpdateRequest {
	p.bond = bond
	return p
}

func (p *iscsiBondServiceUpdateRequest) Send() (*iscsiBondServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondService.connection.URL(), p.iscsiBondService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLIscsiBondWriteOne(writer, p.bond, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iscsiBondService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iscsiBondService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIscsiBondReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &iscsiBondServiceUpdateResponse{bond: result}, nil
}

func (p *iscsiBondServiceUpdateRequest) MustSend() *iscsiBondServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondService.connection.URL(), p.iscsiBondService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLIscsiBondWriteOne(writer, p.bond, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iscsiBondService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iscsiBondService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIscsiBondReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &iscsiBondServiceUpdateResponse{bond: result}
}

//
// Updates an iSCSI bond.
// Updating of an iSCSI bond can be done on the `name` and the `description` attributes only. For example, to
// update the iSCSI bond `456` of data center `123`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/iscsibonds/1234
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//    <name>mybond</name>
//    <description>My iSCSI bond</description>
// </iscsi_bond>
// ----
//
type iscsiBondServiceUpdateResponse struct {
	bond *IscsiBond
}

func (p *iscsiBondServiceUpdateResponse) Bond() (*IscsiBond, bool) {
	if p.bond != nil {
		return p.bond, true
	}
	return nil, false
}

func (p *iscsiBondServiceUpdateResponse) MustBond() *IscsiBond {
	if p.bond == nil {
		panic("bond in response does not exist")
	}
	return p.bond
}

//
// Updates an iSCSI bond.
// Updating of an iSCSI bond can be done on the `name` and the `description` attributes only. For example, to
// update the iSCSI bond `456` of data center `123`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/iscsibonds/1234
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//    <name>mybond</name>
//    <description>My iSCSI bond</description>
// </iscsi_bond>
// ----
//
func (p *iscsiBondService) Update() *iscsiBondServiceUpdateRequest {
	return &iscsiBondServiceUpdateRequest{iscsiBondService: p}
}

//
//
func (op *iscsiBondService) NetworksService() *networksService {
	return NewNetworksService(op.connection, fmt.Sprintf("%s/networks", op.path))
}

//
//
func (op *iscsiBondService) StorageServerConnectionsService() *storageServerConnectionsService {
	return NewStorageServerConnectionsService(op.connection, fmt.Sprintf("%s/storageserverconnections", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *iscsiBondService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "storageserverconnections" {
		return op.StorageServerConnectionsService(), nil
	}
	if strings.HasPrefix(path, "storageserverconnections/") {
		return op.StorageServerConnectionsService().Service(path[25:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *iscsiBondService) String() string {
	return fmt.Sprintf("iscsiBondService:%s", op.path)
}

//
//
type storageDomainContentDiskService struct {
	baseService
}

func NewStorageDomainContentDiskService(connection *Connection, path string) *storageDomainContentDiskService {
	var result storageDomainContentDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type storageDomainContentDiskServiceGetRequest struct {
	storageDomainContentDiskService *storageDomainContentDiskService
	header                          map[string]string
	query                           map[string]string
	filter                          *bool
	follow                          *string
}

func (p *storageDomainContentDiskServiceGetRequest) Header(key, value string) *storageDomainContentDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainContentDiskServiceGetRequest) Query(key, value string) *storageDomainContentDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainContentDiskServiceGetRequest) Filter(filter bool) *storageDomainContentDiskServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *storageDomainContentDiskServiceGetRequest) Follow(follow string) *storageDomainContentDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainContentDiskServiceGetRequest) Send() (*storageDomainContentDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainContentDiskService.connection.URL(), p.storageDomainContentDiskService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainContentDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainContentDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageDomainContentDiskServiceGetResponse{disk: result}, nil
}

func (p *storageDomainContentDiskServiceGetRequest) MustSend() *storageDomainContentDiskServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainContentDiskService.connection.URL(), p.storageDomainContentDiskService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainContentDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainContentDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageDomainContentDiskServiceGetResponse{disk: result}
}

//
//
type storageDomainContentDiskServiceGetResponse struct {
	disk *Disk
}

func (p *storageDomainContentDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *storageDomainContentDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
//
func (p *storageDomainContentDiskService) Get() *storageDomainContentDiskServiceGetRequest {
	return &storageDomainContentDiskServiceGetRequest{storageDomainContentDiskService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainContentDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *storageDomainContentDiskService) String() string {
	return fmt.Sprintf("storageDomainContentDiskService:%s", op.path)
}

//
//
type networkAttachmentService struct {
	baseService
}

func NewNetworkAttachmentService(connection *Connection, path string) *networkAttachmentService {
	var result networkAttachmentService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type networkAttachmentServiceGetRequest struct {
	networkAttachmentService *networkAttachmentService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *networkAttachmentServiceGetRequest) Header(key, value string) *networkAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkAttachmentServiceGetRequest) Query(key, value string) *networkAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkAttachmentServiceGetRequest) Follow(follow string) *networkAttachmentServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *networkAttachmentServiceGetRequest) Send() (*networkAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentService.connection.URL(), p.networkAttachmentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &networkAttachmentServiceGetResponse{attachment: result}, nil
}

func (p *networkAttachmentServiceGetRequest) MustSend() *networkAttachmentServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentService.connection.URL(), p.networkAttachmentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkAttachmentService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkAttachmentService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkAttachmentReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &networkAttachmentServiceGetResponse{attachment: result}
}

//
//
type networkAttachmentServiceGetResponse struct {
	attachment *NetworkAttachment
}

func (p *networkAttachmentServiceGetResponse) Attachment() (*NetworkAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *networkAttachmentServiceGetResponse) MustAttachment() *NetworkAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
//
func (p *networkAttachmentService) Get() *networkAttachmentServiceGetRequest {
	return &networkAttachmentServiceGetRequest{networkAttachmentService: p}
}

//
//
type networkAttachmentServiceRemoveRequest struct {
	networkAttachmentService *networkAttachmentService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *networkAttachmentServiceRemoveRequest) Header(key, value string) *networkAttachmentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkAttachmentServiceRemoveRequest) Query(key, value string) *networkAttachmentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkAttachmentServiceRemoveRequest) Async(async bool) *networkAttachmentServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *networkAttachmentServiceRemoveRequest) Send() (*networkAttachmentServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentService.connection.URL(), p.networkAttachmentService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(networkAttachmentServiceRemoveResponse), nil
}

func (p *networkAttachmentServiceRemoveRequest) MustSend() *networkAttachmentServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentService.connection.URL(), p.networkAttachmentService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkAttachmentService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkAttachmentService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(networkAttachmentServiceRemoveResponse)
}

//
//
type networkAttachmentServiceRemoveResponse struct {
}

//
//
func (p *networkAttachmentService) Remove() *networkAttachmentServiceRemoveRequest {
	return &networkAttachmentServiceRemoveRequest{networkAttachmentService: p}
}

//
// Update the specified network attachment on the host.
//
type networkAttachmentServiceUpdateRequest struct {
	networkAttachmentService *networkAttachmentService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
	attachment               *NetworkAttachment
}

func (p *networkAttachmentServiceUpdateRequest) Header(key, value string) *networkAttachmentServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkAttachmentServiceUpdateRequest) Query(key, value string) *networkAttachmentServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkAttachmentServiceUpdateRequest) Async(async bool) *networkAttachmentServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *networkAttachmentServiceUpdateRequest) Attachment(attachment *NetworkAttachment) *networkAttachmentServiceUpdateRequest {
	p.attachment = attachment
	return p
}

func (p *networkAttachmentServiceUpdateRequest) Send() (*networkAttachmentServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentService.connection.URL(), p.networkAttachmentService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkAttachmentWriteOne(writer, p.attachment, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &networkAttachmentServiceUpdateResponse{attachment: result}, nil
}

func (p *networkAttachmentServiceUpdateRequest) MustSend() *networkAttachmentServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkAttachmentService.connection.URL(), p.networkAttachmentService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkAttachmentWriteOne(writer, p.attachment, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkAttachmentService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkAttachmentService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkAttachmentReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &networkAttachmentServiceUpdateResponse{attachment: result}
}

//
// Update the specified network attachment on the host.
//
type networkAttachmentServiceUpdateResponse struct {
	attachment *NetworkAttachment
}

func (p *networkAttachmentServiceUpdateResponse) Attachment() (*NetworkAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *networkAttachmentServiceUpdateResponse) MustAttachment() *NetworkAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
// Update the specified network attachment on the host.
//
func (p *networkAttachmentService) Update() *networkAttachmentServiceUpdateRequest {
	return &networkAttachmentServiceUpdateRequest{networkAttachmentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *networkAttachmentService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *networkAttachmentService) String() string {
	return fmt.Sprintf("networkAttachmentService:%s", op.path)
}

//
//
type vmReportedDeviceService struct {
	baseService
}

func NewVmReportedDeviceService(connection *Connection, path string) *vmReportedDeviceService {
	var result vmReportedDeviceService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type vmReportedDeviceServiceGetRequest struct {
	vmReportedDeviceService *vmReportedDeviceService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
}

func (p *vmReportedDeviceServiceGetRequest) Header(key, value string) *vmReportedDeviceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmReportedDeviceServiceGetRequest) Query(key, value string) *vmReportedDeviceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmReportedDeviceServiceGetRequest) Follow(follow string) *vmReportedDeviceServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vmReportedDeviceServiceGetRequest) Send() (*vmReportedDeviceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmReportedDeviceService.connection.URL(), p.vmReportedDeviceService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmReportedDeviceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmReportedDeviceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLReportedDeviceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmReportedDeviceServiceGetResponse{reportedDevice: result}, nil
}

func (p *vmReportedDeviceServiceGetRequest) MustSend() *vmReportedDeviceServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmReportedDeviceService.connection.URL(), p.vmReportedDeviceService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmReportedDeviceService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmReportedDeviceService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLReportedDeviceReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmReportedDeviceServiceGetResponse{reportedDevice: result}
}

//
//
type vmReportedDeviceServiceGetResponse struct {
	reportedDevice *ReportedDevice
}

func (p *vmReportedDeviceServiceGetResponse) ReportedDevice() (*ReportedDevice, bool) {
	if p.reportedDevice != nil {
		return p.reportedDevice, true
	}
	return nil, false
}

func (p *vmReportedDeviceServiceGetResponse) MustReportedDevice() *ReportedDevice {
	if p.reportedDevice == nil {
		panic("reportedDevice in response does not exist")
	}
	return p.reportedDevice
}

//
//
func (p *vmReportedDeviceService) Get() *vmReportedDeviceServiceGetRequest {
	return &vmReportedDeviceServiceGetRequest{vmReportedDeviceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmReportedDeviceService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vmReportedDeviceService) String() string {
	return fmt.Sprintf("vmReportedDeviceService:%s", op.path)
}

//
//
type snapshotDiskService struct {
	baseService
}

func NewSnapshotDiskService(connection *Connection, path string) *snapshotDiskService {
	var result snapshotDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type snapshotDiskServiceGetRequest struct {
	snapshotDiskService *snapshotDiskService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *snapshotDiskServiceGetRequest) Header(key, value string) *snapshotDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *snapshotDiskServiceGetRequest) Query(key, value string) *snapshotDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *snapshotDiskServiceGetRequest) Follow(follow string) *snapshotDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *snapshotDiskServiceGetRequest) Send() (*snapshotDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotDiskService.connection.URL(), p.snapshotDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &snapshotDiskServiceGetResponse{disk: result}, nil
}

func (p *snapshotDiskServiceGetRequest) MustSend() *snapshotDiskServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.snapshotDiskService.connection.URL(), p.snapshotDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &snapshotDiskServiceGetResponse{disk: result}
}

//
//
type snapshotDiskServiceGetResponse struct {
	disk *Disk
}

func (p *snapshotDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *snapshotDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
//
func (p *snapshotDiskService) Get() *snapshotDiskServiceGetRequest {
	return &snapshotDiskServiceGetRequest{snapshotDiskService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *snapshotDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *snapshotDiskService) String() string {
	return fmt.Sprintf("snapshotDiskService:%s", op.path)
}

//
// Lists the virtual machines of an export storage domain.
// For example, to retrieve the virtual machines that are available in the storage domain with identifier `123` send the
// following request:
// [source]
// ----
// GET /ovirt-engine/api/storagedomains/123/vms
// ----
// This will return the following response body:
// [source,xml]
// ----
// <vms>
//   <vm id="456" href="/api/storagedomains/123/vms/456">
//     <name>vm1</name>
//     ...
//     <storage_domain id="123" href="/api/storagedomains/123"/>
//     <actions>
//       <link rel="import" href="/api/storagedomains/123/vms/456/import"/>
//     </actions>
//   </vm>
// </vms>
// ----
// Virtual machines and templates in these collections have a similar representation to their counterparts in the
// top-level <<types/vm, Vm>> and <<types/template, Template>> collections, except they also contain a
// <<types/storage_domain, StorageDomain>> reference and an <<services/storage_domain_vm/methods/import, import>>
// action.
//
type storageDomainVmsService struct {
	baseService
}

func NewStorageDomainVmsService(connection *Connection, path string) *storageDomainVmsService {
	var result storageDomainVmsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of virtual machines of the export storage domain.
// The order of the returned list of virtual machines isn't guaranteed.
//
type storageDomainVmsServiceListRequest struct {
	storageDomainVmsService *storageDomainVmsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
	max                     *int64
	unregistered            *bool
}

func (p *storageDomainVmsServiceListRequest) Header(key, value string) *storageDomainVmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainVmsServiceListRequest) Query(key, value string) *storageDomainVmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainVmsServiceListRequest) Follow(follow string) *storageDomainVmsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainVmsServiceListRequest) Max(max int64) *storageDomainVmsServiceListRequest {
	p.max = &max
	return p
}

func (p *storageDomainVmsServiceListRequest) Unregistered(unregistered bool) *storageDomainVmsServiceListRequest {
	p.unregistered = &unregistered
	return p
}

func (p *storageDomainVmsServiceListRequest) Send() (*storageDomainVmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmsService.connection.URL(), p.storageDomainVmsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &storageDomainVmsServiceListResponse{vm: result}, nil
}

func (p *storageDomainVmsServiceListRequest) MustSend() *storageDomainVmsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmsService.connection.URL(), p.storageDomainVmsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &storageDomainVmsServiceListResponse{vm: result}
}

//
// Returns the list of virtual machines of the export storage domain.
// The order of the returned list of virtual machines isn't guaranteed.
//
type storageDomainVmsServiceListResponse struct {
	vm *VmSlice
}

func (p *storageDomainVmsServiceListResponse) Vm() (*VmSlice, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *storageDomainVmsServiceListResponse) MustVm() *VmSlice {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Returns the list of virtual machines of the export storage domain.
// The order of the returned list of virtual machines isn't guaranteed.
//
func (p *storageDomainVmsService) List() *storageDomainVmsServiceListRequest {
	return &storageDomainVmsServiceListRequest{storageDomainVmsService: p}
}

//
//
func (op *storageDomainVmsService) VmService(id string) *storageDomainVmService {
	return NewStorageDomainVmService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainVmsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.VmService(path), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *storageDomainVmsService) String() string {
	return fmt.Sprintf("storageDomainVmsService:%s", op.path)
}

//
//
type instanceTypesService struct {
	baseService
}

func NewInstanceTypesService(connection *Connection, path string) *instanceTypesService {
	var result instanceTypesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new instance type.
// This requires only a name attribute and can include all hardware configurations of the
// virtual machine.
// [source]
// ----
// POST /ovirt-engine/api/instancetypes
// ----
// With a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
// </template>
// ----
// Creating an instance type with all hardware configurations with a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
//   <console>
//     <enabled>true</enabled>
//   </console>
//   <cpu>
//     <topology>
//       <cores>2</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
//   <custom_cpu_model>AMD Opteron_G2</custom_cpu_model>
//   <custom_emulated_machine>q35</custom_emulated_machine>
//   <display>
//     <monitors>1</monitors>
//     <single_qxl_pci>true</single_qxl_pci>
//     <smartcard_enabled>true</smartcard_enabled>
//     <type>spice</type>
//   </display>
//   <high_availability>
//     <enabled>true</enabled>
//     <priority>1</priority>
//   </high_availability>
//   <io>
//     <threads>2</threads>
//   </io>
//   <memory>4294967296</memory>
//   <memory_policy>
//     <ballooning>true</ballooning>
//     <guaranteed>268435456</guaranteed>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <compressed>inherit</compressed>
//     <policy id="00000000-0000-0000-0000-000000000000"/>
//   </migration>
//   <migration_downtime>2</migration_downtime>
//   <os>
//     <boot>
//       <devices>
//         <device>hd</device>
//       </devices>
//     </boot>
//   </os>
//   <rng_device>
//     <rate>
//       <bytes>200</bytes>
//       <period>2</period>
//     </rate>
//     <source>urandom</source>
//   </rng_device>
//   <soundcard_enabled>true</soundcard_enabled>
//   <usb>
//     <enabled>true</enabled>
//     <type>native</type>
//   </usb>
//   <virtio_scsi>
//     <enabled>true</enabled>
//   </virtio_scsi>
// </instance_type>
// ----
//
type instanceTypesServiceAddRequest struct {
	instanceTypesService *instanceTypesService
	header               map[string]string
	query                map[string]string
	instanceType         *InstanceType
}

func (p *instanceTypesServiceAddRequest) Header(key, value string) *instanceTypesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypesServiceAddRequest) Query(key, value string) *instanceTypesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypesServiceAddRequest) InstanceType(instanceType *InstanceType) *instanceTypesServiceAddRequest {
	p.instanceType = instanceType
	return p
}

func (p *instanceTypesServiceAddRequest) Send() (*instanceTypesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypesService.connection.URL(), p.instanceTypesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLInstanceTypeWriteOne(writer, p.instanceType, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLInstanceTypeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &instanceTypesServiceAddResponse{instanceType: result}, nil
}

func (p *instanceTypesServiceAddRequest) MustSend() *instanceTypesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypesService.connection.URL(), p.instanceTypesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLInstanceTypeWriteOne(writer, p.instanceType, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLInstanceTypeReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &instanceTypesServiceAddResponse{instanceType: result}
}

//
// Creates a new instance type.
// This requires only a name attribute and can include all hardware configurations of the
// virtual machine.
// [source]
// ----
// POST /ovirt-engine/api/instancetypes
// ----
// With a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
// </template>
// ----
// Creating an instance type with all hardware configurations with a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
//   <console>
//     <enabled>true</enabled>
//   </console>
//   <cpu>
//     <topology>
//       <cores>2</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
//   <custom_cpu_model>AMD Opteron_G2</custom_cpu_model>
//   <custom_emulated_machine>q35</custom_emulated_machine>
//   <display>
//     <monitors>1</monitors>
//     <single_qxl_pci>true</single_qxl_pci>
//     <smartcard_enabled>true</smartcard_enabled>
//     <type>spice</type>
//   </display>
//   <high_availability>
//     <enabled>true</enabled>
//     <priority>1</priority>
//   </high_availability>
//   <io>
//     <threads>2</threads>
//   </io>
//   <memory>4294967296</memory>
//   <memory_policy>
//     <ballooning>true</ballooning>
//     <guaranteed>268435456</guaranteed>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <compressed>inherit</compressed>
//     <policy id="00000000-0000-0000-0000-000000000000"/>
//   </migration>
//   <migration_downtime>2</migration_downtime>
//   <os>
//     <boot>
//       <devices>
//         <device>hd</device>
//       </devices>
//     </boot>
//   </os>
//   <rng_device>
//     <rate>
//       <bytes>200</bytes>
//       <period>2</period>
//     </rate>
//     <source>urandom</source>
//   </rng_device>
//   <soundcard_enabled>true</soundcard_enabled>
//   <usb>
//     <enabled>true</enabled>
//     <type>native</type>
//   </usb>
//   <virtio_scsi>
//     <enabled>true</enabled>
//   </virtio_scsi>
// </instance_type>
// ----
//
type instanceTypesServiceAddResponse struct {
	instanceType *InstanceType
}

func (p *instanceTypesServiceAddResponse) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

func (p *instanceTypesServiceAddResponse) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("instanceType in response does not exist")
	}
	return p.instanceType
}

//
// Creates a new instance type.
// This requires only a name attribute and can include all hardware configurations of the
// virtual machine.
// [source]
// ----
// POST /ovirt-engine/api/instancetypes
// ----
// With a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
// </template>
// ----
// Creating an instance type with all hardware configurations with a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
//   <console>
//     <enabled>true</enabled>
//   </console>
//   <cpu>
//     <topology>
//       <cores>2</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
//   <custom_cpu_model>AMD Opteron_G2</custom_cpu_model>
//   <custom_emulated_machine>q35</custom_emulated_machine>
//   <display>
//     <monitors>1</monitors>
//     <single_qxl_pci>true</single_qxl_pci>
//     <smartcard_enabled>true</smartcard_enabled>
//     <type>spice</type>
//   </display>
//   <high_availability>
//     <enabled>true</enabled>
//     <priority>1</priority>
//   </high_availability>
//   <io>
//     <threads>2</threads>
//   </io>
//   <memory>4294967296</memory>
//   <memory_policy>
//     <ballooning>true</ballooning>
//     <guaranteed>268435456</guaranteed>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <compressed>inherit</compressed>
//     <policy id="00000000-0000-0000-0000-000000000000"/>
//   </migration>
//   <migration_downtime>2</migration_downtime>
//   <os>
//     <boot>
//       <devices>
//         <device>hd</device>
//       </devices>
//     </boot>
//   </os>
//   <rng_device>
//     <rate>
//       <bytes>200</bytes>
//       <period>2</period>
//     </rate>
//     <source>urandom</source>
//   </rng_device>
//   <soundcard_enabled>true</soundcard_enabled>
//   <usb>
//     <enabled>true</enabled>
//     <type>native</type>
//   </usb>
//   <virtio_scsi>
//     <enabled>true</enabled>
//   </virtio_scsi>
// </instance_type>
// ----
//
func (p *instanceTypesService) Add() *instanceTypesServiceAddRequest {
	return &instanceTypesServiceAddRequest{instanceTypesService: p}
}

//
// Lists all existing instance types in the system.
// The order of the returned list of instance types isn't guaranteed.
//
type instanceTypesServiceListRequest struct {
	instanceTypesService *instanceTypesService
	header               map[string]string
	query                map[string]string
	caseSensitive        *bool
	follow               *string
	max                  *int64
	search               *string
}

func (p *instanceTypesServiceListRequest) Header(key, value string) *instanceTypesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypesServiceListRequest) Query(key, value string) *instanceTypesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypesServiceListRequest) CaseSensitive(caseSensitive bool) *instanceTypesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *instanceTypesServiceListRequest) Follow(follow string) *instanceTypesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *instanceTypesServiceListRequest) Max(max int64) *instanceTypesServiceListRequest {
	p.max = &max
	return p
}

func (p *instanceTypesServiceListRequest) Search(search string) *instanceTypesServiceListRequest {
	p.search = &search
	return p
}

func (p *instanceTypesServiceListRequest) Send() (*instanceTypesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypesService.connection.URL(), p.instanceTypesService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLInstanceTypeReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &instanceTypesServiceListResponse{instanceType: result}, nil
}

func (p *instanceTypesServiceListRequest) MustSend() *instanceTypesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypesService.connection.URL(), p.instanceTypesService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLInstanceTypeReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &instanceTypesServiceListResponse{instanceType: result}
}

//
// Lists all existing instance types in the system.
// The order of the returned list of instance types isn't guaranteed.
//
type instanceTypesServiceListResponse struct {
	instanceType *InstanceTypeSlice
}

func (p *instanceTypesServiceListResponse) InstanceType() (*InstanceTypeSlice, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

func (p *instanceTypesServiceListResponse) MustInstanceType() *InstanceTypeSlice {
	if p.instanceType == nil {
		panic("instanceType in response does not exist")
	}
	return p.instanceType
}

//
// Lists all existing instance types in the system.
// The order of the returned list of instance types isn't guaranteed.
//
func (p *instanceTypesService) List() *instanceTypesServiceListRequest {
	return &instanceTypesServiceListRequest{instanceTypesService: p}
}

//
//
func (op *instanceTypesService) InstanceTypeService(id string) *instanceTypeService {
	return NewInstanceTypeService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *instanceTypesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.InstanceTypeService(path), nil
	}
	return op.InstanceTypeService(path[:index]).Service(path[index+1:])
}

func (op *instanceTypesService) String() string {
	return fmt.Sprintf("instanceTypesService:%s", op.path)
}

//
// A service to list all domain users in the system.
//
type domainUsersService struct {
	baseService
}

func NewDomainUsersService(connection *Connection, path string) *domainUsersService {
	var result domainUsersService
	result.connection = connection
	result.path = path
	return &result
}

//
// List all the users in the domain.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users
// ....
// Will return the list of users in the domain:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/domains/5678/users/1234" id="1234">
//     <name>admin</name>
//     <namespace>*</namespace>
//     <principal>admin</principal>
//     <user_name>admin@internal-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/5678" id="5678">
//       <name>internal-authz</name>
//     </domain>
//     <groups/>
//   </user>
// </users>
// ----
// The order of the returned list of users isn't guaranteed.
//
type domainUsersServiceListRequest struct {
	domainUsersService *domainUsersService
	header             map[string]string
	query              map[string]string
	caseSensitive      *bool
	follow             *string
	max                *int64
	search             *string
}

func (p *domainUsersServiceListRequest) Header(key, value string) *domainUsersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *domainUsersServiceListRequest) Query(key, value string) *domainUsersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *domainUsersServiceListRequest) CaseSensitive(caseSensitive bool) *domainUsersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *domainUsersServiceListRequest) Follow(follow string) *domainUsersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *domainUsersServiceListRequest) Max(max int64) *domainUsersServiceListRequest {
	p.max = &max
	return p
}

func (p *domainUsersServiceListRequest) Search(search string) *domainUsersServiceListRequest {
	p.search = &search
	return p
}

func (p *domainUsersServiceListRequest) Send() (*domainUsersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainUsersService.connection.URL(), p.domainUsersService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.domainUsersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.domainUsersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &domainUsersServiceListResponse{users: result}, nil
}

func (p *domainUsersServiceListRequest) MustSend() *domainUsersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.domainUsersService.connection.URL(), p.domainUsersService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.domainUsersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.domainUsersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &domainUsersServiceListResponse{users: result}
}

//
// List all the users in the domain.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users
// ....
// Will return the list of users in the domain:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/domains/5678/users/1234" id="1234">
//     <name>admin</name>
//     <namespace>*</namespace>
//     <principal>admin</principal>
//     <user_name>admin@internal-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/5678" id="5678">
//       <name>internal-authz</name>
//     </domain>
//     <groups/>
//   </user>
// </users>
// ----
// The order of the returned list of users isn't guaranteed.
//
type domainUsersServiceListResponse struct {
	users *UserSlice
}

func (p *domainUsersServiceListResponse) Users() (*UserSlice, bool) {
	if p.users != nil {
		return p.users, true
	}
	return nil, false
}

func (p *domainUsersServiceListResponse) MustUsers() *UserSlice {
	if p.users == nil {
		panic("users in response does not exist")
	}
	return p.users
}

//
// List all the users in the domain.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users
// ....
// Will return the list of users in the domain:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/domains/5678/users/1234" id="1234">
//     <name>admin</name>
//     <namespace>*</namespace>
//     <principal>admin</principal>
//     <user_name>admin@internal-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/5678" id="5678">
//       <name>internal-authz</name>
//     </domain>
//     <groups/>
//   </user>
// </users>
// ----
// The order of the returned list of users isn't guaranteed.
//
func (p *domainUsersService) List() *domainUsersServiceListRequest {
	return &domainUsersServiceListRequest{domainUsersService: p}
}

//
// Reference to a service to view details of a domain user.
//
func (op *domainUsersService) UserService(id string) *domainUserService {
	return NewDomainUserService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *domainUsersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.UserService(path), nil
	}
	return op.UserService(path[:index]).Service(path[index+1:])
}

func (op *domainUsersService) String() string {
	return fmt.Sprintf("domainUsersService:%s", op.path)
}

//
//
type domainGroupService struct {
	baseService
}

func NewDomainGroupService(connection *Connection, path string) *domainGroupService {
	var result domainGroupService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type domainGroupServiceGetRequest struct {
	domainGroupService *domainGroupService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *domainGroupServiceGetRequest) Header(key, value string) *domainGroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *domainGroupServiceGetRequest) Query(key, value string) *domainGroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *domainGroupServiceGetRequest) Follow(follow string) *domainGroupServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *domainGroupServiceGetRequest) Send() (*domainGroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainGroupService.connection.URL(), p.domainGroupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.domainGroupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.domainGroupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &domainGroupServiceGetResponse{get: result}, nil
}

func (p *domainGroupServiceGetRequest) MustSend() *domainGroupServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.domainGroupService.connection.URL(), p.domainGroupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.domainGroupService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.domainGroupService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &domainGroupServiceGetResponse{get: result}
}

//
//
type domainGroupServiceGetResponse struct {
	get *Group
}

func (p *domainGroupServiceGetResponse) Get() (*Group, bool) {
	if p.get != nil {
		return p.get, true
	}
	return nil, false
}

func (p *domainGroupServiceGetResponse) MustGet() *Group {
	if p.get == nil {
		panic("get in response does not exist")
	}
	return p.get
}

//
//
func (p *domainGroupService) Get() *domainGroupServiceGetRequest {
	return &domainGroupServiceGetRequest{domainGroupService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *domainGroupService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *domainGroupService) String() string {
	return fmt.Sprintf("domainGroupService:%s", op.path)
}

//
//
type domainGroupsService struct {
	baseService
}

func NewDomainGroupsService(connection *Connection, path string) *domainGroupsService {
	var result domainGroupsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of groups.
// The order of the returned list of groups isn't guaranteed.
//
type domainGroupsServiceListRequest struct {
	domainGroupsService *domainGroupsService
	header              map[string]string
	query               map[string]string
	caseSensitive       *bool
	follow              *string
	max                 *int64
	search              *string
}

func (p *domainGroupsServiceListRequest) Header(key, value string) *domainGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *domainGroupsServiceListRequest) Query(key, value string) *domainGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *domainGroupsServiceListRequest) CaseSensitive(caseSensitive bool) *domainGroupsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *domainGroupsServiceListRequest) Follow(follow string) *domainGroupsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *domainGroupsServiceListRequest) Max(max int64) *domainGroupsServiceListRequest {
	p.max = &max
	return p
}

func (p *domainGroupsServiceListRequest) Search(search string) *domainGroupsServiceListRequest {
	p.search = &search
	return p
}

func (p *domainGroupsServiceListRequest) Send() (*domainGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainGroupsService.connection.URL(), p.domainGroupsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.domainGroupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.domainGroupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &domainGroupsServiceListResponse{groups: result}, nil
}

func (p *domainGroupsServiceListRequest) MustSend() *domainGroupsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.domainGroupsService.connection.URL(), p.domainGroupsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.domainGroupsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.domainGroupsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &domainGroupsServiceListResponse{groups: result}
}

//
// Returns the list of groups.
// The order of the returned list of groups isn't guaranteed.
//
type domainGroupsServiceListResponse struct {
	groups *GroupSlice
}

func (p *domainGroupsServiceListResponse) Groups() (*GroupSlice, bool) {
	if p.groups != nil {
		return p.groups, true
	}
	return nil, false
}

func (p *domainGroupsServiceListResponse) MustGroups() *GroupSlice {
	if p.groups == nil {
		panic("groups in response does not exist")
	}
	return p.groups
}

//
// Returns the list of groups.
// The order of the returned list of groups isn't guaranteed.
//
func (p *domainGroupsService) List() *domainGroupsServiceListRequest {
	return &domainGroupsServiceListRequest{domainGroupsService: p}
}

//
//
func (op *domainGroupsService) GroupService(id string) *domainGroupService {
	return NewDomainGroupService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *domainGroupsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.GroupService(path), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *domainGroupsService) String() string {
	return fmt.Sprintf("domainGroupsService:%s", op.path)
}

//
// Manages a group of users. Use this service to either get groups details or remove groups. In order
// to add new groups please use <<services/groups, service>> that manages the collection of groups.
//
type groupService struct {
	baseService
}

func NewGroupService(connection *Connection, path string) *groupService {
	var result groupService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the system group information.
// Usage:
// ....
// GET /ovirt-engine/api/groups/123
// ....
// Will return the group information:
// [source,xml]
// ----
// <group href="/ovirt-engine/api/groups/123" id="123">
//   <name>mygroup</name>
//   <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
//   <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
//   <namespace>DC=example,DC=com</namespace>
//   <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
//     <name>myextension-authz</name>
//   </domain>
// </group>
// ----
//
type groupServiceGetRequest struct {
	groupService *groupService
	header       map[string]string
	query        map[string]string
	follow       *string
}

func (p *groupServiceGetRequest) Header(key, value string) *groupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *groupServiceGetRequest) Query(key, value string) *groupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *groupServiceGetRequest) Follow(follow string) *groupServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *groupServiceGetRequest) Send() (*groupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.groupService.connection.URL(), p.groupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.groupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.groupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &groupServiceGetResponse{get: result}, nil
}

func (p *groupServiceGetRequest) MustSend() *groupServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.groupService.connection.URL(), p.groupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.groupService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.groupService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &groupServiceGetResponse{get: result}
}

//
// Gets the system group information.
// Usage:
// ....
// GET /ovirt-engine/api/groups/123
// ....
// Will return the group information:
// [source,xml]
// ----
// <group href="/ovirt-engine/api/groups/123" id="123">
//   <name>mygroup</name>
//   <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
//   <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
//   <namespace>DC=example,DC=com</namespace>
//   <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
//     <name>myextension-authz</name>
//   </domain>
// </group>
// ----
//
type groupServiceGetResponse struct {
	get *Group
}

func (p *groupServiceGetResponse) Get() (*Group, bool) {
	if p.get != nil {
		return p.get, true
	}
	return nil, false
}

func (p *groupServiceGetResponse) MustGet() *Group {
	if p.get == nil {
		panic("get in response does not exist")
	}
	return p.get
}

//
// Gets the system group information.
// Usage:
// ....
// GET /ovirt-engine/api/groups/123
// ....
// Will return the group information:
// [source,xml]
// ----
// <group href="/ovirt-engine/api/groups/123" id="123">
//   <name>mygroup</name>
//   <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
//   <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
//   <namespace>DC=example,DC=com</namespace>
//   <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
//     <name>myextension-authz</name>
//   </domain>
// </group>
// ----
//
func (p *groupService) Get() *groupServiceGetRequest {
	return &groupServiceGetRequest{groupService: p}
}

//
// Removes the system group.
// Usage:
// ....
// DELETE /ovirt-engine/api/groups/123
// ....
//
type groupServiceRemoveRequest struct {
	groupService *groupService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *groupServiceRemoveRequest) Header(key, value string) *groupServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *groupServiceRemoveRequest) Query(key, value string) *groupServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *groupServiceRemoveRequest) Async(async bool) *groupServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *groupServiceRemoveRequest) Send() (*groupServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.groupService.connection.URL(), p.groupService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.groupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.groupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(groupServiceRemoveResponse), nil
}

func (p *groupServiceRemoveRequest) MustSend() *groupServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.groupService.connection.URL(), p.groupService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.groupService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.groupService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(groupServiceRemoveResponse)
}

//
// Removes the system group.
// Usage:
// ....
// DELETE /ovirt-engine/api/groups/123
// ....
//
type groupServiceRemoveResponse struct {
}

//
// Removes the system group.
// Usage:
// ....
// DELETE /ovirt-engine/api/groups/123
// ....
//
func (p *groupService) Remove() *groupServiceRemoveRequest {
	return &groupServiceRemoveRequest{groupService: p}
}

//
// Reference to the service that manages the collection of permissions assigned to this system group.
//
func (op *groupService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Reference to the service that manages the collection of roles assigned to this system group.
//
func (op *groupService) RolesService() *assignedRolesService {
	return NewAssignedRolesService(op.connection, fmt.Sprintf("%s/roles", op.path))
}

//
// Reference to the service that manages the collection of tags assigned to this system group.
//
func (op *groupService) TagsService() *assignedTagsService {
	return NewAssignedTagsService(op.connection, fmt.Sprintf("%s/tags", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *groupService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "roles" {
		return op.RolesService(), nil
	}
	if strings.HasPrefix(path, "roles/") {
		return op.RolesService().Service(path[6:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *groupService) String() string {
	return fmt.Sprintf("groupService:%s", op.path)
}

//
//
type sshPublicKeysService struct {
	baseService
}

func NewSshPublicKeysService(connection *Connection, path string) *sshPublicKeysService {
	var result sshPublicKeysService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type sshPublicKeysServiceAddRequest struct {
	sshPublicKeysService *sshPublicKeysService
	header               map[string]string
	query                map[string]string
	key                  *SshPublicKey
}

func (p *sshPublicKeysServiceAddRequest) Header(key, value string) *sshPublicKeysServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *sshPublicKeysServiceAddRequest) Query(key, value string) *sshPublicKeysServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *sshPublicKeysServiceAddRequest) Key(key *SshPublicKey) *sshPublicKeysServiceAddRequest {
	p.key = key
	return p
}

func (p *sshPublicKeysServiceAddRequest) Send() (*sshPublicKeysServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeysService.connection.URL(), p.sshPublicKeysService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSshPublicKeyWriteOne(writer, p.key, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.sshPublicKeysService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.sshPublicKeysService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSshPublicKeyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &sshPublicKeysServiceAddResponse{key: result}, nil
}

func (p *sshPublicKeysServiceAddRequest) MustSend() *sshPublicKeysServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeysService.connection.URL(), p.sshPublicKeysService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSshPublicKeyWriteOne(writer, p.key, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.sshPublicKeysService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.sshPublicKeysService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSshPublicKeyReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &sshPublicKeysServiceAddResponse{key: result}
}

//
//
type sshPublicKeysServiceAddResponse struct {
	key *SshPublicKey
}

func (p *sshPublicKeysServiceAddResponse) Key() (*SshPublicKey, bool) {
	if p.key != nil {
		return p.key, true
	}
	return nil, false
}

func (p *sshPublicKeysServiceAddResponse) MustKey() *SshPublicKey {
	if p.key == nil {
		panic("key in response does not exist")
	}
	return p.key
}

//
//
func (p *sshPublicKeysService) Add() *sshPublicKeysServiceAddRequest {
	return &sshPublicKeysServiceAddRequest{sshPublicKeysService: p}
}

//
// Returns a list of SSH public keys of the user.
// For example, to retrieve the list of SSH keys of user with identifier `123`,
// send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/users/123/sshpublickeys
// ----
// The result will be the following XML document:
// [source,xml]
// ----
// <ssh_public_keys>
//   <ssh_public_key href="/ovirt-engine/api/users/123/sshpublickeys/456" id="456">
//     <content>ssh-rsa ...</content>
//     <user href="/ovirt-engine/api/users/123" id="123"/>
//   </ssh_public_key>
// </ssh_public_keys>
// ----
// Or the following JSON object
// [source,json]
// ----
// {
//   "ssh_public_key": [
//     {
//       "content": "ssh-rsa ...",
//       "user": {
//         "href": "/ovirt-engine/api/users/123",
//         "id": "123"
//       },
//       "href": "/ovirt-engine/api/users/123/sshpublickeys/456",
//       "id": "456"
//     }
//   ]
// }
// ----
// The order of the returned list of keys is not guaranteed.
//
type sshPublicKeysServiceListRequest struct {
	sshPublicKeysService *sshPublicKeysService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *sshPublicKeysServiceListRequest) Header(key, value string) *sshPublicKeysServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *sshPublicKeysServiceListRequest) Query(key, value string) *sshPublicKeysServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *sshPublicKeysServiceListRequest) Follow(follow string) *sshPublicKeysServiceListRequest {
	p.follow = &follow
	return p
}

func (p *sshPublicKeysServiceListRequest) Max(max int64) *sshPublicKeysServiceListRequest {
	p.max = &max
	return p
}

func (p *sshPublicKeysServiceListRequest) Send() (*sshPublicKeysServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeysService.connection.URL(), p.sshPublicKeysService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.sshPublicKeysService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.sshPublicKeysService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSshPublicKeyReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &sshPublicKeysServiceListResponse{keys: result}, nil
}

func (p *sshPublicKeysServiceListRequest) MustSend() *sshPublicKeysServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeysService.connection.URL(), p.sshPublicKeysService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.sshPublicKeysService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.sshPublicKeysService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSshPublicKeyReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &sshPublicKeysServiceListResponse{keys: result}
}

//
// Returns a list of SSH public keys of the user.
// For example, to retrieve the list of SSH keys of user with identifier `123`,
// send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/users/123/sshpublickeys
// ----
// The result will be the following XML document:
// [source,xml]
// ----
// <ssh_public_keys>
//   <ssh_public_key href="/ovirt-engine/api/users/123/sshpublickeys/456" id="456">
//     <content>ssh-rsa ...</content>
//     <user href="/ovirt-engine/api/users/123" id="123"/>
//   </ssh_public_key>
// </ssh_public_keys>
// ----
// Or the following JSON object
// [source,json]
// ----
// {
//   "ssh_public_key": [
//     {
//       "content": "ssh-rsa ...",
//       "user": {
//         "href": "/ovirt-engine/api/users/123",
//         "id": "123"
//       },
//       "href": "/ovirt-engine/api/users/123/sshpublickeys/456",
//       "id": "456"
//     }
//   ]
// }
// ----
// The order of the returned list of keys is not guaranteed.
//
type sshPublicKeysServiceListResponse struct {
	keys *SshPublicKeySlice
}

func (p *sshPublicKeysServiceListResponse) Keys() (*SshPublicKeySlice, bool) {
	if p.keys != nil {
		return p.keys, true
	}
	return nil, false
}

func (p *sshPublicKeysServiceListResponse) MustKeys() *SshPublicKeySlice {
	if p.keys == nil {
		panic("keys in response does not exist")
	}
	return p.keys
}

//
// Returns a list of SSH public keys of the user.
// For example, to retrieve the list of SSH keys of user with identifier `123`,
// send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/users/123/sshpublickeys
// ----
// The result will be the following XML document:
// [source,xml]
// ----
// <ssh_public_keys>
//   <ssh_public_key href="/ovirt-engine/api/users/123/sshpublickeys/456" id="456">
//     <content>ssh-rsa ...</content>
//     <user href="/ovirt-engine/api/users/123" id="123"/>
//   </ssh_public_key>
// </ssh_public_keys>
// ----
// Or the following JSON object
// [source,json]
// ----
// {
//   "ssh_public_key": [
//     {
//       "content": "ssh-rsa ...",
//       "user": {
//         "href": "/ovirt-engine/api/users/123",
//         "id": "123"
//       },
//       "href": "/ovirt-engine/api/users/123/sshpublickeys/456",
//       "id": "456"
//     }
//   ]
// }
// ----
// The order of the returned list of keys is not guaranteed.
//
func (p *sshPublicKeysService) List() *sshPublicKeysServiceListRequest {
	return &sshPublicKeysServiceListRequest{sshPublicKeysService: p}
}

//
//
func (op *sshPublicKeysService) KeyService(id string) *sshPublicKeyService {
	return NewSshPublicKeyService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *sshPublicKeysService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.KeyService(path), nil
	}
	return op.KeyService(path[:index]).Service(path[index+1:])
}

func (op *sshPublicKeysService) String() string {
	return fmt.Sprintf("sshPublicKeysService:%s", op.path)
}

//
// A service to manage a user in the system.
// Use this service to either get users details or remove users.
// In order to add new users please use
// <<services/users>>.
//
type userService struct {
	baseService
}

func NewUserService(connection *Connection, path string) *userService {
	var result userService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the system user information.
// Usage:
// ....
// GET /ovirt-engine/api/users/1234
// ....
// Will return the user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//   <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//   <department></department>
//   <domain_entry_id>23456</domain_entry_id>
//   <email>user1@domain.com</email>
//   <last_name>Lastname</last_name>
//   <namespace>*</namespace>
//   <principal>user1</principal>
//   <user_name>user1@domain-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/45678" id="45678">
//     <name>domain-authz</name>
//   </domain>
// </user>
// ----
//
type userServiceGetRequest struct {
	userService *userService
	header      map[string]string
	query       map[string]string
	follow      *string
}

func (p *userServiceGetRequest) Header(key, value string) *userServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *userServiceGetRequest) Query(key, value string) *userServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *userServiceGetRequest) Follow(follow string) *userServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *userServiceGetRequest) Send() (*userServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.userService.connection.URL(), p.userService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.userService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.userService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &userServiceGetResponse{user: result}, nil
}

func (p *userServiceGetRequest) MustSend() *userServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.userService.connection.URL(), p.userService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.userService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.userService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &userServiceGetResponse{user: result}
}

//
// Gets the system user information.
// Usage:
// ....
// GET /ovirt-engine/api/users/1234
// ....
// Will return the user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//   <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//   <department></department>
//   <domain_entry_id>23456</domain_entry_id>
//   <email>user1@domain.com</email>
//   <last_name>Lastname</last_name>
//   <namespace>*</namespace>
//   <principal>user1</principal>
//   <user_name>user1@domain-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/45678" id="45678">
//     <name>domain-authz</name>
//   </domain>
// </user>
// ----
//
type userServiceGetResponse struct {
	user *User
}

func (p *userServiceGetResponse) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

func (p *userServiceGetResponse) MustUser() *User {
	if p.user == nil {
		panic("user in response does not exist")
	}
	return p.user
}

//
// Gets the system user information.
// Usage:
// ....
// GET /ovirt-engine/api/users/1234
// ....
// Will return the user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//   <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//   <department></department>
//   <domain_entry_id>23456</domain_entry_id>
//   <email>user1@domain.com</email>
//   <last_name>Lastname</last_name>
//   <namespace>*</namespace>
//   <principal>user1</principal>
//   <user_name>user1@domain-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/45678" id="45678">
//     <name>domain-authz</name>
//   </domain>
// </user>
// ----
//
func (p *userService) Get() *userServiceGetRequest {
	return &userServiceGetRequest{userService: p}
}

//
// Removes the system user.
// Usage:
// ....
// DELETE /ovirt-engine/api/users/1234
// ....
//
type userServiceRemoveRequest struct {
	userService *userService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *userServiceRemoveRequest) Header(key, value string) *userServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *userServiceRemoveRequest) Query(key, value string) *userServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *userServiceRemoveRequest) Async(async bool) *userServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *userServiceRemoveRequest) Send() (*userServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.userService.connection.URL(), p.userService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.userService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.userService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(userServiceRemoveResponse), nil
}

func (p *userServiceRemoveRequest) MustSend() *userServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.userService.connection.URL(), p.userService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.userService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.userService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(userServiceRemoveResponse)
}

//
// Removes the system user.
// Usage:
// ....
// DELETE /ovirt-engine/api/users/1234
// ....
//
type userServiceRemoveResponse struct {
}

//
// Removes the system user.
// Usage:
// ....
// DELETE /ovirt-engine/api/users/1234
// ....
//
func (p *userService) Remove() *userServiceRemoveRequest {
	return &userServiceRemoveRequest{userService: p}
}

//
//
func (op *userService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *userService) RolesService() *assignedRolesService {
	return NewAssignedRolesService(op.connection, fmt.Sprintf("%s/roles", op.path))
}

//
//
func (op *userService) SshPublicKeysService() *sshPublicKeysService {
	return NewSshPublicKeysService(op.connection, fmt.Sprintf("%s/sshpublickeys", op.path))
}

//
//
func (op *userService) TagsService() *assignedTagsService {
	return NewAssignedTagsService(op.connection, fmt.Sprintf("%s/tags", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *userService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "roles" {
		return op.RolesService(), nil
	}
	if strings.HasPrefix(path, "roles/") {
		return op.RolesService().Service(path[6:])
	}
	if path == "sshpublickeys" {
		return op.SshPublicKeysService(), nil
	}
	if strings.HasPrefix(path, "sshpublickeys/") {
		return op.SshPublicKeysService().Service(path[14:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *userService) String() string {
	return fmt.Sprintf("userService:%s", op.path)
}

//
// Manages the collection of groups of users.
//
type groupsService struct {
	baseService
}

func NewGroupsService(connection *Connection, path string) *groupsService {
	var result groupsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add group from a directory service. Please note that domain name is name of the authorization provider.
// For example, to add the `Developers` group from the `internal-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/groups
// ----
// With a request body like this:
// [source,xml]
// ----
// <group>
//   <name>Developers</name>
//   <domain>
//     <name>internal-authz</name>
//   </domain>
// </group>
// ----
//
type groupsServiceAddRequest struct {
	groupsService *groupsService
	header        map[string]string
	query         map[string]string
	group         *Group
}

func (p *groupsServiceAddRequest) Header(key, value string) *groupsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *groupsServiceAddRequest) Query(key, value string) *groupsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *groupsServiceAddRequest) Group(group *Group) *groupsServiceAddRequest {
	p.group = group
	return p
}

func (p *groupsServiceAddRequest) Send() (*groupsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.groupsService.connection.URL(), p.groupsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGroupWriteOne(writer, p.group, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.groupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.groupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &groupsServiceAddResponse{group: result}, nil
}

func (p *groupsServiceAddRequest) MustSend() *groupsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.groupsService.connection.URL(), p.groupsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGroupWriteOne(writer, p.group, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.groupsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.groupsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &groupsServiceAddResponse{group: result}
}

//
// Add group from a directory service. Please note that domain name is name of the authorization provider.
// For example, to add the `Developers` group from the `internal-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/groups
// ----
// With a request body like this:
// [source,xml]
// ----
// <group>
//   <name>Developers</name>
//   <domain>
//     <name>internal-authz</name>
//   </domain>
// </group>
// ----
//
type groupsServiceAddResponse struct {
	group *Group
}

func (p *groupsServiceAddResponse) Group() (*Group, bool) {
	if p.group != nil {
		return p.group, true
	}
	return nil, false
}

func (p *groupsServiceAddResponse) MustGroup() *Group {
	if p.group == nil {
		panic("group in response does not exist")
	}
	return p.group
}

//
// Add group from a directory service. Please note that domain name is name of the authorization provider.
// For example, to add the `Developers` group from the `internal-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/groups
// ----
// With a request body like this:
// [source,xml]
// ----
// <group>
//   <name>Developers</name>
//   <domain>
//     <name>internal-authz</name>
//   </domain>
// </group>
// ----
//
func (p *groupsService) Add() *groupsServiceAddRequest {
	return &groupsServiceAddRequest{groupsService: p}
}

//
// List all the groups in the system.
// Usage:
// ....
// GET /ovirt-engine/api/groups
// ....
// Will return the list of groups:
// [source,xml]
// ----
// <groups>
//   <group href="/ovirt-engine/api/groups/123" id="123">
//     <name>mygroup</name>
//     <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
//     <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
//     <namespace>DC=example,DC=com</namespace>
//     <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
//       <name>myextension-authz</name>
//     </domain>
//   </group>
//   ...
// </groups>
// ----
// The order of the returned list of groups isn't guaranteed.
//
type groupsServiceListRequest struct {
	groupsService *groupsService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	follow        *string
	max           *int64
	search        *string
}

func (p *groupsServiceListRequest) Header(key, value string) *groupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *groupsServiceListRequest) Query(key, value string) *groupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *groupsServiceListRequest) CaseSensitive(caseSensitive bool) *groupsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *groupsServiceListRequest) Follow(follow string) *groupsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *groupsServiceListRequest) Max(max int64) *groupsServiceListRequest {
	p.max = &max
	return p
}

func (p *groupsServiceListRequest) Search(search string) *groupsServiceListRequest {
	p.search = &search
	return p
}

func (p *groupsServiceListRequest) Send() (*groupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.groupsService.connection.URL(), p.groupsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.groupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.groupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &groupsServiceListResponse{groups: result}, nil
}

func (p *groupsServiceListRequest) MustSend() *groupsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.groupsService.connection.URL(), p.groupsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.groupsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.groupsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &groupsServiceListResponse{groups: result}
}

//
// List all the groups in the system.
// Usage:
// ....
// GET /ovirt-engine/api/groups
// ....
// Will return the list of groups:
// [source,xml]
// ----
// <groups>
//   <group href="/ovirt-engine/api/groups/123" id="123">
//     <name>mygroup</name>
//     <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
//     <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
//     <namespace>DC=example,DC=com</namespace>
//     <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
//       <name>myextension-authz</name>
//     </domain>
//   </group>
//   ...
// </groups>
// ----
// The order of the returned list of groups isn't guaranteed.
//
type groupsServiceListResponse struct {
	groups *GroupSlice
}

func (p *groupsServiceListResponse) Groups() (*GroupSlice, bool) {
	if p.groups != nil {
		return p.groups, true
	}
	return nil, false
}

func (p *groupsServiceListResponse) MustGroups() *GroupSlice {
	if p.groups == nil {
		panic("groups in response does not exist")
	}
	return p.groups
}

//
// List all the groups in the system.
// Usage:
// ....
// GET /ovirt-engine/api/groups
// ....
// Will return the list of groups:
// [source,xml]
// ----
// <groups>
//   <group href="/ovirt-engine/api/groups/123" id="123">
//     <name>mygroup</name>
//     <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
//     <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
//     <namespace>DC=example,DC=com</namespace>
//     <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
//       <name>myextension-authz</name>
//     </domain>
//   </group>
//   ...
// </groups>
// ----
// The order of the returned list of groups isn't guaranteed.
//
func (p *groupsService) List() *groupsServiceListRequest {
	return &groupsServiceListRequest{groupsService: p}
}

//
// Reference to the service that manages a specific group.
//
func (op *groupsService) GroupService(id string) *groupService {
	return NewGroupService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *groupsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.GroupService(path), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *groupsService) String() string {
	return fmt.Sprintf("groupsService:%s", op.path)
}

//
// A service to list all authentication domains in the system.
//
type domainsService struct {
	baseService
}

func NewDomainsService(connection *Connection, path string) *domainsService {
	var result domainsService
	result.connection = connection
	result.path = path
	return &result
}

//
// List all the authentication domains in the system.
// Usage:
// ....
// GET /ovirt-engine/api/domains
// ....
// Will return the list of domains:
// [source,xml]
// ----
// <domains>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//     <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//     <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//     <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//     <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
//   </domain>
// </domains>
// ----
// The order of the returned list of domains isn't guaranteed.
//
type domainsServiceListRequest struct {
	domainsService *domainsService
	header         map[string]string
	query          map[string]string
	follow         *string
	max            *int64
}

func (p *domainsServiceListRequest) Header(key, value string) *domainsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *domainsServiceListRequest) Query(key, value string) *domainsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *domainsServiceListRequest) Follow(follow string) *domainsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *domainsServiceListRequest) Max(max int64) *domainsServiceListRequest {
	p.max = &max
	return p
}

func (p *domainsServiceListRequest) Send() (*domainsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainsService.connection.URL(), p.domainsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.domainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.domainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDomainReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &domainsServiceListResponse{domains: result}, nil
}

func (p *domainsServiceListRequest) MustSend() *domainsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.domainsService.connection.URL(), p.domainsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.domainsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.domainsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDomainReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &domainsServiceListResponse{domains: result}
}

//
// List all the authentication domains in the system.
// Usage:
// ....
// GET /ovirt-engine/api/domains
// ....
// Will return the list of domains:
// [source,xml]
// ----
// <domains>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//     <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//     <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//     <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//     <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
//   </domain>
// </domains>
// ----
// The order of the returned list of domains isn't guaranteed.
//
type domainsServiceListResponse struct {
	domains *DomainSlice
}

func (p *domainsServiceListResponse) Domains() (*DomainSlice, bool) {
	if p.domains != nil {
		return p.domains, true
	}
	return nil, false
}

func (p *domainsServiceListResponse) MustDomains() *DomainSlice {
	if p.domains == nil {
		panic("domains in response does not exist")
	}
	return p.domains
}

//
// List all the authentication domains in the system.
// Usage:
// ....
// GET /ovirt-engine/api/domains
// ....
// Will return the list of domains:
// [source,xml]
// ----
// <domains>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//     <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//     <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//     <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//     <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
//   </domain>
// </domains>
// ----
// The order of the returned list of domains isn't guaranteed.
//
func (p *domainsService) List() *domainsServiceListRequest {
	return &domainsServiceListRequest{domainsService: p}
}

//
// Reference to a service to view details of a domain.
//
func (op *domainsService) DomainService(id string) *domainService {
	return NewDomainService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *domainsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DomainService(path), nil
	}
	return op.DomainService(path[:index]).Service(path[index+1:])
}

func (op *domainsService) String() string {
	return fmt.Sprintf("domainsService:%s", op.path)
}

//
//
type sshPublicKeyService struct {
	baseService
}

func NewSshPublicKeyService(connection *Connection, path string) *sshPublicKeyService {
	var result sshPublicKeyService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type sshPublicKeyServiceGetRequest struct {
	sshPublicKeyService *sshPublicKeyService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *sshPublicKeyServiceGetRequest) Header(key, value string) *sshPublicKeyServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *sshPublicKeyServiceGetRequest) Query(key, value string) *sshPublicKeyServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *sshPublicKeyServiceGetRequest) Follow(follow string) *sshPublicKeyServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *sshPublicKeyServiceGetRequest) Send() (*sshPublicKeyServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeyService.connection.URL(), p.sshPublicKeyService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.sshPublicKeyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.sshPublicKeyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSshPublicKeyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &sshPublicKeyServiceGetResponse{key: result}, nil
}

func (p *sshPublicKeyServiceGetRequest) MustSend() *sshPublicKeyServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeyService.connection.URL(), p.sshPublicKeyService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.sshPublicKeyService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.sshPublicKeyService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSshPublicKeyReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &sshPublicKeyServiceGetResponse{key: result}
}

//
//
type sshPublicKeyServiceGetResponse struct {
	key *SshPublicKey
}

func (p *sshPublicKeyServiceGetResponse) Key() (*SshPublicKey, bool) {
	if p.key != nil {
		return p.key, true
	}
	return nil, false
}

func (p *sshPublicKeyServiceGetResponse) MustKey() *SshPublicKey {
	if p.key == nil {
		panic("key in response does not exist")
	}
	return p.key
}

//
//
func (p *sshPublicKeyService) Get() *sshPublicKeyServiceGetRequest {
	return &sshPublicKeyServiceGetRequest{sshPublicKeyService: p}
}

//
//
type sshPublicKeyServiceRemoveRequest struct {
	sshPublicKeyService *sshPublicKeyService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *sshPublicKeyServiceRemoveRequest) Header(key, value string) *sshPublicKeyServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *sshPublicKeyServiceRemoveRequest) Query(key, value string) *sshPublicKeyServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *sshPublicKeyServiceRemoveRequest) Async(async bool) *sshPublicKeyServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *sshPublicKeyServiceRemoveRequest) Send() (*sshPublicKeyServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeyService.connection.URL(), p.sshPublicKeyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.sshPublicKeyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.sshPublicKeyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(sshPublicKeyServiceRemoveResponse), nil
}

func (p *sshPublicKeyServiceRemoveRequest) MustSend() *sshPublicKeyServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeyService.connection.URL(), p.sshPublicKeyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.sshPublicKeyService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.sshPublicKeyService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(sshPublicKeyServiceRemoveResponse)
}

//
//
type sshPublicKeyServiceRemoveResponse struct {
}

//
//
func (p *sshPublicKeyService) Remove() *sshPublicKeyServiceRemoveRequest {
	return &sshPublicKeyServiceRemoveRequest{sshPublicKeyService: p}
}

//
//
type sshPublicKeyServiceUpdateRequest struct {
	sshPublicKeyService *sshPublicKeyService
	header              map[string]string
	query               map[string]string
	async               *bool
	key                 *SshPublicKey
}

func (p *sshPublicKeyServiceUpdateRequest) Header(key, value string) *sshPublicKeyServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *sshPublicKeyServiceUpdateRequest) Query(key, value string) *sshPublicKeyServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *sshPublicKeyServiceUpdateRequest) Async(async bool) *sshPublicKeyServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *sshPublicKeyServiceUpdateRequest) Key(key *SshPublicKey) *sshPublicKeyServiceUpdateRequest {
	p.key = key
	return p
}

func (p *sshPublicKeyServiceUpdateRequest) Send() (*sshPublicKeyServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeyService.connection.URL(), p.sshPublicKeyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSshPublicKeyWriteOne(writer, p.key, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.sshPublicKeyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.sshPublicKeyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSshPublicKeyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &sshPublicKeyServiceUpdateResponse{key: result}, nil
}

func (p *sshPublicKeyServiceUpdateRequest) MustSend() *sshPublicKeyServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.sshPublicKeyService.connection.URL(), p.sshPublicKeyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSshPublicKeyWriteOne(writer, p.key, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.sshPublicKeyService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.sshPublicKeyService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSshPublicKeyReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &sshPublicKeyServiceUpdateResponse{key: result}
}

//
//
type sshPublicKeyServiceUpdateResponse struct {
	key *SshPublicKey
}

func (p *sshPublicKeyServiceUpdateResponse) Key() (*SshPublicKey, bool) {
	if p.key != nil {
		return p.key, true
	}
	return nil, false
}

func (p *sshPublicKeyServiceUpdateResponse) MustKey() *SshPublicKey {
	if p.key == nil {
		panic("key in response does not exist")
	}
	return p.key
}

//
//
func (p *sshPublicKeyService) Update() *sshPublicKeyServiceUpdateRequest {
	return &sshPublicKeyServiceUpdateRequest{sshPublicKeyService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *sshPublicKeyService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *sshPublicKeyService) String() string {
	return fmt.Sprintf("sshPublicKeyService:%s", op.path)
}

//
// A service to manage the users in the system.
//
type usersService struct {
	baseService
}

func NewUsersService(connection *Connection, path string) *usersService {
	var result usersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add user from a directory service.
// For example, to add the `myuser` user from the `myextension-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/users
// ----
// With a request body like this:
// [source,xml]
// ----
// <user>
//   <user_name>myuser@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
// In case you are working with Active Directory you have to pass user principal name (UPN) as `username`, followed
// by authorization provider name. Due to https://bugzilla.redhat.com/1147900[bug 1147900] you need to provide
// also `principal` parameter set to UPN of the user.
// For example, to add the user with UPN `myuser@mysubdomain.mydomain.com` from the `myextension-authz`
// authorization provider send a request body like this:
// [source,xml]
// ----
// <user>
//   <principal>myuser@mysubdomain.mydomain.com</principal>
//   <user_name>myuser@mysubdomain.mydomain.com@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
//
type usersServiceAddRequest struct {
	usersService *usersService
	header       map[string]string
	query        map[string]string
	user         *User
}

func (p *usersServiceAddRequest) Header(key, value string) *usersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *usersServiceAddRequest) Query(key, value string) *usersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *usersServiceAddRequest) User(user *User) *usersServiceAddRequest {
	p.user = user
	return p
}

func (p *usersServiceAddRequest) Send() (*usersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.usersService.connection.URL(), p.usersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLUserWriteOne(writer, p.user, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.usersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.usersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &usersServiceAddResponse{user: result}, nil
}

func (p *usersServiceAddRequest) MustSend() *usersServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.usersService.connection.URL(), p.usersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLUserWriteOne(writer, p.user, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.usersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.usersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &usersServiceAddResponse{user: result}
}

//
// Add user from a directory service.
// For example, to add the `myuser` user from the `myextension-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/users
// ----
// With a request body like this:
// [source,xml]
// ----
// <user>
//   <user_name>myuser@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
// In case you are working with Active Directory you have to pass user principal name (UPN) as `username`, followed
// by authorization provider name. Due to https://bugzilla.redhat.com/1147900[bug 1147900] you need to provide
// also `principal` parameter set to UPN of the user.
// For example, to add the user with UPN `myuser@mysubdomain.mydomain.com` from the `myextension-authz`
// authorization provider send a request body like this:
// [source,xml]
// ----
// <user>
//   <principal>myuser@mysubdomain.mydomain.com</principal>
//   <user_name>myuser@mysubdomain.mydomain.com@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
//
type usersServiceAddResponse struct {
	user *User
}

func (p *usersServiceAddResponse) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

func (p *usersServiceAddResponse) MustUser() *User {
	if p.user == nil {
		panic("user in response does not exist")
	}
	return p.user
}

//
// Add user from a directory service.
// For example, to add the `myuser` user from the `myextension-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/users
// ----
// With a request body like this:
// [source,xml]
// ----
// <user>
//   <user_name>myuser@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
// In case you are working with Active Directory you have to pass user principal name (UPN) as `username`, followed
// by authorization provider name. Due to https://bugzilla.redhat.com/1147900[bug 1147900] you need to provide
// also `principal` parameter set to UPN of the user.
// For example, to add the user with UPN `myuser@mysubdomain.mydomain.com` from the `myextension-authz`
// authorization provider send a request body like this:
// [source,xml]
// ----
// <user>
//   <principal>myuser@mysubdomain.mydomain.com</principal>
//   <user_name>myuser@mysubdomain.mydomain.com@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
//
func (p *usersService) Add() *usersServiceAddRequest {
	return &usersServiceAddRequest{usersService: p}
}

//
// List all the users in the system.
// Usage:
// ....
// GET /ovirt-engine/api/users
// ....
// Will return the list of users:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/users/1234" id="1234">
//     <name>admin</name>
//     <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//     <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//     <domain_entry_id>23456</domain_entry_id>
//     <namespace>*</namespace>
//     <principal>user1</principal>
//     <user_name>user1@domain-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/45678" id="45678">
//       <name>domain-authz</name>
//     </domain>
//   </user>
// </users>
// ----
// The order of the returned list of users isn't guaranteed.
//
type usersServiceListRequest struct {
	usersService  *usersService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	follow        *string
	max           *int64
	search        *string
}

func (p *usersServiceListRequest) Header(key, value string) *usersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *usersServiceListRequest) Query(key, value string) *usersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *usersServiceListRequest) CaseSensitive(caseSensitive bool) *usersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *usersServiceListRequest) Follow(follow string) *usersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *usersServiceListRequest) Max(max int64) *usersServiceListRequest {
	p.max = &max
	return p
}

func (p *usersServiceListRequest) Search(search string) *usersServiceListRequest {
	p.search = &search
	return p
}

func (p *usersServiceListRequest) Send() (*usersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.usersService.connection.URL(), p.usersService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.usersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.usersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &usersServiceListResponse{users: result}, nil
}

func (p *usersServiceListRequest) MustSend() *usersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.usersService.connection.URL(), p.usersService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.usersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.usersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &usersServiceListResponse{users: result}
}

//
// List all the users in the system.
// Usage:
// ....
// GET /ovirt-engine/api/users
// ....
// Will return the list of users:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/users/1234" id="1234">
//     <name>admin</name>
//     <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//     <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//     <domain_entry_id>23456</domain_entry_id>
//     <namespace>*</namespace>
//     <principal>user1</principal>
//     <user_name>user1@domain-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/45678" id="45678">
//       <name>domain-authz</name>
//     </domain>
//   </user>
// </users>
// ----
// The order of the returned list of users isn't guaranteed.
//
type usersServiceListResponse struct {
	users *UserSlice
}

func (p *usersServiceListResponse) Users() (*UserSlice, bool) {
	if p.users != nil {
		return p.users, true
	}
	return nil, false
}

func (p *usersServiceListResponse) MustUsers() *UserSlice {
	if p.users == nil {
		panic("users in response does not exist")
	}
	return p.users
}

//
// List all the users in the system.
// Usage:
// ....
// GET /ovirt-engine/api/users
// ....
// Will return the list of users:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/users/1234" id="1234">
//     <name>admin</name>
//     <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//     <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//     <domain_entry_id>23456</domain_entry_id>
//     <namespace>*</namespace>
//     <principal>user1</principal>
//     <user_name>user1@domain-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/45678" id="45678">
//       <name>domain-authz</name>
//     </domain>
//   </user>
// </users>
// ----
// The order of the returned list of users isn't guaranteed.
//
func (p *usersService) List() *usersServiceListRequest {
	return &usersServiceListRequest{usersService: p}
}

//
//
func (op *usersService) UserService(id string) *userService {
	return NewUserService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *usersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.UserService(path), nil
	}
	return op.UserService(path[:index]).Service(path[index+1:])
}

func (op *usersService) String() string {
	return fmt.Sprintf("usersService:%s", op.path)
}

//
// A service to view a domain user in the system.
//
type domainUserService struct {
	baseService
}

func NewDomainUserService(connection *Connection, path string) *domainUserService {
	var result domainUserService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the domain user information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users/1234
// ....
// Will return the domain user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <namespace>*</namespace>
//   <principal>admin</principal>
//   <user_name>admin@internal-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//   </domain>
//   <groups/>
// </user>
// ----
//
type domainUserServiceGetRequest struct {
	domainUserService *domainUserService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *domainUserServiceGetRequest) Header(key, value string) *domainUserServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *domainUserServiceGetRequest) Query(key, value string) *domainUserServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *domainUserServiceGetRequest) Follow(follow string) *domainUserServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *domainUserServiceGetRequest) Send() (*domainUserServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainUserService.connection.URL(), p.domainUserService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.domainUserService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.domainUserService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &domainUserServiceGetResponse{user: result}, nil
}

func (p *domainUserServiceGetRequest) MustSend() *domainUserServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.domainUserService.connection.URL(), p.domainUserService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.domainUserService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.domainUserService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &domainUserServiceGetResponse{user: result}
}

//
// Gets the domain user information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users/1234
// ....
// Will return the domain user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <namespace>*</namespace>
//   <principal>admin</principal>
//   <user_name>admin@internal-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//   </domain>
//   <groups/>
// </user>
// ----
//
type domainUserServiceGetResponse struct {
	user *User
}

func (p *domainUserServiceGetResponse) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

func (p *domainUserServiceGetResponse) MustUser() *User {
	if p.user == nil {
		panic("user in response does not exist")
	}
	return p.user
}

//
// Gets the domain user information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users/1234
// ....
// Will return the domain user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <namespace>*</namespace>
//   <principal>admin</principal>
//   <user_name>admin@internal-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//   </domain>
//   <groups/>
// </user>
// ----
//
func (p *domainUserService) Get() *domainUserServiceGetRequest {
	return &domainUserServiceGetRequest{domainUserService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *domainUserService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *domainUserService) String() string {
	return fmt.Sprintf("domainUserService:%s", op.path)
}

//
// A service to view details of an authentication domain in the system.
//
type domainService struct {
	baseService
}

func NewDomainService(connection *Connection, path string) *domainService {
	var result domainService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the authentication domain information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678
// ....
// Will return the domain information:
// [source,xml]
// ----
// <domain href="/ovirt-engine/api/domains/5678" id="5678">
//   <name>internal-authz</name>
//   <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//   <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//   <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//   <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
// </domain>
// ----
//
type domainServiceGetRequest struct {
	domainService *domainService
	header        map[string]string
	query         map[string]string
	follow        *string
}

func (p *domainServiceGetRequest) Header(key, value string) *domainServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *domainServiceGetRequest) Query(key, value string) *domainServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *domainServiceGetRequest) Follow(follow string) *domainServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *domainServiceGetRequest) Send() (*domainServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.domainService.connection.URL(), p.domainService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.domainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.domainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDomainReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &domainServiceGetResponse{domain: result}, nil
}

func (p *domainServiceGetRequest) MustSend() *domainServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.domainService.connection.URL(), p.domainService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.domainService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.domainService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDomainReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &domainServiceGetResponse{domain: result}
}

//
// Gets the authentication domain information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678
// ....
// Will return the domain information:
// [source,xml]
// ----
// <domain href="/ovirt-engine/api/domains/5678" id="5678">
//   <name>internal-authz</name>
//   <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//   <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//   <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//   <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
// </domain>
// ----
//
type domainServiceGetResponse struct {
	domain *Domain
}

func (p *domainServiceGetResponse) Domain() (*Domain, bool) {
	if p.domain != nil {
		return p.domain, true
	}
	return nil, false
}

func (p *domainServiceGetResponse) MustDomain() *Domain {
	if p.domain == nil {
		panic("domain in response does not exist")
	}
	return p.domain
}

//
// Gets the authentication domain information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678
// ....
// Will return the domain information:
// [source,xml]
// ----
// <domain href="/ovirt-engine/api/domains/5678" id="5678">
//   <name>internal-authz</name>
//   <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//   <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//   <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//   <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
// </domain>
// ----
//
func (p *domainService) Get() *domainServiceGetRequest {
	return &domainServiceGetRequest{domainService: p}
}

//
// Reference to a service to manage domain groups.
//
func (op *domainService) GroupsService() *domainGroupsService {
	return NewDomainGroupsService(op.connection, fmt.Sprintf("%s/groups", op.path))
}

//
// Reference to a service to manage domain users.
//
func (op *domainService) UsersService() *domainUsersService {
	return NewDomainUsersService(op.connection, fmt.Sprintf("%s/users", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *domainService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "groups" {
		return op.GroupsService(), nil
	}
	if strings.HasPrefix(path, "groups/") {
		return op.GroupsService().Service(path[7:])
	}
	if path == "users" {
		return op.UsersService(), nil
	}
	if strings.HasPrefix(path, "users/") {
		return op.UsersService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *domainService) String() string {
	return fmt.Sprintf("domainService:%s", op.path)
}

//
// The details of a single affinity label.
//
type affinityLabelService struct {
	baseService
}

func NewAffinityLabelService(connection *Connection, path string) *affinityLabelService {
	var result affinityLabelService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the details of a label.
//
type affinityLabelServiceGetRequest struct {
	affinityLabelService *affinityLabelService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *affinityLabelServiceGetRequest) Header(key, value string) *affinityLabelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelServiceGetRequest) Query(key, value string) *affinityLabelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelServiceGetRequest) Follow(follow string) *affinityLabelServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *affinityLabelServiceGetRequest) Send() (*affinityLabelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelService.connection.URL(), p.affinityLabelService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &affinityLabelServiceGetResponse{label: result}, nil
}

func (p *affinityLabelServiceGetRequest) MustSend() *affinityLabelServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelService.connection.URL(), p.affinityLabelService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &affinityLabelServiceGetResponse{label: result}
}

//
// Retrieves the details of a label.
//
type affinityLabelServiceGetResponse struct {
	label *AffinityLabel
}

func (p *affinityLabelServiceGetResponse) Label() (*AffinityLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *affinityLabelServiceGetResponse) MustLabel() *AffinityLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Retrieves the details of a label.
//
func (p *affinityLabelService) Get() *affinityLabelServiceGetRequest {
	return &affinityLabelServiceGetRequest{affinityLabelService: p}
}

//
// Removes a label from the system and clears all assignments
// of the removed label.
//
type affinityLabelServiceRemoveRequest struct {
	affinityLabelService *affinityLabelService
	header               map[string]string
	query                map[string]string
}

func (p *affinityLabelServiceRemoveRequest) Header(key, value string) *affinityLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelServiceRemoveRequest) Query(key, value string) *affinityLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelServiceRemoveRequest) Send() (*affinityLabelServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelService.connection.URL(), p.affinityLabelService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(affinityLabelServiceRemoveResponse), nil
}

func (p *affinityLabelServiceRemoveRequest) MustSend() *affinityLabelServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelService.connection.URL(), p.affinityLabelService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(affinityLabelServiceRemoveResponse)
}

//
// Removes a label from the system and clears all assignments
// of the removed label.
//
type affinityLabelServiceRemoveResponse struct {
}

//
// Removes a label from the system and clears all assignments
// of the removed label.
//
func (p *affinityLabelService) Remove() *affinityLabelServiceRemoveRequest {
	return &affinityLabelServiceRemoveRequest{affinityLabelService: p}
}

//
// Updates a label. This call will update all metadata, such as the name
// or description.
//
type affinityLabelServiceUpdateRequest struct {
	affinityLabelService *affinityLabelService
	header               map[string]string
	query                map[string]string
	label                *AffinityLabel
}

func (p *affinityLabelServiceUpdateRequest) Header(key, value string) *affinityLabelServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelServiceUpdateRequest) Query(key, value string) *affinityLabelServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelServiceUpdateRequest) Label(label *AffinityLabel) *affinityLabelServiceUpdateRequest {
	p.label = label
	return p
}

func (p *affinityLabelServiceUpdateRequest) Send() (*affinityLabelServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelService.connection.URL(), p.affinityLabelService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityLabelWriteOne(writer, p.label, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &affinityLabelServiceUpdateResponse{label: result}, nil
}

func (p *affinityLabelServiceUpdateRequest) MustSend() *affinityLabelServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelService.connection.URL(), p.affinityLabelService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityLabelWriteOne(writer, p.label, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &affinityLabelServiceUpdateResponse{label: result}
}

//
// Updates a label. This call will update all metadata, such as the name
// or description.
//
type affinityLabelServiceUpdateResponse struct {
	label *AffinityLabel
}

func (p *affinityLabelServiceUpdateResponse) Label() (*AffinityLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *affinityLabelServiceUpdateResponse) MustLabel() *AffinityLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Updates a label. This call will update all metadata, such as the name
// or description.
//
func (p *affinityLabelService) Update() *affinityLabelServiceUpdateRequest {
	return &affinityLabelServiceUpdateRequest{affinityLabelService: p}
}

//
// List all hosts with this label.
//
func (op *affinityLabelService) HostsService() *affinityLabelHostsService {
	return NewAffinityLabelHostsService(op.connection, fmt.Sprintf("%s/hosts", op.path))
}

//
// List all virtual machines with this label.
//
func (op *affinityLabelService) VmsService() *affinityLabelVmsService {
	return NewAffinityLabelVmsService(op.connection, fmt.Sprintf("%s/vms", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *affinityLabelService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *affinityLabelService) String() string {
	return fmt.Sprintf("affinityLabelService:%s", op.path)
}

//
// A service to manage a network interface of a host.
//
type hostNicService struct {
	baseService
}

func NewHostNicService(connection *Connection, path string) *hostNicService {
	var result hostNicService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type hostNicServiceGetRequest struct {
	hostNicService *hostNicService
	header         map[string]string
	query          map[string]string
	follow         *string
}

func (p *hostNicServiceGetRequest) Header(key, value string) *hostNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostNicServiceGetRequest) Query(key, value string) *hostNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostNicServiceGetRequest) Follow(follow string) *hostNicServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *hostNicServiceGetRequest) Send() (*hostNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostNicService.connection.URL(), p.hostNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &hostNicServiceGetResponse{nic: result}, nil
}

func (p *hostNicServiceGetRequest) MustSend() *hostNicServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostNicService.connection.URL(), p.hostNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostNicReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &hostNicServiceGetResponse{nic: result}
}

//
//
type hostNicServiceGetResponse struct {
	nic *HostNic
}

func (p *hostNicServiceGetResponse) Nic() (*HostNic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *hostNicServiceGetResponse) MustNic() *HostNic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
//
func (p *hostNicService) Get() *hostNicServiceGetRequest {
	return &hostNicServiceGetRequest{hostNicService: p}
}

//
// The action updates virtual function configuration in case the current resource represents an SR-IOV enabled NIC.
// The input should be consisted of at least one of the following properties:
// - `allNetworksAllowed`
// - `numberOfVirtualFunctions`
// Please see the `HostNicVirtualFunctionsConfiguration` type for the meaning of the properties.
//
type hostNicServiceUpdateVirtualFunctionsConfigurationRequest struct {
	hostNicService                *hostNicService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
	virtualFunctionsConfiguration *HostNicVirtualFunctionsConfiguration
}

func (p *hostNicServiceUpdateVirtualFunctionsConfigurationRequest) Header(key, value string) *hostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostNicServiceUpdateVirtualFunctionsConfigurationRequest) Query(key, value string) *hostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostNicServiceUpdateVirtualFunctionsConfigurationRequest) Async(async bool) *hostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	p.async = &async
	return p
}

func (p *hostNicServiceUpdateVirtualFunctionsConfigurationRequest) VirtualFunctionsConfiguration(virtualFunctionsConfiguration *HostNicVirtualFunctionsConfiguration) *hostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	p.virtualFunctionsConfiguration = virtualFunctionsConfiguration
	return p
}

func (p *hostNicServiceUpdateVirtualFunctionsConfigurationRequest) Send() (*hostNicServiceUpdateVirtualFunctionsConfigurationResponse, error) {
	rawURL := fmt.Sprintf("%s%s/updatevirtualfunctionsconfiguration", p.hostNicService.connection.URL(), p.hostNicService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.VirtualFunctionsConfiguration(p.virtualFunctionsConfiguration)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostNicServiceUpdateVirtualFunctionsConfigurationResponse), nil
}

func (p *hostNicServiceUpdateVirtualFunctionsConfigurationRequest) MustSend() *hostNicServiceUpdateVirtualFunctionsConfigurationResponse {
	rawURL := fmt.Sprintf("%s%s/updatevirtualfunctionsconfiguration", p.hostNicService.connection.URL(), p.hostNicService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.VirtualFunctionsConfiguration(p.virtualFunctionsConfiguration)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostNicServiceUpdateVirtualFunctionsConfigurationResponse)
}

//
// The action updates virtual function configuration in case the current resource represents an SR-IOV enabled NIC.
// The input should be consisted of at least one of the following properties:
// - `allNetworksAllowed`
// - `numberOfVirtualFunctions`
// Please see the `HostNicVirtualFunctionsConfiguration` type for the meaning of the properties.
//
type hostNicServiceUpdateVirtualFunctionsConfigurationResponse struct {
}

//
// The action updates virtual function configuration in case the current resource represents an SR-IOV enabled NIC.
// The input should be consisted of at least one of the following properties:
// - `allNetworksAllowed`
// - `numberOfVirtualFunctions`
// Please see the `HostNicVirtualFunctionsConfiguration` type for the meaning of the properties.
//
func (p *hostNicService) UpdateVirtualFunctionsConfiguration() *hostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	return &hostNicServiceUpdateVirtualFunctionsConfigurationRequest{hostNicService: p}
}

//
// A reference to information elements received by LLDP on the NIC.
//
func (op *hostNicService) LinkLayerDiscoveryProtocolElementsService() *linkLayerDiscoveryProtocolService {
	return NewLinkLayerDiscoveryProtocolService(op.connection, fmt.Sprintf("%s/linklayerdiscoveryprotocolelements", op.path))
}

//
// Reference to the service that manages the network attachments assigned to this network interface.
//
func (op *hostNicService) NetworkAttachmentsService() *networkAttachmentsService {
	return NewNetworkAttachmentsService(op.connection, fmt.Sprintf("%s/networkattachments", op.path))
}

//
// Reference to the service that manages the network labels assigned to this network interface.
//
func (op *hostNicService) NetworkLabelsService() *networkLabelsService {
	return NewNetworkLabelsService(op.connection, fmt.Sprintf("%s/networklabels", op.path))
}

//
//
func (op *hostNicService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Retrieves sub-collection resource of network labels that are allowed on an the virtual functions
// in case that the current resource represents an SR-IOV physical function NIC.
//
func (op *hostNicService) VirtualFunctionAllowedLabelsService() *networkLabelsService {
	return NewNetworkLabelsService(op.connection, fmt.Sprintf("%s/virtualfunctionallowedlabels", op.path))
}

//
// Retrieves sub-collection resource of networks that are allowed on an the virtual functions
// in case that the current resource represents an SR-IOV physical function NIC.
//
func (op *hostNicService) VirtualFunctionAllowedNetworksService() *virtualFunctionAllowedNetworksService {
	return NewVirtualFunctionAllowedNetworksService(op.connection, fmt.Sprintf("%s/virtualfunctionallowednetworks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *hostNicService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "linklayerdiscoveryprotocolelements" {
		return op.LinkLayerDiscoveryProtocolElementsService(), nil
	}
	if strings.HasPrefix(path, "linklayerdiscoveryprotocolelements/") {
		return op.LinkLayerDiscoveryProtocolElementsService().Service(path[35:])
	}
	if path == "networkattachments" {
		return op.NetworkAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "networkattachments/") {
		return op.NetworkAttachmentsService().Service(path[19:])
	}
	if path == "networklabels" {
		return op.NetworkLabelsService(), nil
	}
	if strings.HasPrefix(path, "networklabels/") {
		return op.NetworkLabelsService().Service(path[14:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	if path == "virtualfunctionallowedlabels" {
		return op.VirtualFunctionAllowedLabelsService(), nil
	}
	if strings.HasPrefix(path, "virtualfunctionallowedlabels/") {
		return op.VirtualFunctionAllowedLabelsService().Service(path[29:])
	}
	if path == "virtualfunctionallowednetworks" {
		return op.VirtualFunctionAllowedNetworksService(), nil
	}
	if strings.HasPrefix(path, "virtualfunctionallowednetworks/") {
		return op.VirtualFunctionAllowedNetworksService().Service(path[31:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *hostNicService) String() string {
	return fmt.Sprintf("hostNicService:%s", op.path)
}

//
// Manages a single disk available in a storage domain attached to a data center.
// IMPORTANT: Since version 4.2 of the engine this service is intended only to list disks available in the storage
// domain, and to register unregistered disks. All the other operations, like copying a disk, moving a disk, etc, have
// been deprecated and will be removed in the future. To perform those operations use the <<services/disks, service
// that manages all the disks of the system>>, or the <<services/disk, service that manages an specific disk>>.
//
type attachedStorageDomainDiskService struct {
	baseService
}

func NewAttachedStorageDomainDiskService(connection *Connection, path string) *attachedStorageDomainDiskService {
	var result attachedStorageDomainDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
//
type attachedStorageDomainDiskServiceCopyRequest struct {
	attachedStorageDomainDiskService *attachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	disk                             *Disk
	storageDomain                    *StorageDomain
}

func (p *attachedStorageDomainDiskServiceCopyRequest) Header(key, value string) *attachedStorageDomainDiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceCopyRequest) Query(key, value string) *attachedStorageDomainDiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceCopyRequest) Disk(disk *Disk) *attachedStorageDomainDiskServiceCopyRequest {
	p.disk = disk
	return p
}

func (p *attachedStorageDomainDiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *attachedStorageDomainDiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *attachedStorageDomainDiskServiceCopyRequest) Send() (*attachedStorageDomainDiskServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(attachedStorageDomainDiskServiceCopyResponse), nil
}

func (p *attachedStorageDomainDiskServiceCopyRequest) MustSend() *attachedStorageDomainDiskServiceCopyResponse {
	rawURL := fmt.Sprintf("%s%s/copy", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(attachedStorageDomainDiskServiceCopyResponse)
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
//
type attachedStorageDomainDiskServiceCopyResponse struct {
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
//
func (p *attachedStorageDomainDiskService) Copy() *attachedStorageDomainDiskServiceCopyRequest {
	return &attachedStorageDomainDiskServiceCopyRequest{attachedStorageDomainDiskService: p}
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
//
type attachedStorageDomainDiskServiceExportRequest struct {
	attachedStorageDomainDiskService *attachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	storageDomain                    *StorageDomain
}

func (p *attachedStorageDomainDiskServiceExportRequest) Header(key, value string) *attachedStorageDomainDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceExportRequest) Query(key, value string) *attachedStorageDomainDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *attachedStorageDomainDiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *attachedStorageDomainDiskServiceExportRequest) Send() (*attachedStorageDomainDiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(attachedStorageDomainDiskServiceExportResponse), nil
}

func (p *attachedStorageDomainDiskServiceExportRequest) MustSend() *attachedStorageDomainDiskServiceExportResponse {
	rawURL := fmt.Sprintf("%s%s/export", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(attachedStorageDomainDiskServiceExportResponse)
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
//
type attachedStorageDomainDiskServiceExportResponse struct {
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
//
func (p *attachedStorageDomainDiskService) Export() *attachedStorageDomainDiskServiceExportRequest {
	return &attachedStorageDomainDiskServiceExportRequest{attachedStorageDomainDiskService: p}
}

//
// Retrieves the description of the disk.
//
type attachedStorageDomainDiskServiceGetRequest struct {
	attachedStorageDomainDiskService *attachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	follow                           *string
}

func (p *attachedStorageDomainDiskServiceGetRequest) Header(key, value string) *attachedStorageDomainDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceGetRequest) Query(key, value string) *attachedStorageDomainDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceGetRequest) Follow(follow string) *attachedStorageDomainDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *attachedStorageDomainDiskServiceGetRequest) Send() (*attachedStorageDomainDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &attachedStorageDomainDiskServiceGetResponse{disk: result}, nil
}

func (p *attachedStorageDomainDiskServiceGetRequest) MustSend() *attachedStorageDomainDiskServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &attachedStorageDomainDiskServiceGetResponse{disk: result}
}

//
// Retrieves the description of the disk.
//
type attachedStorageDomainDiskServiceGetResponse struct {
	disk *Disk
}

func (p *attachedStorageDomainDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *attachedStorageDomainDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Retrieves the description of the disk.
//
func (p *attachedStorageDomainDiskService) Get() *attachedStorageDomainDiskServiceGetRequest {
	return &attachedStorageDomainDiskServiceGetRequest{attachedStorageDomainDiskService: p}
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
//
type attachedStorageDomainDiskServiceMoveRequest struct {
	attachedStorageDomainDiskService *attachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	async                            *bool
	filter                           *bool
	storageDomain                    *StorageDomain
}

func (p *attachedStorageDomainDiskServiceMoveRequest) Header(key, value string) *attachedStorageDomainDiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceMoveRequest) Query(key, value string) *attachedStorageDomainDiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceMoveRequest) Async(async bool) *attachedStorageDomainDiskServiceMoveRequest {
	p.async = &async
	return p
}

func (p *attachedStorageDomainDiskServiceMoveRequest) Filter(filter bool) *attachedStorageDomainDiskServiceMoveRequest {
	p.filter = &filter
	return p
}

func (p *attachedStorageDomainDiskServiceMoveRequest) StorageDomain(storageDomain *StorageDomain) *attachedStorageDomainDiskServiceMoveRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *attachedStorageDomainDiskServiceMoveRequest) Send() (*attachedStorageDomainDiskServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(attachedStorageDomainDiskServiceMoveResponse), nil
}

func (p *attachedStorageDomainDiskServiceMoveRequest) MustSend() *attachedStorageDomainDiskServiceMoveResponse {
	rawURL := fmt.Sprintf("%s%s/move", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(attachedStorageDomainDiskServiceMoveResponse)
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
//
type attachedStorageDomainDiskServiceMoveResponse struct {
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
//
func (p *attachedStorageDomainDiskService) Move() *attachedStorageDomainDiskServiceMoveRequest {
	return &attachedStorageDomainDiskServiceMoveRequest{attachedStorageDomainDiskService: p}
}

//
// Registers an unregistered disk.
//
type attachedStorageDomainDiskServiceRegisterRequest struct {
	attachedStorageDomainDiskService *attachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *attachedStorageDomainDiskServiceRegisterRequest) Header(key, value string) *attachedStorageDomainDiskServiceRegisterRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceRegisterRequest) Query(key, value string) *attachedStorageDomainDiskServiceRegisterRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceRegisterRequest) Send() (*attachedStorageDomainDiskServiceRegisterResponse, error) {
	rawURL := fmt.Sprintf("%s%s/register", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(attachedStorageDomainDiskServiceRegisterResponse), nil
}

func (p *attachedStorageDomainDiskServiceRegisterRequest) MustSend() *attachedStorageDomainDiskServiceRegisterResponse {
	rawURL := fmt.Sprintf("%s%s/register", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(attachedStorageDomainDiskServiceRegisterResponse)
}

//
// Registers an unregistered disk.
//
type attachedStorageDomainDiskServiceRegisterResponse struct {
}

//
// Registers an unregistered disk.
//
func (p *attachedStorageDomainDiskService) Register() *attachedStorageDomainDiskServiceRegisterRequest {
	return &attachedStorageDomainDiskServiceRegisterRequest{attachedStorageDomainDiskService: p}
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type attachedStorageDomainDiskServiceRemoveRequest struct {
	attachedStorageDomainDiskService *attachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *attachedStorageDomainDiskServiceRemoveRequest) Header(key, value string) *attachedStorageDomainDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceRemoveRequest) Query(key, value string) *attachedStorageDomainDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceRemoveRequest) Send() (*attachedStorageDomainDiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(attachedStorageDomainDiskServiceRemoveResponse), nil
}

func (p *attachedStorageDomainDiskServiceRemoveRequest) MustSend() *attachedStorageDomainDiskServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(attachedStorageDomainDiskServiceRemoveResponse)
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type attachedStorageDomainDiskServiceRemoveResponse struct {
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
func (p *attachedStorageDomainDiskService) Remove() *attachedStorageDomainDiskServiceRemoveRequest {
	return &attachedStorageDomainDiskServiceRemoveRequest{attachedStorageDomainDiskService: p}
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type attachedStorageDomainDiskServiceSparsifyRequest struct {
	attachedStorageDomainDiskService *attachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *attachedStorageDomainDiskServiceSparsifyRequest) Header(key, value string) *attachedStorageDomainDiskServiceSparsifyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceSparsifyRequest) Query(key, value string) *attachedStorageDomainDiskServiceSparsifyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceSparsifyRequest) Send() (*attachedStorageDomainDiskServiceSparsifyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/sparsify", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(attachedStorageDomainDiskServiceSparsifyResponse), nil
}

func (p *attachedStorageDomainDiskServiceSparsifyRequest) MustSend() *attachedStorageDomainDiskServiceSparsifyResponse {
	rawURL := fmt.Sprintf("%s%s/sparsify", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(attachedStorageDomainDiskServiceSparsifyResponse)
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type attachedStorageDomainDiskServiceSparsifyResponse struct {
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
func (p *attachedStorageDomainDiskService) Sparsify() *attachedStorageDomainDiskServiceSparsifyRequest {
	return &attachedStorageDomainDiskServiceSparsifyRequest{attachedStorageDomainDiskService: p}
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
//
type attachedStorageDomainDiskServiceUpdateRequest struct {
	attachedStorageDomainDiskService *attachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	disk                             *Disk
}

func (p *attachedStorageDomainDiskServiceUpdateRequest) Header(key, value string) *attachedStorageDomainDiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceUpdateRequest) Query(key, value string) *attachedStorageDomainDiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainDiskServiceUpdateRequest) Disk(disk *Disk) *attachedStorageDomainDiskServiceUpdateRequest {
	p.disk = disk
	return p
}

func (p *attachedStorageDomainDiskServiceUpdateRequest) Send() (*attachedStorageDomainDiskServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &attachedStorageDomainDiskServiceUpdateResponse{disk: result}, nil
}

func (p *attachedStorageDomainDiskServiceUpdateRequest) MustSend() *attachedStorageDomainDiskServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDiskService.connection.URL(), p.attachedStorageDomainDiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &attachedStorageDomainDiskServiceUpdateResponse{disk: result}
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
//
type attachedStorageDomainDiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *attachedStorageDomainDiskServiceUpdateResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *attachedStorageDomainDiskServiceUpdateResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
//
func (p *attachedStorageDomainDiskService) Update() *attachedStorageDomainDiskServiceUpdateRequest {
	return &attachedStorageDomainDiskServiceUpdateRequest{attachedStorageDomainDiskService: p}
}

//
// Reference to the service that manages the permissions assigned to the disk.
//
func (op *attachedStorageDomainDiskService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *attachedStorageDomainDiskService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *attachedStorageDomainDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *attachedStorageDomainDiskService) String() string {
	return fmt.Sprintf("attachedStorageDomainDiskService:%s", op.path)
}

//
//
type instanceTypeNicService struct {
	baseService
}

func NewInstanceTypeNicService(connection *Connection, path string) *instanceTypeNicService {
	var result instanceTypeNicService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets network interface configuration of the instance type.
//
type instanceTypeNicServiceGetRequest struct {
	instanceTypeNicService *instanceTypeNicService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *instanceTypeNicServiceGetRequest) Header(key, value string) *instanceTypeNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeNicServiceGetRequest) Query(key, value string) *instanceTypeNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeNicServiceGetRequest) Follow(follow string) *instanceTypeNicServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *instanceTypeNicServiceGetRequest) Send() (*instanceTypeNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicService.connection.URL(), p.instanceTypeNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &instanceTypeNicServiceGetResponse{nic: result}, nil
}

func (p *instanceTypeNicServiceGetRequest) MustSend() *instanceTypeNicServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicService.connection.URL(), p.instanceTypeNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &instanceTypeNicServiceGetResponse{nic: result}
}

//
// Gets network interface configuration of the instance type.
//
type instanceTypeNicServiceGetResponse struct {
	nic *Nic
}

func (p *instanceTypeNicServiceGetResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *instanceTypeNicServiceGetResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Gets network interface configuration of the instance type.
//
func (p *instanceTypeNicService) Get() *instanceTypeNicServiceGetRequest {
	return &instanceTypeNicServiceGetRequest{instanceTypeNicService: p}
}

//
// Remove the network interface from the instance type.
//
type instanceTypeNicServiceRemoveRequest struct {
	instanceTypeNicService *instanceTypeNicService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *instanceTypeNicServiceRemoveRequest) Header(key, value string) *instanceTypeNicServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeNicServiceRemoveRequest) Query(key, value string) *instanceTypeNicServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeNicServiceRemoveRequest) Async(async bool) *instanceTypeNicServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *instanceTypeNicServiceRemoveRequest) Send() (*instanceTypeNicServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicService.connection.URL(), p.instanceTypeNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(instanceTypeNicServiceRemoveResponse), nil
}

func (p *instanceTypeNicServiceRemoveRequest) MustSend() *instanceTypeNicServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicService.connection.URL(), p.instanceTypeNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(instanceTypeNicServiceRemoveResponse)
}

//
// Remove the network interface from the instance type.
//
type instanceTypeNicServiceRemoveResponse struct {
}

//
// Remove the network interface from the instance type.
//
func (p *instanceTypeNicService) Remove() *instanceTypeNicServiceRemoveRequest {
	return &instanceTypeNicServiceRemoveRequest{instanceTypeNicService: p}
}

//
// Updates the network interface configuration of the instance type.
//
type instanceTypeNicServiceUpdateRequest struct {
	instanceTypeNicService *instanceTypeNicService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
	nic                    *Nic
}

func (p *instanceTypeNicServiceUpdateRequest) Header(key, value string) *instanceTypeNicServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeNicServiceUpdateRequest) Query(key, value string) *instanceTypeNicServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeNicServiceUpdateRequest) Async(async bool) *instanceTypeNicServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *instanceTypeNicServiceUpdateRequest) Nic(nic *Nic) *instanceTypeNicServiceUpdateRequest {
	p.nic = nic
	return p
}

func (p *instanceTypeNicServiceUpdateRequest) Send() (*instanceTypeNicServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicService.connection.URL(), p.instanceTypeNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &instanceTypeNicServiceUpdateResponse{nic: result}, nil
}

func (p *instanceTypeNicServiceUpdateRequest) MustSend() *instanceTypeNicServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicService.connection.URL(), p.instanceTypeNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &instanceTypeNicServiceUpdateResponse{nic: result}
}

//
// Updates the network interface configuration of the instance type.
//
type instanceTypeNicServiceUpdateResponse struct {
	nic *Nic
}

func (p *instanceTypeNicServiceUpdateResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *instanceTypeNicServiceUpdateResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Updates the network interface configuration of the instance type.
//
func (p *instanceTypeNicService) Update() *instanceTypeNicServiceUpdateRequest {
	return &instanceTypeNicServiceUpdateRequest{instanceTypeNicService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *instanceTypeNicService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *instanceTypeNicService) String() string {
	return fmt.Sprintf("instanceTypeNicService:%s", op.path)
}

//
// Manages the affinity labels available in the system.
//
type affinityLabelsService struct {
	baseService
}

func NewAffinityLabelsService(connection *Connection, path string) *affinityLabelsService {
	var result affinityLabelsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new label. The label is automatically attached
// to all entities mentioned in the vms or hosts lists.
//
type affinityLabelsServiceAddRequest struct {
	affinityLabelsService *affinityLabelsService
	header                map[string]string
	query                 map[string]string
	label                 *AffinityLabel
}

func (p *affinityLabelsServiceAddRequest) Header(key, value string) *affinityLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelsServiceAddRequest) Query(key, value string) *affinityLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelsServiceAddRequest) Label(label *AffinityLabel) *affinityLabelsServiceAddRequest {
	p.label = label
	return p
}

func (p *affinityLabelsServiceAddRequest) Send() (*affinityLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelsService.connection.URL(), p.affinityLabelsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityLabelWriteOne(writer, p.label, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &affinityLabelsServiceAddResponse{label: result}, nil
}

func (p *affinityLabelsServiceAddRequest) MustSend() *affinityLabelsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelsService.connection.URL(), p.affinityLabelsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityLabelWriteOne(writer, p.label, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &affinityLabelsServiceAddResponse{label: result}
}

//
// Creates a new label. The label is automatically attached
// to all entities mentioned in the vms or hosts lists.
//
type affinityLabelsServiceAddResponse struct {
	label *AffinityLabel
}

func (p *affinityLabelsServiceAddResponse) Label() (*AffinityLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *affinityLabelsServiceAddResponse) MustLabel() *AffinityLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Creates a new label. The label is automatically attached
// to all entities mentioned in the vms or hosts lists.
//
func (p *affinityLabelsService) Add() *affinityLabelsServiceAddRequest {
	return &affinityLabelsServiceAddRequest{affinityLabelsService: p}
}

//
// Lists all labels present in the system.
// The order of the returned labels isn't guaranteed.
//
type affinityLabelsServiceListRequest struct {
	affinityLabelsService *affinityLabelsService
	header                map[string]string
	query                 map[string]string
	follow                *string
	max                   *int64
}

func (p *affinityLabelsServiceListRequest) Header(key, value string) *affinityLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelsServiceListRequest) Query(key, value string) *affinityLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelsServiceListRequest) Follow(follow string) *affinityLabelsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *affinityLabelsServiceListRequest) Max(max int64) *affinityLabelsServiceListRequest {
	p.max = &max
	return p
}

func (p *affinityLabelsServiceListRequest) Send() (*affinityLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelsService.connection.URL(), p.affinityLabelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &affinityLabelsServiceListResponse{labels: result}, nil
}

func (p *affinityLabelsServiceListRequest) MustSend() *affinityLabelsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelsService.connection.URL(), p.affinityLabelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &affinityLabelsServiceListResponse{labels: result}
}

//
// Lists all labels present in the system.
// The order of the returned labels isn't guaranteed.
//
type affinityLabelsServiceListResponse struct {
	labels *AffinityLabelSlice
}

func (p *affinityLabelsServiceListResponse) Labels() (*AffinityLabelSlice, bool) {
	if p.labels != nil {
		return p.labels, true
	}
	return nil, false
}

func (p *affinityLabelsServiceListResponse) MustLabels() *AffinityLabelSlice {
	if p.labels == nil {
		panic("labels in response does not exist")
	}
	return p.labels
}

//
// Lists all labels present in the system.
// The order of the returned labels isn't guaranteed.
//
func (p *affinityLabelsService) List() *affinityLabelsServiceListRequest {
	return &affinityLabelsServiceListRequest{affinityLabelsService: p}
}

//
// Link to a single label details.
//
func (op *affinityLabelsService) LabelService(id string) *affinityLabelService {
	return NewAffinityLabelService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *affinityLabelsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LabelService(path), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *affinityLabelsService) String() string {
	return fmt.Sprintf("affinityLabelsService:%s", op.path)
}

//
//
type templateWatchdogService struct {
	baseService
}

func NewTemplateWatchdogService(connection *Connection, path string) *templateWatchdogService {
	var result templateWatchdogService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type templateWatchdogServiceGetRequest struct {
	templateWatchdogService *templateWatchdogService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
}

func (p *templateWatchdogServiceGetRequest) Header(key, value string) *templateWatchdogServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateWatchdogServiceGetRequest) Query(key, value string) *templateWatchdogServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateWatchdogServiceGetRequest) Follow(follow string) *templateWatchdogServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *templateWatchdogServiceGetRequest) Send() (*templateWatchdogServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogService.connection.URL(), p.templateWatchdogService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateWatchdogServiceGetResponse{watchdog: result}, nil
}

func (p *templateWatchdogServiceGetRequest) MustSend() *templateWatchdogServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogService.connection.URL(), p.templateWatchdogService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateWatchdogService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateWatchdogService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateWatchdogServiceGetResponse{watchdog: result}
}

//
//
type templateWatchdogServiceGetResponse struct {
	watchdog *Watchdog
}

func (p *templateWatchdogServiceGetResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *templateWatchdogServiceGetResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
//
func (p *templateWatchdogService) Get() *templateWatchdogServiceGetRequest {
	return &templateWatchdogServiceGetRequest{templateWatchdogService: p}
}

//
//
type templateWatchdogServiceRemoveRequest struct {
	templateWatchdogService *templateWatchdogService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *templateWatchdogServiceRemoveRequest) Header(key, value string) *templateWatchdogServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateWatchdogServiceRemoveRequest) Query(key, value string) *templateWatchdogServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateWatchdogServiceRemoveRequest) Async(async bool) *templateWatchdogServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *templateWatchdogServiceRemoveRequest) Send() (*templateWatchdogServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogService.connection.URL(), p.templateWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(templateWatchdogServiceRemoveResponse), nil
}

func (p *templateWatchdogServiceRemoveRequest) MustSend() *templateWatchdogServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogService.connection.URL(), p.templateWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateWatchdogService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateWatchdogService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(templateWatchdogServiceRemoveResponse)
}

//
//
type templateWatchdogServiceRemoveResponse struct {
}

//
//
func (p *templateWatchdogService) Remove() *templateWatchdogServiceRemoveRequest {
	return &templateWatchdogServiceRemoveRequest{templateWatchdogService: p}
}

//
// Update the watchdog for the template identified by the given id.
//
type templateWatchdogServiceUpdateRequest struct {
	templateWatchdogService *templateWatchdogService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	watchdog                *Watchdog
}

func (p *templateWatchdogServiceUpdateRequest) Header(key, value string) *templateWatchdogServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateWatchdogServiceUpdateRequest) Query(key, value string) *templateWatchdogServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateWatchdogServiceUpdateRequest) Async(async bool) *templateWatchdogServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *templateWatchdogServiceUpdateRequest) Watchdog(watchdog *Watchdog) *templateWatchdogServiceUpdateRequest {
	p.watchdog = watchdog
	return p
}

func (p *templateWatchdogServiceUpdateRequest) Send() (*templateWatchdogServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogService.connection.URL(), p.templateWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateWatchdogServiceUpdateResponse{watchdog: result}, nil
}

func (p *templateWatchdogServiceUpdateRequest) MustSend() *templateWatchdogServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogService.connection.URL(), p.templateWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateWatchdogService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateWatchdogService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateWatchdogServiceUpdateResponse{watchdog: result}
}

//
// Update the watchdog for the template identified by the given id.
//
type templateWatchdogServiceUpdateResponse struct {
	watchdog *Watchdog
}

func (p *templateWatchdogServiceUpdateResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *templateWatchdogServiceUpdateResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Update the watchdog for the template identified by the given id.
//
func (p *templateWatchdogService) Update() *templateWatchdogServiceUpdateRequest {
	return &templateWatchdogServiceUpdateRequest{templateWatchdogService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateWatchdogService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *templateWatchdogService) String() string {
	return fmt.Sprintf("templateWatchdogService:%s", op.path)
}

//
//
type vmsService struct {
	baseService
}

func NewVmsService(connection *Connection, path string) *vmsService {
	var result vmsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new virtual machine.
// The virtual machine can be created in different ways:
// - From a template. In this case the identifier or name of the template must be provided. For example, using a
//   plain shell script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <template>
//     <name>Blank</name>
//   </template>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// - From a snapshot. In this case the identifier of the snapshot has to be provided. For example, using a plain
//   shel script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <snapshots>
//     <snapshot id="266742a5-6a65-483c-816d-d2ce49746680"/>
//   </snapshots>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// When creating a virtual machine from a template or from a snapshot it is usually useful to explicitly indicate
// in what storage domain to create the disks for the virtual machine. If the virtual machine is created from
// a template then this is achieved passing a set of `disk_attachment` elements that indicate the mapping:
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="8d4bd566-6c86-4592-a4a7-912dbf93c298">
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// When the virtual machine is created from a snapshot this set of disks is slightly different, it uses the
// `image_id` attribute instead of `id`.
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk>
//         <image_id>8d4bd566-6c86-4592-a4a7-912dbf93c298</image_id>
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// It is possible to specify additional virtual machine parameters in the XML description, e.g. a virtual machine
// of `desktop` type, with 2 GiB of RAM and additional description can be added sending a request body like the
// following:
// [source,xml]
// ----
// <vm>
//   <name>myvm</name>
//   <description>My Desktop Virtual Machine</description>
//   <type>desktop</type>
//   <memory>2147483648</memory>
//   ...
// </vm>
// ----
// A bootable CDROM device can be set like this:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot dev="cdrom"/>
//   </os>
// </vm>
// ----
// In order to boot from CDROM, you first need to insert a disk, as described in the
// <<services/vm_cdrom, CDROM service>>. Then booting from that CDROM can be specified using the `os.boot.devices`
// attribute:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot>
//       <devices>
//         <device>cdrom</device>
//       </devices>
//     </boot>
//   </os>
// </vm>
// ----
// In all cases the name or identifier of the cluster where the virtual machine will be created is mandatory.
//
type vmsServiceAddRequest struct {
	vmsService       *vmsService
	header           map[string]string
	query            map[string]string
	clone            *bool
	clonePermissions *bool
	vm               *Vm
}

func (p *vmsServiceAddRequest) Header(key, value string) *vmsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmsServiceAddRequest) Query(key, value string) *vmsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmsServiceAddRequest) Clone(clone bool) *vmsServiceAddRequest {
	p.clone = &clone
	return p
}

func (p *vmsServiceAddRequest) ClonePermissions(clonePermissions bool) *vmsServiceAddRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *vmsServiceAddRequest) Vm(vm *Vm) *vmsServiceAddRequest {
	p.vm = vm
	return p
}

func (p *vmsServiceAddRequest) Send() (*vmsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmsService.connection.URL(), p.vmsService.path)
	values := make(url.Values)
	if p.clone != nil {
		values["clone"] = []string{fmt.Sprintf("%v", *p.clone)}
	}

	if p.clonePermissions != nil {
		values["clone_permissions"] = []string{fmt.Sprintf("%v", *p.clonePermissions)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmWriteOne(writer, p.vm, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmsServiceAddResponse{vm: result}, nil
}

func (p *vmsServiceAddRequest) MustSend() *vmsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmsService.connection.URL(), p.vmsService.path)
	values := make(url.Values)
	if p.clone != nil {
		values["clone"] = []string{fmt.Sprintf("%v", *p.clone)}
	}

	if p.clonePermissions != nil {
		values["clone_permissions"] = []string{fmt.Sprintf("%v", *p.clonePermissions)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmWriteOne(writer, p.vm, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmsServiceAddResponse{vm: result}
}

//
// Creates a new virtual machine.
// The virtual machine can be created in different ways:
// - From a template. In this case the identifier or name of the template must be provided. For example, using a
//   plain shell script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <template>
//     <name>Blank</name>
//   </template>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// - From a snapshot. In this case the identifier of the snapshot has to be provided. For example, using a plain
//   shel script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <snapshots>
//     <snapshot id="266742a5-6a65-483c-816d-d2ce49746680"/>
//   </snapshots>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// When creating a virtual machine from a template or from a snapshot it is usually useful to explicitly indicate
// in what storage domain to create the disks for the virtual machine. If the virtual machine is created from
// a template then this is achieved passing a set of `disk_attachment` elements that indicate the mapping:
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="8d4bd566-6c86-4592-a4a7-912dbf93c298">
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// When the virtual machine is created from a snapshot this set of disks is slightly different, it uses the
// `image_id` attribute instead of `id`.
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk>
//         <image_id>8d4bd566-6c86-4592-a4a7-912dbf93c298</image_id>
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// It is possible to specify additional virtual machine parameters in the XML description, e.g. a virtual machine
// of `desktop` type, with 2 GiB of RAM and additional description can be added sending a request body like the
// following:
// [source,xml]
// ----
// <vm>
//   <name>myvm</name>
//   <description>My Desktop Virtual Machine</description>
//   <type>desktop</type>
//   <memory>2147483648</memory>
//   ...
// </vm>
// ----
// A bootable CDROM device can be set like this:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot dev="cdrom"/>
//   </os>
// </vm>
// ----
// In order to boot from CDROM, you first need to insert a disk, as described in the
// <<services/vm_cdrom, CDROM service>>. Then booting from that CDROM can be specified using the `os.boot.devices`
// attribute:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot>
//       <devices>
//         <device>cdrom</device>
//       </devices>
//     </boot>
//   </os>
// </vm>
// ----
// In all cases the name or identifier of the cluster where the virtual machine will be created is mandatory.
//
type vmsServiceAddResponse struct {
	vm *Vm
}

func (p *vmsServiceAddResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *vmsServiceAddResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Creates a new virtual machine.
// The virtual machine can be created in different ways:
// - From a template. In this case the identifier or name of the template must be provided. For example, using a
//   plain shell script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <template>
//     <name>Blank</name>
//   </template>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// - From a snapshot. In this case the identifier of the snapshot has to be provided. For example, using a plain
//   shel script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <snapshots>
//     <snapshot id="266742a5-6a65-483c-816d-d2ce49746680"/>
//   </snapshots>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// When creating a virtual machine from a template or from a snapshot it is usually useful to explicitly indicate
// in what storage domain to create the disks for the virtual machine. If the virtual machine is created from
// a template then this is achieved passing a set of `disk_attachment` elements that indicate the mapping:
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="8d4bd566-6c86-4592-a4a7-912dbf93c298">
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// When the virtual machine is created from a snapshot this set of disks is slightly different, it uses the
// `image_id` attribute instead of `id`.
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk>
//         <image_id>8d4bd566-6c86-4592-a4a7-912dbf93c298</image_id>
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// It is possible to specify additional virtual machine parameters in the XML description, e.g. a virtual machine
// of `desktop` type, with 2 GiB of RAM and additional description can be added sending a request body like the
// following:
// [source,xml]
// ----
// <vm>
//   <name>myvm</name>
//   <description>My Desktop Virtual Machine</description>
//   <type>desktop</type>
//   <memory>2147483648</memory>
//   ...
// </vm>
// ----
// A bootable CDROM device can be set like this:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot dev="cdrom"/>
//   </os>
// </vm>
// ----
// In order to boot from CDROM, you first need to insert a disk, as described in the
// <<services/vm_cdrom, CDROM service>>. Then booting from that CDROM can be specified using the `os.boot.devices`
// attribute:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot>
//       <devices>
//         <device>cdrom</device>
//       </devices>
//     </boot>
//   </os>
// </vm>
// ----
// In all cases the name or identifier of the cluster where the virtual machine will be created is mandatory.
//
func (p *vmsService) Add() *vmsServiceAddRequest {
	return &vmsServiceAddRequest{vmsService: p}
}

//
// add a virtual machine to the system from a configuration - requires the configuration type and the configuration data
//
type vmsServiceAddFromConfigurationRequest struct {
	vmsService       *vmsService
	header           map[string]string
	query            map[string]string
	clone            *bool
	clonePermissions *bool
	vm               *Vm
}

func (p *vmsServiceAddFromConfigurationRequest) Header(key, value string) *vmsServiceAddFromConfigurationRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmsServiceAddFromConfigurationRequest) Query(key, value string) *vmsServiceAddFromConfigurationRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmsServiceAddFromConfigurationRequest) Clone(clone bool) *vmsServiceAddFromConfigurationRequest {
	p.clone = &clone
	return p
}

func (p *vmsServiceAddFromConfigurationRequest) ClonePermissions(clonePermissions bool) *vmsServiceAddFromConfigurationRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *vmsServiceAddFromConfigurationRequest) Vm(vm *Vm) *vmsServiceAddFromConfigurationRequest {
	p.vm = vm
	return p
}

func (p *vmsServiceAddFromConfigurationRequest) Send() (*vmsServiceAddFromConfigurationResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fromconfiguration", p.vmsService.connection.URL(), p.vmsService.path)
	actionBuilder := NewActionBuilder()
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	if p.clonePermissions != nil {
		actionBuilder.ClonePermissions(*p.clonePermissions)
	}
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustVm()
	return &vmsServiceAddFromConfigurationResponse{vm: result}, nil
}

func (p *vmsServiceAddFromConfigurationRequest) MustSend() *vmsServiceAddFromConfigurationResponse {
	rawURL := fmt.Sprintf("%s%s/fromconfiguration", p.vmsService.connection.URL(), p.vmsService.path)
	actionBuilder := NewActionBuilder()
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	if p.clonePermissions != nil {
		actionBuilder.ClonePermissions(*p.clonePermissions)
	}
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustVm()
	return &vmsServiceAddFromConfigurationResponse{vm: result}
}

//
// add a virtual machine to the system from a configuration - requires the configuration type and the configuration data
//
type vmsServiceAddFromConfigurationResponse struct {
	vm *Vm
}

func (p *vmsServiceAddFromConfigurationResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *vmsServiceAddFromConfigurationResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// add a virtual machine to the system from a configuration - requires the configuration type and the configuration data
//
func (p *vmsService) AddFromConfiguration() *vmsServiceAddFromConfigurationRequest {
	return &vmsServiceAddFromConfigurationRequest{vmsService: p}
}

//
// add a virtual machine to the system from scratch
//
type vmsServiceAddFromScratchRequest struct {
	vmsService       *vmsService
	header           map[string]string
	query            map[string]string
	clone            *bool
	clonePermissions *bool
	vm               *Vm
}

func (p *vmsServiceAddFromScratchRequest) Header(key, value string) *vmsServiceAddFromScratchRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmsServiceAddFromScratchRequest) Query(key, value string) *vmsServiceAddFromScratchRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmsServiceAddFromScratchRequest) Clone(clone bool) *vmsServiceAddFromScratchRequest {
	p.clone = &clone
	return p
}

func (p *vmsServiceAddFromScratchRequest) ClonePermissions(clonePermissions bool) *vmsServiceAddFromScratchRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *vmsServiceAddFromScratchRequest) Vm(vm *Vm) *vmsServiceAddFromScratchRequest {
	p.vm = vm
	return p
}

func (p *vmsServiceAddFromScratchRequest) Send() (*vmsServiceAddFromScratchResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fromscratch", p.vmsService.connection.URL(), p.vmsService.path)
	actionBuilder := NewActionBuilder()
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	if p.clonePermissions != nil {
		actionBuilder.ClonePermissions(*p.clonePermissions)
	}
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustVm()
	return &vmsServiceAddFromScratchResponse{vm: result}, nil
}

func (p *vmsServiceAddFromScratchRequest) MustSend() *vmsServiceAddFromScratchResponse {
	rawURL := fmt.Sprintf("%s%s/fromscratch", p.vmsService.connection.URL(), p.vmsService.path)
	actionBuilder := NewActionBuilder()
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	if p.clonePermissions != nil {
		actionBuilder.ClonePermissions(*p.clonePermissions)
	}
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustVm()
	return &vmsServiceAddFromScratchResponse{vm: result}
}

//
// add a virtual machine to the system from scratch
//
type vmsServiceAddFromScratchResponse struct {
	vm *Vm
}

func (p *vmsServiceAddFromScratchResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *vmsServiceAddFromScratchResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// add a virtual machine to the system from scratch
//
func (p *vmsService) AddFromScratch() *vmsServiceAddFromScratchRequest {
	return &vmsServiceAddFromScratchRequest{vmsService: p}
}

//
// add a virtual machine to the system by cloning from a snapshot
//
type vmsServiceAddFromSnapshotRequest struct {
	vmsService       *vmsService
	header           map[string]string
	query            map[string]string
	clone            *bool
	clonePermissions *bool
	vm               *Vm
}

func (p *vmsServiceAddFromSnapshotRequest) Header(key, value string) *vmsServiceAddFromSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmsServiceAddFromSnapshotRequest) Query(key, value string) *vmsServiceAddFromSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmsServiceAddFromSnapshotRequest) Clone(clone bool) *vmsServiceAddFromSnapshotRequest {
	p.clone = &clone
	return p
}

func (p *vmsServiceAddFromSnapshotRequest) ClonePermissions(clonePermissions bool) *vmsServiceAddFromSnapshotRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *vmsServiceAddFromSnapshotRequest) Vm(vm *Vm) *vmsServiceAddFromSnapshotRequest {
	p.vm = vm
	return p
}

func (p *vmsServiceAddFromSnapshotRequest) Send() (*vmsServiceAddFromSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fromsnapshot", p.vmsService.connection.URL(), p.vmsService.path)
	actionBuilder := NewActionBuilder()
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	if p.clonePermissions != nil {
		actionBuilder.ClonePermissions(*p.clonePermissions)
	}
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustVm()
	return &vmsServiceAddFromSnapshotResponse{vm: result}, nil
}

func (p *vmsServiceAddFromSnapshotRequest) MustSend() *vmsServiceAddFromSnapshotResponse {
	rawURL := fmt.Sprintf("%s%s/fromsnapshot", p.vmsService.connection.URL(), p.vmsService.path)
	actionBuilder := NewActionBuilder()
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	if p.clonePermissions != nil {
		actionBuilder.ClonePermissions(*p.clonePermissions)
	}
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustVm()
	return &vmsServiceAddFromSnapshotResponse{vm: result}
}

//
// add a virtual machine to the system by cloning from a snapshot
//
type vmsServiceAddFromSnapshotResponse struct {
	vm *Vm
}

func (p *vmsServiceAddFromSnapshotResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *vmsServiceAddFromSnapshotResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// add a virtual machine to the system by cloning from a snapshot
//
func (p *vmsService) AddFromSnapshot() *vmsServiceAddFromSnapshotRequest {
	return &vmsServiceAddFromSnapshotRequest{vmsService: p}
}

//
// Returns the list of virtual machines of the system.
// The order of the returned list of virtual machines is guaranteed only if the `sortby` clause is included
// in the `search` parameter.
//
type vmsServiceListRequest struct {
	vmsService    *vmsService
	header        map[string]string
	query         map[string]string
	allContent    *bool
	caseSensitive *bool
	filter        *bool
	follow        *string
	max           *int64
	search        *string
}

func (p *vmsServiceListRequest) Header(key, value string) *vmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmsServiceListRequest) Query(key, value string) *vmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmsServiceListRequest) AllContent(allContent bool) *vmsServiceListRequest {
	p.allContent = &allContent
	return p
}

func (p *vmsServiceListRequest) CaseSensitive(caseSensitive bool) *vmsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *vmsServiceListRequest) Filter(filter bool) *vmsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *vmsServiceListRequest) Follow(follow string) *vmsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vmsServiceListRequest) Max(max int64) *vmsServiceListRequest {
	p.max = &max
	return p
}

func (p *vmsServiceListRequest) Search(search string) *vmsServiceListRequest {
	p.search = &search
	return p
}

func (p *vmsServiceListRequest) Send() (*vmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmsService.connection.URL(), p.vmsService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vmsServiceListResponse{vms: result}, nil
}

func (p *vmsServiceListRequest) MustSend() *vmsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmsService.connection.URL(), p.vmsService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vmsServiceListResponse{vms: result}
}

//
// Returns the list of virtual machines of the system.
// The order of the returned list of virtual machines is guaranteed only if the `sortby` clause is included
// in the `search` parameter.
//
type vmsServiceListResponse struct {
	vms *VmSlice
}

func (p *vmsServiceListResponse) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *vmsServiceListResponse) MustVms() *VmSlice {
	if p.vms == nil {
		panic("vms in response does not exist")
	}
	return p.vms
}

//
// Returns the list of virtual machines of the system.
// The order of the returned list of virtual machines is guaranteed only if the `sortby` clause is included
// in the `search` parameter.
//
func (p *vmsService) List() *vmsServiceListRequest {
	return &vmsServiceListRequest{vmsService: p}
}

//
//
func (op *vmsService) VmService(id string) *vmService {
	return NewVmService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.VmService(path), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *vmsService) String() string {
	return fmt.Sprintf("vmsService:%s", op.path)
}

//
// Provides a way for clients to list available files.
// This service is specifically targeted to ISO storage domains, which contain ISO images and virtual floppy disks
// (VFDs) that an administrator uploads.
// The addition of a CD-ROM device to a virtual machine requires an ISO image from the files of an ISO storage domain.
//
type filesService struct {
	baseService
}

func NewFilesService(connection *Connection, path string) *filesService {
	var result filesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of ISO images and virtual floppy disks available in the storage domain. The order of
// the returned list is not guaranteed.
// If the `refresh` parameter is `false`, the returned list may not reflect recent changes to the storage domain;
// for example, it may not contain a new ISO file that was recently added. This is because the
// server caches the list of files to improve performance. To get the very latest results, set the `refresh`
// parameter to `true`.
// The default value of the `refresh` parameter is `true`, but it can be changed using the configuration value
// `ForceRefreshDomainFilesByDefault`:
// [source]
// ----
// # engine-config -s ForceRefreshDomainFilesByDefault=false
// ----
// IMPORTANT: Setting the value of the `refresh` parameter to `true` has an impact on the performance of the
// server. Use it only if necessary.
//
type filesServiceListRequest struct {
	filesService  *filesService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	follow        *string
	max           *int64
	refresh       *bool
	search        *string
}

func (p *filesServiceListRequest) Header(key, value string) *filesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *filesServiceListRequest) Query(key, value string) *filesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *filesServiceListRequest) CaseSensitive(caseSensitive bool) *filesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *filesServiceListRequest) Follow(follow string) *filesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *filesServiceListRequest) Max(max int64) *filesServiceListRequest {
	p.max = &max
	return p
}

func (p *filesServiceListRequest) Refresh(refresh bool) *filesServiceListRequest {
	p.refresh = &refresh
	return p
}

func (p *filesServiceListRequest) Search(search string) *filesServiceListRequest {
	p.search = &search
	return p
}

func (p *filesServiceListRequest) Send() (*filesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filesService.connection.URL(), p.filesService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.refresh != nil {
		values["refresh"] = []string{fmt.Sprintf("%v", *p.refresh)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.filesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.filesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &filesServiceListResponse{file: result}, nil
}

func (p *filesServiceListRequest) MustSend() *filesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.filesService.connection.URL(), p.filesService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.refresh != nil {
		values["refresh"] = []string{fmt.Sprintf("%v", *p.refresh)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.filesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.filesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFileReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &filesServiceListResponse{file: result}
}

//
// Returns the list of ISO images and virtual floppy disks available in the storage domain. The order of
// the returned list is not guaranteed.
// If the `refresh` parameter is `false`, the returned list may not reflect recent changes to the storage domain;
// for example, it may not contain a new ISO file that was recently added. This is because the
// server caches the list of files to improve performance. To get the very latest results, set the `refresh`
// parameter to `true`.
// The default value of the `refresh` parameter is `true`, but it can be changed using the configuration value
// `ForceRefreshDomainFilesByDefault`:
// [source]
// ----
// # engine-config -s ForceRefreshDomainFilesByDefault=false
// ----
// IMPORTANT: Setting the value of the `refresh` parameter to `true` has an impact on the performance of the
// server. Use it only if necessary.
//
type filesServiceListResponse struct {
	file *FileSlice
}

func (p *filesServiceListResponse) File() (*FileSlice, bool) {
	if p.file != nil {
		return p.file, true
	}
	return nil, false
}

func (p *filesServiceListResponse) MustFile() *FileSlice {
	if p.file == nil {
		panic("file in response does not exist")
	}
	return p.file
}

//
// Returns the list of ISO images and virtual floppy disks available in the storage domain. The order of
// the returned list is not guaranteed.
// If the `refresh` parameter is `false`, the returned list may not reflect recent changes to the storage domain;
// for example, it may not contain a new ISO file that was recently added. This is because the
// server caches the list of files to improve performance. To get the very latest results, set the `refresh`
// parameter to `true`.
// The default value of the `refresh` parameter is `true`, but it can be changed using the configuration value
// `ForceRefreshDomainFilesByDefault`:
// [source]
// ----
// # engine-config -s ForceRefreshDomainFilesByDefault=false
// ----
// IMPORTANT: Setting the value of the `refresh` parameter to `true` has an impact on the performance of the
// server. Use it only if necessary.
//
func (p *filesService) List() *filesServiceListRequest {
	return &filesServiceListRequest{filesService: p}
}

//
//
func (op *filesService) FileService(id string) *fileService {
	return NewFileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *filesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.FileService(path), nil
	}
	return op.FileService(path[:index]).Service(path[index+1:])
}

func (op *filesService) String() string {
	return fmt.Sprintf("filesService:%s", op.path)
}

//
// A service managing a network
//
type networkService struct {
	baseService
}

func NewNetworkService(connection *Connection, path string) *networkService {
	var result networkService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets a logical network.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks/123
// ----
// Will respond:
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/123" id="123">
//   <name>ovirtmgmt</name>
//   <description>Default Management Network</description>
//   <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//   <mtu>0</mtu>
//   <stp>false</stp>
//   <usages>
//     <usage>vm</usage>
//   </usages>
//   <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
// </network>
// ----
//
type networkServiceGetRequest struct {
	networkService *networkService
	header         map[string]string
	query          map[string]string
	follow         *string
}

func (p *networkServiceGetRequest) Header(key, value string) *networkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkServiceGetRequest) Query(key, value string) *networkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkServiceGetRequest) Follow(follow string) *networkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *networkServiceGetRequest) Send() (*networkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkService.connection.URL(), p.networkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &networkServiceGetResponse{network: result}, nil
}

func (p *networkServiceGetRequest) MustSend() *networkServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkService.connection.URL(), p.networkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &networkServiceGetResponse{network: result}
}

//
// Gets a logical network.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks/123
// ----
// Will respond:
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/123" id="123">
//   <name>ovirtmgmt</name>
//   <description>Default Management Network</description>
//   <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//   <mtu>0</mtu>
//   <stp>false</stp>
//   <usages>
//     <usage>vm</usage>
//   </usages>
//   <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
// </network>
// ----
//
type networkServiceGetResponse struct {
	network *Network
}

func (p *networkServiceGetResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *networkServiceGetResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Gets a logical network.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks/123
// ----
// Will respond:
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/123" id="123">
//   <name>ovirtmgmt</name>
//   <description>Default Management Network</description>
//   <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//   <mtu>0</mtu>
//   <stp>false</stp>
//   <usages>
//     <usage>vm</usage>
//   </usages>
//   <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
// </network>
// ----
//
func (p *networkService) Get() *networkServiceGetRequest {
	return &networkServiceGetRequest{networkService: p}
}

//
// Removes a logical network, or the association of a logical network to a data center.
// For example, to remove the logical network `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123
// ----
// Each network is bound exactly to one data center. So if we disassociate network with data center it has the same
// result as if we would just remove that network. However it might be more specific to say we're removing network
// `456` of data center `123`.
// For example, to remove the association of network `456` to data center `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/networks/456
// ----
//
type networkServiceRemoveRequest struct {
	networkService *networkService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *networkServiceRemoveRequest) Header(key, value string) *networkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkServiceRemoveRequest) Query(key, value string) *networkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkServiceRemoveRequest) Async(async bool) *networkServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *networkServiceRemoveRequest) Send() (*networkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkService.connection.URL(), p.networkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(networkServiceRemoveResponse), nil
}

func (p *networkServiceRemoveRequest) MustSend() *networkServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkService.connection.URL(), p.networkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(networkServiceRemoveResponse)
}

//
// Removes a logical network, or the association of a logical network to a data center.
// For example, to remove the logical network `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123
// ----
// Each network is bound exactly to one data center. So if we disassociate network with data center it has the same
// result as if we would just remove that network. However it might be more specific to say we're removing network
// `456` of data center `123`.
// For example, to remove the association of network `456` to data center `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/networks/456
// ----
//
type networkServiceRemoveResponse struct {
}

//
// Removes a logical network, or the association of a logical network to a data center.
// For example, to remove the logical network `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123
// ----
// Each network is bound exactly to one data center. So if we disassociate network with data center it has the same
// result as if we would just remove that network. However it might be more specific to say we're removing network
// `456` of data center `123`.
// For example, to remove the association of network `456` to data center `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/networks/456
// ----
//
func (p *networkService) Remove() *networkServiceRemoveRequest {
	return &networkServiceRemoveRequest{networkService: p}
}

//
// Updates a logical network.
// The `name`, `description`, `ip`, `vlan`, `stp` and `display` attributes can be updated.
// For example, to update the description of the logical network `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/networks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <description>My updated description</description>
// </network>
// ----
// The maximum transmission unit of a network is set using a PUT request to
// specify the integer value of the `mtu` attribute.
// For example, to set the maximum transmission unit send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/networks/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <mtu>1500</mtu>
// </network>
// ----
//
type networkServiceUpdateRequest struct {
	networkService *networkService
	header         map[string]string
	query          map[string]string
	async          *bool
	network        *Network
}

func (p *networkServiceUpdateRequest) Header(key, value string) *networkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkServiceUpdateRequest) Query(key, value string) *networkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkServiceUpdateRequest) Async(async bool) *networkServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *networkServiceUpdateRequest) Network(network *Network) *networkServiceUpdateRequest {
	p.network = network
	return p
}

func (p *networkServiceUpdateRequest) Send() (*networkServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkService.connection.URL(), p.networkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &networkServiceUpdateResponse{network: result}, nil
}

func (p *networkServiceUpdateRequest) MustSend() *networkServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkService.connection.URL(), p.networkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &networkServiceUpdateResponse{network: result}
}

//
// Updates a logical network.
// The `name`, `description`, `ip`, `vlan`, `stp` and `display` attributes can be updated.
// For example, to update the description of the logical network `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/networks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <description>My updated description</description>
// </network>
// ----
// The maximum transmission unit of a network is set using a PUT request to
// specify the integer value of the `mtu` attribute.
// For example, to set the maximum transmission unit send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/networks/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <mtu>1500</mtu>
// </network>
// ----
//
type networkServiceUpdateResponse struct {
	network *Network
}

func (p *networkServiceUpdateResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *networkServiceUpdateResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Updates a logical network.
// The `name`, `description`, `ip`, `vlan`, `stp` and `display` attributes can be updated.
// For example, to update the description of the logical network `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/networks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <description>My updated description</description>
// </network>
// ----
// The maximum transmission unit of a network is set using a PUT request to
// specify the integer value of the `mtu` attribute.
// For example, to set the maximum transmission unit send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/networks/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <mtu>1500</mtu>
// </network>
// ----
//
func (p *networkService) Update() *networkServiceUpdateRequest {
	return &networkServiceUpdateRequest{networkService: p}
}

//
// Reference to the service that manages the network labels assigned to this network.
//
func (op *networkService) NetworkLabelsService() *networkLabelsService {
	return NewNetworkLabelsService(op.connection, fmt.Sprintf("%s/networklabels", op.path))
}

//
// Reference to the service that manages the permissions assigned to this network.
//
func (op *networkService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Reference to the service that manages the vNIC profiles assigned to this network.
//
func (op *networkService) VnicProfilesService() *assignedVnicProfilesService {
	return NewAssignedVnicProfilesService(op.connection, fmt.Sprintf("%s/vnicprofiles", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *networkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "networklabels" {
		return op.NetworkLabelsService(), nil
	}
	if strings.HasPrefix(path, "networklabels/") {
		return op.NetworkLabelsService().Service(path[14:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "vnicprofiles" {
		return op.VnicProfilesService(), nil
	}
	if strings.HasPrefix(path, "vnicprofiles/") {
		return op.VnicProfilesService().Service(path[13:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *networkService) String() string {
	return fmt.Sprintf("networkService:%s", op.path)
}

//
//
type iscsiBondsService struct {
	baseService
}

func NewIscsiBondsService(connection *Connection, path string) *iscsiBondsService {
	var result iscsiBondsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Create a new iSCSI bond on a data center.
// For example, to create a new iSCSI bond on data center `123` using storage connections `456` and `789`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/iscsibonds
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//   <name>mybond</name>
//   <storage_connections>
//     <storage_connection id="456"/>
//     <storage_connection id="789"/>
//   </storage_connections>
//   <networks>
//     <network id="abc"/>
//   </networks>
// </iscsi_bond>
// ----
//
type iscsiBondsServiceAddRequest struct {
	iscsiBondsService *iscsiBondsService
	header            map[string]string
	query             map[string]string
	bond              *IscsiBond
}

func (p *iscsiBondsServiceAddRequest) Header(key, value string) *iscsiBondsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *iscsiBondsServiceAddRequest) Query(key, value string) *iscsiBondsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *iscsiBondsServiceAddRequest) Bond(bond *IscsiBond) *iscsiBondsServiceAddRequest {
	p.bond = bond
	return p
}

func (p *iscsiBondsServiceAddRequest) Send() (*iscsiBondsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondsService.connection.URL(), p.iscsiBondsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLIscsiBondWriteOne(writer, p.bond, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iscsiBondsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iscsiBondsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIscsiBondReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &iscsiBondsServiceAddResponse{bond: result}, nil
}

func (p *iscsiBondsServiceAddRequest) MustSend() *iscsiBondsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondsService.connection.URL(), p.iscsiBondsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLIscsiBondWriteOne(writer, p.bond, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iscsiBondsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iscsiBondsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIscsiBondReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &iscsiBondsServiceAddResponse{bond: result}
}

//
// Create a new iSCSI bond on a data center.
// For example, to create a new iSCSI bond on data center `123` using storage connections `456` and `789`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/iscsibonds
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//   <name>mybond</name>
//   <storage_connections>
//     <storage_connection id="456"/>
//     <storage_connection id="789"/>
//   </storage_connections>
//   <networks>
//     <network id="abc"/>
//   </networks>
// </iscsi_bond>
// ----
//
type iscsiBondsServiceAddResponse struct {
	bond *IscsiBond
}

func (p *iscsiBondsServiceAddResponse) Bond() (*IscsiBond, bool) {
	if p.bond != nil {
		return p.bond, true
	}
	return nil, false
}

func (p *iscsiBondsServiceAddResponse) MustBond() *IscsiBond {
	if p.bond == nil {
		panic("bond in response does not exist")
	}
	return p.bond
}

//
// Create a new iSCSI bond on a data center.
// For example, to create a new iSCSI bond on data center `123` using storage connections `456` and `789`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/iscsibonds
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//   <name>mybond</name>
//   <storage_connections>
//     <storage_connection id="456"/>
//     <storage_connection id="789"/>
//   </storage_connections>
//   <networks>
//     <network id="abc"/>
//   </networks>
// </iscsi_bond>
// ----
//
func (p *iscsiBondsService) Add() *iscsiBondsServiceAddRequest {
	return &iscsiBondsServiceAddRequest{iscsiBondsService: p}
}

//
// Returns the list of iSCSI bonds configured in the data center.
// The order of the returned list of iSCSI bonds isn't guaranteed.
//
type iscsiBondsServiceListRequest struct {
	iscsiBondsService *iscsiBondsService
	header            map[string]string
	query             map[string]string
	follow            *string
	max               *int64
}

func (p *iscsiBondsServiceListRequest) Header(key, value string) *iscsiBondsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *iscsiBondsServiceListRequest) Query(key, value string) *iscsiBondsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *iscsiBondsServiceListRequest) Follow(follow string) *iscsiBondsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *iscsiBondsServiceListRequest) Max(max int64) *iscsiBondsServiceListRequest {
	p.max = &max
	return p
}

func (p *iscsiBondsServiceListRequest) Send() (*iscsiBondsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondsService.connection.URL(), p.iscsiBondsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iscsiBondsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iscsiBondsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIscsiBondReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &iscsiBondsServiceListResponse{bonds: result}, nil
}

func (p *iscsiBondsServiceListRequest) MustSend() *iscsiBondsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.iscsiBondsService.connection.URL(), p.iscsiBondsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iscsiBondsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iscsiBondsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIscsiBondReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &iscsiBondsServiceListResponse{bonds: result}
}

//
// Returns the list of iSCSI bonds configured in the data center.
// The order of the returned list of iSCSI bonds isn't guaranteed.
//
type iscsiBondsServiceListResponse struct {
	bonds *IscsiBondSlice
}

func (p *iscsiBondsServiceListResponse) Bonds() (*IscsiBondSlice, bool) {
	if p.bonds != nil {
		return p.bonds, true
	}
	return nil, false
}

func (p *iscsiBondsServiceListResponse) MustBonds() *IscsiBondSlice {
	if p.bonds == nil {
		panic("bonds in response does not exist")
	}
	return p.bonds
}

//
// Returns the list of iSCSI bonds configured in the data center.
// The order of the returned list of iSCSI bonds isn't guaranteed.
//
func (p *iscsiBondsService) List() *iscsiBondsServiceListRequest {
	return &iscsiBondsServiceListRequest{iscsiBondsService: p}
}

//
//
func (op *iscsiBondsService) IscsiBondService(id string) *iscsiBondService {
	return NewIscsiBondService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *iscsiBondsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.IscsiBondService(path), nil
	}
	return op.IscsiBondService(path[:index]).Service(path[index+1:])
}

func (op *iscsiBondsService) String() string {
	return fmt.Sprintf("iscsiBondsService:%s", op.path)
}

//
// A service to access host devices.
//
type hostDevicesService struct {
	baseService
}

func NewHostDevicesService(connection *Connection, path string) *hostDevicesService {
	var result hostDevicesService
	result.connection = connection
	result.path = path
	return &result
}

//
// List the devices of a host.
// The order of the returned list of devices isn't guaranteed.
//
type hostDevicesServiceListRequest struct {
	hostDevicesService *hostDevicesService
	header             map[string]string
	query              map[string]string
	follow             *string
	max                *int64
}

func (p *hostDevicesServiceListRequest) Header(key, value string) *hostDevicesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostDevicesServiceListRequest) Query(key, value string) *hostDevicesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostDevicesServiceListRequest) Follow(follow string) *hostDevicesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *hostDevicesServiceListRequest) Max(max int64) *hostDevicesServiceListRequest {
	p.max = &max
	return p
}

func (p *hostDevicesServiceListRequest) Send() (*hostDevicesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostDevicesService.connection.URL(), p.hostDevicesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostDevicesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostDevicesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &hostDevicesServiceListResponse{devices: result}, nil
}

func (p *hostDevicesServiceListRequest) MustSend() *hostDevicesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostDevicesService.connection.URL(), p.hostDevicesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostDevicesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostDevicesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &hostDevicesServiceListResponse{devices: result}
}

//
// List the devices of a host.
// The order of the returned list of devices isn't guaranteed.
//
type hostDevicesServiceListResponse struct {
	devices *HostDeviceSlice
}

func (p *hostDevicesServiceListResponse) Devices() (*HostDeviceSlice, bool) {
	if p.devices != nil {
		return p.devices, true
	}
	return nil, false
}

func (p *hostDevicesServiceListResponse) MustDevices() *HostDeviceSlice {
	if p.devices == nil {
		panic("devices in response does not exist")
	}
	return p.devices
}

//
// List the devices of a host.
// The order of the returned list of devices isn't guaranteed.
//
func (p *hostDevicesService) List() *hostDevicesServiceListRequest {
	return &hostDevicesServiceListRequest{hostDevicesService: p}
}

//
// Reference to the service that can be used to access a specific host device.
//
func (op *hostDevicesService) DeviceService(id string) *hostDeviceService {
	return NewHostDeviceService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *hostDevicesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DeviceService(path), nil
	}
	return op.DeviceService(path[:index]).Service(path[index+1:])
}

func (op *hostDevicesService) String() string {
	return fmt.Sprintf("hostDevicesService:%s", op.path)
}

//
//
type vmReportedDevicesService struct {
	baseService
}

func NewVmReportedDevicesService(connection *Connection, path string) *vmReportedDevicesService {
	var result vmReportedDevicesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of reported devices of the virtual machine.
// The order of the returned list of devices isn't guaranteed.
//
type vmReportedDevicesServiceListRequest struct {
	vmReportedDevicesService *vmReportedDevicesService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
	max                      *int64
}

func (p *vmReportedDevicesServiceListRequest) Header(key, value string) *vmReportedDevicesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmReportedDevicesServiceListRequest) Query(key, value string) *vmReportedDevicesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmReportedDevicesServiceListRequest) Follow(follow string) *vmReportedDevicesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vmReportedDevicesServiceListRequest) Max(max int64) *vmReportedDevicesServiceListRequest {
	p.max = &max
	return p
}

func (p *vmReportedDevicesServiceListRequest) Send() (*vmReportedDevicesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmReportedDevicesService.connection.URL(), p.vmReportedDevicesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmReportedDevicesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmReportedDevicesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLReportedDeviceReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vmReportedDevicesServiceListResponse{reportedDevice: result}, nil
}

func (p *vmReportedDevicesServiceListRequest) MustSend() *vmReportedDevicesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmReportedDevicesService.connection.URL(), p.vmReportedDevicesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmReportedDevicesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmReportedDevicesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLReportedDeviceReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vmReportedDevicesServiceListResponse{reportedDevice: result}
}

//
// Returns the list of reported devices of the virtual machine.
// The order of the returned list of devices isn't guaranteed.
//
type vmReportedDevicesServiceListResponse struct {
	reportedDevice *ReportedDeviceSlice
}

func (p *vmReportedDevicesServiceListResponse) ReportedDevice() (*ReportedDeviceSlice, bool) {
	if p.reportedDevice != nil {
		return p.reportedDevice, true
	}
	return nil, false
}

func (p *vmReportedDevicesServiceListResponse) MustReportedDevice() *ReportedDeviceSlice {
	if p.reportedDevice == nil {
		panic("reportedDevice in response does not exist")
	}
	return p.reportedDevice
}

//
// Returns the list of reported devices of the virtual machine.
// The order of the returned list of devices isn't guaranteed.
//
func (p *vmReportedDevicesService) List() *vmReportedDevicesServiceListRequest {
	return &vmReportedDevicesServiceListRequest{vmReportedDevicesService: p}
}

//
//
func (op *vmReportedDevicesService) ReportedDeviceService(id string) *vmReportedDeviceService {
	return NewVmReportedDeviceService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmReportedDevicesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ReportedDeviceService(path), nil
	}
	return op.ReportedDeviceService(path[:index]).Service(path[index+1:])
}

func (op *vmReportedDevicesService) String() string {
	return fmt.Sprintf("vmReportedDevicesService:%s", op.path)
}

//
// A service to manage individual host device attached to a virtual machine.
//
type vmHostDeviceService struct {
	baseService
}

func NewVmHostDeviceService(connection *Connection, path string) *vmHostDeviceService {
	var result vmHostDeviceService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieve information about particular host device attached to given virtual machine.
// Example:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/hostdevices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//   <name>pci_0000_04_00_0</name>
//   <capability>pci</capability>
//   <iommu_group>30</iommu_group>
//   <placeholder>true</placeholder>
//   <product id="0x13ba">
//     <name>GM107GL [Quadro K2200]</name>
//   </product>
//   <vendor id="0x10de">
//     <name>NVIDIA Corporation</name>
//   </vendor>
//   <host href="/ovirt-engine/api/hosts/543" id="543"/>
//   <parent_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//     <name>pci_0000_00_03_0</name>
//   </parent_device>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </host_device>
// ----
//
type vmHostDeviceServiceGetRequest struct {
	vmHostDeviceService *vmHostDeviceService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *vmHostDeviceServiceGetRequest) Header(key, value string) *vmHostDeviceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmHostDeviceServiceGetRequest) Query(key, value string) *vmHostDeviceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmHostDeviceServiceGetRequest) Follow(follow string) *vmHostDeviceServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vmHostDeviceServiceGetRequest) Send() (*vmHostDeviceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDeviceService.connection.URL(), p.vmHostDeviceService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmHostDeviceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmHostDeviceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmHostDeviceServiceGetResponse{device: result}, nil
}

func (p *vmHostDeviceServiceGetRequest) MustSend() *vmHostDeviceServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDeviceService.connection.URL(), p.vmHostDeviceService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmHostDeviceService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmHostDeviceService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmHostDeviceServiceGetResponse{device: result}
}

//
// Retrieve information about particular host device attached to given virtual machine.
// Example:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/hostdevices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//   <name>pci_0000_04_00_0</name>
//   <capability>pci</capability>
//   <iommu_group>30</iommu_group>
//   <placeholder>true</placeholder>
//   <product id="0x13ba">
//     <name>GM107GL [Quadro K2200]</name>
//   </product>
//   <vendor id="0x10de">
//     <name>NVIDIA Corporation</name>
//   </vendor>
//   <host href="/ovirt-engine/api/hosts/543" id="543"/>
//   <parent_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//     <name>pci_0000_00_03_0</name>
//   </parent_device>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </host_device>
// ----
//
type vmHostDeviceServiceGetResponse struct {
	device *HostDevice
}

func (p *vmHostDeviceServiceGetResponse) Device() (*HostDevice, bool) {
	if p.device != nil {
		return p.device, true
	}
	return nil, false
}

func (p *vmHostDeviceServiceGetResponse) MustDevice() *HostDevice {
	if p.device == nil {
		panic("device in response does not exist")
	}
	return p.device
}

//
// Retrieve information about particular host device attached to given virtual machine.
// Example:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/hostdevices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//   <name>pci_0000_04_00_0</name>
//   <capability>pci</capability>
//   <iommu_group>30</iommu_group>
//   <placeholder>true</placeholder>
//   <product id="0x13ba">
//     <name>GM107GL [Quadro K2200]</name>
//   </product>
//   <vendor id="0x10de">
//     <name>NVIDIA Corporation</name>
//   </vendor>
//   <host href="/ovirt-engine/api/hosts/543" id="543"/>
//   <parent_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//     <name>pci_0000_00_03_0</name>
//   </parent_device>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </host_device>
// ----
//
func (p *vmHostDeviceService) Get() *vmHostDeviceServiceGetRequest {
	return &vmHostDeviceServiceGetRequest{vmHostDeviceService: p}
}

//
// Remove the attachment of this host device from given virtual machine.
// NOTE: In case this device serves as an IOMMU placeholder, it cannot be removed (remove will result only
// in setting its `placeholder` flag to `true`). Note that all IOMMU placeholder devices will be removed
// automatically as soon as there will be no more non-placeholder devices (all devices from given IOMMU
// group are detached).
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/hostdevices/456
// ----
//
type vmHostDeviceServiceRemoveRequest struct {
	vmHostDeviceService *vmHostDeviceService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *vmHostDeviceServiceRemoveRequest) Header(key, value string) *vmHostDeviceServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmHostDeviceServiceRemoveRequest) Query(key, value string) *vmHostDeviceServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmHostDeviceServiceRemoveRequest) Async(async bool) *vmHostDeviceServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *vmHostDeviceServiceRemoveRequest) Send() (*vmHostDeviceServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDeviceService.connection.URL(), p.vmHostDeviceService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmHostDeviceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmHostDeviceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(vmHostDeviceServiceRemoveResponse), nil
}

func (p *vmHostDeviceServiceRemoveRequest) MustSend() *vmHostDeviceServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDeviceService.connection.URL(), p.vmHostDeviceService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmHostDeviceService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmHostDeviceService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(vmHostDeviceServiceRemoveResponse)
}

//
// Remove the attachment of this host device from given virtual machine.
// NOTE: In case this device serves as an IOMMU placeholder, it cannot be removed (remove will result only
// in setting its `placeholder` flag to `true`). Note that all IOMMU placeholder devices will be removed
// automatically as soon as there will be no more non-placeholder devices (all devices from given IOMMU
// group are detached).
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/hostdevices/456
// ----
//
type vmHostDeviceServiceRemoveResponse struct {
}

//
// Remove the attachment of this host device from given virtual machine.
// NOTE: In case this device serves as an IOMMU placeholder, it cannot be removed (remove will result only
// in setting its `placeholder` flag to `true`). Note that all IOMMU placeholder devices will be removed
// automatically as soon as there will be no more non-placeholder devices (all devices from given IOMMU
// group are detached).
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/hostdevices/456
// ----
//
func (p *vmHostDeviceService) Remove() *vmHostDeviceServiceRemoveRequest {
	return &vmHostDeviceServiceRemoveRequest{vmHostDeviceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmHostDeviceService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vmHostDeviceService) String() string {
	return fmt.Sprintf("vmHostDeviceService:%s", op.path)
}

//
// Manages the filters used by an scheduling policy.
//
type filtersService struct {
	baseService
}

func NewFiltersService(connection *Connection, path string) *filtersService {
	var result filtersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a filter to a specified user defined scheduling policy.
//
type filtersServiceAddRequest struct {
	filtersService *filtersService
	header         map[string]string
	query          map[string]string
	filter         *Filter
}

func (p *filtersServiceAddRequest) Header(key, value string) *filtersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *filtersServiceAddRequest) Query(key, value string) *filtersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *filtersServiceAddRequest) Filter(filter *Filter) *filtersServiceAddRequest {
	p.filter = filter
	return p
}

func (p *filtersServiceAddRequest) Send() (*filtersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filtersService.connection.URL(), p.filtersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLFilterWriteOne(writer, p.filter, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.filtersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.filtersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFilterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &filtersServiceAddResponse{filter: result}, nil
}

func (p *filtersServiceAddRequest) MustSend() *filtersServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.filtersService.connection.URL(), p.filtersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLFilterWriteOne(writer, p.filter, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.filtersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.filtersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFilterReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &filtersServiceAddResponse{filter: result}
}

//
// Add a filter to a specified user defined scheduling policy.
//
type filtersServiceAddResponse struct {
	filter *Filter
}

func (p *filtersServiceAddResponse) Filter() (*Filter, bool) {
	if p.filter != nil {
		return p.filter, true
	}
	return nil, false
}

func (p *filtersServiceAddResponse) MustFilter() *Filter {
	if p.filter == nil {
		panic("filter in response does not exist")
	}
	return p.filter
}

//
// Add a filter to a specified user defined scheduling policy.
//
func (p *filtersService) Add() *filtersServiceAddRequest {
	return &filtersServiceAddRequest{filtersService: p}
}

//
// Returns the list of filters used by the scheduling policy.
// The order of the returned list of filters isn't guaranteed.
//
type filtersServiceListRequest struct {
	filtersService *filtersService
	header         map[string]string
	query          map[string]string
	filter         *bool
	follow         *string
	max            *int64
}

func (p *filtersServiceListRequest) Header(key, value string) *filtersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *filtersServiceListRequest) Query(key, value string) *filtersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *filtersServiceListRequest) Filter(filter bool) *filtersServiceListRequest {
	p.filter = &filter
	return p
}

func (p *filtersServiceListRequest) Follow(follow string) *filtersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *filtersServiceListRequest) Max(max int64) *filtersServiceListRequest {
	p.max = &max
	return p
}

func (p *filtersServiceListRequest) Send() (*filtersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filtersService.connection.URL(), p.filtersService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.filtersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.filtersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFilterReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &filtersServiceListResponse{filters: result}, nil
}

func (p *filtersServiceListRequest) MustSend() *filtersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.filtersService.connection.URL(), p.filtersService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.filtersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.filtersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFilterReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &filtersServiceListResponse{filters: result}
}

//
// Returns the list of filters used by the scheduling policy.
// The order of the returned list of filters isn't guaranteed.
//
type filtersServiceListResponse struct {
	filters *FilterSlice
}

func (p *filtersServiceListResponse) Filters() (*FilterSlice, bool) {
	if p.filters != nil {
		return p.filters, true
	}
	return nil, false
}

func (p *filtersServiceListResponse) MustFilters() *FilterSlice {
	if p.filters == nil {
		panic("filters in response does not exist")
	}
	return p.filters
}

//
// Returns the list of filters used by the scheduling policy.
// The order of the returned list of filters isn't guaranteed.
//
func (p *filtersService) List() *filtersServiceListRequest {
	return &filtersServiceListRequest{filtersService: p}
}

//
//
func (op *filtersService) FilterService(id string) *filterService {
	return NewFilterService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *filtersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.FilterService(path), nil
	}
	return op.FilterService(path[:index]).Service(path[index+1:])
}

func (op *filtersService) String() string {
	return fmt.Sprintf("filtersService:%s", op.path)
}

//
// Manages the set of storage limits configured for a quota.
//
type quotaStorageLimitsService struct {
	baseService
}

func NewQuotaStorageLimitsService(connection *Connection, path string) *quotaStorageLimitsService {
	var result quotaStorageLimitsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a storage limit to a specified quota.
// To create a 100GiB storage limit for all storage domains in a data center, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
// ----
// With a request body like this:
// [source,xml]
// ----
// <quota_storage_limit>
//   <limit>100</limit>
// </quota_storage_limit>
// ----
// To create a 50GiB storage limit for a storage domain with the ID `000`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
// ----
// With a request body like this:
// [source,xml]
// ----
// <quota_storage_limit>
//   <limit>50</limit>
//   <storage_domain id="000"/>
// </quota_storage_limit>
// ----
//
type quotaStorageLimitsServiceAddRequest struct {
	quotaStorageLimitsService *quotaStorageLimitsService
	header                    map[string]string
	query                     map[string]string
	limit                     *QuotaStorageLimit
}

func (p *quotaStorageLimitsServiceAddRequest) Header(key, value string) *quotaStorageLimitsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotaStorageLimitsServiceAddRequest) Query(key, value string) *quotaStorageLimitsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotaStorageLimitsServiceAddRequest) Limit(limit *QuotaStorageLimit) *quotaStorageLimitsServiceAddRequest {
	p.limit = limit
	return p
}

func (p *quotaStorageLimitsServiceAddRequest) Send() (*quotaStorageLimitsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitsService.connection.URL(), p.quotaStorageLimitsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQuotaStorageLimitWriteOne(writer, p.limit, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaStorageLimitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaStorageLimitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &quotaStorageLimitsServiceAddResponse{limit: result}, nil
}

func (p *quotaStorageLimitsServiceAddRequest) MustSend() *quotaStorageLimitsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitsService.connection.URL(), p.quotaStorageLimitsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQuotaStorageLimitWriteOne(writer, p.limit, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaStorageLimitsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaStorageLimitReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &quotaStorageLimitsServiceAddResponse{limit: result}
}

//
// Adds a storage limit to a specified quota.
// To create a 100GiB storage limit for all storage domains in a data center, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
// ----
// With a request body like this:
// [source,xml]
// ----
// <quota_storage_limit>
//   <limit>100</limit>
// </quota_storage_limit>
// ----
// To create a 50GiB storage limit for a storage domain with the ID `000`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
// ----
// With a request body like this:
// [source,xml]
// ----
// <quota_storage_limit>
//   <limit>50</limit>
//   <storage_domain id="000"/>
// </quota_storage_limit>
// ----
//
type quotaStorageLimitsServiceAddResponse struct {
	limit *QuotaStorageLimit
}

func (p *quotaStorageLimitsServiceAddResponse) Limit() (*QuotaStorageLimit, bool) {
	if p.limit != nil {
		return p.limit, true
	}
	return nil, false
}

func (p *quotaStorageLimitsServiceAddResponse) MustLimit() *QuotaStorageLimit {
	if p.limit == nil {
		panic("limit in response does not exist")
	}
	return p.limit
}

//
// Adds a storage limit to a specified quota.
// To create a 100GiB storage limit for all storage domains in a data center, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
// ----
// With a request body like this:
// [source,xml]
// ----
// <quota_storage_limit>
//   <limit>100</limit>
// </quota_storage_limit>
// ----
// To create a 50GiB storage limit for a storage domain with the ID `000`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
// ----
// With a request body like this:
// [source,xml]
// ----
// <quota_storage_limit>
//   <limit>50</limit>
//   <storage_domain id="000"/>
// </quota_storage_limit>
// ----
//
func (p *quotaStorageLimitsService) Add() *quotaStorageLimitsServiceAddRequest {
	return &quotaStorageLimitsServiceAddRequest{quotaStorageLimitsService: p}
}

//
// Returns the list of storage limits configured for the quota.
// The order of the returned list of storage limits is not guaranteed.
//
type quotaStorageLimitsServiceListRequest struct {
	quotaStorageLimitsService *quotaStorageLimitsService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
}

func (p *quotaStorageLimitsServiceListRequest) Header(key, value string) *quotaStorageLimitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotaStorageLimitsServiceListRequest) Query(key, value string) *quotaStorageLimitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotaStorageLimitsServiceListRequest) Follow(follow string) *quotaStorageLimitsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *quotaStorageLimitsServiceListRequest) Max(max int64) *quotaStorageLimitsServiceListRequest {
	p.max = &max
	return p
}

func (p *quotaStorageLimitsServiceListRequest) Send() (*quotaStorageLimitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitsService.connection.URL(), p.quotaStorageLimitsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaStorageLimitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaStorageLimitReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &quotaStorageLimitsServiceListResponse{limits: result}, nil
}

func (p *quotaStorageLimitsServiceListRequest) MustSend() *quotaStorageLimitsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitsService.connection.URL(), p.quotaStorageLimitsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaStorageLimitsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaStorageLimitReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &quotaStorageLimitsServiceListResponse{limits: result}
}

//
// Returns the list of storage limits configured for the quota.
// The order of the returned list of storage limits is not guaranteed.
//
type quotaStorageLimitsServiceListResponse struct {
	limits *QuotaStorageLimitSlice
}

func (p *quotaStorageLimitsServiceListResponse) Limits() (*QuotaStorageLimitSlice, bool) {
	if p.limits != nil {
		return p.limits, true
	}
	return nil, false
}

func (p *quotaStorageLimitsServiceListResponse) MustLimits() *QuotaStorageLimitSlice {
	if p.limits == nil {
		panic("limits in response does not exist")
	}
	return p.limits
}

//
// Returns the list of storage limits configured for the quota.
// The order of the returned list of storage limits is not guaranteed.
//
func (p *quotaStorageLimitsService) List() *quotaStorageLimitsServiceListRequest {
	return &quotaStorageLimitsServiceListRequest{quotaStorageLimitsService: p}
}

//
//
func (op *quotaStorageLimitsService) LimitService(id string) *quotaStorageLimitService {
	return NewQuotaStorageLimitService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *quotaStorageLimitsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LimitService(path), nil
	}
	return op.LimitService(path[:index]).Service(path[index+1:])
}

func (op *quotaStorageLimitsService) String() string {
	return fmt.Sprintf("quotaStorageLimitsService:%s", op.path)
}

//
//
type schedulingPolicyService struct {
	baseService
}

func NewSchedulingPolicyService(connection *Connection, path string) *schedulingPolicyService {
	var result schedulingPolicyService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type schedulingPolicyServiceGetRequest struct {
	schedulingPolicyService *schedulingPolicyService
	header                  map[string]string
	query                   map[string]string
	filter                  *bool
	follow                  *string
}

func (p *schedulingPolicyServiceGetRequest) Header(key, value string) *schedulingPolicyServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *schedulingPolicyServiceGetRequest) Query(key, value string) *schedulingPolicyServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *schedulingPolicyServiceGetRequest) Filter(filter bool) *schedulingPolicyServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *schedulingPolicyServiceGetRequest) Follow(follow string) *schedulingPolicyServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *schedulingPolicyServiceGetRequest) Send() (*schedulingPolicyServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyService.connection.URL(), p.schedulingPolicyService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPolicyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &schedulingPolicyServiceGetResponse{policy: result}, nil
}

func (p *schedulingPolicyServiceGetRequest) MustSend() *schedulingPolicyServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyService.connection.URL(), p.schedulingPolicyService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPolicyService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &schedulingPolicyServiceGetResponse{policy: result}
}

//
//
type schedulingPolicyServiceGetResponse struct {
	policy *SchedulingPolicy
}

func (p *schedulingPolicyServiceGetResponse) Policy() (*SchedulingPolicy, bool) {
	if p.policy != nil {
		return p.policy, true
	}
	return nil, false
}

func (p *schedulingPolicyServiceGetResponse) MustPolicy() *SchedulingPolicy {
	if p.policy == nil {
		panic("policy in response does not exist")
	}
	return p.policy
}

//
//
func (p *schedulingPolicyService) Get() *schedulingPolicyServiceGetRequest {
	return &schedulingPolicyServiceGetRequest{schedulingPolicyService: p}
}

//
//
type schedulingPolicyServiceRemoveRequest struct {
	schedulingPolicyService *schedulingPolicyService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *schedulingPolicyServiceRemoveRequest) Header(key, value string) *schedulingPolicyServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *schedulingPolicyServiceRemoveRequest) Query(key, value string) *schedulingPolicyServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *schedulingPolicyServiceRemoveRequest) Async(async bool) *schedulingPolicyServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *schedulingPolicyServiceRemoveRequest) Send() (*schedulingPolicyServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyService.connection.URL(), p.schedulingPolicyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPolicyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(schedulingPolicyServiceRemoveResponse), nil
}

func (p *schedulingPolicyServiceRemoveRequest) MustSend() *schedulingPolicyServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyService.connection.URL(), p.schedulingPolicyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPolicyService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(schedulingPolicyServiceRemoveResponse)
}

//
//
type schedulingPolicyServiceRemoveResponse struct {
}

//
//
func (p *schedulingPolicyService) Remove() *schedulingPolicyServiceRemoveRequest {
	return &schedulingPolicyServiceRemoveRequest{schedulingPolicyService: p}
}

//
// Update the specified user defined scheduling policy in the system.
//
type schedulingPolicyServiceUpdateRequest struct {
	schedulingPolicyService *schedulingPolicyService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	policy                  *SchedulingPolicy
}

func (p *schedulingPolicyServiceUpdateRequest) Header(key, value string) *schedulingPolicyServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *schedulingPolicyServiceUpdateRequest) Query(key, value string) *schedulingPolicyServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *schedulingPolicyServiceUpdateRequest) Async(async bool) *schedulingPolicyServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *schedulingPolicyServiceUpdateRequest) Policy(policy *SchedulingPolicy) *schedulingPolicyServiceUpdateRequest {
	p.policy = policy
	return p
}

func (p *schedulingPolicyServiceUpdateRequest) Send() (*schedulingPolicyServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyService.connection.URL(), p.schedulingPolicyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSchedulingPolicyWriteOne(writer, p.policy, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPolicyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &schedulingPolicyServiceUpdateResponse{policy: result}, nil
}

func (p *schedulingPolicyServiceUpdateRequest) MustSend() *schedulingPolicyServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyService.connection.URL(), p.schedulingPolicyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSchedulingPolicyWriteOne(writer, p.policy, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPolicyService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &schedulingPolicyServiceUpdateResponse{policy: result}
}

//
// Update the specified user defined scheduling policy in the system.
//
type schedulingPolicyServiceUpdateResponse struct {
	policy *SchedulingPolicy
}

func (p *schedulingPolicyServiceUpdateResponse) Policy() (*SchedulingPolicy, bool) {
	if p.policy != nil {
		return p.policy, true
	}
	return nil, false
}

func (p *schedulingPolicyServiceUpdateResponse) MustPolicy() *SchedulingPolicy {
	if p.policy == nil {
		panic("policy in response does not exist")
	}
	return p.policy
}

//
// Update the specified user defined scheduling policy in the system.
//
func (p *schedulingPolicyService) Update() *schedulingPolicyServiceUpdateRequest {
	return &schedulingPolicyServiceUpdateRequest{schedulingPolicyService: p}
}

//
//
func (op *schedulingPolicyService) BalancesService() *balancesService {
	return NewBalancesService(op.connection, fmt.Sprintf("%s/balances", op.path))
}

//
//
func (op *schedulingPolicyService) FiltersService() *filtersService {
	return NewFiltersService(op.connection, fmt.Sprintf("%s/filters", op.path))
}

//
//
func (op *schedulingPolicyService) WeightsService() *weightsService {
	return NewWeightsService(op.connection, fmt.Sprintf("%s/weights", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *schedulingPolicyService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "balances" {
		return op.BalancesService(), nil
	}
	if strings.HasPrefix(path, "balances/") {
		return op.BalancesService().Service(path[9:])
	}
	if path == "filters" {
		return op.FiltersService(), nil
	}
	if strings.HasPrefix(path, "filters/") {
		return op.FiltersService().Service(path[8:])
	}
	if path == "weights" {
		return op.WeightsService(), nil
	}
	if strings.HasPrefix(path, "weights/") {
		return op.WeightsService().Service(path[8:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *schedulingPolicyService) String() string {
	return fmt.Sprintf("schedulingPolicyService:%s", op.path)
}

//
// A service to manage a host.
//
type hostService struct {
	baseService
}

func NewHostService(connection *Connection, path string) *hostService {
	var result hostService
	result.connection = connection
	result.path = path
	return &result
}

//
// Activates the host for use, for example to run virtual machines.
//
type hostServiceActivateRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *hostServiceActivateRequest) Header(key, value string) *hostServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceActivateRequest) Query(key, value string) *hostServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceActivateRequest) Async(async bool) *hostServiceActivateRequest {
	p.async = &async
	return p
}

func (p *hostServiceActivateRequest) Send() (*hostServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceActivateResponse), nil
}

func (p *hostServiceActivateRequest) MustSend() *hostServiceActivateResponse {
	rawURL := fmt.Sprintf("%s%s/activate", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceActivateResponse)
}

//
// Activates the host for use, for example to run virtual machines.
//
type hostServiceActivateResponse struct {
}

//
// Activates the host for use, for example to run virtual machines.
//
func (p *hostService) Activate() *hostServiceActivateRequest {
	return &hostServiceActivateRequest{hostService: p}
}

//
// Approve a pre-installed Hypervisor host for usage in the virtualization environment.
// This action also accepts an optional cluster element to define the target cluster for this host.
//
type hostServiceApproveRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
	cluster     *Cluster
	host        *Host
}

func (p *hostServiceApproveRequest) Header(key, value string) *hostServiceApproveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceApproveRequest) Query(key, value string) *hostServiceApproveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceApproveRequest) Async(async bool) *hostServiceApproveRequest {
	p.async = &async
	return p
}

func (p *hostServiceApproveRequest) Cluster(cluster *Cluster) *hostServiceApproveRequest {
	p.cluster = cluster
	return p
}

func (p *hostServiceApproveRequest) Host(host *Host) *hostServiceApproveRequest {
	p.host = host
	return p
}

func (p *hostServiceApproveRequest) Send() (*hostServiceApproveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/approve", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceApproveResponse), nil
}

func (p *hostServiceApproveRequest) MustSend() *hostServiceApproveResponse {
	rawURL := fmt.Sprintf("%s%s/approve", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceApproveResponse)
}

//
// Approve a pre-installed Hypervisor host for usage in the virtualization environment.
// This action also accepts an optional cluster element to define the target cluster for this host.
//
type hostServiceApproveResponse struct {
}

//
// Approve a pre-installed Hypervisor host for usage in the virtualization environment.
// This action also accepts an optional cluster element to define the target cluster for this host.
//
func (p *hostService) Approve() *hostServiceApproveRequest {
	return &hostServiceApproveRequest{hostService: p}
}

//
// Marks the network configuration as good and persists it inside the host.
// An API user commits the network configuration to persist a host network interface attachment or detachment, or
// persist the creation and deletion of a bonded interface.
// IMPORTANT: Networking configuration is only committed after the engine has established that host connectivity is
// not lost as a result of the configuration changes. If host connectivity is lost, the host requires a reboot and
// automatically reverts to the previous networking configuration.
// For example, to commit the network configuration of host with id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/commitnetconfig
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
type hostServiceCommitNetConfigRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *hostServiceCommitNetConfigRequest) Header(key, value string) *hostServiceCommitNetConfigRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceCommitNetConfigRequest) Query(key, value string) *hostServiceCommitNetConfigRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceCommitNetConfigRequest) Async(async bool) *hostServiceCommitNetConfigRequest {
	p.async = &async
	return p
}

func (p *hostServiceCommitNetConfigRequest) Send() (*hostServiceCommitNetConfigResponse, error) {
	rawURL := fmt.Sprintf("%s%s/commitnetconfig", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceCommitNetConfigResponse), nil
}

func (p *hostServiceCommitNetConfigRequest) MustSend() *hostServiceCommitNetConfigResponse {
	rawURL := fmt.Sprintf("%s%s/commitnetconfig", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceCommitNetConfigResponse)
}

//
// Marks the network configuration as good and persists it inside the host.
// An API user commits the network configuration to persist a host network interface attachment or detachment, or
// persist the creation and deletion of a bonded interface.
// IMPORTANT: Networking configuration is only committed after the engine has established that host connectivity is
// not lost as a result of the configuration changes. If host connectivity is lost, the host requires a reboot and
// automatically reverts to the previous networking configuration.
// For example, to commit the network configuration of host with id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/commitnetconfig
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
type hostServiceCommitNetConfigResponse struct {
}

//
// Marks the network configuration as good and persists it inside the host.
// An API user commits the network configuration to persist a host network interface attachment or detachment, or
// persist the creation and deletion of a bonded interface.
// IMPORTANT: Networking configuration is only committed after the engine has established that host connectivity is
// not lost as a result of the configuration changes. If host connectivity is lost, the host requires a reboot and
// automatically reverts to the previous networking configuration.
// For example, to commit the network configuration of host with id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/commitnetconfig
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *hostService) CommitNetConfig() *hostServiceCommitNetConfigRequest {
	return &hostServiceCommitNetConfigRequest{hostService: p}
}

//
// Deactivates the host to perform maintenance tasks.
//
type hostServiceDeactivateRequest struct {
	hostService        *hostService
	header             map[string]string
	query              map[string]string
	async              *bool
	reason             *string
	stopGlusterService *bool
}

func (p *hostServiceDeactivateRequest) Header(key, value string) *hostServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceDeactivateRequest) Query(key, value string) *hostServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceDeactivateRequest) Async(async bool) *hostServiceDeactivateRequest {
	p.async = &async
	return p
}

func (p *hostServiceDeactivateRequest) Reason(reason string) *hostServiceDeactivateRequest {
	p.reason = &reason
	return p
}

func (p *hostServiceDeactivateRequest) StopGlusterService(stopGlusterService bool) *hostServiceDeactivateRequest {
	p.stopGlusterService = &stopGlusterService
	return p
}

func (p *hostServiceDeactivateRequest) Send() (*hostServiceDeactivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.reason != nil {
		actionBuilder.Reason(*p.reason)
	}
	if p.stopGlusterService != nil {
		actionBuilder.StopGlusterService(*p.stopGlusterService)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceDeactivateResponse), nil
}

func (p *hostServiceDeactivateRequest) MustSend() *hostServiceDeactivateResponse {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.reason != nil {
		actionBuilder.Reason(*p.reason)
	}
	if p.stopGlusterService != nil {
		actionBuilder.StopGlusterService(*p.stopGlusterService)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceDeactivateResponse)
}

//
// Deactivates the host to perform maintenance tasks.
//
type hostServiceDeactivateResponse struct {
}

//
// Deactivates the host to perform maintenance tasks.
//
func (p *hostService) Deactivate() *hostServiceDeactivateRequest {
	return &hostServiceDeactivateRequest{hostService: p}
}

//
// Enrolls the certificate of the host. Useful in case you get a warning that it is about to expire or has already
// expired.
//
type hostServiceEnrollCertificateRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *hostServiceEnrollCertificateRequest) Header(key, value string) *hostServiceEnrollCertificateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceEnrollCertificateRequest) Query(key, value string) *hostServiceEnrollCertificateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceEnrollCertificateRequest) Async(async bool) *hostServiceEnrollCertificateRequest {
	p.async = &async
	return p
}

func (p *hostServiceEnrollCertificateRequest) Send() (*hostServiceEnrollCertificateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/enrollcertificate", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceEnrollCertificateResponse), nil
}

func (p *hostServiceEnrollCertificateRequest) MustSend() *hostServiceEnrollCertificateResponse {
	rawURL := fmt.Sprintf("%s%s/enrollcertificate", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceEnrollCertificateResponse)
}

//
// Enrolls the certificate of the host. Useful in case you get a warning that it is about to expire or has already
// expired.
//
type hostServiceEnrollCertificateResponse struct {
}

//
// Enrolls the certificate of the host. Useful in case you get a warning that it is about to expire or has already
// expired.
//
func (p *hostService) EnrollCertificate() *hostServiceEnrollCertificateRequest {
	return &hostServiceEnrollCertificateRequest{hostService: p}
}

//
// Controls the host's power management device.
// For example, to start the host. This can be done via:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <fence_type>start</fence_type>
// </action>
// ' \
// "${url}/hosts/123/fence"
// ----
//
type hostServiceFenceRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
	fenceType   *string
}

func (p *hostServiceFenceRequest) Header(key, value string) *hostServiceFenceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceFenceRequest) Query(key, value string) *hostServiceFenceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceFenceRequest) Async(async bool) *hostServiceFenceRequest {
	p.async = &async
	return p
}

func (p *hostServiceFenceRequest) FenceType(fenceType string) *hostServiceFenceRequest {
	p.fenceType = &fenceType
	return p
}

func (p *hostServiceFenceRequest) Send() (*hostServiceFenceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fence", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.fenceType != nil {
		actionBuilder.FenceType(*p.fenceType)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPowerManagement()
	return &hostServiceFenceResponse{powerManagement: result}, nil
}

func (p *hostServiceFenceRequest) MustSend() *hostServiceFenceResponse {
	rawURL := fmt.Sprintf("%s%s/fence", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.fenceType != nil {
		actionBuilder.FenceType(*p.fenceType)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPowerManagement()
	return &hostServiceFenceResponse{powerManagement: result}
}

//
// Controls the host's power management device.
// For example, to start the host. This can be done via:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <fence_type>start</fence_type>
// </action>
// ' \
// "${url}/hosts/123/fence"
// ----
//
type hostServiceFenceResponse struct {
	powerManagement *PowerManagement
}

func (p *hostServiceFenceResponse) PowerManagement() (*PowerManagement, bool) {
	if p.powerManagement != nil {
		return p.powerManagement, true
	}
	return nil, false
}

func (p *hostServiceFenceResponse) MustPowerManagement() *PowerManagement {
	if p.powerManagement == nil {
		panic("powerManagement in response does not exist")
	}
	return p.powerManagement
}

//
// Controls the host's power management device.
// For example, to start the host. This can be done via:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <fence_type>start</fence_type>
// </action>
// ' \
// "${url}/hosts/123/fence"
// ----
//
func (p *hostService) Fence() *hostServiceFenceRequest {
	return &hostServiceFenceRequest{hostService: p}
}

//
// To manually set a host as the storage pool manager (SPM).
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/forceselectspm
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
type hostServiceForceSelectSpmRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *hostServiceForceSelectSpmRequest) Header(key, value string) *hostServiceForceSelectSpmRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceForceSelectSpmRequest) Query(key, value string) *hostServiceForceSelectSpmRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceForceSelectSpmRequest) Async(async bool) *hostServiceForceSelectSpmRequest {
	p.async = &async
	return p
}

func (p *hostServiceForceSelectSpmRequest) Send() (*hostServiceForceSelectSpmResponse, error) {
	rawURL := fmt.Sprintf("%s%s/forceselectspm", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceForceSelectSpmResponse), nil
}

func (p *hostServiceForceSelectSpmRequest) MustSend() *hostServiceForceSelectSpmResponse {
	rawURL := fmt.Sprintf("%s%s/forceselectspm", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceForceSelectSpmResponse)
}

//
// To manually set a host as the storage pool manager (SPM).
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/forceselectspm
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
type hostServiceForceSelectSpmResponse struct {
}

//
// To manually set a host as the storage pool manager (SPM).
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/forceselectspm
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *hostService) ForceSelectSpm() *hostServiceForceSelectSpmRequest {
	return &hostServiceForceSelectSpmRequest{hostService: p}
}

//
// Gets the host details.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123
// ----
//
type hostServiceGetRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	allContent  *bool
	filter      *bool
	follow      *string
}

func (p *hostServiceGetRequest) Header(key, value string) *hostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceGetRequest) Query(key, value string) *hostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceGetRequest) AllContent(allContent bool) *hostServiceGetRequest {
	p.allContent = &allContent
	return p
}

func (p *hostServiceGetRequest) Filter(filter bool) *hostServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *hostServiceGetRequest) Follow(follow string) *hostServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *hostServiceGetRequest) Send() (*hostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostService.connection.URL(), p.hostService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &hostServiceGetResponse{host: result}, nil
}

func (p *hostServiceGetRequest) MustSend() *hostServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostService.connection.URL(), p.hostService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &hostServiceGetResponse{host: result}
}

//
// Gets the host details.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123
// ----
//
type hostServiceGetResponse struct {
	host *Host
}

func (p *hostServiceGetResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *hostServiceGetResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Gets the host details.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123
// ----
//
func (p *hostService) Get() *hostServiceGetRequest {
	return &hostServiceGetRequest{hostService: p}
}

//
// Installs the latest version of VDSM and related software on the host.
// The action also performs every configuration steps on the host which is done during adding host to the engine:
// kdump configuration, hosted-engine deploy, kernel options changes, etc.
// The host type defines additional parameters for the action.
// Example of installing a host, using `curl` and JSON, plain:
// [source,bash]
// ----
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123"
// ----
// Example of installing a host, using `curl` and JSON, with hosted engine components:
// [source,bash]
// ----
// curl \
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123?deploy_hosted_engine=true"
// ----
// IMPORTANT: Since version 4.1.2 of the engine when a host is reinstalled we override the host firewall
// definitions by default.
//
type hostServiceInstallRequest struct {
	hostService          *hostService
	header               map[string]string
	query                map[string]string
	async                *bool
	deployHostedEngine   *bool
	host                 *Host
	image                *string
	rootPassword         *string
	ssh                  *Ssh
	undeployHostedEngine *bool
}

func (p *hostServiceInstallRequest) Header(key, value string) *hostServiceInstallRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceInstallRequest) Query(key, value string) *hostServiceInstallRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceInstallRequest) Async(async bool) *hostServiceInstallRequest {
	p.async = &async
	return p
}

func (p *hostServiceInstallRequest) DeployHostedEngine(deployHostedEngine bool) *hostServiceInstallRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}

func (p *hostServiceInstallRequest) Host(host *Host) *hostServiceInstallRequest {
	p.host = host
	return p
}

func (p *hostServiceInstallRequest) Image(image string) *hostServiceInstallRequest {
	p.image = &image
	return p
}

func (p *hostServiceInstallRequest) RootPassword(rootPassword string) *hostServiceInstallRequest {
	p.rootPassword = &rootPassword
	return p
}

func (p *hostServiceInstallRequest) Ssh(ssh *Ssh) *hostServiceInstallRequest {
	p.ssh = ssh
	return p
}

func (p *hostServiceInstallRequest) UndeployHostedEngine(undeployHostedEngine bool) *hostServiceInstallRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}

func (p *hostServiceInstallRequest) Send() (*hostServiceInstallResponse, error) {
	rawURL := fmt.Sprintf("%s%s/install", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.image != nil {
		actionBuilder.Image(*p.image)
	}
	if p.rootPassword != nil {
		actionBuilder.RootPassword(*p.rootPassword)
	}
	actionBuilder.Ssh(p.ssh)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceInstallResponse), nil
}

func (p *hostServiceInstallRequest) MustSend() *hostServiceInstallResponse {
	rawURL := fmt.Sprintf("%s%s/install", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.image != nil {
		actionBuilder.Image(*p.image)
	}
	if p.rootPassword != nil {
		actionBuilder.RootPassword(*p.rootPassword)
	}
	actionBuilder.Ssh(p.ssh)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceInstallResponse)
}

//
// Installs the latest version of VDSM and related software on the host.
// The action also performs every configuration steps on the host which is done during adding host to the engine:
// kdump configuration, hosted-engine deploy, kernel options changes, etc.
// The host type defines additional parameters for the action.
// Example of installing a host, using `curl` and JSON, plain:
// [source,bash]
// ----
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123"
// ----
// Example of installing a host, using `curl` and JSON, with hosted engine components:
// [source,bash]
// ----
// curl \
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123?deploy_hosted_engine=true"
// ----
// IMPORTANT: Since version 4.1.2 of the engine when a host is reinstalled we override the host firewall
// definitions by default.
//
type hostServiceInstallResponse struct {
}

//
// Installs the latest version of VDSM and related software on the host.
// The action also performs every configuration steps on the host which is done during adding host to the engine:
// kdump configuration, hosted-engine deploy, kernel options changes, etc.
// The host type defines additional parameters for the action.
// Example of installing a host, using `curl` and JSON, plain:
// [source,bash]
// ----
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123"
// ----
// Example of installing a host, using `curl` and JSON, with hosted engine components:
// [source,bash]
// ----
// curl \
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123?deploy_hosted_engine=true"
// ----
// IMPORTANT: Since version 4.1.2 of the engine when a host is reinstalled we override the host firewall
// definitions by default.
//
func (p *hostService) Install() *hostServiceInstallRequest {
	return &hostServiceInstallRequest{hostService: p}
}

//
// Discovers iSCSI targets on the host, using the initiator details.
// For example, to discover iSCSI targets available in `myiscsi.example.com`,
// from host `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/iscsidiscover
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <iscsi>
//     <address>myiscsi.example.com</address>
//   </iscsi>
// </action>
// ----
// The result will be like this:
// [source,xml]
// ----
// <discovered_targets>
//   <iscsi_details>
//     <address>10.35.1.72</address>
//     <port>3260</port>
//     <portal>10.35.1.72:3260,1</portal>
//     <target>iqn.2015-08.com.tgt:444</target>
//   </iscsi_details>
// </discovered_targets>
// ----
//
type hostServiceIscsiDiscoverRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
	iscsi       *IscsiDetails
}

func (p *hostServiceIscsiDiscoverRequest) Header(key, value string) *hostServiceIscsiDiscoverRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceIscsiDiscoverRequest) Query(key, value string) *hostServiceIscsiDiscoverRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceIscsiDiscoverRequest) Async(async bool) *hostServiceIscsiDiscoverRequest {
	p.async = &async
	return p
}

func (p *hostServiceIscsiDiscoverRequest) Iscsi(iscsi *IscsiDetails) *hostServiceIscsiDiscoverRequest {
	p.iscsi = iscsi
	return p
}

func (p *hostServiceIscsiDiscoverRequest) Send() (*hostServiceIscsiDiscoverResponse, error) {
	rawURL := fmt.Sprintf("%s%s/iscsidiscover", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Iscsi(p.iscsi)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustIscsiTargets()
	return &hostServiceIscsiDiscoverResponse{iscsiTargets: result}, nil
}

func (p *hostServiceIscsiDiscoverRequest) MustSend() *hostServiceIscsiDiscoverResponse {
	rawURL := fmt.Sprintf("%s%s/iscsidiscover", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Iscsi(p.iscsi)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustIscsiTargets()
	return &hostServiceIscsiDiscoverResponse{iscsiTargets: result}
}

//
// Discovers iSCSI targets on the host, using the initiator details.
// For example, to discover iSCSI targets available in `myiscsi.example.com`,
// from host `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/iscsidiscover
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <iscsi>
//     <address>myiscsi.example.com</address>
//   </iscsi>
// </action>
// ----
// The result will be like this:
// [source,xml]
// ----
// <discovered_targets>
//   <iscsi_details>
//     <address>10.35.1.72</address>
//     <port>3260</port>
//     <portal>10.35.1.72:3260,1</portal>
//     <target>iqn.2015-08.com.tgt:444</target>
//   </iscsi_details>
// </discovered_targets>
// ----
//
type hostServiceIscsiDiscoverResponse struct {
	discoveredTargets *IscsiDetailsSlice
	iscsiTargets      []string
}

func (p *hostServiceIscsiDiscoverResponse) DiscoveredTargets() (*IscsiDetailsSlice, bool) {
	if p.discoveredTargets != nil {
		return p.discoveredTargets, true
	}
	return nil, false
}

func (p *hostServiceIscsiDiscoverResponse) MustDiscoveredTargets() *IscsiDetailsSlice {
	if p.discoveredTargets == nil {
		panic("discoveredTargets in response does not exist")
	}
	return p.discoveredTargets
}

func (p *hostServiceIscsiDiscoverResponse) IscsiTargets() ([]string, bool) {
	if p.iscsiTargets != nil {
		return p.iscsiTargets, true
	}
	return nil, false
}

func (p *hostServiceIscsiDiscoverResponse) MustIscsiTargets() []string {
	if p.iscsiTargets == nil {
		panic("iscsiTargets in response does not exist")
	}
	return p.iscsiTargets
}

//
// Discovers iSCSI targets on the host, using the initiator details.
// For example, to discover iSCSI targets available in `myiscsi.example.com`,
// from host `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/iscsidiscover
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <iscsi>
//     <address>myiscsi.example.com</address>
//   </iscsi>
// </action>
// ----
// The result will be like this:
// [source,xml]
// ----
// <discovered_targets>
//   <iscsi_details>
//     <address>10.35.1.72</address>
//     <port>3260</port>
//     <portal>10.35.1.72:3260,1</portal>
//     <target>iqn.2015-08.com.tgt:444</target>
//   </iscsi_details>
// </discovered_targets>
// ----
//
func (p *hostService) IscsiDiscover() *hostServiceIscsiDiscoverRequest {
	return &hostServiceIscsiDiscoverRequest{hostService: p}
}

//
// Login to iSCSI targets on the host, using the target details.
//
type hostServiceIscsiLoginRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
	iscsi       *IscsiDetails
}

func (p *hostServiceIscsiLoginRequest) Header(key, value string) *hostServiceIscsiLoginRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceIscsiLoginRequest) Query(key, value string) *hostServiceIscsiLoginRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceIscsiLoginRequest) Async(async bool) *hostServiceIscsiLoginRequest {
	p.async = &async
	return p
}

func (p *hostServiceIscsiLoginRequest) Iscsi(iscsi *IscsiDetails) *hostServiceIscsiLoginRequest {
	p.iscsi = iscsi
	return p
}

func (p *hostServiceIscsiLoginRequest) Send() (*hostServiceIscsiLoginResponse, error) {
	rawURL := fmt.Sprintf("%s%s/iscsilogin", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Iscsi(p.iscsi)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceIscsiLoginResponse), nil
}

func (p *hostServiceIscsiLoginRequest) MustSend() *hostServiceIscsiLoginResponse {
	rawURL := fmt.Sprintf("%s%s/iscsilogin", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Iscsi(p.iscsi)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceIscsiLoginResponse)
}

//
// Login to iSCSI targets on the host, using the target details.
//
type hostServiceIscsiLoginResponse struct {
}

//
// Login to iSCSI targets on the host, using the target details.
//
func (p *hostService) IscsiLogin() *hostServiceIscsiLoginRequest {
	return &hostServiceIscsiLoginRequest{hostService: p}
}

//
// Refresh the host devices and capabilities.
//
type hostServiceRefreshRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *hostServiceRefreshRequest) Header(key, value string) *hostServiceRefreshRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceRefreshRequest) Query(key, value string) *hostServiceRefreshRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceRefreshRequest) Async(async bool) *hostServiceRefreshRequest {
	p.async = &async
	return p
}

func (p *hostServiceRefreshRequest) Send() (*hostServiceRefreshResponse, error) {
	rawURL := fmt.Sprintf("%s%s/refresh", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceRefreshResponse), nil
}

func (p *hostServiceRefreshRequest) MustSend() *hostServiceRefreshResponse {
	rawURL := fmt.Sprintf("%s%s/refresh", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceRefreshResponse)
}

//
// Refresh the host devices and capabilities.
//
type hostServiceRefreshResponse struct {
}

//
// Refresh the host devices and capabilities.
//
func (p *hostService) Refresh() *hostServiceRefreshRequest {
	return &hostServiceRefreshRequest{hostService: p}
}

//
// Remove the host from the system.
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request DELETE \
// --header "Version: 4" \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc"
// ----
//
type hostServiceRemoveRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *hostServiceRemoveRequest) Header(key, value string) *hostServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceRemoveRequest) Query(key, value string) *hostServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceRemoveRequest) Async(async bool) *hostServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *hostServiceRemoveRequest) Send() (*hostServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostService.connection.URL(), p.hostService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(hostServiceRemoveResponse), nil
}

func (p *hostServiceRemoveRequest) MustSend() *hostServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostService.connection.URL(), p.hostService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(hostServiceRemoveResponse)
}

//
// Remove the host from the system.
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request DELETE \
// --header "Version: 4" \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc"
// ----
//
type hostServiceRemoveResponse struct {
}

//
// Remove the host from the system.
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request DELETE \
// --header "Version: 4" \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc"
// ----
//
func (p *hostService) Remove() *hostServiceRemoveRequest {
	return &hostServiceRemoveRequest{hostService: p}
}

//
// This method is used to change the configuration of the network interfaces of a host.
// For example, if you have a host with three network interfaces `eth0`, `eth1` and `eth2` and you want to configure
// a new bond using `eth0` and `eth1`, and put a VLAN on top of it. Using a simple shell script and the `curl`
// command line HTTP client that can be done as follows:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <modified_bonds>
//     <host_nic>
//       <name>bond0</name>
//       <bonding>
//         <options>
//           <option>
//             <name>mode</name>
//             <value>4</value>
//           </option>
//           <option>
//             <name>miimon</name>
//             <value>100</value>
//           </option>
//         </options>
//         <slaves>
//           <host_nic>
//             <name>eth1</name>
//           </host_nic>
//           <host_nic>
//             <name>eth2</name>
//           </host_nic>
//         </slaves>
//       </bonding>
//     </host_nic>
//   </modified_bonds>
//   <modified_network_attachments>
//     <network_attachment>
//       <network>
//         <name>myvlan</name>
//       </network>
//       <host_nic>
//         <name>bond0</name>
//       </host_nic>
//       <ip_address_assignments>
//         <assignment_method>static</assignment_method>
//         <ip_address_assignment>
//           <ip>
//             <address>192.168.122.10</address>
//             <netmask>255.255.255.0</netmask>
//           </ip>
//         </ip_address_assignment>
//       </ip_address_assignments>
//       <dns_resolver_configuration>
//         <name_servers>
//           <name_server>1.1.1.1</name_server>
//           <name_server>2.2.2.2</name_server>
//         </name_servers>
//       </dns_resolver_configuration>
//     </network_attachment>
//   </modified_network_attachments>
//  </action>
// ' \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc/setupnetworks"
// ----
// NOTE: This is valid for version 4 of the API. In previous versions some elements were represented as XML
// attributes instead of XML elements. In particular the `options` and `ip` elements were represented as follows:
// [source,xml]
// ----
// <options name="mode" value="4"/>
// <options name="miimon" value="100"/>
// <ip address="192.168.122.10" netmask="255.255.255.0"/>
// ----
// Using the Python SDK the same can be done with the following code:
// [source,python]
// ----
// # Find the service that manages the collection of hosts:
// hosts_service = connection.system_service().hosts_service()
// # Find the host:
// host = hosts_service.list(search='name=myhost')[0]
// # Find the service that manages the host:
// host_service = hosts_service.host_service(host.id)
// # Configure the network adding a bond with two slaves and attaching it to a
// # network with an static IP address:
// host_service.setup_networks(
//     modified_bonds=[
//         types.HostNic(
//             name='bond0',
//             bonding=types.Bonding(
//                 options=[
//                     types.Option(
//                         name='mode',
//                         value='4',
//                     ),
//                     types.Option(
//                         name='miimon',
//                         value='100',
//                     ),
//                 ],
//                 slaves=[
//                     types.HostNic(
//                         name='eth1',
//                     ),
//                     types.HostNic(
//                         name='eth2',
//                     ),
//                 ],
//             ),
//         ),
//     ],
//     modified_network_attachments=[
//         types.NetworkAttachment(
//             network=types.Network(
//                 name='myvlan',
//             ),
//             host_nic=types.HostNic(
//                 name='bond0',
//             ),
//             ip_address_assignments=[
//                 types.IpAddressAssignment(
//                     assignment_method=types.BootProtocol.STATIC,
//                     ip=types.Ip(
//                         address='192.168.122.10',
//                         netmask='255.255.255.0',
//                     ),
//                 ),
//             ],
//             dns_resolver_configuration=types.DnsResolverConfiguration(
//                 name_servers=[
//                     '1.1.1.1',
//                     '2.2.2.2',
//                 ],
//             ),
//         ),
//     ],
// )
// # After modifying the network configuration it is very important to make it
// # persistent:
// host_service.commit_net_config()
// ----
// IMPORTANT: To make sure that the network configuration has been saved in the host, and that it will be applied
// when the host is rebooted, remember to call <<services/host/methods/commit_net_config, commitnetconfig>>.
//
type hostServiceSetupNetworksRequest struct {
	hostService                    *hostService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	checkConnectivity              *bool
	connectivityTimeout            *int64
	modifiedBonds                  *HostNicSlice
	modifiedLabels                 *NetworkLabelSlice
	modifiedNetworkAttachments     *NetworkAttachmentSlice
	removedBonds                   *HostNicSlice
	removedLabels                  *NetworkLabelSlice
	removedNetworkAttachments      *NetworkAttachmentSlice
	synchronizedNetworkAttachments *NetworkAttachmentSlice
}

func (p *hostServiceSetupNetworksRequest) Header(key, value string) *hostServiceSetupNetworksRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceSetupNetworksRequest) Query(key, value string) *hostServiceSetupNetworksRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceSetupNetworksRequest) Async(async bool) *hostServiceSetupNetworksRequest {
	p.async = &async
	return p
}

func (p *hostServiceSetupNetworksRequest) CheckConnectivity(checkConnectivity bool) *hostServiceSetupNetworksRequest {
	p.checkConnectivity = &checkConnectivity
	return p
}

func (p *hostServiceSetupNetworksRequest) ConnectivityTimeout(connectivityTimeout int64) *hostServiceSetupNetworksRequest {
	p.connectivityTimeout = &connectivityTimeout
	return p
}

func (p *hostServiceSetupNetworksRequest) ModifiedBonds(modifiedBonds *HostNicSlice) *hostServiceSetupNetworksRequest {
	p.modifiedBonds = modifiedBonds
	return p
}

func (p *hostServiceSetupNetworksRequest) ModifiedBondsOfAny(anys ...*HostNic) *hostServiceSetupNetworksRequest {
	if p.modifiedBonds == nil {
		p.modifiedBonds = new(HostNicSlice)
	}
	p.modifiedBonds.slice = append(p.modifiedBonds.slice, anys...)
	return p
}

func (p *hostServiceSetupNetworksRequest) ModifiedLabels(modifiedLabels *NetworkLabelSlice) *hostServiceSetupNetworksRequest {
	p.modifiedLabels = modifiedLabels
	return p
}

func (p *hostServiceSetupNetworksRequest) ModifiedLabelsOfAny(anys ...*NetworkLabel) *hostServiceSetupNetworksRequest {
	if p.modifiedLabels == nil {
		p.modifiedLabels = new(NetworkLabelSlice)
	}
	p.modifiedLabels.slice = append(p.modifiedLabels.slice, anys...)
	return p
}

func (p *hostServiceSetupNetworksRequest) ModifiedNetworkAttachments(modifiedNetworkAttachments *NetworkAttachmentSlice) *hostServiceSetupNetworksRequest {
	p.modifiedNetworkAttachments = modifiedNetworkAttachments
	return p
}

func (p *hostServiceSetupNetworksRequest) ModifiedNetworkAttachmentsOfAny(anys ...*NetworkAttachment) *hostServiceSetupNetworksRequest {
	if p.modifiedNetworkAttachments == nil {
		p.modifiedNetworkAttachments = new(NetworkAttachmentSlice)
	}
	p.modifiedNetworkAttachments.slice = append(p.modifiedNetworkAttachments.slice, anys...)
	return p
}

func (p *hostServiceSetupNetworksRequest) RemovedBonds(removedBonds *HostNicSlice) *hostServiceSetupNetworksRequest {
	p.removedBonds = removedBonds
	return p
}

func (p *hostServiceSetupNetworksRequest) RemovedBondsOfAny(anys ...*HostNic) *hostServiceSetupNetworksRequest {
	if p.removedBonds == nil {
		p.removedBonds = new(HostNicSlice)
	}
	p.removedBonds.slice = append(p.removedBonds.slice, anys...)
	return p
}

func (p *hostServiceSetupNetworksRequest) RemovedLabels(removedLabels *NetworkLabelSlice) *hostServiceSetupNetworksRequest {
	p.removedLabels = removedLabels
	return p
}

func (p *hostServiceSetupNetworksRequest) RemovedLabelsOfAny(anys ...*NetworkLabel) *hostServiceSetupNetworksRequest {
	if p.removedLabels == nil {
		p.removedLabels = new(NetworkLabelSlice)
	}
	p.removedLabels.slice = append(p.removedLabels.slice, anys...)
	return p
}

func (p *hostServiceSetupNetworksRequest) RemovedNetworkAttachments(removedNetworkAttachments *NetworkAttachmentSlice) *hostServiceSetupNetworksRequest {
	p.removedNetworkAttachments = removedNetworkAttachments
	return p
}

func (p *hostServiceSetupNetworksRequest) RemovedNetworkAttachmentsOfAny(anys ...*NetworkAttachment) *hostServiceSetupNetworksRequest {
	if p.removedNetworkAttachments == nil {
		p.removedNetworkAttachments = new(NetworkAttachmentSlice)
	}
	p.removedNetworkAttachments.slice = append(p.removedNetworkAttachments.slice, anys...)
	return p
}

func (p *hostServiceSetupNetworksRequest) SynchronizedNetworkAttachments(synchronizedNetworkAttachments *NetworkAttachmentSlice) *hostServiceSetupNetworksRequest {
	p.synchronizedNetworkAttachments = synchronizedNetworkAttachments
	return p
}

func (p *hostServiceSetupNetworksRequest) SynchronizedNetworkAttachmentsOfAny(anys ...*NetworkAttachment) *hostServiceSetupNetworksRequest {
	if p.synchronizedNetworkAttachments == nil {
		p.synchronizedNetworkAttachments = new(NetworkAttachmentSlice)
	}
	p.synchronizedNetworkAttachments.slice = append(p.synchronizedNetworkAttachments.slice, anys...)
	return p
}

func (p *hostServiceSetupNetworksRequest) Send() (*hostServiceSetupNetworksResponse, error) {
	rawURL := fmt.Sprintf("%s%s/setupnetworks", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.checkConnectivity != nil {
		actionBuilder.CheckConnectivity(*p.checkConnectivity)
	}
	if p.connectivityTimeout != nil {
		actionBuilder.ConnectivityTimeout(*p.connectivityTimeout)
	}
	actionBuilder.ModifiedBonds(p.modifiedBonds)
	actionBuilder.ModifiedLabels(p.modifiedLabels)
	actionBuilder.ModifiedNetworkAttachments(p.modifiedNetworkAttachments)
	actionBuilder.RemovedBonds(p.removedBonds)
	actionBuilder.RemovedLabels(p.removedLabels)
	actionBuilder.RemovedNetworkAttachments(p.removedNetworkAttachments)
	actionBuilder.SynchronizedNetworkAttachments(p.synchronizedNetworkAttachments)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceSetupNetworksResponse), nil
}

func (p *hostServiceSetupNetworksRequest) MustSend() *hostServiceSetupNetworksResponse {
	rawURL := fmt.Sprintf("%s%s/setupnetworks", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.checkConnectivity != nil {
		actionBuilder.CheckConnectivity(*p.checkConnectivity)
	}
	if p.connectivityTimeout != nil {
		actionBuilder.ConnectivityTimeout(*p.connectivityTimeout)
	}
	actionBuilder.ModifiedBonds(p.modifiedBonds)
	actionBuilder.ModifiedLabels(p.modifiedLabels)
	actionBuilder.ModifiedNetworkAttachments(p.modifiedNetworkAttachments)
	actionBuilder.RemovedBonds(p.removedBonds)
	actionBuilder.RemovedLabels(p.removedLabels)
	actionBuilder.RemovedNetworkAttachments(p.removedNetworkAttachments)
	actionBuilder.SynchronizedNetworkAttachments(p.synchronizedNetworkAttachments)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceSetupNetworksResponse)
}

//
// This method is used to change the configuration of the network interfaces of a host.
// For example, if you have a host with three network interfaces `eth0`, `eth1` and `eth2` and you want to configure
// a new bond using `eth0` and `eth1`, and put a VLAN on top of it. Using a simple shell script and the `curl`
// command line HTTP client that can be done as follows:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <modified_bonds>
//     <host_nic>
//       <name>bond0</name>
//       <bonding>
//         <options>
//           <option>
//             <name>mode</name>
//             <value>4</value>
//           </option>
//           <option>
//             <name>miimon</name>
//             <value>100</value>
//           </option>
//         </options>
//         <slaves>
//           <host_nic>
//             <name>eth1</name>
//           </host_nic>
//           <host_nic>
//             <name>eth2</name>
//           </host_nic>
//         </slaves>
//       </bonding>
//     </host_nic>
//   </modified_bonds>
//   <modified_network_attachments>
//     <network_attachment>
//       <network>
//         <name>myvlan</name>
//       </network>
//       <host_nic>
//         <name>bond0</name>
//       </host_nic>
//       <ip_address_assignments>
//         <assignment_method>static</assignment_method>
//         <ip_address_assignment>
//           <ip>
//             <address>192.168.122.10</address>
//             <netmask>255.255.255.0</netmask>
//           </ip>
//         </ip_address_assignment>
//       </ip_address_assignments>
//       <dns_resolver_configuration>
//         <name_servers>
//           <name_server>1.1.1.1</name_server>
//           <name_server>2.2.2.2</name_server>
//         </name_servers>
//       </dns_resolver_configuration>
//     </network_attachment>
//   </modified_network_attachments>
//  </action>
// ' \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc/setupnetworks"
// ----
// NOTE: This is valid for version 4 of the API. In previous versions some elements were represented as XML
// attributes instead of XML elements. In particular the `options` and `ip` elements were represented as follows:
// [source,xml]
// ----
// <options name="mode" value="4"/>
// <options name="miimon" value="100"/>
// <ip address="192.168.122.10" netmask="255.255.255.0"/>
// ----
// Using the Python SDK the same can be done with the following code:
// [source,python]
// ----
// # Find the service that manages the collection of hosts:
// hosts_service = connection.system_service().hosts_service()
// # Find the host:
// host = hosts_service.list(search='name=myhost')[0]
// # Find the service that manages the host:
// host_service = hosts_service.host_service(host.id)
// # Configure the network adding a bond with two slaves and attaching it to a
// # network with an static IP address:
// host_service.setup_networks(
//     modified_bonds=[
//         types.HostNic(
//             name='bond0',
//             bonding=types.Bonding(
//                 options=[
//                     types.Option(
//                         name='mode',
//                         value='4',
//                     ),
//                     types.Option(
//                         name='miimon',
//                         value='100',
//                     ),
//                 ],
//                 slaves=[
//                     types.HostNic(
//                         name='eth1',
//                     ),
//                     types.HostNic(
//                         name='eth2',
//                     ),
//                 ],
//             ),
//         ),
//     ],
//     modified_network_attachments=[
//         types.NetworkAttachment(
//             network=types.Network(
//                 name='myvlan',
//             ),
//             host_nic=types.HostNic(
//                 name='bond0',
//             ),
//             ip_address_assignments=[
//                 types.IpAddressAssignment(
//                     assignment_method=types.BootProtocol.STATIC,
//                     ip=types.Ip(
//                         address='192.168.122.10',
//                         netmask='255.255.255.0',
//                     ),
//                 ),
//             ],
//             dns_resolver_configuration=types.DnsResolverConfiguration(
//                 name_servers=[
//                     '1.1.1.1',
//                     '2.2.2.2',
//                 ],
//             ),
//         ),
//     ],
// )
// # After modifying the network configuration it is very important to make it
// # persistent:
// host_service.commit_net_config()
// ----
// IMPORTANT: To make sure that the network configuration has been saved in the host, and that it will be applied
// when the host is rebooted, remember to call <<services/host/methods/commit_net_config, commitnetconfig>>.
//
type hostServiceSetupNetworksResponse struct {
}

//
// This method is used to change the configuration of the network interfaces of a host.
// For example, if you have a host with three network interfaces `eth0`, `eth1` and `eth2` and you want to configure
// a new bond using `eth0` and `eth1`, and put a VLAN on top of it. Using a simple shell script and the `curl`
// command line HTTP client that can be done as follows:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <modified_bonds>
//     <host_nic>
//       <name>bond0</name>
//       <bonding>
//         <options>
//           <option>
//             <name>mode</name>
//             <value>4</value>
//           </option>
//           <option>
//             <name>miimon</name>
//             <value>100</value>
//           </option>
//         </options>
//         <slaves>
//           <host_nic>
//             <name>eth1</name>
//           </host_nic>
//           <host_nic>
//             <name>eth2</name>
//           </host_nic>
//         </slaves>
//       </bonding>
//     </host_nic>
//   </modified_bonds>
//   <modified_network_attachments>
//     <network_attachment>
//       <network>
//         <name>myvlan</name>
//       </network>
//       <host_nic>
//         <name>bond0</name>
//       </host_nic>
//       <ip_address_assignments>
//         <assignment_method>static</assignment_method>
//         <ip_address_assignment>
//           <ip>
//             <address>192.168.122.10</address>
//             <netmask>255.255.255.0</netmask>
//           </ip>
//         </ip_address_assignment>
//       </ip_address_assignments>
//       <dns_resolver_configuration>
//         <name_servers>
//           <name_server>1.1.1.1</name_server>
//           <name_server>2.2.2.2</name_server>
//         </name_servers>
//       </dns_resolver_configuration>
//     </network_attachment>
//   </modified_network_attachments>
//  </action>
// ' \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc/setupnetworks"
// ----
// NOTE: This is valid for version 4 of the API. In previous versions some elements were represented as XML
// attributes instead of XML elements. In particular the `options` and `ip` elements were represented as follows:
// [source,xml]
// ----
// <options name="mode" value="4"/>
// <options name="miimon" value="100"/>
// <ip address="192.168.122.10" netmask="255.255.255.0"/>
// ----
// Using the Python SDK the same can be done with the following code:
// [source,python]
// ----
// # Find the service that manages the collection of hosts:
// hosts_service = connection.system_service().hosts_service()
// # Find the host:
// host = hosts_service.list(search='name=myhost')[0]
// # Find the service that manages the host:
// host_service = hosts_service.host_service(host.id)
// # Configure the network adding a bond with two slaves and attaching it to a
// # network with an static IP address:
// host_service.setup_networks(
//     modified_bonds=[
//         types.HostNic(
//             name='bond0',
//             bonding=types.Bonding(
//                 options=[
//                     types.Option(
//                         name='mode',
//                         value='4',
//                     ),
//                     types.Option(
//                         name='miimon',
//                         value='100',
//                     ),
//                 ],
//                 slaves=[
//                     types.HostNic(
//                         name='eth1',
//                     ),
//                     types.HostNic(
//                         name='eth2',
//                     ),
//                 ],
//             ),
//         ),
//     ],
//     modified_network_attachments=[
//         types.NetworkAttachment(
//             network=types.Network(
//                 name='myvlan',
//             ),
//             host_nic=types.HostNic(
//                 name='bond0',
//             ),
//             ip_address_assignments=[
//                 types.IpAddressAssignment(
//                     assignment_method=types.BootProtocol.STATIC,
//                     ip=types.Ip(
//                         address='192.168.122.10',
//                         netmask='255.255.255.0',
//                     ),
//                 ),
//             ],
//             dns_resolver_configuration=types.DnsResolverConfiguration(
//                 name_servers=[
//                     '1.1.1.1',
//                     '2.2.2.2',
//                 ],
//             ),
//         ),
//     ],
// )
// # After modifying the network configuration it is very important to make it
// # persistent:
// host_service.commit_net_config()
// ----
// IMPORTANT: To make sure that the network configuration has been saved in the host, and that it will be applied
// when the host is rebooted, remember to call <<services/host/methods/commit_net_config, commitnetconfig>>.
//
func (p *hostService) SetupNetworks() *hostServiceSetupNetworksRequest {
	return &hostServiceSetupNetworksRequest{hostService: p}
}

//
// To synchronize all networks on the host, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/syncallnetworks
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
type hostServiceSyncAllNetworksRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *hostServiceSyncAllNetworksRequest) Header(key, value string) *hostServiceSyncAllNetworksRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceSyncAllNetworksRequest) Query(key, value string) *hostServiceSyncAllNetworksRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceSyncAllNetworksRequest) Async(async bool) *hostServiceSyncAllNetworksRequest {
	p.async = &async
	return p
}

func (p *hostServiceSyncAllNetworksRequest) Send() (*hostServiceSyncAllNetworksResponse, error) {
	rawURL := fmt.Sprintf("%s%s/syncallnetworks", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceSyncAllNetworksResponse), nil
}

func (p *hostServiceSyncAllNetworksRequest) MustSend() *hostServiceSyncAllNetworksResponse {
	rawURL := fmt.Sprintf("%s%s/syncallnetworks", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceSyncAllNetworksResponse)
}

//
// To synchronize all networks on the host, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/syncallnetworks
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
type hostServiceSyncAllNetworksResponse struct {
}

//
// To synchronize all networks on the host, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/syncallnetworks
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *hostService) SyncAllNetworks() *hostServiceSyncAllNetworksRequest {
	return &hostServiceSyncAllNetworksRequest{hostService: p}
}

//
// Discovers the block Storage Domains which are candidates to be imported to the setup. For FCP no arguments are
// required.
//
type hostServiceUnregisteredStorageDomainsDiscoverRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
	iscsi       *IscsiDetails
}

func (p *hostServiceUnregisteredStorageDomainsDiscoverRequest) Header(key, value string) *hostServiceUnregisteredStorageDomainsDiscoverRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceUnregisteredStorageDomainsDiscoverRequest) Query(key, value string) *hostServiceUnregisteredStorageDomainsDiscoverRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceUnregisteredStorageDomainsDiscoverRequest) Async(async bool) *hostServiceUnregisteredStorageDomainsDiscoverRequest {
	p.async = &async
	return p
}

func (p *hostServiceUnregisteredStorageDomainsDiscoverRequest) Iscsi(iscsi *IscsiDetails) *hostServiceUnregisteredStorageDomainsDiscoverRequest {
	p.iscsi = iscsi
	return p
}

func (p *hostServiceUnregisteredStorageDomainsDiscoverRequest) Send() (*hostServiceUnregisteredStorageDomainsDiscoverResponse, error) {
	rawURL := fmt.Sprintf("%s%s/unregisteredstoragedomainsdiscover", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Iscsi(p.iscsi)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustStorageDomains()
	return &hostServiceUnregisteredStorageDomainsDiscoverResponse{storageDomains: result}, nil
}

func (p *hostServiceUnregisteredStorageDomainsDiscoverRequest) MustSend() *hostServiceUnregisteredStorageDomainsDiscoverResponse {
	rawURL := fmt.Sprintf("%s%s/unregisteredstoragedomainsdiscover", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Iscsi(p.iscsi)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustStorageDomains()
	return &hostServiceUnregisteredStorageDomainsDiscoverResponse{storageDomains: result}
}

//
// Discovers the block Storage Domains which are candidates to be imported to the setup. For FCP no arguments are
// required.
//
type hostServiceUnregisteredStorageDomainsDiscoverResponse struct {
	storageDomains *StorageDomainSlice
}

func (p *hostServiceUnregisteredStorageDomainsDiscoverResponse) StorageDomains() (*StorageDomainSlice, bool) {
	if p.storageDomains != nil {
		return p.storageDomains, true
	}
	return nil, false
}

func (p *hostServiceUnregisteredStorageDomainsDiscoverResponse) MustStorageDomains() *StorageDomainSlice {
	if p.storageDomains == nil {
		panic("storageDomains in response does not exist")
	}
	return p.storageDomains
}

//
// Discovers the block Storage Domains which are candidates to be imported to the setup. For FCP no arguments are
// required.
//
func (p *hostService) UnregisteredStorageDomainsDiscover() *hostServiceUnregisteredStorageDomainsDiscoverRequest {
	return &hostServiceUnregisteredStorageDomainsDiscoverRequest{hostService: p}
}

//
// Update the host properties.
// For example, to update a the kernel command line of a host send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123
// ----
// With request body like this:
// [source, xml]
// ----
// <host>
//   <os>
//     <custom_kernel_cmdline>vfio_iommu_type1.allow_unsafe_interrupts=1</custom_kernel_cmdline>
//   </os>
// </host>
// ----
//
type hostServiceUpdateRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
	host        *Host
}

func (p *hostServiceUpdateRequest) Header(key, value string) *hostServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceUpdateRequest) Query(key, value string) *hostServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceUpdateRequest) Async(async bool) *hostServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *hostServiceUpdateRequest) Host(host *Host) *hostServiceUpdateRequest {
	p.host = host
	return p
}

func (p *hostServiceUpdateRequest) Send() (*hostServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostService.connection.URL(), p.hostService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostWriteOne(writer, p.host, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &hostServiceUpdateResponse{host: result}, nil
}

func (p *hostServiceUpdateRequest) MustSend() *hostServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostService.connection.URL(), p.hostService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostWriteOne(writer, p.host, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &hostServiceUpdateResponse{host: result}
}

//
// Update the host properties.
// For example, to update a the kernel command line of a host send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123
// ----
// With request body like this:
// [source, xml]
// ----
// <host>
//   <os>
//     <custom_kernel_cmdline>vfio_iommu_type1.allow_unsafe_interrupts=1</custom_kernel_cmdline>
//   </os>
// </host>
// ----
//
type hostServiceUpdateResponse struct {
	host *Host
}

func (p *hostServiceUpdateResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *hostServiceUpdateResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Update the host properties.
// For example, to update a the kernel command line of a host send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123
// ----
// With request body like this:
// [source, xml]
// ----
// <host>
//   <os>
//     <custom_kernel_cmdline>vfio_iommu_type1.allow_unsafe_interrupts=1</custom_kernel_cmdline>
//   </os>
// </host>
// ----
//
func (p *hostService) Update() *hostServiceUpdateRequest {
	return &hostServiceUpdateRequest{hostService: p}
}

//
// Upgrades VDSM and selected software on the host.
//
type hostServiceUpgradeRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
	image       *string
	reboot      *bool
}

func (p *hostServiceUpgradeRequest) Header(key, value string) *hostServiceUpgradeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceUpgradeRequest) Query(key, value string) *hostServiceUpgradeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceUpgradeRequest) Async(async bool) *hostServiceUpgradeRequest {
	p.async = &async
	return p
}

func (p *hostServiceUpgradeRequest) Image(image string) *hostServiceUpgradeRequest {
	p.image = &image
	return p
}

func (p *hostServiceUpgradeRequest) Reboot(reboot bool) *hostServiceUpgradeRequest {
	p.reboot = &reboot
	return p
}

func (p *hostServiceUpgradeRequest) Send() (*hostServiceUpgradeResponse, error) {
	rawURL := fmt.Sprintf("%s%s/upgrade", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.image != nil {
		actionBuilder.Image(*p.image)
	}
	if p.reboot != nil {
		actionBuilder.Reboot(*p.reboot)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceUpgradeResponse), nil
}

func (p *hostServiceUpgradeRequest) MustSend() *hostServiceUpgradeResponse {
	rawURL := fmt.Sprintf("%s%s/upgrade", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.image != nil {
		actionBuilder.Image(*p.image)
	}
	if p.reboot != nil {
		actionBuilder.Reboot(*p.reboot)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceUpgradeResponse)
}

//
// Upgrades VDSM and selected software on the host.
//
type hostServiceUpgradeResponse struct {
}

//
// Upgrades VDSM and selected software on the host.
//
func (p *hostService) Upgrade() *hostServiceUpgradeRequest {
	return &hostServiceUpgradeRequest{hostService: p}
}

//
// Check if there are upgrades available for the host. If there are upgrades available an icon will be displayed
// next to host status icon in the Administration Portal. Audit log messages are also added to indicate the
// availability of upgrades. The upgrade can be started from the webadmin or by using the
// <<services/host/methods/upgrade, upgrade>> host action.
//
type hostServiceUpgradeCheckRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
}

func (p *hostServiceUpgradeCheckRequest) Header(key, value string) *hostServiceUpgradeCheckRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceUpgradeCheckRequest) Query(key, value string) *hostServiceUpgradeCheckRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceUpgradeCheckRequest) Send() (*hostServiceUpgradeCheckResponse, error) {
	rawURL := fmt.Sprintf("%s%s/upgradecheck", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceUpgradeCheckResponse), nil
}

func (p *hostServiceUpgradeCheckRequest) MustSend() *hostServiceUpgradeCheckResponse {
	rawURL := fmt.Sprintf("%s%s/upgradecheck", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceUpgradeCheckResponse)
}

//
// Check if there are upgrades available for the host. If there are upgrades available an icon will be displayed
// next to host status icon in the Administration Portal. Audit log messages are also added to indicate the
// availability of upgrades. The upgrade can be started from the webadmin or by using the
// <<services/host/methods/upgrade, upgrade>> host action.
//
type hostServiceUpgradeCheckResponse struct {
}

//
// Check if there are upgrades available for the host. If there are upgrades available an icon will be displayed
// next to host status icon in the Administration Portal. Audit log messages are also added to indicate the
// availability of upgrades. The upgrade can be started from the webadmin or by using the
// <<services/host/methods/upgrade, upgrade>> host action.
//
func (p *hostService) UpgradeCheck() *hostServiceUpgradeCheckRequest {
	return &hostServiceUpgradeCheckRequest{hostService: p}
}

//
// Approve the specified host to be added to the engine by using the root password (deprecated verb). This
// occurs when the host registers itself with the engine.
//
type hostServiceApproveUsingRootPasswordRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
	cluster     *Cluster
	host        *Host
}

func (p *hostServiceApproveUsingRootPasswordRequest) Header(key, value string) *hostServiceApproveUsingRootPasswordRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceApproveUsingRootPasswordRequest) Query(key, value string) *hostServiceApproveUsingRootPasswordRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceApproveUsingRootPasswordRequest) Async(async bool) *hostServiceApproveUsingRootPasswordRequest {
	p.async = &async
	return p
}

func (p *hostServiceApproveUsingRootPasswordRequest) Cluster(cluster *Cluster) *hostServiceApproveUsingRootPasswordRequest {
	p.cluster = cluster
	return p
}

func (p *hostServiceApproveUsingRootPasswordRequest) Host(host *Host) *hostServiceApproveUsingRootPasswordRequest {
	p.host = host
	return p
}

func (p *hostServiceApproveUsingRootPasswordRequest) Send() (*hostServiceApproveUsingRootPasswordResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingrootpassword", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceApproveUsingRootPasswordResponse), nil
}

func (p *hostServiceApproveUsingRootPasswordRequest) MustSend() *hostServiceApproveUsingRootPasswordResponse {
	rawURL := fmt.Sprintf("%s%s/usingrootpassword", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceApproveUsingRootPasswordResponse)
}

//
// Approve the specified host to be added to the engine by using the root password (deprecated verb). This
// occurs when the host registers itself with the engine.
//
type hostServiceApproveUsingRootPasswordResponse struct {
}

//
// Approve the specified host to be added to the engine by using the root password (deprecated verb). This
// occurs when the host registers itself with the engine.
//
func (p *hostService) ApproveUsingRootPassword() *hostServiceApproveUsingRootPasswordRequest {
	return &hostServiceApproveUsingRootPasswordRequest{hostService: p}
}

//
// Install VDSM and other packages required to get the host ready to be used in the engine providing the root
// password. This has been deprecated.
//
type hostServiceInstallUsingRootPasswordRequest struct {
	hostService          *hostService
	header               map[string]string
	query                map[string]string
	async                *bool
	deployHostedEngine   *bool
	host                 *Host
	image                *string
	rootPassword         *string
	ssh                  *Ssh
	undeployHostedEngine *bool
}

func (p *hostServiceInstallUsingRootPasswordRequest) Header(key, value string) *hostServiceInstallUsingRootPasswordRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceInstallUsingRootPasswordRequest) Query(key, value string) *hostServiceInstallUsingRootPasswordRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceInstallUsingRootPasswordRequest) Async(async bool) *hostServiceInstallUsingRootPasswordRequest {
	p.async = &async
	return p
}

func (p *hostServiceInstallUsingRootPasswordRequest) DeployHostedEngine(deployHostedEngine bool) *hostServiceInstallUsingRootPasswordRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}

func (p *hostServiceInstallUsingRootPasswordRequest) Host(host *Host) *hostServiceInstallUsingRootPasswordRequest {
	p.host = host
	return p
}

func (p *hostServiceInstallUsingRootPasswordRequest) Image(image string) *hostServiceInstallUsingRootPasswordRequest {
	p.image = &image
	return p
}

func (p *hostServiceInstallUsingRootPasswordRequest) RootPassword(rootPassword string) *hostServiceInstallUsingRootPasswordRequest {
	p.rootPassword = &rootPassword
	return p
}

func (p *hostServiceInstallUsingRootPasswordRequest) Ssh(ssh *Ssh) *hostServiceInstallUsingRootPasswordRequest {
	p.ssh = ssh
	return p
}

func (p *hostServiceInstallUsingRootPasswordRequest) UndeployHostedEngine(undeployHostedEngine bool) *hostServiceInstallUsingRootPasswordRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}

func (p *hostServiceInstallUsingRootPasswordRequest) Send() (*hostServiceInstallUsingRootPasswordResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingrootpassword", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.image != nil {
		actionBuilder.Image(*p.image)
	}
	if p.rootPassword != nil {
		actionBuilder.RootPassword(*p.rootPassword)
	}
	actionBuilder.Ssh(p.ssh)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceInstallUsingRootPasswordResponse), nil
}

func (p *hostServiceInstallUsingRootPasswordRequest) MustSend() *hostServiceInstallUsingRootPasswordResponse {
	rawURL := fmt.Sprintf("%s%s/usingrootpassword", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.image != nil {
		actionBuilder.Image(*p.image)
	}
	if p.rootPassword != nil {
		actionBuilder.RootPassword(*p.rootPassword)
	}
	actionBuilder.Ssh(p.ssh)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceInstallUsingRootPasswordResponse)
}

//
// Install VDSM and other packages required to get the host ready to be used in the engine providing the root
// password. This has been deprecated.
//
type hostServiceInstallUsingRootPasswordResponse struct {
}

//
// Install VDSM and other packages required to get the host ready to be used in the engine providing the root
// password. This has been deprecated.
//
func (p *hostService) InstallUsingRootPassword() *hostServiceInstallUsingRootPasswordRequest {
	return &hostServiceInstallUsingRootPasswordRequest{hostService: p}
}

//
// Update the specified host in the system. This is deprecated and is provided only for backwards compatibility.
//
type hostServiceUpdateUsingRootPasswordRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
	host        *Host
}

func (p *hostServiceUpdateUsingRootPasswordRequest) Header(key, value string) *hostServiceUpdateUsingRootPasswordRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceUpdateUsingRootPasswordRequest) Query(key, value string) *hostServiceUpdateUsingRootPasswordRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceUpdateUsingRootPasswordRequest) Async(async bool) *hostServiceUpdateUsingRootPasswordRequest {
	p.async = &async
	return p
}

func (p *hostServiceUpdateUsingRootPasswordRequest) Host(host *Host) *hostServiceUpdateUsingRootPasswordRequest {
	p.host = host
	return p
}

func (p *hostServiceUpdateUsingRootPasswordRequest) Send() (*hostServiceUpdateUsingRootPasswordResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingrootpassword", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustHost()
	return &hostServiceUpdateUsingRootPasswordResponse{host: result}, nil
}

func (p *hostServiceUpdateUsingRootPasswordRequest) MustSend() *hostServiceUpdateUsingRootPasswordResponse {
	rawURL := fmt.Sprintf("%s%s/usingrootpassword", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustHost()
	return &hostServiceUpdateUsingRootPasswordResponse{host: result}
}

//
// Update the specified host in the system. This is deprecated and is provided only for backwards compatibility.
//
type hostServiceUpdateUsingRootPasswordResponse struct {
	host *Host
}

func (p *hostServiceUpdateUsingRootPasswordResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *hostServiceUpdateUsingRootPasswordResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Update the specified host in the system. This is deprecated and is provided only for backwards compatibility.
//
func (p *hostService) UpdateUsingRootPassword() *hostServiceUpdateUsingRootPasswordRequest {
	return &hostServiceUpdateUsingRootPasswordRequest{hostService: p}
}

//
// Approve the specified host to be added to the engine by using ssh authentication. This occurs when the host
// registers itself with the engine.
//
type hostServiceApproveUsingSshRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
	cluster     *Cluster
	host        *Host
}

func (p *hostServiceApproveUsingSshRequest) Header(key, value string) *hostServiceApproveUsingSshRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceApproveUsingSshRequest) Query(key, value string) *hostServiceApproveUsingSshRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceApproveUsingSshRequest) Async(async bool) *hostServiceApproveUsingSshRequest {
	p.async = &async
	return p
}

func (p *hostServiceApproveUsingSshRequest) Cluster(cluster *Cluster) *hostServiceApproveUsingSshRequest {
	p.cluster = cluster
	return p
}

func (p *hostServiceApproveUsingSshRequest) Host(host *Host) *hostServiceApproveUsingSshRequest {
	p.host = host
	return p
}

func (p *hostServiceApproveUsingSshRequest) Send() (*hostServiceApproveUsingSshResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingssh", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceApproveUsingSshResponse), nil
}

func (p *hostServiceApproveUsingSshRequest) MustSend() *hostServiceApproveUsingSshResponse {
	rawURL := fmt.Sprintf("%s%s/usingssh", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceApproveUsingSshResponse)
}

//
// Approve the specified host to be added to the engine by using ssh authentication. This occurs when the host
// registers itself with the engine.
//
type hostServiceApproveUsingSshResponse struct {
}

//
// Approve the specified host to be added to the engine by using ssh authentication. This occurs when the host
// registers itself with the engine.
//
func (p *hostService) ApproveUsingSsh() *hostServiceApproveUsingSshRequest {
	return &hostServiceApproveUsingSshRequest{hostService: p}
}

//
// Install VDSM and other packages required to get the host ready to be used in the engine providing the SSH
// password.
//
type hostServiceInstallUsingSshRequest struct {
	hostService          *hostService
	header               map[string]string
	query                map[string]string
	async                *bool
	deployHostedEngine   *bool
	host                 *Host
	image                *string
	rootPassword         *string
	ssh                  *Ssh
	undeployHostedEngine *bool
}

func (p *hostServiceInstallUsingSshRequest) Header(key, value string) *hostServiceInstallUsingSshRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceInstallUsingSshRequest) Query(key, value string) *hostServiceInstallUsingSshRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceInstallUsingSshRequest) Async(async bool) *hostServiceInstallUsingSshRequest {
	p.async = &async
	return p
}

func (p *hostServiceInstallUsingSshRequest) DeployHostedEngine(deployHostedEngine bool) *hostServiceInstallUsingSshRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}

func (p *hostServiceInstallUsingSshRequest) Host(host *Host) *hostServiceInstallUsingSshRequest {
	p.host = host
	return p
}

func (p *hostServiceInstallUsingSshRequest) Image(image string) *hostServiceInstallUsingSshRequest {
	p.image = &image
	return p
}

func (p *hostServiceInstallUsingSshRequest) RootPassword(rootPassword string) *hostServiceInstallUsingSshRequest {
	p.rootPassword = &rootPassword
	return p
}

func (p *hostServiceInstallUsingSshRequest) Ssh(ssh *Ssh) *hostServiceInstallUsingSshRequest {
	p.ssh = ssh
	return p
}

func (p *hostServiceInstallUsingSshRequest) UndeployHostedEngine(undeployHostedEngine bool) *hostServiceInstallUsingSshRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}

func (p *hostServiceInstallUsingSshRequest) Send() (*hostServiceInstallUsingSshResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingssh", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.image != nil {
		actionBuilder.Image(*p.image)
	}
	if p.rootPassword != nil {
		actionBuilder.RootPassword(*p.rootPassword)
	}
	actionBuilder.Ssh(p.ssh)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(hostServiceInstallUsingSshResponse), nil
}

func (p *hostServiceInstallUsingSshRequest) MustSend() *hostServiceInstallUsingSshResponse {
	rawURL := fmt.Sprintf("%s%s/usingssh", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.image != nil {
		actionBuilder.Image(*p.image)
	}
	if p.rootPassword != nil {
		actionBuilder.RootPassword(*p.rootPassword)
	}
	actionBuilder.Ssh(p.ssh)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(hostServiceInstallUsingSshResponse)
}

//
// Install VDSM and other packages required to get the host ready to be used in the engine providing the SSH
// password.
//
type hostServiceInstallUsingSshResponse struct {
}

//
// Install VDSM and other packages required to get the host ready to be used in the engine providing the SSH
// password.
//
func (p *hostService) InstallUsingSsh() *hostServiceInstallUsingSshRequest {
	return &hostServiceInstallUsingSshRequest{hostService: p}
}

//
// Updates the specified host in the system.
//
type hostServiceUpdateUsingSshRequest struct {
	hostService *hostService
	header      map[string]string
	query       map[string]string
	async       *bool
	host        *Host
}

func (p *hostServiceUpdateUsingSshRequest) Header(key, value string) *hostServiceUpdateUsingSshRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostServiceUpdateUsingSshRequest) Query(key, value string) *hostServiceUpdateUsingSshRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostServiceUpdateUsingSshRequest) Async(async bool) *hostServiceUpdateUsingSshRequest {
	p.async = &async
	return p
}

func (p *hostServiceUpdateUsingSshRequest) Host(host *Host) *hostServiceUpdateUsingSshRequest {
	p.host = host
	return p
}

func (p *hostServiceUpdateUsingSshRequest) Send() (*hostServiceUpdateUsingSshResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingssh", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustHost()
	return &hostServiceUpdateUsingSshResponse{host: result}, nil
}

func (p *hostServiceUpdateUsingSshRequest) MustSend() *hostServiceUpdateUsingSshResponse {
	rawURL := fmt.Sprintf("%s%s/usingssh", p.hostService.connection.URL(), p.hostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustHost()
	return &hostServiceUpdateUsingSshResponse{host: result}
}

//
// Updates the specified host in the system.
//
type hostServiceUpdateUsingSshResponse struct {
	host *Host
}

func (p *hostServiceUpdateUsingSshResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *hostServiceUpdateUsingSshResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Updates the specified host in the system.
//
func (p *hostService) UpdateUsingSsh() *hostServiceUpdateUsingSshRequest {
	return &hostServiceUpdateUsingSshRequest{hostService: p}
}

//
// List of scheduling labels assigned to this host.
//
func (op *hostService) AffinityLabelsService() *assignedAffinityLabelsService {
	return NewAssignedAffinityLabelsService(op.connection, fmt.Sprintf("%s/affinitylabels", op.path))
}

//
// A reference to the host devices service. Use this service to view the devices of the host object.
//
func (op *hostService) DevicesService() *hostDevicesService {
	return NewHostDevicesService(op.connection, fmt.Sprintf("%s/devices", op.path))
}

//
// External network providers provisioned by the system on the host.
//
func (op *hostService) ExternalNetworkProviderConfigurationsService() *externalNetworkProviderConfigurationsService {
	return NewExternalNetworkProviderConfigurationsService(op.connection, fmt.Sprintf("%s/externalnetworkproviderconfigurations", op.path))
}

//
// A reference to the fence agents service. Use this service to manage fence and power management agents on the host
// object.
//
func (op *hostService) FenceAgentsService() *fenceAgentsService {
	return NewFenceAgentsService(op.connection, fmt.Sprintf("%s/fenceagents", op.path))
}

//
// A reference to the host hooks service. Use this service to view the hooks available in the host object.
//
func (op *hostService) HooksService() *hostHooksService {
	return NewHostHooksService(op.connection, fmt.Sprintf("%s/hooks", op.path))
}

//
// A reference to the service that can show the applicable errata available on the host. This information is taken
// from Katello.
//
func (op *hostService) KatelloErrataService() *katelloErrataService {
	return NewKatelloErrataService(op.connection, fmt.Sprintf("%s/katelloerrata", op.path))
}

//
// A reference to the network attachments service. You can use this service to attach Logical networks to host
// interfaces.
//
func (op *hostService) NetworkAttachmentsService() *networkAttachmentsService {
	return NewNetworkAttachmentsService(op.connection, fmt.Sprintf("%s/networkattachments", op.path))
}

//
// A reference to the service that manages the network interface devices on the host.
//
func (op *hostService) NicsService() *hostNicsService {
	return NewHostNicsService(op.connection, fmt.Sprintf("%s/nics", op.path))
}

//
// A reference to the service that manage NUMA nodes for the host.
//
func (op *hostService) NumaNodesService() *hostNumaNodesService {
	return NewHostNumaNodesService(op.connection, fmt.Sprintf("%s/numanodes", op.path))
}

//
// A reference to the host permission service.
// Use this service to manage permissions on the host object.
//
func (op *hostService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *hostService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// A reference to the service that manages the host's storage.
//
func (op *hostService) StorageService() *hostStorageService {
	return NewHostStorageService(op.connection, fmt.Sprintf("%s/storage", op.path))
}

//
// A reference to storage connection extensions.
//
func (op *hostService) StorageConnectionExtensionsService() *storageServerConnectionExtensionsService {
	return NewStorageServerConnectionExtensionsService(op.connection, fmt.Sprintf("%s/storageconnectionextensions", op.path))
}

//
// A reference to the host tags service. Use this service to manage tags on the host object.
//
func (op *hostService) TagsService() *assignedTagsService {
	return NewAssignedTagsService(op.connection, fmt.Sprintf("%s/tags", op.path))
}

//
// A reference to unmanaged networks.
//
func (op *hostService) UnmanagedNetworksService() *unmanagedNetworksService {
	return NewUnmanagedNetworksService(op.connection, fmt.Sprintf("%s/unmanagednetworks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *hostService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitylabels" {
		return op.AffinityLabelsService(), nil
	}
	if strings.HasPrefix(path, "affinitylabels/") {
		return op.AffinityLabelsService().Service(path[15:])
	}
	if path == "devices" {
		return op.DevicesService(), nil
	}
	if strings.HasPrefix(path, "devices/") {
		return op.DevicesService().Service(path[8:])
	}
	if path == "externalnetworkproviderconfigurations" {
		return op.ExternalNetworkProviderConfigurationsService(), nil
	}
	if strings.HasPrefix(path, "externalnetworkproviderconfigurations/") {
		return op.ExternalNetworkProviderConfigurationsService().Service(path[38:])
	}
	if path == "fenceagents" {
		return op.FenceAgentsService(), nil
	}
	if strings.HasPrefix(path, "fenceagents/") {
		return op.FenceAgentsService().Service(path[12:])
	}
	if path == "hooks" {
		return op.HooksService(), nil
	}
	if strings.HasPrefix(path, "hooks/") {
		return op.HooksService().Service(path[6:])
	}
	if path == "katelloerrata" {
		return op.KatelloErrataService(), nil
	}
	if strings.HasPrefix(path, "katelloerrata/") {
		return op.KatelloErrataService().Service(path[14:])
	}
	if path == "networkattachments" {
		return op.NetworkAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "networkattachments/") {
		return op.NetworkAttachmentsService().Service(path[19:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "numanodes" {
		return op.NumaNodesService(), nil
	}
	if strings.HasPrefix(path, "numanodes/") {
		return op.NumaNodesService().Service(path[10:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	if path == "storage" {
		return op.StorageService(), nil
	}
	if strings.HasPrefix(path, "storage/") {
		return op.StorageService().Service(path[8:])
	}
	if path == "storageconnectionextensions" {
		return op.StorageConnectionExtensionsService(), nil
	}
	if strings.HasPrefix(path, "storageconnectionextensions/") {
		return op.StorageConnectionExtensionsService().Service(path[28:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "unmanagednetworks" {
		return op.UnmanagedNetworksService(), nil
	}
	if strings.HasPrefix(path, "unmanagednetworks/") {
		return op.UnmanagedNetworksService().Service(path[18:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *hostService) String() string {
	return fmt.Sprintf("hostService:%s", op.path)
}

//
// A service to manage a specific cluster.
//
type clusterService struct {
	baseService
}

func NewClusterService(connection *Connection, path string) *clusterService {
	var result clusterService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets information about the cluster.
// An example of getting a cluster:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123
// ----
// [source,xml]
// ----
// <cluster href="/ovirt-engine/api/clusters/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/clusters/123/resetemulatedmachine" rel="resetemulatedmachine"/>
//   </actions>
//   <name>Default</name>
//   <description>The default server cluster</description>
//   <link href="/ovirt-engine/api/clusters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/clusters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/clusters/123/glustervolumes" rel="glustervolumes"/>
//   <link href="/ovirt-engine/api/clusters/123/glusterhooks" rel="glusterhooks"/>
//   <link href="/ovirt-engine/api/clusters/123/affinitygroups" rel="affinitygroups"/>
//   <link href="/ovirt-engine/api/clusters/123/cpuprofiles" rel="cpuprofiles"/>
//   <ballooning_enabled>false</ballooning_enabled>
//   <cpu>
//     <architecture>x86_64</architecture>
//     <type>Intel Penryn Family</type>
//   </cpu>
//   <error_handling>
//     <on_error>migrate</on_error>
//   </error_handling>
//   <fencing_policy>
//     <enabled>true</enabled>
//     <skip_if_connectivity_broken>
//       <enabled>false</enabled>
//       <threshold>50</threshold>
//     </skip_if_connectivity_broken>
//     <skip_if_sd_active>
//       <enabled>false</enabled>
//     </skip_if_sd_active>
//   </fencing_policy>
//   <gluster_service>false</gluster_service>
//   <ha_reservation>false</ha_reservation>
//   <ksm>
//     <enabled>true</enabled>
//     <merge_across_nodes>true</merge_across_nodes>
//   </ksm>
//   <maintenance_reason_required>false</maintenance_reason_required>
//   <memory_policy>
//     <over_commit>
//       <percent>100</percent>
//     </over_commit>
//     <transparent_hugepages>
//       <enabled>true</enabled>
//     </transparent_hugepages>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <bandwidth>
//       <assignment_method>auto</assignment_method>
//     </bandwidth>
//     <compressed>inherit</compressed>
//   </migration>
//   <optional_reason>false</optional_reason>
//   <required_rng_sources>
//     <required_rng_source>random</required_rng_source>
//   </required_rng_sources>
//   <scheduling_policy href="/ovirt-engine/api/schedulingpolicies/456" id="456"/>
//   <threads_as_cores>false</threads_as_cores>
//   <trusted_service>false</trusted_service>
//   <tunnel_migration>false</tunnel_migration>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <virt_service>true</virt_service>
//   <data_center href="/ovirt-engine/api/datacenters/111" id="111"/>
// </cluster>
// ----
//
type clusterServiceGetRequest struct {
	clusterService *clusterService
	header         map[string]string
	query          map[string]string
	filter         *bool
	follow         *string
}

func (p *clusterServiceGetRequest) Header(key, value string) *clusterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterServiceGetRequest) Query(key, value string) *clusterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterServiceGetRequest) Filter(filter bool) *clusterServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *clusterServiceGetRequest) Follow(follow string) *clusterServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *clusterServiceGetRequest) Send() (*clusterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterService.connection.URL(), p.clusterService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &clusterServiceGetResponse{cluster: result}, nil
}

func (p *clusterServiceGetRequest) MustSend() *clusterServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterService.connection.URL(), p.clusterService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &clusterServiceGetResponse{cluster: result}
}

//
// Gets information about the cluster.
// An example of getting a cluster:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123
// ----
// [source,xml]
// ----
// <cluster href="/ovirt-engine/api/clusters/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/clusters/123/resetemulatedmachine" rel="resetemulatedmachine"/>
//   </actions>
//   <name>Default</name>
//   <description>The default server cluster</description>
//   <link href="/ovirt-engine/api/clusters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/clusters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/clusters/123/glustervolumes" rel="glustervolumes"/>
//   <link href="/ovirt-engine/api/clusters/123/glusterhooks" rel="glusterhooks"/>
//   <link href="/ovirt-engine/api/clusters/123/affinitygroups" rel="affinitygroups"/>
//   <link href="/ovirt-engine/api/clusters/123/cpuprofiles" rel="cpuprofiles"/>
//   <ballooning_enabled>false</ballooning_enabled>
//   <cpu>
//     <architecture>x86_64</architecture>
//     <type>Intel Penryn Family</type>
//   </cpu>
//   <error_handling>
//     <on_error>migrate</on_error>
//   </error_handling>
//   <fencing_policy>
//     <enabled>true</enabled>
//     <skip_if_connectivity_broken>
//       <enabled>false</enabled>
//       <threshold>50</threshold>
//     </skip_if_connectivity_broken>
//     <skip_if_sd_active>
//       <enabled>false</enabled>
//     </skip_if_sd_active>
//   </fencing_policy>
//   <gluster_service>false</gluster_service>
//   <ha_reservation>false</ha_reservation>
//   <ksm>
//     <enabled>true</enabled>
//     <merge_across_nodes>true</merge_across_nodes>
//   </ksm>
//   <maintenance_reason_required>false</maintenance_reason_required>
//   <memory_policy>
//     <over_commit>
//       <percent>100</percent>
//     </over_commit>
//     <transparent_hugepages>
//       <enabled>true</enabled>
//     </transparent_hugepages>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <bandwidth>
//       <assignment_method>auto</assignment_method>
//     </bandwidth>
//     <compressed>inherit</compressed>
//   </migration>
//   <optional_reason>false</optional_reason>
//   <required_rng_sources>
//     <required_rng_source>random</required_rng_source>
//   </required_rng_sources>
//   <scheduling_policy href="/ovirt-engine/api/schedulingpolicies/456" id="456"/>
//   <threads_as_cores>false</threads_as_cores>
//   <trusted_service>false</trusted_service>
//   <tunnel_migration>false</tunnel_migration>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <virt_service>true</virt_service>
//   <data_center href="/ovirt-engine/api/datacenters/111" id="111"/>
// </cluster>
// ----
//
type clusterServiceGetResponse struct {
	cluster *Cluster
}

func (p *clusterServiceGetResponse) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

func (p *clusterServiceGetResponse) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("cluster in response does not exist")
	}
	return p.cluster
}

//
// Gets information about the cluster.
// An example of getting a cluster:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123
// ----
// [source,xml]
// ----
// <cluster href="/ovirt-engine/api/clusters/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/clusters/123/resetemulatedmachine" rel="resetemulatedmachine"/>
//   </actions>
//   <name>Default</name>
//   <description>The default server cluster</description>
//   <link href="/ovirt-engine/api/clusters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/clusters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/clusters/123/glustervolumes" rel="glustervolumes"/>
//   <link href="/ovirt-engine/api/clusters/123/glusterhooks" rel="glusterhooks"/>
//   <link href="/ovirt-engine/api/clusters/123/affinitygroups" rel="affinitygroups"/>
//   <link href="/ovirt-engine/api/clusters/123/cpuprofiles" rel="cpuprofiles"/>
//   <ballooning_enabled>false</ballooning_enabled>
//   <cpu>
//     <architecture>x86_64</architecture>
//     <type>Intel Penryn Family</type>
//   </cpu>
//   <error_handling>
//     <on_error>migrate</on_error>
//   </error_handling>
//   <fencing_policy>
//     <enabled>true</enabled>
//     <skip_if_connectivity_broken>
//       <enabled>false</enabled>
//       <threshold>50</threshold>
//     </skip_if_connectivity_broken>
//     <skip_if_sd_active>
//       <enabled>false</enabled>
//     </skip_if_sd_active>
//   </fencing_policy>
//   <gluster_service>false</gluster_service>
//   <ha_reservation>false</ha_reservation>
//   <ksm>
//     <enabled>true</enabled>
//     <merge_across_nodes>true</merge_across_nodes>
//   </ksm>
//   <maintenance_reason_required>false</maintenance_reason_required>
//   <memory_policy>
//     <over_commit>
//       <percent>100</percent>
//     </over_commit>
//     <transparent_hugepages>
//       <enabled>true</enabled>
//     </transparent_hugepages>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <bandwidth>
//       <assignment_method>auto</assignment_method>
//     </bandwidth>
//     <compressed>inherit</compressed>
//   </migration>
//   <optional_reason>false</optional_reason>
//   <required_rng_sources>
//     <required_rng_source>random</required_rng_source>
//   </required_rng_sources>
//   <scheduling_policy href="/ovirt-engine/api/schedulingpolicies/456" id="456"/>
//   <threads_as_cores>false</threads_as_cores>
//   <trusted_service>false</trusted_service>
//   <tunnel_migration>false</tunnel_migration>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <virt_service>true</virt_service>
//   <data_center href="/ovirt-engine/api/datacenters/111" id="111"/>
// </cluster>
// ----
//
func (p *clusterService) Get() *clusterServiceGetRequest {
	return &clusterServiceGetRequest{clusterService: p}
}

//
// Removes the cluster from the system.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/00000000-0000-0000-0000-000000000000
// ----
//
type clusterServiceRemoveRequest struct {
	clusterService *clusterService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *clusterServiceRemoveRequest) Header(key, value string) *clusterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterServiceRemoveRequest) Query(key, value string) *clusterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterServiceRemoveRequest) Async(async bool) *clusterServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *clusterServiceRemoveRequest) Send() (*clusterServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterService.connection.URL(), p.clusterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(clusterServiceRemoveResponse), nil
}

func (p *clusterServiceRemoveRequest) MustSend() *clusterServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterService.connection.URL(), p.clusterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(clusterServiceRemoveResponse)
}

//
// Removes the cluster from the system.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/00000000-0000-0000-0000-000000000000
// ----
//
type clusterServiceRemoveResponse struct {
}

//
// Removes the cluster from the system.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/00000000-0000-0000-0000-000000000000
// ----
//
func (p *clusterService) Remove() *clusterServiceRemoveRequest {
	return &clusterServiceRemoveRequest{clusterService: p}
}

//
//
type clusterServiceResetEmulatedMachineRequest struct {
	clusterService *clusterService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *clusterServiceResetEmulatedMachineRequest) Header(key, value string) *clusterServiceResetEmulatedMachineRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterServiceResetEmulatedMachineRequest) Query(key, value string) *clusterServiceResetEmulatedMachineRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterServiceResetEmulatedMachineRequest) Async(async bool) *clusterServiceResetEmulatedMachineRequest {
	p.async = &async
	return p
}

func (p *clusterServiceResetEmulatedMachineRequest) Send() (*clusterServiceResetEmulatedMachineResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resetemulatedmachine", p.clusterService.connection.URL(), p.clusterService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(clusterServiceResetEmulatedMachineResponse), nil
}

func (p *clusterServiceResetEmulatedMachineRequest) MustSend() *clusterServiceResetEmulatedMachineResponse {
	rawURL := fmt.Sprintf("%s%s/resetemulatedmachine", p.clusterService.connection.URL(), p.clusterService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(clusterServiceResetEmulatedMachineResponse)
}

//
//
type clusterServiceResetEmulatedMachineResponse struct {
}

//
//
func (p *clusterService) ResetEmulatedMachine() *clusterServiceResetEmulatedMachineRequest {
	return &clusterServiceResetEmulatedMachineRequest{clusterService: p}
}

//
// Updates information about the cluster.
// Only the specified fields are updated; others remain unchanged.
// For example, to update the cluster's CPU:
// [source]
// ----
// PUT /ovirt-engine/api/clusters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <cpu>
//     <type>Intel Haswell-noTSX Family</type>
//   </cpu>
// </cluster>
// ----
//
type clusterServiceUpdateRequest struct {
	clusterService *clusterService
	header         map[string]string
	query          map[string]string
	async          *bool
	cluster        *Cluster
}

func (p *clusterServiceUpdateRequest) Header(key, value string) *clusterServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterServiceUpdateRequest) Query(key, value string) *clusterServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterServiceUpdateRequest) Async(async bool) *clusterServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *clusterServiceUpdateRequest) Cluster(cluster *Cluster) *clusterServiceUpdateRequest {
	p.cluster = cluster
	return p
}

func (p *clusterServiceUpdateRequest) Send() (*clusterServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterService.connection.URL(), p.clusterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLClusterWriteOne(writer, p.cluster, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &clusterServiceUpdateResponse{cluster: result}, nil
}

func (p *clusterServiceUpdateRequest) MustSend() *clusterServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterService.connection.URL(), p.clusterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLClusterWriteOne(writer, p.cluster, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &clusterServiceUpdateResponse{cluster: result}
}

//
// Updates information about the cluster.
// Only the specified fields are updated; others remain unchanged.
// For example, to update the cluster's CPU:
// [source]
// ----
// PUT /ovirt-engine/api/clusters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <cpu>
//     <type>Intel Haswell-noTSX Family</type>
//   </cpu>
// </cluster>
// ----
//
type clusterServiceUpdateResponse struct {
	cluster *Cluster
}

func (p *clusterServiceUpdateResponse) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

func (p *clusterServiceUpdateResponse) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("cluster in response does not exist")
	}
	return p.cluster
}

//
// Updates information about the cluster.
// Only the specified fields are updated; others remain unchanged.
// For example, to update the cluster's CPU:
// [source]
// ----
// PUT /ovirt-engine/api/clusters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <cpu>
//     <type>Intel Haswell-noTSX Family</type>
//   </cpu>
// </cluster>
// ----
//
func (p *clusterService) Update() *clusterServiceUpdateRequest {
	return &clusterServiceUpdateRequest{clusterService: p}
}

//
// A reference to the service that manages affinity groups.
//
func (op *clusterService) AffinityGroupsService() *affinityGroupsService {
	return NewAffinityGroupsService(op.connection, fmt.Sprintf("%s/affinitygroups", op.path))
}

//
// A reference to the service that manages assigned CPU profiles for the cluster.
//
func (op *clusterService) CpuProfilesService() *assignedCpuProfilesService {
	return NewAssignedCpuProfilesService(op.connection, fmt.Sprintf("%s/cpuprofiles", op.path))
}

//
// A reference to the service that manages the collection of enabled features for the cluster.
//
func (op *clusterService) EnabledFeaturesService() *clusterEnabledFeaturesService {
	return NewClusterEnabledFeaturesService(op.connection, fmt.Sprintf("%s/enabledfeatures", op.path))
}

//
// A reference to the service that manages the collection of external network providers.
//
func (op *clusterService) ExternalNetworkProvidersService() *clusterExternalProvidersService {
	return NewClusterExternalProvidersService(op.connection, fmt.Sprintf("%s/externalnetworkproviders", op.path))
}

//
// A reference to the service that manages the Gluster hooks for the cluster.
//
func (op *clusterService) GlusterHooksService() *glusterHooksService {
	return NewGlusterHooksService(op.connection, fmt.Sprintf("%s/glusterhooks", op.path))
}

//
// A reference to the service that manages Gluster volumes for the cluster.
//
func (op *clusterService) GlusterVolumesService() *glusterVolumesService {
	return NewGlusterVolumesService(op.connection, fmt.Sprintf("%s/glustervolumes", op.path))
}

//
// A sub-collection with all the supported network filters for the cluster.
//
func (op *clusterService) NetworkFiltersService() *networkFiltersService {
	return NewNetworkFiltersService(op.connection, fmt.Sprintf("%s/networkfilters", op.path))
}

//
// A reference to the service that manages assigned networks for the cluster.
//
func (op *clusterService) NetworksService() *clusterNetworksService {
	return NewClusterNetworksService(op.connection, fmt.Sprintf("%s/networks", op.path))
}

//
// A reference to permissions.
//
func (op *clusterService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *clusterService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitygroups" {
		return op.AffinityGroupsService(), nil
	}
	if strings.HasPrefix(path, "affinitygroups/") {
		return op.AffinityGroupsService().Service(path[15:])
	}
	if path == "cpuprofiles" {
		return op.CpuProfilesService(), nil
	}
	if strings.HasPrefix(path, "cpuprofiles/") {
		return op.CpuProfilesService().Service(path[12:])
	}
	if path == "enabledfeatures" {
		return op.EnabledFeaturesService(), nil
	}
	if strings.HasPrefix(path, "enabledfeatures/") {
		return op.EnabledFeaturesService().Service(path[16:])
	}
	if path == "externalnetworkproviders" {
		return op.ExternalNetworkProvidersService(), nil
	}
	if strings.HasPrefix(path, "externalnetworkproviders/") {
		return op.ExternalNetworkProvidersService().Service(path[25:])
	}
	if path == "glusterhooks" {
		return op.GlusterHooksService(), nil
	}
	if strings.HasPrefix(path, "glusterhooks/") {
		return op.GlusterHooksService().Service(path[13:])
	}
	if path == "glustervolumes" {
		return op.GlusterVolumesService(), nil
	}
	if strings.HasPrefix(path, "glustervolumes/") {
		return op.GlusterVolumesService().Service(path[15:])
	}
	if path == "networkfilters" {
		return op.NetworkFiltersService(), nil
	}
	if strings.HasPrefix(path, "networkfilters/") {
		return op.NetworkFiltersService().Service(path[15:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *clusterService) String() string {
	return fmt.Sprintf("clusterService:%s", op.path)
}

//
// A service to manage host devices attached to a virtual machine.
//
type vmHostDevicesService struct {
	baseService
}

func NewVmHostDevicesService(connection *Connection, path string) *vmHostDevicesService {
	var result vmHostDevicesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Attach target device to given virtual machine.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/hostdevices
// ----
// With request body of type <<types/host_device,HostDevice>>, for example
// [source,xml]
// ----
// <host_device id="123" />
// ----
// NOTE: A necessary precondition for a successful host device attachment is that the virtual machine must be pinned
// to *exactly* one host. The device ID is then taken relative to this host.
// NOTE: Attachment of a PCI device that is part of a bigger IOMMU group will result in attachment of the remaining
// devices from that IOMMU group as "placeholders". These devices are then identified using the `placeholder`
// attribute of the <<types/host_device,HostDevice>> type set to `true`.
// In case you want attach a device that already serves as an IOMMU placeholder, simply issue an explicit Add operation
// for it, and its `placeholder` flag will be cleared, and the device will be accessible to the virtual machine.
//
type vmHostDevicesServiceAddRequest struct {
	vmHostDevicesService *vmHostDevicesService
	header               map[string]string
	query                map[string]string
	device               *HostDevice
}

func (p *vmHostDevicesServiceAddRequest) Header(key, value string) *vmHostDevicesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmHostDevicesServiceAddRequest) Query(key, value string) *vmHostDevicesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmHostDevicesServiceAddRequest) Device(device *HostDevice) *vmHostDevicesServiceAddRequest {
	p.device = device
	return p
}

func (p *vmHostDevicesServiceAddRequest) Send() (*vmHostDevicesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDevicesService.connection.URL(), p.vmHostDevicesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostDeviceWriteOne(writer, p.device, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmHostDevicesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmHostDevicesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmHostDevicesServiceAddResponse{device: result}, nil
}

func (p *vmHostDevicesServiceAddRequest) MustSend() *vmHostDevicesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDevicesService.connection.URL(), p.vmHostDevicesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostDeviceWriteOne(writer, p.device, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmHostDevicesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmHostDevicesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmHostDevicesServiceAddResponse{device: result}
}

//
// Attach target device to given virtual machine.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/hostdevices
// ----
// With request body of type <<types/host_device,HostDevice>>, for example
// [source,xml]
// ----
// <host_device id="123" />
// ----
// NOTE: A necessary precondition for a successful host device attachment is that the virtual machine must be pinned
// to *exactly* one host. The device ID is then taken relative to this host.
// NOTE: Attachment of a PCI device that is part of a bigger IOMMU group will result in attachment of the remaining
// devices from that IOMMU group as "placeholders". These devices are then identified using the `placeholder`
// attribute of the <<types/host_device,HostDevice>> type set to `true`.
// In case you want attach a device that already serves as an IOMMU placeholder, simply issue an explicit Add operation
// for it, and its `placeholder` flag will be cleared, and the device will be accessible to the virtual machine.
//
type vmHostDevicesServiceAddResponse struct {
	device *HostDevice
}

func (p *vmHostDevicesServiceAddResponse) Device() (*HostDevice, bool) {
	if p.device != nil {
		return p.device, true
	}
	return nil, false
}

func (p *vmHostDevicesServiceAddResponse) MustDevice() *HostDevice {
	if p.device == nil {
		panic("device in response does not exist")
	}
	return p.device
}

//
// Attach target device to given virtual machine.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/hostdevices
// ----
// With request body of type <<types/host_device,HostDevice>>, for example
// [source,xml]
// ----
// <host_device id="123" />
// ----
// NOTE: A necessary precondition for a successful host device attachment is that the virtual machine must be pinned
// to *exactly* one host. The device ID is then taken relative to this host.
// NOTE: Attachment of a PCI device that is part of a bigger IOMMU group will result in attachment of the remaining
// devices from that IOMMU group as "placeholders". These devices are then identified using the `placeholder`
// attribute of the <<types/host_device,HostDevice>> type set to `true`.
// In case you want attach a device that already serves as an IOMMU placeholder, simply issue an explicit Add operation
// for it, and its `placeholder` flag will be cleared, and the device will be accessible to the virtual machine.
//
func (p *vmHostDevicesService) Add() *vmHostDevicesServiceAddRequest {
	return &vmHostDevicesServiceAddRequest{vmHostDevicesService: p}
}

//
// List the host devices assigned to given virtual machine.
// The order of the returned list of devices isn't guaranteed.
//
type vmHostDevicesServiceListRequest struct {
	vmHostDevicesService *vmHostDevicesService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *vmHostDevicesServiceListRequest) Header(key, value string) *vmHostDevicesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmHostDevicesServiceListRequest) Query(key, value string) *vmHostDevicesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmHostDevicesServiceListRequest) Follow(follow string) *vmHostDevicesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vmHostDevicesServiceListRequest) Max(max int64) *vmHostDevicesServiceListRequest {
	p.max = &max
	return p
}

func (p *vmHostDevicesServiceListRequest) Send() (*vmHostDevicesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDevicesService.connection.URL(), p.vmHostDevicesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmHostDevicesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmHostDevicesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vmHostDevicesServiceListResponse{device: result}, nil
}

func (p *vmHostDevicesServiceListRequest) MustSend() *vmHostDevicesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmHostDevicesService.connection.URL(), p.vmHostDevicesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmHostDevicesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmHostDevicesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vmHostDevicesServiceListResponse{device: result}
}

//
// List the host devices assigned to given virtual machine.
// The order of the returned list of devices isn't guaranteed.
//
type vmHostDevicesServiceListResponse struct {
	device *HostDeviceSlice
}

func (p *vmHostDevicesServiceListResponse) Device() (*HostDeviceSlice, bool) {
	if p.device != nil {
		return p.device, true
	}
	return nil, false
}

func (p *vmHostDevicesServiceListResponse) MustDevice() *HostDeviceSlice {
	if p.device == nil {
		panic("device in response does not exist")
	}
	return p.device
}

//
// List the host devices assigned to given virtual machine.
// The order of the returned list of devices isn't guaranteed.
//
func (p *vmHostDevicesService) List() *vmHostDevicesServiceListRequest {
	return &vmHostDevicesServiceListRequest{vmHostDevicesService: p}
}

//
// Returns a reference to the service that manages a specific host device attached to given virtual machine.
//
func (op *vmHostDevicesService) DeviceService(id string) *vmHostDeviceService {
	return NewVmHostDeviceService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmHostDevicesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DeviceService(path), nil
	}
	return op.DeviceService(path[:index]).Service(path[index+1:])
}

func (op *vmHostDevicesService) String() string {
	return fmt.Sprintf("vmHostDevicesService:%s", op.path)
}

//
//
type fileService struct {
	baseService
}

func NewFileService(connection *Connection, path string) *fileService {
	var result fileService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type fileServiceGetRequest struct {
	fileService *fileService
	header      map[string]string
	query       map[string]string
	follow      *string
}

func (p *fileServiceGetRequest) Header(key, value string) *fileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *fileServiceGetRequest) Query(key, value string) *fileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *fileServiceGetRequest) Follow(follow string) *fileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *fileServiceGetRequest) Send() (*fileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fileService.connection.URL(), p.fileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.fileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.fileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &fileServiceGetResponse{file: result}, nil
}

func (p *fileServiceGetRequest) MustSend() *fileServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.fileService.connection.URL(), p.fileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.fileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.fileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &fileServiceGetResponse{file: result}
}

//
//
type fileServiceGetResponse struct {
	file *File
}

func (p *fileServiceGetResponse) File() (*File, bool) {
	if p.file != nil {
		return p.file, true
	}
	return nil, false
}

func (p *fileServiceGetResponse) MustFile() *File {
	if p.file == nil {
		panic("file in response does not exist")
	}
	return p.file
}

//
//
func (p *fileService) Get() *fileServiceGetRequest {
	return &fileServiceGetRequest{fileService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *fileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *fileService) String() string {
	return fmt.Sprintf("fileService:%s", op.path)
}

//
//
type assignedDiskProfileService struct {
	baseService
}

func NewAssignedDiskProfileService(connection *Connection, path string) *assignedDiskProfileService {
	var result assignedDiskProfileService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type assignedDiskProfileServiceGetRequest struct {
	assignedDiskProfileService *assignedDiskProfileService
	header                     map[string]string
	query                      map[string]string
	follow                     *string
}

func (p *assignedDiskProfileServiceGetRequest) Header(key, value string) *assignedDiskProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedDiskProfileServiceGetRequest) Query(key, value string) *assignedDiskProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedDiskProfileServiceGetRequest) Follow(follow string) *assignedDiskProfileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *assignedDiskProfileServiceGetRequest) Send() (*assignedDiskProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfileService.connection.URL(), p.assignedDiskProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedDiskProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &assignedDiskProfileServiceGetResponse{diskProfile: result}, nil
}

func (p *assignedDiskProfileServiceGetRequest) MustSend() *assignedDiskProfileServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfileService.connection.URL(), p.assignedDiskProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedDiskProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &assignedDiskProfileServiceGetResponse{diskProfile: result}
}

//
//
type assignedDiskProfileServiceGetResponse struct {
	diskProfile *DiskProfile
}

func (p *assignedDiskProfileServiceGetResponse) DiskProfile() (*DiskProfile, bool) {
	if p.diskProfile != nil {
		return p.diskProfile, true
	}
	return nil, false
}

func (p *assignedDiskProfileServiceGetResponse) MustDiskProfile() *DiskProfile {
	if p.diskProfile == nil {
		panic("diskProfile in response does not exist")
	}
	return p.diskProfile
}

//
//
func (p *assignedDiskProfileService) Get() *assignedDiskProfileServiceGetRequest {
	return &assignedDiskProfileServiceGetRequest{assignedDiskProfileService: p}
}

//
//
type assignedDiskProfileServiceRemoveRequest struct {
	assignedDiskProfileService *assignedDiskProfileService
	header                     map[string]string
	query                      map[string]string
	async                      *bool
}

func (p *assignedDiskProfileServiceRemoveRequest) Header(key, value string) *assignedDiskProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedDiskProfileServiceRemoveRequest) Query(key, value string) *assignedDiskProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedDiskProfileServiceRemoveRequest) Async(async bool) *assignedDiskProfileServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *assignedDiskProfileServiceRemoveRequest) Send() (*assignedDiskProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfileService.connection.URL(), p.assignedDiskProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedDiskProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(assignedDiskProfileServiceRemoveResponse), nil
}

func (p *assignedDiskProfileServiceRemoveRequest) MustSend() *assignedDiskProfileServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfileService.connection.URL(), p.assignedDiskProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedDiskProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(assignedDiskProfileServiceRemoveResponse)
}

//
//
type assignedDiskProfileServiceRemoveResponse struct {
}

//
//
func (p *assignedDiskProfileService) Remove() *assignedDiskProfileServiceRemoveRequest {
	return &assignedDiskProfileServiceRemoveRequest{assignedDiskProfileService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *assignedDiskProfileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *assignedDiskProfileService) String() string {
	return fmt.Sprintf("assignedDiskProfileService:%s", op.path)
}

//
//
type diskProfilesService struct {
	baseService
}

func NewDiskProfilesService(connection *Connection, path string) *diskProfilesService {
	var result diskProfilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new disk profile to the system.
//
type diskProfilesServiceAddRequest struct {
	diskProfilesService *diskProfilesService
	header              map[string]string
	query               map[string]string
	profile             *DiskProfile
}

func (p *diskProfilesServiceAddRequest) Header(key, value string) *diskProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskProfilesServiceAddRequest) Query(key, value string) *diskProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskProfilesServiceAddRequest) Profile(profile *DiskProfile) *diskProfilesServiceAddRequest {
	p.profile = profile
	return p
}

func (p *diskProfilesServiceAddRequest) Send() (*diskProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfilesService.connection.URL(), p.diskProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &diskProfilesServiceAddResponse{profile: result}, nil
}

func (p *diskProfilesServiceAddRequest) MustSend() *diskProfilesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskProfilesService.connection.URL(), p.diskProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskProfileWriteOne(writer, p.profile, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskProfilesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskProfilesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &diskProfilesServiceAddResponse{profile: result}
}

//
// Add a new disk profile to the system.
//
type diskProfilesServiceAddResponse struct {
	profile *DiskProfile
}

func (p *diskProfilesServiceAddResponse) Profile() (*DiskProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *diskProfilesServiceAddResponse) MustProfile() *DiskProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Add a new disk profile to the system.
//
func (p *diskProfilesService) Add() *diskProfilesServiceAddRequest {
	return &diskProfilesServiceAddRequest{diskProfilesService: p}
}

//
// Returns the list of disk profiles of the system.
// The order of the returned list of disk profiles isn't guaranteed.
//
type diskProfilesServiceListRequest struct {
	diskProfilesService *diskProfilesService
	header              map[string]string
	query               map[string]string
	follow              *string
	max                 *int64
}

func (p *diskProfilesServiceListRequest) Header(key, value string) *diskProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskProfilesServiceListRequest) Query(key, value string) *diskProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskProfilesServiceListRequest) Follow(follow string) *diskProfilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *diskProfilesServiceListRequest) Max(max int64) *diskProfilesServiceListRequest {
	p.max = &max
	return p
}

func (p *diskProfilesServiceListRequest) Send() (*diskProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfilesService.connection.URL(), p.diskProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &diskProfilesServiceListResponse{profile: result}, nil
}

func (p *diskProfilesServiceListRequest) MustSend() *diskProfilesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskProfilesService.connection.URL(), p.diskProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskProfilesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskProfilesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &diskProfilesServiceListResponse{profile: result}
}

//
// Returns the list of disk profiles of the system.
// The order of the returned list of disk profiles isn't guaranteed.
//
type diskProfilesServiceListResponse struct {
	profile *DiskProfileSlice
}

func (p *diskProfilesServiceListResponse) Profile() (*DiskProfileSlice, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *diskProfilesServiceListResponse) MustProfile() *DiskProfileSlice {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Returns the list of disk profiles of the system.
// The order of the returned list of disk profiles isn't guaranteed.
//
func (p *diskProfilesService) List() *diskProfilesServiceListRequest {
	return &diskProfilesServiceListRequest{diskProfilesService: p}
}

//
//
func (op *diskProfilesService) DiskProfileService(id string) *diskProfileService {
	return NewDiskProfileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *diskProfilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskProfileService(path), nil
	}
	return op.DiskProfileService(path[:index]).Service(path[index+1:])
}

func (op *diskProfilesService) String() string {
	return fmt.Sprintf("diskProfilesService:%s", op.path)
}

//
//
type measurableService struct {
	baseService
}

func NewMeasurableService(connection *Connection, path string) *measurableService {
	var result measurableService
	result.connection = connection
	result.path = path
	return &result
}

//
//
func (op *measurableService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *measurableService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *measurableService) String() string {
	return fmt.Sprintf("measurableService:%s", op.path)
}

//
// Manages the set of types of operating systems available in the system.
//
type operatingSystemsService struct {
	baseService
}

func NewOperatingSystemsService(connection *Connection, path string) *operatingSystemsService {
	var result operatingSystemsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of types of operating system available in the system.
// The order of the returned list of operating systems isn't guaranteed.
//
type operatingSystemsServiceListRequest struct {
	operatingSystemsService *operatingSystemsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
	max                     *int64
}

func (p *operatingSystemsServiceListRequest) Header(key, value string) *operatingSystemsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *operatingSystemsServiceListRequest) Query(key, value string) *operatingSystemsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *operatingSystemsServiceListRequest) Follow(follow string) *operatingSystemsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *operatingSystemsServiceListRequest) Max(max int64) *operatingSystemsServiceListRequest {
	p.max = &max
	return p
}

func (p *operatingSystemsServiceListRequest) Send() (*operatingSystemsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.operatingSystemsService.connection.URL(), p.operatingSystemsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.operatingSystemsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.operatingSystemsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOperatingSystemInfoReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &operatingSystemsServiceListResponse{operatingSystem: result}, nil
}

func (p *operatingSystemsServiceListRequest) MustSend() *operatingSystemsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.operatingSystemsService.connection.URL(), p.operatingSystemsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.operatingSystemsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.operatingSystemsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOperatingSystemInfoReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &operatingSystemsServiceListResponse{operatingSystem: result}
}

//
// Returns the list of types of operating system available in the system.
// The order of the returned list of operating systems isn't guaranteed.
//
type operatingSystemsServiceListResponse struct {
	operatingSystem *OperatingSystemInfoSlice
}

func (p *operatingSystemsServiceListResponse) OperatingSystem() (*OperatingSystemInfoSlice, bool) {
	if p.operatingSystem != nil {
		return p.operatingSystem, true
	}
	return nil, false
}

func (p *operatingSystemsServiceListResponse) MustOperatingSystem() *OperatingSystemInfoSlice {
	if p.operatingSystem == nil {
		panic("operatingSystem in response does not exist")
	}
	return p.operatingSystem
}

//
// Returns the list of types of operating system available in the system.
// The order of the returned list of operating systems isn't guaranteed.
//
func (p *operatingSystemsService) List() *operatingSystemsServiceListRequest {
	return &operatingSystemsServiceListRequest{operatingSystemsService: p}
}

//
//
func (op *operatingSystemsService) OperatingSystemService(id string) *operatingSystemService {
	return NewOperatingSystemService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *operatingSystemsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.OperatingSystemService(path), nil
	}
	return op.OperatingSystemService(path[:index]).Service(path[index+1:])
}

func (op *operatingSystemsService) String() string {
	return fmt.Sprintf("operatingSystemsService:%s", op.path)
}

//
// Manages the collection of disks available inside a specific storage domain.
//
type storageDomainDisksService struct {
	baseService
}

func NewStorageDomainDisksService(connection *Connection, path string) *storageDomainDisksService {
	var result storageDomainDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the {engine-name} this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
//
type storageDomainDisksServiceAddRequest struct {
	storageDomainDisksService *storageDomainDisksService
	header                    map[string]string
	query                     map[string]string
	disk                      *Disk
	unregistered              *bool
}

func (p *storageDomainDisksServiceAddRequest) Header(key, value string) *storageDomainDisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainDisksServiceAddRequest) Query(key, value string) *storageDomainDisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainDisksServiceAddRequest) Disk(disk *Disk) *storageDomainDisksServiceAddRequest {
	p.disk = disk
	return p
}

func (p *storageDomainDisksServiceAddRequest) Unregistered(unregistered bool) *storageDomainDisksServiceAddRequest {
	p.unregistered = &unregistered
	return p
}

func (p *storageDomainDisksServiceAddRequest) Send() (*storageDomainDisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDisksService.connection.URL(), p.storageDomainDisksService.path)
	values := make(url.Values)
	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageDomainDisksServiceAddResponse{disk: result}, nil
}

func (p *storageDomainDisksServiceAddRequest) MustSend() *storageDomainDisksServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDisksService.connection.URL(), p.storageDomainDisksService.path)
	values := make(url.Values)
	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDisksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDisksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageDomainDisksServiceAddResponse{disk: result}
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the {engine-name} this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
//
type storageDomainDisksServiceAddResponse struct {
	disk *Disk
}

func (p *storageDomainDisksServiceAddResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *storageDomainDisksServiceAddResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the {engine-name} this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
//
func (p *storageDomainDisksService) Add() *storageDomainDisksServiceAddRequest {
	return &storageDomainDisksServiceAddRequest{storageDomainDisksService: p}
}

//
// Retrieves the list of disks that are available in the storage domain.
// The order of the returned list of disks is not guaranteed.
//
type storageDomainDisksServiceListRequest struct {
	storageDomainDisksService *storageDomainDisksService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
	unregistered              *bool
}

func (p *storageDomainDisksServiceListRequest) Header(key, value string) *storageDomainDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainDisksServiceListRequest) Query(key, value string) *storageDomainDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainDisksServiceListRequest) Follow(follow string) *storageDomainDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainDisksServiceListRequest) Max(max int64) *storageDomainDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *storageDomainDisksServiceListRequest) Unregistered(unregistered bool) *storageDomainDisksServiceListRequest {
	p.unregistered = &unregistered
	return p
}

func (p *storageDomainDisksServiceListRequest) Send() (*storageDomainDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDisksService.connection.URL(), p.storageDomainDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &storageDomainDisksServiceListResponse{disks: result}, nil
}

func (p *storageDomainDisksServiceListRequest) MustSend() *storageDomainDisksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDisksService.connection.URL(), p.storageDomainDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDisksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDisksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &storageDomainDisksServiceListResponse{disks: result}
}

//
// Retrieves the list of disks that are available in the storage domain.
// The order of the returned list of disks is not guaranteed.
//
type storageDomainDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *storageDomainDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *storageDomainDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Retrieves the list of disks that are available in the storage domain.
// The order of the returned list of disks is not guaranteed.
//
func (p *storageDomainDisksService) List() *storageDomainDisksServiceListRequest {
	return &storageDomainDisksServiceListRequest{storageDomainDisksService: p}
}

//
// A reference to the service that manages a specific disk.
//
func (op *storageDomainDisksService) DiskService(id string) *storageDomainDiskService {
	return NewStorageDomainDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *storageDomainDisksService) String() string {
	return fmt.Sprintf("storageDomainDisksService:%s", op.path)
}

//
//
type vmGraphicsConsolesService struct {
	baseService
}

func NewVmGraphicsConsolesService(connection *Connection, path string) *vmGraphicsConsolesService {
	var result vmGraphicsConsolesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add new graphics console to the virtual machine.
//
type vmGraphicsConsolesServiceAddRequest struct {
	vmGraphicsConsolesService *vmGraphicsConsolesService
	header                    map[string]string
	query                     map[string]string
	console                   *GraphicsConsole
}

func (p *vmGraphicsConsolesServiceAddRequest) Header(key, value string) *vmGraphicsConsolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmGraphicsConsolesServiceAddRequest) Query(key, value string) *vmGraphicsConsolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmGraphicsConsolesServiceAddRequest) Console(console *GraphicsConsole) *vmGraphicsConsolesServiceAddRequest {
	p.console = console
	return p
}

func (p *vmGraphicsConsolesServiceAddRequest) Send() (*vmGraphicsConsolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsolesService.connection.URL(), p.vmGraphicsConsolesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGraphicsConsoleWriteOne(writer, p.console, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmGraphicsConsolesServiceAddResponse{console: result}, nil
}

func (p *vmGraphicsConsolesServiceAddRequest) MustSend() *vmGraphicsConsolesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsolesService.connection.URL(), p.vmGraphicsConsolesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGraphicsConsoleWriteOne(writer, p.console, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsolesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmGraphicsConsolesServiceAddResponse{console: result}
}

//
// Add new graphics console to the virtual machine.
//
type vmGraphicsConsolesServiceAddResponse struct {
	console *GraphicsConsole
}

func (p *vmGraphicsConsolesServiceAddResponse) Console() (*GraphicsConsole, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

func (p *vmGraphicsConsolesServiceAddResponse) MustConsole() *GraphicsConsole {
	if p.console == nil {
		panic("console in response does not exist")
	}
	return p.console
}

//
// Add new graphics console to the virtual machine.
//
func (p *vmGraphicsConsolesService) Add() *vmGraphicsConsolesServiceAddRequest {
	return &vmGraphicsConsolesServiceAddRequest{vmGraphicsConsolesService: p}
}

//
// Lists all the configured graphics consoles of the virtual machine.
// IMPORTANT: By default, when the `current` parameter is not specified, the data returned
// corresponds to the next execution of the virtual machine. In the current implementation of
// the system this means that the `address` and `port` attributes will not be populated because
// the system does not know what address and port will be used for the next execution. Since in most
// cases those attributes are needed, it is strongly advised to aways explicitly include the
// `current` parameter with the value `true`.
// The order of the returned list of graphics consoles is not guaranteed.
//
type vmGraphicsConsolesServiceListRequest struct {
	vmGraphicsConsolesService *vmGraphicsConsolesService
	header                    map[string]string
	query                     map[string]string
	current                   *bool
	follow                    *string
	max                       *int64
}

func (p *vmGraphicsConsolesServiceListRequest) Header(key, value string) *vmGraphicsConsolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmGraphicsConsolesServiceListRequest) Query(key, value string) *vmGraphicsConsolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmGraphicsConsolesServiceListRequest) Current(current bool) *vmGraphicsConsolesServiceListRequest {
	p.current = &current
	return p
}

func (p *vmGraphicsConsolesServiceListRequest) Follow(follow string) *vmGraphicsConsolesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vmGraphicsConsolesServiceListRequest) Max(max int64) *vmGraphicsConsolesServiceListRequest {
	p.max = &max
	return p
}

func (p *vmGraphicsConsolesServiceListRequest) Send() (*vmGraphicsConsolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsolesService.connection.URL(), p.vmGraphicsConsolesService.path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vmGraphicsConsolesServiceListResponse{consoles: result}, nil
}

func (p *vmGraphicsConsolesServiceListRequest) MustSend() *vmGraphicsConsolesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsolesService.connection.URL(), p.vmGraphicsConsolesService.path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsolesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vmGraphicsConsolesServiceListResponse{consoles: result}
}

//
// Lists all the configured graphics consoles of the virtual machine.
// IMPORTANT: By default, when the `current` parameter is not specified, the data returned
// corresponds to the next execution of the virtual machine. In the current implementation of
// the system this means that the `address` and `port` attributes will not be populated because
// the system does not know what address and port will be used for the next execution. Since in most
// cases those attributes are needed, it is strongly advised to aways explicitly include the
// `current` parameter with the value `true`.
// The order of the returned list of graphics consoles is not guaranteed.
//
type vmGraphicsConsolesServiceListResponse struct {
	consoles *GraphicsConsoleSlice
}

func (p *vmGraphicsConsolesServiceListResponse) Consoles() (*GraphicsConsoleSlice, bool) {
	if p.consoles != nil {
		return p.consoles, true
	}
	return nil, false
}

func (p *vmGraphicsConsolesServiceListResponse) MustConsoles() *GraphicsConsoleSlice {
	if p.consoles == nil {
		panic("consoles in response does not exist")
	}
	return p.consoles
}

//
// Lists all the configured graphics consoles of the virtual machine.
// IMPORTANT: By default, when the `current` parameter is not specified, the data returned
// corresponds to the next execution of the virtual machine. In the current implementation of
// the system this means that the `address` and `port` attributes will not be populated because
// the system does not know what address and port will be used for the next execution. Since in most
// cases those attributes are needed, it is strongly advised to aways explicitly include the
// `current` parameter with the value `true`.
// The order of the returned list of graphics consoles is not guaranteed.
//
func (p *vmGraphicsConsolesService) List() *vmGraphicsConsolesServiceListRequest {
	return &vmGraphicsConsolesServiceListRequest{vmGraphicsConsolesService: p}
}

//
// Returns a reference to the service that manages a specific virtual machine graphics console.
//
func (op *vmGraphicsConsolesService) ConsoleService(id string) *vmGraphicsConsoleService {
	return NewVmGraphicsConsoleService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmGraphicsConsolesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ConsoleService(path), nil
	}
	return op.ConsoleService(path[:index]).Service(path[index+1:])
}

func (op *vmGraphicsConsolesService) String() string {
	return fmt.Sprintf("vmGraphicsConsolesService:%s", op.path)
}

//
//
type statisticService struct {
	baseService
}

func NewStatisticService(connection *Connection, path string) *statisticService {
	var result statisticService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type statisticServiceGetRequest struct {
	statisticService *statisticService
	header           map[string]string
	query            map[string]string
	follow           *string
}

func (p *statisticServiceGetRequest) Header(key, value string) *statisticServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *statisticServiceGetRequest) Query(key, value string) *statisticServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *statisticServiceGetRequest) Follow(follow string) *statisticServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *statisticServiceGetRequest) Send() (*statisticServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.statisticService.connection.URL(), p.statisticService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.statisticService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.statisticService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStatisticReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &statisticServiceGetResponse{statistic: result}, nil
}

func (p *statisticServiceGetRequest) MustSend() *statisticServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.statisticService.connection.URL(), p.statisticService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.statisticService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.statisticService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStatisticReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &statisticServiceGetResponse{statistic: result}
}

//
//
type statisticServiceGetResponse struct {
	statistic *Statistic
}

func (p *statisticServiceGetResponse) Statistic() (*Statistic, bool) {
	if p.statistic != nil {
		return p.statistic, true
	}
	return nil, false
}

func (p *statisticServiceGetResponse) MustStatistic() *Statistic {
	if p.statistic == nil {
		panic("statistic in response does not exist")
	}
	return p.statistic
}

//
//
func (p *statisticService) Get() *statisticServiceGetRequest {
	return &statisticServiceGetRequest{statisticService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *statisticService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *statisticService) String() string {
	return fmt.Sprintf("statisticService:%s", op.path)
}

//
// Manages the set of scheduling policy units available in the system.
//
type schedulingPolicyUnitsService struct {
	baseService
}

func NewSchedulingPolicyUnitsService(connection *Connection, path string) *schedulingPolicyUnitsService {
	var result schedulingPolicyUnitsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of scheduling policy units available in the system.
// The order of the returned list of scheduling policy units isn't guaranteed.
//
type schedulingPolicyUnitsServiceListRequest struct {
	schedulingPolicyUnitsService *schedulingPolicyUnitsService
	header                       map[string]string
	query                        map[string]string
	filter                       *bool
	follow                       *string
	max                          *int64
}

func (p *schedulingPolicyUnitsServiceListRequest) Header(key, value string) *schedulingPolicyUnitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *schedulingPolicyUnitsServiceListRequest) Query(key, value string) *schedulingPolicyUnitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *schedulingPolicyUnitsServiceListRequest) Filter(filter bool) *schedulingPolicyUnitsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *schedulingPolicyUnitsServiceListRequest) Follow(follow string) *schedulingPolicyUnitsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *schedulingPolicyUnitsServiceListRequest) Max(max int64) *schedulingPolicyUnitsServiceListRequest {
	p.max = &max
	return p
}

func (p *schedulingPolicyUnitsServiceListRequest) Send() (*schedulingPolicyUnitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyUnitsService.connection.URL(), p.schedulingPolicyUnitsService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPolicyUnitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyUnitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyUnitReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &schedulingPolicyUnitsServiceListResponse{units: result}, nil
}

func (p *schedulingPolicyUnitsServiceListRequest) MustSend() *schedulingPolicyUnitsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.schedulingPolicyUnitsService.connection.URL(), p.schedulingPolicyUnitsService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.schedulingPolicyUnitsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.schedulingPolicyUnitsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyUnitReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &schedulingPolicyUnitsServiceListResponse{units: result}
}

//
// Returns the list of scheduling policy units available in the system.
// The order of the returned list of scheduling policy units isn't guaranteed.
//
type schedulingPolicyUnitsServiceListResponse struct {
	units *SchedulingPolicyUnitSlice
}

func (p *schedulingPolicyUnitsServiceListResponse) Units() (*SchedulingPolicyUnitSlice, bool) {
	if p.units != nil {
		return p.units, true
	}
	return nil, false
}

func (p *schedulingPolicyUnitsServiceListResponse) MustUnits() *SchedulingPolicyUnitSlice {
	if p.units == nil {
		panic("units in response does not exist")
	}
	return p.units
}

//
// Returns the list of scheduling policy units available in the system.
// The order of the returned list of scheduling policy units isn't guaranteed.
//
func (p *schedulingPolicyUnitsService) List() *schedulingPolicyUnitsServiceListRequest {
	return &schedulingPolicyUnitsServiceListRequest{schedulingPolicyUnitsService: p}
}

//
//
func (op *schedulingPolicyUnitsService) UnitService(id string) *schedulingPolicyUnitService {
	return NewSchedulingPolicyUnitService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *schedulingPolicyUnitsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.UnitService(path), nil
	}
	return op.UnitService(path[:index]).Service(path[index+1:])
}

func (op *schedulingPolicyUnitsService) String() string {
	return fmt.Sprintf("schedulingPolicyUnitsService:%s", op.path)
}

//
// This service represents list of vms that have a specific
// label when accessed through the affinitylabels/vms
// subcollection.
//
type affinityLabelVmsService struct {
	baseService
}

func NewAffinityLabelVmsService(connection *Connection, path string) *affinityLabelVmsService {
	var result affinityLabelVmsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a label to a vm.
//
type affinityLabelVmsServiceAddRequest struct {
	affinityLabelVmsService *affinityLabelVmsService
	header                  map[string]string
	query                   map[string]string
	vm                      *Vm
}

func (p *affinityLabelVmsServiceAddRequest) Header(key, value string) *affinityLabelVmsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelVmsServiceAddRequest) Query(key, value string) *affinityLabelVmsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelVmsServiceAddRequest) Vm(vm *Vm) *affinityLabelVmsServiceAddRequest {
	p.vm = vm
	return p
}

func (p *affinityLabelVmsServiceAddRequest) Send() (*affinityLabelVmsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmsService.connection.URL(), p.affinityLabelVmsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmWriteOne(writer, p.vm, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelVmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &affinityLabelVmsServiceAddResponse{vm: result}, nil
}

func (p *affinityLabelVmsServiceAddRequest) MustSend() *affinityLabelVmsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmsService.connection.URL(), p.affinityLabelVmsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmWriteOne(writer, p.vm, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelVmsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &affinityLabelVmsServiceAddResponse{vm: result}
}

//
// Add a label to a vm.
//
type affinityLabelVmsServiceAddResponse struct {
	vm *Vm
}

func (p *affinityLabelVmsServiceAddResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *affinityLabelVmsServiceAddResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Add a label to a vm.
//
func (p *affinityLabelVmsService) Add() *affinityLabelVmsServiceAddRequest {
	return &affinityLabelVmsServiceAddRequest{affinityLabelVmsService: p}
}

//
// List all virtual machines with the label.
// The order of the returned virtual machines isn't guaranteed.
//
type affinityLabelVmsServiceListRequest struct {
	affinityLabelVmsService *affinityLabelVmsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
}

func (p *affinityLabelVmsServiceListRequest) Header(key, value string) *affinityLabelVmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelVmsServiceListRequest) Query(key, value string) *affinityLabelVmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelVmsServiceListRequest) Follow(follow string) *affinityLabelVmsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *affinityLabelVmsServiceListRequest) Send() (*affinityLabelVmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmsService.connection.URL(), p.affinityLabelVmsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelVmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &affinityLabelVmsServiceListResponse{vms: result}, nil
}

func (p *affinityLabelVmsServiceListRequest) MustSend() *affinityLabelVmsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmsService.connection.URL(), p.affinityLabelVmsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelVmsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &affinityLabelVmsServiceListResponse{vms: result}
}

//
// List all virtual machines with the label.
// The order of the returned virtual machines isn't guaranteed.
//
type affinityLabelVmsServiceListResponse struct {
	vms *VmSlice
}

func (p *affinityLabelVmsServiceListResponse) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *affinityLabelVmsServiceListResponse) MustVms() *VmSlice {
	if p.vms == nil {
		panic("vms in response does not exist")
	}
	return p.vms
}

//
// List all virtual machines with the label.
// The order of the returned virtual machines isn't guaranteed.
//
func (p *affinityLabelVmsService) List() *affinityLabelVmsServiceListRequest {
	return &affinityLabelVmsServiceListRequest{affinityLabelVmsService: p}
}

//
// A link to the specific label-vm assignment to
// allow label removal.
//
func (op *affinityLabelVmsService) VmService(id string) *affinityLabelVmService {
	return NewAffinityLabelVmService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *affinityLabelVmsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.VmService(path), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *affinityLabelVmsService) String() string {
	return fmt.Sprintf("affinityLabelVmsService:%s", op.path)
}

//
//
type vmNicsService struct {
	baseService
}

func NewVmNicsService(connection *Connection, path string) *vmNicsService {
	var result vmNicsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a NIC to the virtual machine.
// The following example adds to the virtual machine `123` a network interface named `mynic` using `virtio` and the
// NIC profile `456`.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/nics
// ----
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>virtio</interface>
//   <vnic_profile id="456"/>
// </nic>
// ----
// The following example sends that request using `curl`:
// [source,bash]
// ----
// curl \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --data '
// <nic>
//   <name>mynic</name>
//   <interface>virtio</interface>
//   <vnic_profile id="456"/>
// </nic>
// ' \
// https://myengine.example.com/ovirt-engine/api/vms/123/nics
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
type vmNicsServiceAddRequest struct {
	vmNicsService *vmNicsService
	header        map[string]string
	query         map[string]string
	nic           *Nic
}

func (p *vmNicsServiceAddRequest) Header(key, value string) *vmNicsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmNicsServiceAddRequest) Query(key, value string) *vmNicsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmNicsServiceAddRequest) Nic(nic *Nic) *vmNicsServiceAddRequest {
	p.nic = nic
	return p
}

func (p *vmNicsServiceAddRequest) Send() (*vmNicsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicsService.connection.URL(), p.vmNicsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmNicsServiceAddResponse{nic: result}, nil
}

func (p *vmNicsServiceAddRequest) MustSend() *vmNicsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmNicsService.connection.URL(), p.vmNicsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmNicsServiceAddResponse{nic: result}
}

//
// Adds a NIC to the virtual machine.
// The following example adds to the virtual machine `123` a network interface named `mynic` using `virtio` and the
// NIC profile `456`.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/nics
// ----
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>virtio</interface>
//   <vnic_profile id="456"/>
// </nic>
// ----
// The following example sends that request using `curl`:
// [source,bash]
// ----
// curl \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --data '
// <nic>
//   <name>mynic</name>
//   <interface>virtio</interface>
//   <vnic_profile id="456"/>
// </nic>
// ' \
// https://myengine.example.com/ovirt-engine/api/vms/123/nics
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
type vmNicsServiceAddResponse struct {
	nic *Nic
}

func (p *vmNicsServiceAddResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *vmNicsServiceAddResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Adds a NIC to the virtual machine.
// The following example adds to the virtual machine `123` a network interface named `mynic` using `virtio` and the
// NIC profile `456`.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/nics
// ----
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>virtio</interface>
//   <vnic_profile id="456"/>
// </nic>
// ----
// The following example sends that request using `curl`:
// [source,bash]
// ----
// curl \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --data '
// <nic>
//   <name>mynic</name>
//   <interface>virtio</interface>
//   <vnic_profile id="456"/>
// </nic>
// ' \
// https://myengine.example.com/ovirt-engine/api/vms/123/nics
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
func (p *vmNicsService) Add() *vmNicsServiceAddRequest {
	return &vmNicsServiceAddRequest{vmNicsService: p}
}

//
// Returns the list of NICs of the virtual machine.
// The order of the returned list of NICs isn't guaranteed.
//
type vmNicsServiceListRequest struct {
	vmNicsService *vmNicsService
	header        map[string]string
	query         map[string]string
	follow        *string
	max           *int64
}

func (p *vmNicsServiceListRequest) Header(key, value string) *vmNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmNicsServiceListRequest) Query(key, value string) *vmNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmNicsServiceListRequest) Follow(follow string) *vmNicsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vmNicsServiceListRequest) Max(max int64) *vmNicsServiceListRequest {
	p.max = &max
	return p
}

func (p *vmNicsServiceListRequest) Send() (*vmNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicsService.connection.URL(), p.vmNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vmNicsServiceListResponse{nics: result}, nil
}

func (p *vmNicsServiceListRequest) MustSend() *vmNicsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmNicsService.connection.URL(), p.vmNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vmNicsServiceListResponse{nics: result}
}

//
// Returns the list of NICs of the virtual machine.
// The order of the returned list of NICs isn't guaranteed.
//
type vmNicsServiceListResponse struct {
	nics *NicSlice
}

func (p *vmNicsServiceListResponse) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *vmNicsServiceListResponse) MustNics() *NicSlice {
	if p.nics == nil {
		panic("nics in response does not exist")
	}
	return p.nics
}

//
// Returns the list of NICs of the virtual machine.
// The order of the returned list of NICs isn't guaranteed.
//
func (p *vmNicsService) List() *vmNicsServiceListRequest {
	return &vmNicsServiceListRequest{vmNicsService: p}
}

//
//
func (op *vmNicsService) NicService(id string) *vmNicService {
	return NewVmNicService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmNicsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NicService(path), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *vmNicsService) String() string {
	return fmt.Sprintf("vmNicsService:%s", op.path)
}

//
//
type moveableService struct {
	baseService
}

func NewMoveableService(connection *Connection, path string) *moveableService {
	var result moveableService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type moveableServiceMoveRequest struct {
	moveableService *moveableService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *moveableServiceMoveRequest) Header(key, value string) *moveableServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *moveableServiceMoveRequest) Query(key, value string) *moveableServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *moveableServiceMoveRequest) Async(async bool) *moveableServiceMoveRequest {
	p.async = &async
	return p
}

func (p *moveableServiceMoveRequest) Send() (*moveableServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.moveableService.connection.URL(), p.moveableService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.moveableService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.moveableService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(moveableServiceMoveResponse), nil
}

func (p *moveableServiceMoveRequest) MustSend() *moveableServiceMoveResponse {
	rawURL := fmt.Sprintf("%s%s/move", p.moveableService.connection.URL(), p.moveableService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.moveableService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.moveableService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(moveableServiceMoveResponse)
}

//
//
type moveableServiceMoveResponse struct {
}

//
//
func (p *moveableService) Move() *moveableServiceMoveRequest {
	return &moveableServiceMoveRequest{moveableService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *moveableService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *moveableService) String() string {
	return fmt.Sprintf("moveableService:%s", op.path)
}

//
// A service to manage an event in the system.
//
type eventService struct {
	baseService
}

func NewEventService(connection *Connection, path string) *eventService {
	var result eventService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get an event.
// An example of getting an event:
// [source]
// ----
// GET /ovirt-engine/api/events/123
// ----
// [source,xml]
// ----
// <event href="/ovirt-engine/api/events/123" id="123">
//   <description>Host example.com was added by admin@internal-authz.</description>
//   <code>42</code>
//   <correlation_id>135</correlation_id>
//   <custom_id>-1</custom_id>
//   <flood_rate>30</flood_rate>
//   <origin>oVirt</origin>
//   <severity>normal</severity>
//   <time>2016-12-11T11:13:44.654+02:00</time>
//   <cluster href="/ovirt-engine/api/clusters/456" id="456"/>
//   <host href="/ovirt-engine/api/hosts/789" id="789"/>
//   <user href="/ovirt-engine/api/users/987" id="987"/>
// </event>
// ----
// Note that the number of fields changes according to the information that resides on the event.
// For example, for storage domain related events you will get the storage domain reference,
// as well as the reference for the data center this storage domain resides in.
//
type eventServiceGetRequest struct {
	eventService *eventService
	header       map[string]string
	query        map[string]string
	follow       *string
}

func (p *eventServiceGetRequest) Header(key, value string) *eventServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *eventServiceGetRequest) Query(key, value string) *eventServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *eventServiceGetRequest) Follow(follow string) *eventServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *eventServiceGetRequest) Send() (*eventServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.eventService.connection.URL(), p.eventService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.eventService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.eventService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLEventReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &eventServiceGetResponse{event: result}, nil
}

func (p *eventServiceGetRequest) MustSend() *eventServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.eventService.connection.URL(), p.eventService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.eventService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.eventService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLEventReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &eventServiceGetResponse{event: result}
}

//
// Get an event.
// An example of getting an event:
// [source]
// ----
// GET /ovirt-engine/api/events/123
// ----
// [source,xml]
// ----
// <event href="/ovirt-engine/api/events/123" id="123">
//   <description>Host example.com was added by admin@internal-authz.</description>
//   <code>42</code>
//   <correlation_id>135</correlation_id>
//   <custom_id>-1</custom_id>
//   <flood_rate>30</flood_rate>
//   <origin>oVirt</origin>
//   <severity>normal</severity>
//   <time>2016-12-11T11:13:44.654+02:00</time>
//   <cluster href="/ovirt-engine/api/clusters/456" id="456"/>
//   <host href="/ovirt-engine/api/hosts/789" id="789"/>
//   <user href="/ovirt-engine/api/users/987" id="987"/>
// </event>
// ----
// Note that the number of fields changes according to the information that resides on the event.
// For example, for storage domain related events you will get the storage domain reference,
// as well as the reference for the data center this storage domain resides in.
//
type eventServiceGetResponse struct {
	event *Event
}

func (p *eventServiceGetResponse) Event() (*Event, bool) {
	if p.event != nil {
		return p.event, true
	}
	return nil, false
}

func (p *eventServiceGetResponse) MustEvent() *Event {
	if p.event == nil {
		panic("event in response does not exist")
	}
	return p.event
}

//
// Get an event.
// An example of getting an event:
// [source]
// ----
// GET /ovirt-engine/api/events/123
// ----
// [source,xml]
// ----
// <event href="/ovirt-engine/api/events/123" id="123">
//   <description>Host example.com was added by admin@internal-authz.</description>
//   <code>42</code>
//   <correlation_id>135</correlation_id>
//   <custom_id>-1</custom_id>
//   <flood_rate>30</flood_rate>
//   <origin>oVirt</origin>
//   <severity>normal</severity>
//   <time>2016-12-11T11:13:44.654+02:00</time>
//   <cluster href="/ovirt-engine/api/clusters/456" id="456"/>
//   <host href="/ovirt-engine/api/hosts/789" id="789"/>
//   <user href="/ovirt-engine/api/users/987" id="987"/>
// </event>
// ----
// Note that the number of fields changes according to the information that resides on the event.
// For example, for storage domain related events you will get the storage domain reference,
// as well as the reference for the data center this storage domain resides in.
//
func (p *eventService) Get() *eventServiceGetRequest {
	return &eventServiceGetRequest{eventService: p}
}

//
// Removes an event from internal audit log.
// An event can be removed by sending following request
// [source]
// ----
// DELETE /ovirt-engine/api/events/123
// ----
//
type eventServiceRemoveRequest struct {
	eventService *eventService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *eventServiceRemoveRequest) Header(key, value string) *eventServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *eventServiceRemoveRequest) Query(key, value string) *eventServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *eventServiceRemoveRequest) Async(async bool) *eventServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *eventServiceRemoveRequest) Send() (*eventServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.eventService.connection.URL(), p.eventService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.eventService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.eventService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(eventServiceRemoveResponse), nil
}

func (p *eventServiceRemoveRequest) MustSend() *eventServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.eventService.connection.URL(), p.eventService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.eventService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.eventService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(eventServiceRemoveResponse)
}

//
// Removes an event from internal audit log.
// An event can be removed by sending following request
// [source]
// ----
// DELETE /ovirt-engine/api/events/123
// ----
//
type eventServiceRemoveResponse struct {
}

//
// Removes an event from internal audit log.
// An event can be removed by sending following request
// [source]
// ----
// DELETE /ovirt-engine/api/events/123
// ----
//
func (p *eventService) Remove() *eventServiceRemoveRequest {
	return &eventServiceRemoveRequest{eventService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *eventService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *eventService) String() string {
	return fmt.Sprintf("eventService:%s", op.path)
}

//
//
type snapshotService struct {
	baseService
}

func NewSnapshotService(connection *Connection, path string) *snapshotService {
	var result snapshotService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type snapshotServiceGetRequest struct {
	snapshotService *snapshotService
	header          map[string]string
	query           map[string]string
	follow          *string
}

func (p *snapshotServiceGetRequest) Header(key, value string) *snapshotServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *snapshotServiceGetRequest) Query(key, value string) *snapshotServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *snapshotServiceGetRequest) Follow(follow string) *snapshotServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *snapshotServiceGetRequest) Send() (*snapshotServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotService.connection.URL(), p.snapshotService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSnapshotReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &snapshotServiceGetResponse{snapshot: result}, nil
}

func (p *snapshotServiceGetRequest) MustSend() *snapshotServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.snapshotService.connection.URL(), p.snapshotService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSnapshotReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &snapshotServiceGetResponse{snapshot: result}
}

//
//
type snapshotServiceGetResponse struct {
	snapshot *Snapshot
}

func (p *snapshotServiceGetResponse) Snapshot() (*Snapshot, bool) {
	if p.snapshot != nil {
		return p.snapshot, true
	}
	return nil, false
}

func (p *snapshotServiceGetResponse) MustSnapshot() *Snapshot {
	if p.snapshot == nil {
		panic("snapshot in response does not exist")
	}
	return p.snapshot
}

//
//
func (p *snapshotService) Get() *snapshotServiceGetRequest {
	return &snapshotServiceGetRequest{snapshotService: p}
}

//
//
type snapshotServiceRemoveRequest struct {
	snapshotService *snapshotService
	header          map[string]string
	query           map[string]string
	allContent      *bool
	async           *bool
}

func (p *snapshotServiceRemoveRequest) Header(key, value string) *snapshotServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *snapshotServiceRemoveRequest) Query(key, value string) *snapshotServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *snapshotServiceRemoveRequest) AllContent(allContent bool) *snapshotServiceRemoveRequest {
	p.allContent = &allContent
	return p
}

func (p *snapshotServiceRemoveRequest) Async(async bool) *snapshotServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *snapshotServiceRemoveRequest) Send() (*snapshotServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotService.connection.URL(), p.snapshotService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(snapshotServiceRemoveResponse), nil
}

func (p *snapshotServiceRemoveRequest) MustSend() *snapshotServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.snapshotService.connection.URL(), p.snapshotService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(snapshotServiceRemoveResponse)
}

//
//
type snapshotServiceRemoveResponse struct {
}

//
//
func (p *snapshotService) Remove() *snapshotServiceRemoveRequest {
	return &snapshotServiceRemoveRequest{snapshotService: p}
}

//
// Restores a virtual machine snapshot.
// For example, to restore the snapshot with identifier `456` of virtual machine with identifier `123` send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots/456/restore
// ----
// With an empty `action` in the body:
// [source,xml]
// ----
// <action/>
// ----
//
type snapshotServiceRestoreRequest struct {
	snapshotService *snapshotService
	header          map[string]string
	query           map[string]string
	async           *bool
	disks           *DiskSlice
	restoreMemory   *bool
}

func (p *snapshotServiceRestoreRequest) Header(key, value string) *snapshotServiceRestoreRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *snapshotServiceRestoreRequest) Query(key, value string) *snapshotServiceRestoreRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *snapshotServiceRestoreRequest) Async(async bool) *snapshotServiceRestoreRequest {
	p.async = &async
	return p
}

func (p *snapshotServiceRestoreRequest) Disks(disks *DiskSlice) *snapshotServiceRestoreRequest {
	p.disks = disks
	return p
}

func (p *snapshotServiceRestoreRequest) DisksOfAny(anys ...*Disk) *snapshotServiceRestoreRequest {
	if p.disks == nil {
		p.disks = new(DiskSlice)
	}
	p.disks.slice = append(p.disks.slice, anys...)
	return p
}

func (p *snapshotServiceRestoreRequest) RestoreMemory(restoreMemory bool) *snapshotServiceRestoreRequest {
	p.restoreMemory = &restoreMemory
	return p
}

func (p *snapshotServiceRestoreRequest) Send() (*snapshotServiceRestoreResponse, error) {
	rawURL := fmt.Sprintf("%s%s/restore", p.snapshotService.connection.URL(), p.snapshotService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Disks(p.disks)
	if p.restoreMemory != nil {
		actionBuilder.RestoreMemory(*p.restoreMemory)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(snapshotServiceRestoreResponse), nil
}

func (p *snapshotServiceRestoreRequest) MustSend() *snapshotServiceRestoreResponse {
	rawURL := fmt.Sprintf("%s%s/restore", p.snapshotService.connection.URL(), p.snapshotService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Disks(p.disks)
	if p.restoreMemory != nil {
		actionBuilder.RestoreMemory(*p.restoreMemory)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(snapshotServiceRestoreResponse)
}

//
// Restores a virtual machine snapshot.
// For example, to restore the snapshot with identifier `456` of virtual machine with identifier `123` send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots/456/restore
// ----
// With an empty `action` in the body:
// [source,xml]
// ----
// <action/>
// ----
//
type snapshotServiceRestoreResponse struct {
}

//
// Restores a virtual machine snapshot.
// For example, to restore the snapshot with identifier `456` of virtual machine with identifier `123` send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots/456/restore
// ----
// With an empty `action` in the body:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *snapshotService) Restore() *snapshotServiceRestoreRequest {
	return &snapshotServiceRestoreRequest{snapshotService: p}
}

//
//
func (op *snapshotService) CdromsService() *snapshotCdromsService {
	return NewSnapshotCdromsService(op.connection, fmt.Sprintf("%s/cdroms", op.path))
}

//
//
func (op *snapshotService) DisksService() *snapshotDisksService {
	return NewSnapshotDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
//
func (op *snapshotService) NicsService() *snapshotNicsService {
	return NewSnapshotNicsService(op.connection, fmt.Sprintf("%s/nics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *snapshotService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "cdroms" {
		return op.CdromsService(), nil
	}
	if strings.HasPrefix(path, "cdroms/") {
		return op.CdromsService().Service(path[7:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *snapshotService) String() string {
	return fmt.Sprintf("snapshotService:%s", op.path)
}

//
//
type templateNicsService struct {
	baseService
}

func NewTemplateNicsService(connection *Connection, path string) *templateNicsService {
	var result templateNicsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new network interface card to the template.
//
type templateNicsServiceAddRequest struct {
	templateNicsService *templateNicsService
	header              map[string]string
	query               map[string]string
	nic                 *Nic
}

func (p *templateNicsServiceAddRequest) Header(key, value string) *templateNicsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateNicsServiceAddRequest) Query(key, value string) *templateNicsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateNicsServiceAddRequest) Nic(nic *Nic) *templateNicsServiceAddRequest {
	p.nic = nic
	return p
}

func (p *templateNicsServiceAddRequest) Send() (*templateNicsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicsService.connection.URL(), p.templateNicsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateNicsServiceAddResponse{nic: result}, nil
}

func (p *templateNicsServiceAddRequest) MustSend() *templateNicsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateNicsService.connection.URL(), p.templateNicsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateNicsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateNicsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateNicsServiceAddResponse{nic: result}
}

//
// Add a new network interface card to the template.
//
type templateNicsServiceAddResponse struct {
	nic *Nic
}

func (p *templateNicsServiceAddResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *templateNicsServiceAddResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Add a new network interface card to the template.
//
func (p *templateNicsService) Add() *templateNicsServiceAddRequest {
	return &templateNicsServiceAddRequest{templateNicsService: p}
}

//
// Returns the list of NICs of the template.
// The order of the returned list of NICs isn't guaranteed.
//
type templateNicsServiceListRequest struct {
	templateNicsService *templateNicsService
	header              map[string]string
	query               map[string]string
	follow              *string
	max                 *int64
}

func (p *templateNicsServiceListRequest) Header(key, value string) *templateNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateNicsServiceListRequest) Query(key, value string) *templateNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateNicsServiceListRequest) Follow(follow string) *templateNicsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *templateNicsServiceListRequest) Max(max int64) *templateNicsServiceListRequest {
	p.max = &max
	return p
}

func (p *templateNicsServiceListRequest) Send() (*templateNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicsService.connection.URL(), p.templateNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &templateNicsServiceListResponse{nics: result}, nil
}

func (p *templateNicsServiceListRequest) MustSend() *templateNicsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateNicsService.connection.URL(), p.templateNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateNicsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateNicsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &templateNicsServiceListResponse{nics: result}
}

//
// Returns the list of NICs of the template.
// The order of the returned list of NICs isn't guaranteed.
//
type templateNicsServiceListResponse struct {
	nics *NicSlice
}

func (p *templateNicsServiceListResponse) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *templateNicsServiceListResponse) MustNics() *NicSlice {
	if p.nics == nil {
		panic("nics in response does not exist")
	}
	return p.nics
}

//
// Returns the list of NICs of the template.
// The order of the returned list of NICs isn't guaranteed.
//
func (p *templateNicsService) List() *templateNicsServiceListRequest {
	return &templateNicsServiceListRequest{templateNicsService: p}
}

//
//
func (op *templateNicsService) NicService(id string) *templateNicService {
	return NewTemplateNicService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateNicsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NicService(path), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *templateNicsService) String() string {
	return fmt.Sprintf("templateNicsService:%s", op.path)
}

//
//
type macPoolsService struct {
	baseService
}

func NewMacPoolsService(connection *Connection, path string) *macPoolsService {
	var result macPoolsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new MAC address pool.
// Creation of a MAC address pool requires values for the `name` and `ranges` attributes.
// For example, to create MAC address pool send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/macpools
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>MACPool</name>
//   <description>A MAC address pool</description>
//   <allow_duplicates>true</allow_duplicates>
//   <default_pool>false</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
type macPoolsServiceAddRequest struct {
	macPoolsService *macPoolsService
	header          map[string]string
	query           map[string]string
	pool            *MacPool
}

func (p *macPoolsServiceAddRequest) Header(key, value string) *macPoolsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *macPoolsServiceAddRequest) Query(key, value string) *macPoolsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *macPoolsServiceAddRequest) Pool(pool *MacPool) *macPoolsServiceAddRequest {
	p.pool = pool
	return p
}

func (p *macPoolsServiceAddRequest) Send() (*macPoolsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolsService.connection.URL(), p.macPoolsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLMacPoolWriteOne(writer, p.pool, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.macPoolsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.macPoolsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLMacPoolReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &macPoolsServiceAddResponse{pool: result}, nil
}

func (p *macPoolsServiceAddRequest) MustSend() *macPoolsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.macPoolsService.connection.URL(), p.macPoolsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLMacPoolWriteOne(writer, p.pool, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.macPoolsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.macPoolsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLMacPoolReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &macPoolsServiceAddResponse{pool: result}
}

//
// Creates a new MAC address pool.
// Creation of a MAC address pool requires values for the `name` and `ranges` attributes.
// For example, to create MAC address pool send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/macpools
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>MACPool</name>
//   <description>A MAC address pool</description>
//   <allow_duplicates>true</allow_duplicates>
//   <default_pool>false</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
type macPoolsServiceAddResponse struct {
	pool *MacPool
}

func (p *macPoolsServiceAddResponse) Pool() (*MacPool, bool) {
	if p.pool != nil {
		return p.pool, true
	}
	return nil, false
}

func (p *macPoolsServiceAddResponse) MustPool() *MacPool {
	if p.pool == nil {
		panic("pool in response does not exist")
	}
	return p.pool
}

//
// Creates a new MAC address pool.
// Creation of a MAC address pool requires values for the `name` and `ranges` attributes.
// For example, to create MAC address pool send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/macpools
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>MACPool</name>
//   <description>A MAC address pool</description>
//   <allow_duplicates>true</allow_duplicates>
//   <default_pool>false</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
func (p *macPoolsService) Add() *macPoolsServiceAddRequest {
	return &macPoolsServiceAddRequest{macPoolsService: p}
}

//
// Return the list of MAC address pools of the system.
// The returned list of MAC address pools isn't guaranteed.
//
type macPoolsServiceListRequest struct {
	macPoolsService *macPoolsService
	header          map[string]string
	query           map[string]string
	follow          *string
	max             *int64
}

func (p *macPoolsServiceListRequest) Header(key, value string) *macPoolsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *macPoolsServiceListRequest) Query(key, value string) *macPoolsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *macPoolsServiceListRequest) Follow(follow string) *macPoolsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *macPoolsServiceListRequest) Max(max int64) *macPoolsServiceListRequest {
	p.max = &max
	return p
}

func (p *macPoolsServiceListRequest) Send() (*macPoolsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolsService.connection.URL(), p.macPoolsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.macPoolsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.macPoolsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLMacPoolReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &macPoolsServiceListResponse{pools: result}, nil
}

func (p *macPoolsServiceListRequest) MustSend() *macPoolsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.macPoolsService.connection.URL(), p.macPoolsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.macPoolsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.macPoolsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLMacPoolReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &macPoolsServiceListResponse{pools: result}
}

//
// Return the list of MAC address pools of the system.
// The returned list of MAC address pools isn't guaranteed.
//
type macPoolsServiceListResponse struct {
	pools *MacPoolSlice
}

func (p *macPoolsServiceListResponse) Pools() (*MacPoolSlice, bool) {
	if p.pools != nil {
		return p.pools, true
	}
	return nil, false
}

func (p *macPoolsServiceListResponse) MustPools() *MacPoolSlice {
	if p.pools == nil {
		panic("pools in response does not exist")
	}
	return p.pools
}

//
// Return the list of MAC address pools of the system.
// The returned list of MAC address pools isn't guaranteed.
//
func (p *macPoolsService) List() *macPoolsServiceListRequest {
	return &macPoolsServiceListRequest{macPoolsService: p}
}

//
//
func (op *macPoolsService) MacPoolService(id string) *macPoolService {
	return NewMacPoolService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *macPoolsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.MacPoolService(path), nil
	}
	return op.MacPoolService(path[:index]).Service(path[index+1:])
}

func (op *macPoolsService) String() string {
	return fmt.Sprintf("macPoolsService:%s", op.path)
}

//
// Manages the virtual machine template and template versions.
//
type templateService struct {
	baseService
}

func NewTemplateService(connection *Connection, path string) *templateService {
	var result templateService
	result.connection = connection
	result.path = path
	return &result
}

//
// Exports a template to the data center export domain.
// For example, the operation can be facilitated using the following request:
// [source]
// ----
// POST /ovirt-engine/api/templates/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <exclusive>true<exclusive/>
// </action>
// ----
//
type templateServiceExportRequest struct {
	templateService *templateService
	header          map[string]string
	query           map[string]string
	exclusive       *bool
	storageDomain   *StorageDomain
}

func (p *templateServiceExportRequest) Header(key, value string) *templateServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateServiceExportRequest) Query(key, value string) *templateServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateServiceExportRequest) Exclusive(exclusive bool) *templateServiceExportRequest {
	p.exclusive = &exclusive
	return p
}

func (p *templateServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *templateServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *templateServiceExportRequest) Send() (*templateServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.templateService.connection.URL(), p.templateService.path)
	actionBuilder := NewActionBuilder()
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(templateServiceExportResponse), nil
}

func (p *templateServiceExportRequest) MustSend() *templateServiceExportResponse {
	rawURL := fmt.Sprintf("%s%s/export", p.templateService.connection.URL(), p.templateService.path)
	actionBuilder := NewActionBuilder()
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(templateServiceExportResponse)
}

//
// Exports a template to the data center export domain.
// For example, the operation can be facilitated using the following request:
// [source]
// ----
// POST /ovirt-engine/api/templates/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <exclusive>true<exclusive/>
// </action>
// ----
//
type templateServiceExportResponse struct {
}

//
// Exports a template to the data center export domain.
// For example, the operation can be facilitated using the following request:
// [source]
// ----
// POST /ovirt-engine/api/templates/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <exclusive>true<exclusive/>
// </action>
// ----
//
func (p *templateService) Export() *templateServiceExportRequest {
	return &templateServiceExportRequest{templateService: p}
}

//
// Returns the information about this template or template version.
//
type templateServiceGetRequest struct {
	templateService *templateService
	header          map[string]string
	query           map[string]string
	filter          *bool
	follow          *string
}

func (p *templateServiceGetRequest) Header(key, value string) *templateServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateServiceGetRequest) Query(key, value string) *templateServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateServiceGetRequest) Filter(filter bool) *templateServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *templateServiceGetRequest) Follow(follow string) *templateServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *templateServiceGetRequest) Send() (*templateServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateService.connection.URL(), p.templateService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateServiceGetResponse{template: result}, nil
}

func (p *templateServiceGetRequest) MustSend() *templateServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateService.connection.URL(), p.templateService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateServiceGetResponse{template: result}
}

//
// Returns the information about this template or template version.
//
type templateServiceGetResponse struct {
	template *Template
}

func (p *templateServiceGetResponse) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

func (p *templateServiceGetResponse) MustTemplate() *Template {
	if p.template == nil {
		panic("template in response does not exist")
	}
	return p.template
}

//
// Returns the information about this template or template version.
//
func (p *templateService) Get() *templateServiceGetRequest {
	return &templateServiceGetRequest{templateService: p}
}

//
// Removes a virtual machine template.
// [source]
// ----
// DELETE /ovirt-engine/api/templates/123
// ----
//
type templateServiceRemoveRequest struct {
	templateService *templateService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *templateServiceRemoveRequest) Header(key, value string) *templateServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateServiceRemoveRequest) Query(key, value string) *templateServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateServiceRemoveRequest) Async(async bool) *templateServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *templateServiceRemoveRequest) Send() (*templateServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateService.connection.URL(), p.templateService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(templateServiceRemoveResponse), nil
}

func (p *templateServiceRemoveRequest) MustSend() *templateServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateService.connection.URL(), p.templateService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(templateServiceRemoveResponse)
}

//
// Removes a virtual machine template.
// [source]
// ----
// DELETE /ovirt-engine/api/templates/123
// ----
//
type templateServiceRemoveResponse struct {
}

//
// Removes a virtual machine template.
// [source]
// ----
// DELETE /ovirt-engine/api/templates/123
// ----
//
func (p *templateService) Remove() *templateServiceRemoveRequest {
	return &templateServiceRemoveRequest{templateService: p}
}

//
// Updates the template.
// The `name`, `description`, `type`, `memory`, `cpu`, `topology`, `os`, `high_availability`, `display`,
// `stateless`, `usb` and `timezone` elements can be updated after a template has been created.
// For example, to update a template to so that it has 1 GiB of memory send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/templates/123
// ----
// With the following request body:
// [source,xml]
// ----
// <template>
//   <memory>1073741824</memory>
// </template>
// ----
// The `version_name` name attribute is the only one that can be updated within the `version` attribute used for
// template versions:
// [source,xml]
// ----
// <template>
//   <version>
//     <version_name>mytemplate_2</version_name>
//   </version>
// </template>
// ----
//
type templateServiceUpdateRequest struct {
	templateService *templateService
	header          map[string]string
	query           map[string]string
	async           *bool
	template        *Template
}

func (p *templateServiceUpdateRequest) Header(key, value string) *templateServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateServiceUpdateRequest) Query(key, value string) *templateServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateServiceUpdateRequest) Async(async bool) *templateServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *templateServiceUpdateRequest) Template(template *Template) *templateServiceUpdateRequest {
	p.template = template
	return p
}

func (p *templateServiceUpdateRequest) Send() (*templateServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateService.connection.URL(), p.templateService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTemplateWriteOne(writer, p.template, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateServiceUpdateResponse{template: result}, nil
}

func (p *templateServiceUpdateRequest) MustSend() *templateServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateService.connection.URL(), p.templateService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTemplateWriteOne(writer, p.template, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateServiceUpdateResponse{template: result}
}

//
// Updates the template.
// The `name`, `description`, `type`, `memory`, `cpu`, `topology`, `os`, `high_availability`, `display`,
// `stateless`, `usb` and `timezone` elements can be updated after a template has been created.
// For example, to update a template to so that it has 1 GiB of memory send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/templates/123
// ----
// With the following request body:
// [source,xml]
// ----
// <template>
//   <memory>1073741824</memory>
// </template>
// ----
// The `version_name` name attribute is the only one that can be updated within the `version` attribute used for
// template versions:
// [source,xml]
// ----
// <template>
//   <version>
//     <version_name>mytemplate_2</version_name>
//   </version>
// </template>
// ----
//
type templateServiceUpdateResponse struct {
	template *Template
}

func (p *templateServiceUpdateResponse) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

func (p *templateServiceUpdateResponse) MustTemplate() *Template {
	if p.template == nil {
		panic("template in response does not exist")
	}
	return p.template
}

//
// Updates the template.
// The `name`, `description`, `type`, `memory`, `cpu`, `topology`, `os`, `high_availability`, `display`,
// `stateless`, `usb` and `timezone` elements can be updated after a template has been created.
// For example, to update a template to so that it has 1 GiB of memory send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/templates/123
// ----
// With the following request body:
// [source,xml]
// ----
// <template>
//   <memory>1073741824</memory>
// </template>
// ----
// The `version_name` name attribute is the only one that can be updated within the `version` attribute used for
// template versions:
// [source,xml]
// ----
// <template>
//   <version>
//     <version_name>mytemplate_2</version_name>
//   </version>
// </template>
// ----
//
func (p *templateService) Update() *templateServiceUpdateRequest {
	return &templateServiceUpdateRequest{templateService: p}
}

//
// Returns a reference to the service that manages the CDROMs that are associated with the template.
//
func (op *templateService) CdromsService() *templateCdromsService {
	return NewTemplateCdromsService(op.connection, fmt.Sprintf("%s/cdroms", op.path))
}

//
// Reference to the service that manages a specific
// disk attachment of the template.
//
func (op *templateService) DiskAttachmentsService() *templateDiskAttachmentsService {
	return NewTemplateDiskAttachmentsService(op.connection, fmt.Sprintf("%s/diskattachments", op.path))
}

//
// Returns a reference to the service that manages the graphical consoles that are associated with the template.
//
func (op *templateService) GraphicsConsolesService() *templateGraphicsConsolesService {
	return NewTemplateGraphicsConsolesService(op.connection, fmt.Sprintf("%s/graphicsconsoles", op.path))
}

//
// Returns a reference to the service that manages the NICs that are associated with the template.
//
func (op *templateService) NicsService() *templateNicsService {
	return NewTemplateNicsService(op.connection, fmt.Sprintf("%s/nics", op.path))
}

//
// Returns a reference to the service that manages the permissions that are associated with the template.
//
func (op *templateService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Returns a reference to the service that manages the tags that are associated with the template.
//
func (op *templateService) TagsService() *assignedTagsService {
	return NewAssignedTagsService(op.connection, fmt.Sprintf("%s/tags", op.path))
}

//
// Returns a reference to the service that manages the _watchdogs_ that are associated with the template.
//
func (op *templateService) WatchdogsService() *templateWatchdogsService {
	return NewTemplateWatchdogsService(op.connection, fmt.Sprintf("%s/watchdogs", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "cdroms" {
		return op.CdromsService(), nil
	}
	if strings.HasPrefix(path, "cdroms/") {
		return op.CdromsService().Service(path[7:])
	}
	if path == "diskattachments" {
		return op.DiskAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "diskattachments/") {
		return op.DiskAttachmentsService().Service(path[16:])
	}
	if path == "graphicsconsoles" {
		return op.GraphicsConsolesService(), nil
	}
	if strings.HasPrefix(path, "graphicsconsoles/") {
		return op.GraphicsConsolesService().Service(path[17:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "watchdogs" {
		return op.WatchdogsService(), nil
	}
	if strings.HasPrefix(path, "watchdogs/") {
		return op.WatchdogsService().Service(path[10:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *templateService) String() string {
	return fmt.Sprintf("templateService:%s", op.path)
}

//
// This service manages a collection of all the virtual machines assigned to an affinity group.
//
type affinityGroupVmsService struct {
	baseService
}

func NewAffinityGroupVmsService(connection *Connection, path string) *affinityGroupVmsService {
	var result affinityGroupVmsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a virtual machine to the affinity group.
// For example, to add the virtual machine `789` to the affinity group `456` of cluster `123`, send a request like
// this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/vms
// ....
// With the following body:
// [source,xml]
// ----
// <vm id="789"/>
// ----
//
type affinityGroupVmsServiceAddRequest struct {
	affinityGroupVmsService *affinityGroupVmsService
	header                  map[string]string
	query                   map[string]string
	vm                      *Vm
}

func (p *affinityGroupVmsServiceAddRequest) Header(key, value string) *affinityGroupVmsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityGroupVmsServiceAddRequest) Query(key, value string) *affinityGroupVmsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityGroupVmsServiceAddRequest) Vm(vm *Vm) *affinityGroupVmsServiceAddRequest {
	p.vm = vm
	return p
}

func (p *affinityGroupVmsServiceAddRequest) Send() (*affinityGroupVmsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupVmsService.connection.URL(), p.affinityGroupVmsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmWriteOne(writer, p.vm, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupVmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupVmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &affinityGroupVmsServiceAddResponse{vm: result}, nil
}

func (p *affinityGroupVmsServiceAddRequest) MustSend() *affinityGroupVmsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupVmsService.connection.URL(), p.affinityGroupVmsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmWriteOne(writer, p.vm, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupVmsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupVmsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &affinityGroupVmsServiceAddResponse{vm: result}
}

//
// Adds a virtual machine to the affinity group.
// For example, to add the virtual machine `789` to the affinity group `456` of cluster `123`, send a request like
// this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/vms
// ....
// With the following body:
// [source,xml]
// ----
// <vm id="789"/>
// ----
//
type affinityGroupVmsServiceAddResponse struct {
	vm *Vm
}

func (p *affinityGroupVmsServiceAddResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *affinityGroupVmsServiceAddResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Adds a virtual machine to the affinity group.
// For example, to add the virtual machine `789` to the affinity group `456` of cluster `123`, send a request like
// this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/vms
// ....
// With the following body:
// [source,xml]
// ----
// <vm id="789"/>
// ----
//
func (p *affinityGroupVmsService) Add() *affinityGroupVmsServiceAddRequest {
	return &affinityGroupVmsServiceAddRequest{affinityGroupVmsService: p}
}

//
// List all virtual machines assigned to this affinity group.
// The order of the returned virtual machines isn't guaranteed.
//
type affinityGroupVmsServiceListRequest struct {
	affinityGroupVmsService *affinityGroupVmsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
	max                     *int64
}

func (p *affinityGroupVmsServiceListRequest) Header(key, value string) *affinityGroupVmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityGroupVmsServiceListRequest) Query(key, value string) *affinityGroupVmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityGroupVmsServiceListRequest) Follow(follow string) *affinityGroupVmsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *affinityGroupVmsServiceListRequest) Max(max int64) *affinityGroupVmsServiceListRequest {
	p.max = &max
	return p
}

func (p *affinityGroupVmsServiceListRequest) Send() (*affinityGroupVmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupVmsService.connection.URL(), p.affinityGroupVmsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupVmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupVmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &affinityGroupVmsServiceListResponse{vms: result}, nil
}

func (p *affinityGroupVmsServiceListRequest) MustSend() *affinityGroupVmsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupVmsService.connection.URL(), p.affinityGroupVmsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupVmsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupVmsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &affinityGroupVmsServiceListResponse{vms: result}
}

//
// List all virtual machines assigned to this affinity group.
// The order of the returned virtual machines isn't guaranteed.
//
type affinityGroupVmsServiceListResponse struct {
	vms *VmSlice
}

func (p *affinityGroupVmsServiceListResponse) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *affinityGroupVmsServiceListResponse) MustVms() *VmSlice {
	if p.vms == nil {
		panic("vms in response does not exist")
	}
	return p.vms
}

//
// List all virtual machines assigned to this affinity group.
// The order of the returned virtual machines isn't guaranteed.
//
func (p *affinityGroupVmsService) List() *affinityGroupVmsServiceListRequest {
	return &affinityGroupVmsServiceListRequest{affinityGroupVmsService: p}
}

//
// Access the service that manages the virtual machine assignment to this affinity group.
//
func (op *affinityGroupVmsService) VmService(id string) *affinityGroupVmService {
	return NewAffinityGroupVmService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *affinityGroupVmsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.VmService(path), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *affinityGroupVmsService) String() string {
	return fmt.Sprintf("affinityGroupVmsService:%s", op.path)
}

//
// This service manages image transfers, for performing Image I/O API in {product-name}.
// Please refer to <<services/image_transfer, image transfer>> for further
// documentation.
//
type imageTransfersService struct {
	baseService
}

func NewImageTransfersService(connection *Connection, path string) *imageTransfersService {
	var result imageTransfersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new image transfer. An image, disk or disk snapshot needs to be specified
// in order to make a new transfer.
// IMPORTANT: The `image` attribute is deprecated since version 4.2 of the engine.
// Use the `disk` or `snapshot` attributes instead.
// *Creating a new image transfer for downloading or uploading a `disk`:*
// To create an image transfer to download or upload a disk with id `123`,
// send the following request:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body like this:
// [source,xml]
// ----
// <image_transfer>
//   <disk id="123"/>
//   <direction>upload|download</direction>
// </image_transfer>
// ----
// *Creating a new image transfer for downloading or uploading a `disk_snapshot`:*
// To create an image transfer to download or upload a `disk_snapshot` with id `456`,
// send the following request:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body like this:
// [source,xml]
// ----
// <image_transfer>
//   <snapshot id="456"/>
//   <direction>download|upload</direction>
// </image_transfer>
// ----
//
type imageTransfersServiceAddRequest struct {
	imageTransfersService *imageTransfersService
	header                map[string]string
	query                 map[string]string
	imageTransfer         *ImageTransfer
}

func (p *imageTransfersServiceAddRequest) Header(key, value string) *imageTransfersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imageTransfersServiceAddRequest) Query(key, value string) *imageTransfersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imageTransfersServiceAddRequest) ImageTransfer(imageTransfer *ImageTransfer) *imageTransfersServiceAddRequest {
	p.imageTransfer = imageTransfer
	return p
}

func (p *imageTransfersServiceAddRequest) Send() (*imageTransfersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imageTransfersService.connection.URL(), p.imageTransfersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLImageTransferWriteOne(writer, p.imageTransfer, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransfersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageTransferReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &imageTransfersServiceAddResponse{imageTransfer: result}, nil
}

func (p *imageTransfersServiceAddRequest) MustSend() *imageTransfersServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.imageTransfersService.connection.URL(), p.imageTransfersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLImageTransferWriteOne(writer, p.imageTransfer, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransfersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageTransferReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &imageTransfersServiceAddResponse{imageTransfer: result}
}

//
// Add a new image transfer. An image, disk or disk snapshot needs to be specified
// in order to make a new transfer.
// IMPORTANT: The `image` attribute is deprecated since version 4.2 of the engine.
// Use the `disk` or `snapshot` attributes instead.
// *Creating a new image transfer for downloading or uploading a `disk`:*
// To create an image transfer to download or upload a disk with id `123`,
// send the following request:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body like this:
// [source,xml]
// ----
// <image_transfer>
//   <disk id="123"/>
//   <direction>upload|download</direction>
// </image_transfer>
// ----
// *Creating a new image transfer for downloading or uploading a `disk_snapshot`:*
// To create an image transfer to download or upload a `disk_snapshot` with id `456`,
// send the following request:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body like this:
// [source,xml]
// ----
// <image_transfer>
//   <snapshot id="456"/>
//   <direction>download|upload</direction>
// </image_transfer>
// ----
//
type imageTransfersServiceAddResponse struct {
	imageTransfer *ImageTransfer
}

func (p *imageTransfersServiceAddResponse) ImageTransfer() (*ImageTransfer, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

func (p *imageTransfersServiceAddResponse) MustImageTransfer() *ImageTransfer {
	if p.imageTransfer == nil {
		panic("imageTransfer in response does not exist")
	}
	return p.imageTransfer
}

//
// Add a new image transfer. An image, disk or disk snapshot needs to be specified
// in order to make a new transfer.
// IMPORTANT: The `image` attribute is deprecated since version 4.2 of the engine.
// Use the `disk` or `snapshot` attributes instead.
// *Creating a new image transfer for downloading or uploading a `disk`:*
// To create an image transfer to download or upload a disk with id `123`,
// send the following request:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body like this:
// [source,xml]
// ----
// <image_transfer>
//   <disk id="123"/>
//   <direction>upload|download</direction>
// </image_transfer>
// ----
// *Creating a new image transfer for downloading or uploading a `disk_snapshot`:*
// To create an image transfer to download or upload a `disk_snapshot` with id `456`,
// send the following request:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body like this:
// [source,xml]
// ----
// <image_transfer>
//   <snapshot id="456"/>
//   <direction>download|upload</direction>
// </image_transfer>
// ----
//
func (p *imageTransfersService) Add() *imageTransfersServiceAddRequest {
	return &imageTransfersServiceAddRequest{imageTransfersService: p}
}

//
//
type imageTransfersServiceAddForDiskRequest struct {
	imageTransfersService *imageTransfersService
	header                map[string]string
	query                 map[string]string
	imageTransfer         *ImageTransfer
}

func (p *imageTransfersServiceAddForDiskRequest) Header(key, value string) *imageTransfersServiceAddForDiskRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imageTransfersServiceAddForDiskRequest) Query(key, value string) *imageTransfersServiceAddForDiskRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imageTransfersServiceAddForDiskRequest) ImageTransfer(imageTransfer *ImageTransfer) *imageTransfersServiceAddForDiskRequest {
	p.imageTransfer = imageTransfer
	return p
}

func (p *imageTransfersServiceAddForDiskRequest) Send() (*imageTransfersServiceAddForDiskResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fordisk", p.imageTransfersService.connection.URL(), p.imageTransfersService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.ImageTransfer(p.imageTransfer)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransfersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustImageTransfer()
	return &imageTransfersServiceAddForDiskResponse{imageTransfer: result}, nil
}

func (p *imageTransfersServiceAddForDiskRequest) MustSend() *imageTransfersServiceAddForDiskResponse {
	rawURL := fmt.Sprintf("%s%s/fordisk", p.imageTransfersService.connection.URL(), p.imageTransfersService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.ImageTransfer(p.imageTransfer)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransfersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustImageTransfer()
	return &imageTransfersServiceAddForDiskResponse{imageTransfer: result}
}

//
//
type imageTransfersServiceAddForDiskResponse struct {
	imageTransfer *ImageTransfer
}

func (p *imageTransfersServiceAddForDiskResponse) ImageTransfer() (*ImageTransfer, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

func (p *imageTransfersServiceAddForDiskResponse) MustImageTransfer() *ImageTransfer {
	if p.imageTransfer == nil {
		panic("imageTransfer in response does not exist")
	}
	return p.imageTransfer
}

//
//
func (p *imageTransfersService) AddForDisk() *imageTransfersServiceAddForDiskRequest {
	return &imageTransfersServiceAddForDiskRequest{imageTransfersService: p}
}

//
//
type imageTransfersServiceAddForImageRequest struct {
	imageTransfersService *imageTransfersService
	header                map[string]string
	query                 map[string]string
	imageTransfer         *ImageTransfer
}

func (p *imageTransfersServiceAddForImageRequest) Header(key, value string) *imageTransfersServiceAddForImageRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imageTransfersServiceAddForImageRequest) Query(key, value string) *imageTransfersServiceAddForImageRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imageTransfersServiceAddForImageRequest) ImageTransfer(imageTransfer *ImageTransfer) *imageTransfersServiceAddForImageRequest {
	p.imageTransfer = imageTransfer
	return p
}

func (p *imageTransfersServiceAddForImageRequest) Send() (*imageTransfersServiceAddForImageResponse, error) {
	rawURL := fmt.Sprintf("%s%s/forimage", p.imageTransfersService.connection.URL(), p.imageTransfersService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.ImageTransfer(p.imageTransfer)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransfersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustImageTransfer()
	return &imageTransfersServiceAddForImageResponse{imageTransfer: result}, nil
}

func (p *imageTransfersServiceAddForImageRequest) MustSend() *imageTransfersServiceAddForImageResponse {
	rawURL := fmt.Sprintf("%s%s/forimage", p.imageTransfersService.connection.URL(), p.imageTransfersService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.ImageTransfer(p.imageTransfer)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransfersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustImageTransfer()
	return &imageTransfersServiceAddForImageResponse{imageTransfer: result}
}

//
//
type imageTransfersServiceAddForImageResponse struct {
	imageTransfer *ImageTransfer
}

func (p *imageTransfersServiceAddForImageResponse) ImageTransfer() (*ImageTransfer, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

func (p *imageTransfersServiceAddForImageResponse) MustImageTransfer() *ImageTransfer {
	if p.imageTransfer == nil {
		panic("imageTransfer in response does not exist")
	}
	return p.imageTransfer
}

//
//
func (p *imageTransfersService) AddForImage() *imageTransfersServiceAddForImageRequest {
	return &imageTransfersServiceAddForImageRequest{imageTransfersService: p}
}

//
//
type imageTransfersServiceAddForSnapshotRequest struct {
	imageTransfersService *imageTransfersService
	header                map[string]string
	query                 map[string]string
	imageTransfer         *ImageTransfer
}

func (p *imageTransfersServiceAddForSnapshotRequest) Header(key, value string) *imageTransfersServiceAddForSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imageTransfersServiceAddForSnapshotRequest) Query(key, value string) *imageTransfersServiceAddForSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imageTransfersServiceAddForSnapshotRequest) ImageTransfer(imageTransfer *ImageTransfer) *imageTransfersServiceAddForSnapshotRequest {
	p.imageTransfer = imageTransfer
	return p
}

func (p *imageTransfersServiceAddForSnapshotRequest) Send() (*imageTransfersServiceAddForSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/forsnapshot", p.imageTransfersService.connection.URL(), p.imageTransfersService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.ImageTransfer(p.imageTransfer)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransfersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustImageTransfer()
	return &imageTransfersServiceAddForSnapshotResponse{imageTransfer: result}, nil
}

func (p *imageTransfersServiceAddForSnapshotRequest) MustSend() *imageTransfersServiceAddForSnapshotResponse {
	rawURL := fmt.Sprintf("%s%s/forsnapshot", p.imageTransfersService.connection.URL(), p.imageTransfersService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.ImageTransfer(p.imageTransfer)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransfersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustImageTransfer()
	return &imageTransfersServiceAddForSnapshotResponse{imageTransfer: result}
}

//
//
type imageTransfersServiceAddForSnapshotResponse struct {
	imageTransfer *ImageTransfer
}

func (p *imageTransfersServiceAddForSnapshotResponse) ImageTransfer() (*ImageTransfer, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

func (p *imageTransfersServiceAddForSnapshotResponse) MustImageTransfer() *ImageTransfer {
	if p.imageTransfer == nil {
		panic("imageTransfer in response does not exist")
	}
	return p.imageTransfer
}

//
//
func (p *imageTransfersService) AddForSnapshot() *imageTransfersServiceAddForSnapshotRequest {
	return &imageTransfersServiceAddForSnapshotRequest{imageTransfersService: p}
}

//
// Retrieves the list of image transfers that are currently
// being performed.
// The order of the returned list of image transfers is not guaranteed.
//
type imageTransfersServiceListRequest struct {
	imageTransfersService *imageTransfersService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *imageTransfersServiceListRequest) Header(key, value string) *imageTransfersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imageTransfersServiceListRequest) Query(key, value string) *imageTransfersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imageTransfersServiceListRequest) Follow(follow string) *imageTransfersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *imageTransfersServiceListRequest) Send() (*imageTransfersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imageTransfersService.connection.URL(), p.imageTransfersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransfersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageTransferReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &imageTransfersServiceListResponse{imageTransfer: result}, nil
}

func (p *imageTransfersServiceListRequest) MustSend() *imageTransfersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.imageTransfersService.connection.URL(), p.imageTransfersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransfersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransfersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageTransferReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &imageTransfersServiceListResponse{imageTransfer: result}
}

//
// Retrieves the list of image transfers that are currently
// being performed.
// The order of the returned list of image transfers is not guaranteed.
//
type imageTransfersServiceListResponse struct {
	imageTransfer *ImageTransferSlice
}

func (p *imageTransfersServiceListResponse) ImageTransfer() (*ImageTransferSlice, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

func (p *imageTransfersServiceListResponse) MustImageTransfer() *ImageTransferSlice {
	if p.imageTransfer == nil {
		panic("imageTransfer in response does not exist")
	}
	return p.imageTransfer
}

//
// Retrieves the list of image transfers that are currently
// being performed.
// The order of the returned list of image transfers is not guaranteed.
//
func (p *imageTransfersService) List() *imageTransfersServiceListRequest {
	return &imageTransfersServiceListRequest{imageTransfersService: p}
}

//
// Returns a reference to the service that manages an
// specific image transfer.
//
func (op *imageTransfersService) ImageTransferService(id string) *imageTransferService {
	return NewImageTransferService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *imageTransfersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ImageTransferService(path), nil
	}
	return op.ImageTransferService(path[:index]).Service(path[index+1:])
}

func (op *imageTransfersService) String() string {
	return fmt.Sprintf("imageTransfersService:%s", op.path)
}

//
// This service represents a host that has a specific
// label when accessed through the affinitylabels/hosts
// subcollection.
//
type affinityLabelHostService struct {
	baseService
}

func NewAffinityLabelHostService(connection *Connection, path string) *affinityLabelHostService {
	var result affinityLabelHostService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves details about a host that has this label assigned.
//
type affinityLabelHostServiceGetRequest struct {
	affinityLabelHostService *affinityLabelHostService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *affinityLabelHostServiceGetRequest) Header(key, value string) *affinityLabelHostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelHostServiceGetRequest) Query(key, value string) *affinityLabelHostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelHostServiceGetRequest) Follow(follow string) *affinityLabelHostServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *affinityLabelHostServiceGetRequest) Send() (*affinityLabelHostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostService.connection.URL(), p.affinityLabelHostService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelHostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &affinityLabelHostServiceGetResponse{host: result}, nil
}

func (p *affinityLabelHostServiceGetRequest) MustSend() *affinityLabelHostServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostService.connection.URL(), p.affinityLabelHostService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelHostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &affinityLabelHostServiceGetResponse{host: result}
}

//
// Retrieves details about a host that has this label assigned.
//
type affinityLabelHostServiceGetResponse struct {
	host *Host
}

func (p *affinityLabelHostServiceGetResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *affinityLabelHostServiceGetResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Retrieves details about a host that has this label assigned.
//
func (p *affinityLabelHostService) Get() *affinityLabelHostServiceGetRequest {
	return &affinityLabelHostServiceGetRequest{affinityLabelHostService: p}
}

//
// Remove a label from a host.
//
type affinityLabelHostServiceRemoveRequest struct {
	affinityLabelHostService *affinityLabelHostService
	header                   map[string]string
	query                    map[string]string
}

func (p *affinityLabelHostServiceRemoveRequest) Header(key, value string) *affinityLabelHostServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelHostServiceRemoveRequest) Query(key, value string) *affinityLabelHostServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelHostServiceRemoveRequest) Send() (*affinityLabelHostServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostService.connection.URL(), p.affinityLabelHostService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelHostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(affinityLabelHostServiceRemoveResponse), nil
}

func (p *affinityLabelHostServiceRemoveRequest) MustSend() *affinityLabelHostServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostService.connection.URL(), p.affinityLabelHostService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelHostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(affinityLabelHostServiceRemoveResponse)
}

//
// Remove a label from a host.
//
type affinityLabelHostServiceRemoveResponse struct {
}

//
// Remove a label from a host.
//
func (p *affinityLabelHostService) Remove() *affinityLabelHostServiceRemoveRequest {
	return &affinityLabelHostServiceRemoveRequest{affinityLabelHostService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *affinityLabelHostService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *affinityLabelHostService) String() string {
	return fmt.Sprintf("affinityLabelHostService:%s", op.path)
}

//
// Manages the set of connections to storage servers that exist in a storage domain.
//
type storageDomainServerConnectionsService struct {
	baseService
}

func NewStorageDomainServerConnectionsService(connection *Connection, path string) *storageDomainServerConnectionsService {
	var result storageDomainServerConnectionsService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type storageDomainServerConnectionsServiceAddRequest struct {
	storageDomainServerConnectionsService *storageDomainServerConnectionsService
	header                                map[string]string
	query                                 map[string]string
	connection                            *StorageConnection
}

func (p *storageDomainServerConnectionsServiceAddRequest) Header(key, value string) *storageDomainServerConnectionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainServerConnectionsServiceAddRequest) Query(key, value string) *storageDomainServerConnectionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainServerConnectionsServiceAddRequest) Connection(connection *StorageConnection) *storageDomainServerConnectionsServiceAddRequest {
	p.connection = connection
	return p
}

func (p *storageDomainServerConnectionsServiceAddRequest) Send() (*storageDomainServerConnectionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionsService.connection.URL(), p.storageDomainServerConnectionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionWriteOne(writer, p.connection, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageDomainServerConnectionsServiceAddResponse{connection: result}, nil
}

func (p *storageDomainServerConnectionsServiceAddRequest) MustSend() *storageDomainServerConnectionsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionsService.connection.URL(), p.storageDomainServerConnectionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionWriteOne(writer, p.connection, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainServerConnectionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageDomainServerConnectionsServiceAddResponse{connection: result}
}

//
//
type storageDomainServerConnectionsServiceAddResponse struct {
	connection *StorageConnection
}

func (p *storageDomainServerConnectionsServiceAddResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *storageDomainServerConnectionsServiceAddResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
//
func (p *storageDomainServerConnectionsService) Add() *storageDomainServerConnectionsServiceAddRequest {
	return &storageDomainServerConnectionsServiceAddRequest{storageDomainServerConnectionsService: p}
}

//
// Returns the list of connections to storage servers that existin the storage domain.
// The order of the returned list of connections isn't guaranteed.
//
type storageDomainServerConnectionsServiceListRequest struct {
	storageDomainServerConnectionsService *storageDomainServerConnectionsService
	header                                map[string]string
	query                                 map[string]string
	follow                                *string
	max                                   *int64
}

func (p *storageDomainServerConnectionsServiceListRequest) Header(key, value string) *storageDomainServerConnectionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainServerConnectionsServiceListRequest) Query(key, value string) *storageDomainServerConnectionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainServerConnectionsServiceListRequest) Follow(follow string) *storageDomainServerConnectionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainServerConnectionsServiceListRequest) Max(max int64) *storageDomainServerConnectionsServiceListRequest {
	p.max = &max
	return p
}

func (p *storageDomainServerConnectionsServiceListRequest) Send() (*storageDomainServerConnectionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionsService.connection.URL(), p.storageDomainServerConnectionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &storageDomainServerConnectionsServiceListResponse{connections: result}, nil
}

func (p *storageDomainServerConnectionsServiceListRequest) MustSend() *storageDomainServerConnectionsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainServerConnectionsService.connection.URL(), p.storageDomainServerConnectionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainServerConnectionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainServerConnectionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &storageDomainServerConnectionsServiceListResponse{connections: result}
}

//
// Returns the list of connections to storage servers that existin the storage domain.
// The order of the returned list of connections isn't guaranteed.
//
type storageDomainServerConnectionsServiceListResponse struct {
	connections *StorageConnectionSlice
}

func (p *storageDomainServerConnectionsServiceListResponse) Connections() (*StorageConnectionSlice, bool) {
	if p.connections != nil {
		return p.connections, true
	}
	return nil, false
}

func (p *storageDomainServerConnectionsServiceListResponse) MustConnections() *StorageConnectionSlice {
	if p.connections == nil {
		panic("connections in response does not exist")
	}
	return p.connections
}

//
// Returns the list of connections to storage servers that existin the storage domain.
// The order of the returned list of connections isn't guaranteed.
//
func (p *storageDomainServerConnectionsService) List() *storageDomainServerConnectionsServiceListRequest {
	return &storageDomainServerConnectionsServiceListRequest{storageDomainServerConnectionsService: p}
}

//
//
func (op *storageDomainServerConnectionsService) ConnectionService(id string) *storageDomainServerConnectionService {
	return NewStorageDomainServerConnectionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainServerConnectionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ConnectionService(path), nil
	}
	return op.ConnectionService(path[:index]).Service(path[index+1:])
}

func (op *storageDomainServerConnectionsService) String() string {
	return fmt.Sprintf("storageDomainServerConnectionsService:%s", op.path)
}

//
//
type vmDisksService struct {
	baseService
}

func NewVmDisksService(connection *Connection, path string) *vmDisksService {
	var result vmDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type vmDisksServiceAddRequest struct {
	vmDisksService *vmDisksService
	header         map[string]string
	query          map[string]string
	disk           *Disk
}

func (p *vmDisksServiceAddRequest) Header(key, value string) *vmDisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmDisksServiceAddRequest) Query(key, value string) *vmDisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmDisksServiceAddRequest) Disk(disk *Disk) *vmDisksServiceAddRequest {
	p.disk = disk
	return p
}

func (p *vmDisksServiceAddRequest) Send() (*vmDisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDisksService.connection.URL(), p.vmDisksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmDisksServiceAddResponse{disk: result}, nil
}

func (p *vmDisksServiceAddRequest) MustSend() *vmDisksServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmDisksService.connection.URL(), p.vmDisksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDisksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDisksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmDisksServiceAddResponse{disk: result}
}

//
//
type vmDisksServiceAddResponse struct {
	disk *Disk
}

func (p *vmDisksServiceAddResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *vmDisksServiceAddResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
//
func (p *vmDisksService) Add() *vmDisksServiceAddRequest {
	return &vmDisksServiceAddRequest{vmDisksService: p}
}

//
// Returns the list of disks of the virtual machine.
// The order of the returned list of disks isn't guaranteed.
//
type vmDisksServiceListRequest struct {
	vmDisksService *vmDisksService
	header         map[string]string
	query          map[string]string
	follow         *string
	max            *int64
}

func (p *vmDisksServiceListRequest) Header(key, value string) *vmDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmDisksServiceListRequest) Query(key, value string) *vmDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmDisksServiceListRequest) Follow(follow string) *vmDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vmDisksServiceListRequest) Max(max int64) *vmDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *vmDisksServiceListRequest) Send() (*vmDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmDisksService.connection.URL(), p.vmDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vmDisksServiceListResponse{disks: result}, nil
}

func (p *vmDisksServiceListRequest) MustSend() *vmDisksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmDisksService.connection.URL(), p.vmDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmDisksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmDisksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vmDisksServiceListResponse{disks: result}
}

//
// Returns the list of disks of the virtual machine.
// The order of the returned list of disks isn't guaranteed.
//
type vmDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *vmDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *vmDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Returns the list of disks of the virtual machine.
// The order of the returned list of disks isn't guaranteed.
//
func (p *vmDisksService) List() *vmDisksServiceListRequest {
	return &vmDisksServiceListRequest{vmDisksService: p}
}

//
//
func (op *vmDisksService) DiskService(id string) *vmDiskService {
	return NewVmDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *vmDisksService) String() string {
	return fmt.Sprintf("vmDisksService:%s", op.path)
}

//
// Provides read-write access to virtual machines pools.
//
type vmPoolsService struct {
	baseService
}

func NewVmPoolsService(connection *Connection, path string) *vmPoolsService {
	var result vmPoolsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new virtual machine pool.
// A new pool requires the `name`, `cluster` and `template` attributes. Identify the cluster and template with the
// `id` or `name` nested attributes:
// [source]
// ----
// POST /ovirt-engine/api/vmpools
// ----
// With the following body:
// [source,xml]
// ----
// <vmpool>
//   <name>mypool</name>
//   <cluster id="123"/>
//   <template id="456"/>
// </vmpool>
// ----
//
type vmPoolsServiceAddRequest struct {
	vmPoolsService *vmPoolsService
	header         map[string]string
	query          map[string]string
	pool           *VmPool
}

func (p *vmPoolsServiceAddRequest) Header(key, value string) *vmPoolsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmPoolsServiceAddRequest) Query(key, value string) *vmPoolsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmPoolsServiceAddRequest) Pool(pool *VmPool) *vmPoolsServiceAddRequest {
	p.pool = pool
	return p
}

func (p *vmPoolsServiceAddRequest) Send() (*vmPoolsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolsService.connection.URL(), p.vmPoolsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmPoolWriteOne(writer, p.pool, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmPoolsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmPoolsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmPoolReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmPoolsServiceAddResponse{pool: result}, nil
}

func (p *vmPoolsServiceAddRequest) MustSend() *vmPoolsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolsService.connection.URL(), p.vmPoolsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmPoolWriteOne(writer, p.pool, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmPoolsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmPoolsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmPoolReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmPoolsServiceAddResponse{pool: result}
}

//
// Creates a new virtual machine pool.
// A new pool requires the `name`, `cluster` and `template` attributes. Identify the cluster and template with the
// `id` or `name` nested attributes:
// [source]
// ----
// POST /ovirt-engine/api/vmpools
// ----
// With the following body:
// [source,xml]
// ----
// <vmpool>
//   <name>mypool</name>
//   <cluster id="123"/>
//   <template id="456"/>
// </vmpool>
// ----
//
type vmPoolsServiceAddResponse struct {
	pool *VmPool
}

func (p *vmPoolsServiceAddResponse) Pool() (*VmPool, bool) {
	if p.pool != nil {
		return p.pool, true
	}
	return nil, false
}

func (p *vmPoolsServiceAddResponse) MustPool() *VmPool {
	if p.pool == nil {
		panic("pool in response does not exist")
	}
	return p.pool
}

//
// Creates a new virtual machine pool.
// A new pool requires the `name`, `cluster` and `template` attributes. Identify the cluster and template with the
// `id` or `name` nested attributes:
// [source]
// ----
// POST /ovirt-engine/api/vmpools
// ----
// With the following body:
// [source,xml]
// ----
// <vmpool>
//   <name>mypool</name>
//   <cluster id="123"/>
//   <template id="456"/>
// </vmpool>
// ----
//
func (p *vmPoolsService) Add() *vmPoolsServiceAddRequest {
	return &vmPoolsServiceAddRequest{vmPoolsService: p}
}

//
// Get a list of available virtual machines pools.
// [source]
// ----
// GET /ovirt-engine/api/vmpools
// ----
// You will receive the following response:
// [source,xml]
// ----
// <vm_pools>
//   <vm_pool id="123">
//     ...
//   </vm_pool>
//   ...
// </vm_pools>
// ----
// The order of the returned list of pools is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type vmPoolsServiceListRequest struct {
	vmPoolsService *vmPoolsService
	header         map[string]string
	query          map[string]string
	caseSensitive  *bool
	filter         *bool
	follow         *string
	max            *int64
	search         *string
}

func (p *vmPoolsServiceListRequest) Header(key, value string) *vmPoolsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmPoolsServiceListRequest) Query(key, value string) *vmPoolsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmPoolsServiceListRequest) CaseSensitive(caseSensitive bool) *vmPoolsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *vmPoolsServiceListRequest) Filter(filter bool) *vmPoolsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *vmPoolsServiceListRequest) Follow(follow string) *vmPoolsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vmPoolsServiceListRequest) Max(max int64) *vmPoolsServiceListRequest {
	p.max = &max
	return p
}

func (p *vmPoolsServiceListRequest) Search(search string) *vmPoolsServiceListRequest {
	p.search = &search
	return p
}

func (p *vmPoolsServiceListRequest) Send() (*vmPoolsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolsService.connection.URL(), p.vmPoolsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmPoolsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmPoolsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmPoolReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vmPoolsServiceListResponse{pools: result}, nil
}

func (p *vmPoolsServiceListRequest) MustSend() *vmPoolsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolsService.connection.URL(), p.vmPoolsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmPoolsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmPoolsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmPoolReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vmPoolsServiceListResponse{pools: result}
}

//
// Get a list of available virtual machines pools.
// [source]
// ----
// GET /ovirt-engine/api/vmpools
// ----
// You will receive the following response:
// [source,xml]
// ----
// <vm_pools>
//   <vm_pool id="123">
//     ...
//   </vm_pool>
//   ...
// </vm_pools>
// ----
// The order of the returned list of pools is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type vmPoolsServiceListResponse struct {
	pools *VmPoolSlice
}

func (p *vmPoolsServiceListResponse) Pools() (*VmPoolSlice, bool) {
	if p.pools != nil {
		return p.pools, true
	}
	return nil, false
}

func (p *vmPoolsServiceListResponse) MustPools() *VmPoolSlice {
	if p.pools == nil {
		panic("pools in response does not exist")
	}
	return p.pools
}

//
// Get a list of available virtual machines pools.
// [source]
// ----
// GET /ovirt-engine/api/vmpools
// ----
// You will receive the following response:
// [source,xml]
// ----
// <vm_pools>
//   <vm_pool id="123">
//     ...
//   </vm_pool>
//   ...
// </vm_pools>
// ----
// The order of the returned list of pools is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
func (p *vmPoolsService) List() *vmPoolsServiceListRequest {
	return &vmPoolsServiceListRequest{vmPoolsService: p}
}

//
// Reference to the service that manages a specific virtual machine pool.
//
func (op *vmPoolsService) PoolService(id string) *vmPoolService {
	return NewVmPoolService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmPoolsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.PoolService(path), nil
	}
	return op.PoolService(path[:index]).Service(path[index+1:])
}

func (op *vmPoolsService) String() string {
	return fmt.Sprintf("vmPoolsService:%s", op.path)
}

//
// Manages a CDROM device of a virtual machine.
// Changing and ejecting the disk is done using always the `update` method, to change the value of the `file`
// attribute.
//
type vmCdromService struct {
	baseService
}

func NewVmCdromService(connection *Connection, path string) *vmCdromService {
	var result vmCdromService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the information about this CDROM device.
// The information consists of `cdrom` attribute containing reference to the CDROM device, the virtual machine,
// and optionally the inserted disk.
// If there is a disk inserted then the `file` attribute will contain a reference to the ISO image:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <file id="mycd.iso"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
// If there is no disk inserted then the `file` attribute won't be reported:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
//
type vmCdromServiceGetRequest struct {
	vmCdromService *vmCdromService
	header         map[string]string
	query          map[string]string
	current        *bool
	follow         *string
}

func (p *vmCdromServiceGetRequest) Header(key, value string) *vmCdromServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmCdromServiceGetRequest) Query(key, value string) *vmCdromServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmCdromServiceGetRequest) Current(current bool) *vmCdromServiceGetRequest {
	p.current = &current
	return p
}

func (p *vmCdromServiceGetRequest) Follow(follow string) *vmCdromServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vmCdromServiceGetRequest) Send() (*vmCdromServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromService.connection.URL(), p.vmCdromService.path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmCdromService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmCdromService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmCdromServiceGetResponse{cdrom: result}, nil
}

func (p *vmCdromServiceGetRequest) MustSend() *vmCdromServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromService.connection.URL(), p.vmCdromService.path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmCdromService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmCdromService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmCdromServiceGetResponse{cdrom: result}
}

//
// Returns the information about this CDROM device.
// The information consists of `cdrom` attribute containing reference to the CDROM device, the virtual machine,
// and optionally the inserted disk.
// If there is a disk inserted then the `file` attribute will contain a reference to the ISO image:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <file id="mycd.iso"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
// If there is no disk inserted then the `file` attribute won't be reported:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
//
type vmCdromServiceGetResponse struct {
	cdrom *Cdrom
}

func (p *vmCdromServiceGetResponse) Cdrom() (*Cdrom, bool) {
	if p.cdrom != nil {
		return p.cdrom, true
	}
	return nil, false
}

func (p *vmCdromServiceGetResponse) MustCdrom() *Cdrom {
	if p.cdrom == nil {
		panic("cdrom in response does not exist")
	}
	return p.cdrom
}

//
// Returns the information about this CDROM device.
// The information consists of `cdrom` attribute containing reference to the CDROM device, the virtual machine,
// and optionally the inserted disk.
// If there is a disk inserted then the `file` attribute will contain a reference to the ISO image:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <file id="mycd.iso"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
// If there is no disk inserted then the `file` attribute won't be reported:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
//
func (p *vmCdromService) Get() *vmCdromServiceGetRequest {
	return &vmCdromServiceGetRequest{vmCdromService: p}
}

//
// Updates the information about this CDROM device.
// It allows to change or eject the disk by changing the value of the `file` attribute.
// For example, to insert or change the disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000
// ----
// The body should contain the new value for the `file` attribute:
// [source,xml]
// ----
// <cdrom>
//   <file id="mycd.iso"/>
// </cdrom>
// ----
// The value of the `id` attribute, `mycd.iso` in this example, should correspond to a file available in an
// attached ISO storage domain.
// To eject the disk use a `file` with an empty `id`:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// By default the above operations change permanently the disk that will be visible to the virtual machine
// after the next boot, but they don't have any effect on the currently running virtual machine. If you want
// to change the disk that is visible to the current running virtual machine, add the `current=true` parameter.
// For example, to eject the current disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000?current=true
// ----
// With a request body like this:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// IMPORTANT: The changes made with the `current=true` parameter are never persisted, so they won't have any
// effect after the virtual machine is rebooted.
//
type vmCdromServiceUpdateRequest struct {
	vmCdromService *vmCdromService
	header         map[string]string
	query          map[string]string
	cdrom          *Cdrom
	current        *bool
}

func (p *vmCdromServiceUpdateRequest) Header(key, value string) *vmCdromServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmCdromServiceUpdateRequest) Query(key, value string) *vmCdromServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmCdromServiceUpdateRequest) Cdrom(cdrom *Cdrom) *vmCdromServiceUpdateRequest {
	p.cdrom = cdrom
	return p
}

func (p *vmCdromServiceUpdateRequest) Current(current bool) *vmCdromServiceUpdateRequest {
	p.current = &current
	return p
}

func (p *vmCdromServiceUpdateRequest) Send() (*vmCdromServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromService.connection.URL(), p.vmCdromService.path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCdromWriteOne(writer, p.cdrom, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmCdromService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmCdromService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmCdromServiceUpdateResponse{cdrom: result}, nil
}

func (p *vmCdromServiceUpdateRequest) MustSend() *vmCdromServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromService.connection.URL(), p.vmCdromService.path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCdromWriteOne(writer, p.cdrom, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmCdromService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmCdromService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmCdromServiceUpdateResponse{cdrom: result}
}

//
// Updates the information about this CDROM device.
// It allows to change or eject the disk by changing the value of the `file` attribute.
// For example, to insert or change the disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000
// ----
// The body should contain the new value for the `file` attribute:
// [source,xml]
// ----
// <cdrom>
//   <file id="mycd.iso"/>
// </cdrom>
// ----
// The value of the `id` attribute, `mycd.iso` in this example, should correspond to a file available in an
// attached ISO storage domain.
// To eject the disk use a `file` with an empty `id`:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// By default the above operations change permanently the disk that will be visible to the virtual machine
// after the next boot, but they don't have any effect on the currently running virtual machine. If you want
// to change the disk that is visible to the current running virtual machine, add the `current=true` parameter.
// For example, to eject the current disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000?current=true
// ----
// With a request body like this:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// IMPORTANT: The changes made with the `current=true` parameter are never persisted, so they won't have any
// effect after the virtual machine is rebooted.
//
type vmCdromServiceUpdateResponse struct {
	cdrom *Cdrom
}

func (p *vmCdromServiceUpdateResponse) Cdrom() (*Cdrom, bool) {
	if p.cdrom != nil {
		return p.cdrom, true
	}
	return nil, false
}

func (p *vmCdromServiceUpdateResponse) MustCdrom() *Cdrom {
	if p.cdrom == nil {
		panic("cdrom in response does not exist")
	}
	return p.cdrom
}

//
// Updates the information about this CDROM device.
// It allows to change or eject the disk by changing the value of the `file` attribute.
// For example, to insert or change the disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000
// ----
// The body should contain the new value for the `file` attribute:
// [source,xml]
// ----
// <cdrom>
//   <file id="mycd.iso"/>
// </cdrom>
// ----
// The value of the `id` attribute, `mycd.iso` in this example, should correspond to a file available in an
// attached ISO storage domain.
// To eject the disk use a `file` with an empty `id`:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// By default the above operations change permanently the disk that will be visible to the virtual machine
// after the next boot, but they don't have any effect on the currently running virtual machine. If you want
// to change the disk that is visible to the current running virtual machine, add the `current=true` parameter.
// For example, to eject the current disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000?current=true
// ----
// With a request body like this:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// IMPORTANT: The changes made with the `current=true` parameter are never persisted, so they won't have any
// effect after the virtual machine is rebooted.
//
func (p *vmCdromService) Update() *vmCdromServiceUpdateRequest {
	return &vmCdromServiceUpdateRequest{vmCdromService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmCdromService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vmCdromService) String() string {
	return fmt.Sprintf("vmCdromService:%s", op.path)
}

//
// Manages the set of templates available in a storage domain.
//
type storageDomainTemplatesService struct {
	baseService
}

func NewStorageDomainTemplatesService(connection *Connection, path string) *storageDomainTemplatesService {
	var result storageDomainTemplatesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of templates availalbe in the storage domain.
// The order of the returned list of templates isn't guaranteed.
//
type storageDomainTemplatesServiceListRequest struct {
	storageDomainTemplatesService *storageDomainTemplatesService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
	max                           *int64
	unregistered                  *bool
}

func (p *storageDomainTemplatesServiceListRequest) Header(key, value string) *storageDomainTemplatesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainTemplatesServiceListRequest) Query(key, value string) *storageDomainTemplatesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainTemplatesServiceListRequest) Follow(follow string) *storageDomainTemplatesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainTemplatesServiceListRequest) Max(max int64) *storageDomainTemplatesServiceListRequest {
	p.max = &max
	return p
}

func (p *storageDomainTemplatesServiceListRequest) Unregistered(unregistered bool) *storageDomainTemplatesServiceListRequest {
	p.unregistered = &unregistered
	return p
}

func (p *storageDomainTemplatesServiceListRequest) Send() (*storageDomainTemplatesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainTemplatesService.connection.URL(), p.storageDomainTemplatesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainTemplatesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplatesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &storageDomainTemplatesServiceListResponse{templates: result}, nil
}

func (p *storageDomainTemplatesServiceListRequest) MustSend() *storageDomainTemplatesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainTemplatesService.connection.URL(), p.storageDomainTemplatesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainTemplatesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplatesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &storageDomainTemplatesServiceListResponse{templates: result}
}

//
// Returns the list of templates availalbe in the storage domain.
// The order of the returned list of templates isn't guaranteed.
//
type storageDomainTemplatesServiceListResponse struct {
	templates *TemplateSlice
}

func (p *storageDomainTemplatesServiceListResponse) Templates() (*TemplateSlice, bool) {
	if p.templates != nil {
		return p.templates, true
	}
	return nil, false
}

func (p *storageDomainTemplatesServiceListResponse) MustTemplates() *TemplateSlice {
	if p.templates == nil {
		panic("templates in response does not exist")
	}
	return p.templates
}

//
// Returns the list of templates availalbe in the storage domain.
// The order of the returned list of templates isn't guaranteed.
//
func (p *storageDomainTemplatesService) List() *storageDomainTemplatesServiceListRequest {
	return &storageDomainTemplatesServiceListRequest{storageDomainTemplatesService: p}
}

//
//
func (op *storageDomainTemplatesService) TemplateService(id string) *storageDomainTemplateService {
	return NewStorageDomainTemplateService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainTemplatesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.TemplateService(path), nil
	}
	return op.TemplateService(path[:index]).Service(path[index+1:])
}

func (op *storageDomainTemplatesService) String() string {
	return fmt.Sprintf("storageDomainTemplatesService:%s", op.path)
}

//
//
type quotaStorageLimitService struct {
	baseService
}

func NewQuotaStorageLimitService(connection *Connection, path string) *quotaStorageLimitService {
	var result quotaStorageLimitService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type quotaStorageLimitServiceGetRequest struct {
	quotaStorageLimitService *quotaStorageLimitService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *quotaStorageLimitServiceGetRequest) Header(key, value string) *quotaStorageLimitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotaStorageLimitServiceGetRequest) Query(key, value string) *quotaStorageLimitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotaStorageLimitServiceGetRequest) Follow(follow string) *quotaStorageLimitServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *quotaStorageLimitServiceGetRequest) Send() (*quotaStorageLimitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitService.connection.URL(), p.quotaStorageLimitService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaStorageLimitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaStorageLimitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &quotaStorageLimitServiceGetResponse{limit: result}, nil
}

func (p *quotaStorageLimitServiceGetRequest) MustSend() *quotaStorageLimitServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitService.connection.URL(), p.quotaStorageLimitService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaStorageLimitService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaStorageLimitReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &quotaStorageLimitServiceGetResponse{limit: result}
}

//
//
type quotaStorageLimitServiceGetResponse struct {
	limit *QuotaStorageLimit
}

func (p *quotaStorageLimitServiceGetResponse) Limit() (*QuotaStorageLimit, bool) {
	if p.limit != nil {
		return p.limit, true
	}
	return nil, false
}

func (p *quotaStorageLimitServiceGetResponse) MustLimit() *QuotaStorageLimit {
	if p.limit == nil {
		panic("limit in response does not exist")
	}
	return p.limit
}

//
//
func (p *quotaStorageLimitService) Get() *quotaStorageLimitServiceGetRequest {
	return &quotaStorageLimitServiceGetRequest{quotaStorageLimitService: p}
}

//
//
type quotaStorageLimitServiceRemoveRequest struct {
	quotaStorageLimitService *quotaStorageLimitService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *quotaStorageLimitServiceRemoveRequest) Header(key, value string) *quotaStorageLimitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotaStorageLimitServiceRemoveRequest) Query(key, value string) *quotaStorageLimitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotaStorageLimitServiceRemoveRequest) Async(async bool) *quotaStorageLimitServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *quotaStorageLimitServiceRemoveRequest) Send() (*quotaStorageLimitServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitService.connection.URL(), p.quotaStorageLimitService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaStorageLimitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(quotaStorageLimitServiceRemoveResponse), nil
}

func (p *quotaStorageLimitServiceRemoveRequest) MustSend() *quotaStorageLimitServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotaStorageLimitService.connection.URL(), p.quotaStorageLimitService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaStorageLimitService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaStorageLimitService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(quotaStorageLimitServiceRemoveResponse)
}

//
//
type quotaStorageLimitServiceRemoveResponse struct {
}

//
//
func (p *quotaStorageLimitService) Remove() *quotaStorageLimitServiceRemoveRequest {
	return &quotaStorageLimitServiceRemoveRequest{quotaStorageLimitService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *quotaStorageLimitService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *quotaStorageLimitService) String() string {
	return fmt.Sprintf("quotaStorageLimitService:%s", op.path)
}

//
// A service to manage a specific tag in the system.
//
type tagService struct {
	baseService
}

func NewTagService(connection *Connection, path string) *tagService {
	var result tagService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the information about the tag.
// For example to retrieve the information about the tag with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/tags/123
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/123" id="123">
//   <name>root</name>
//   <description>root</description>
// </tag>
// ----
//
type tagServiceGetRequest struct {
	tagService *tagService
	header     map[string]string
	query      map[string]string
	follow     *string
}

func (p *tagServiceGetRequest) Header(key, value string) *tagServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *tagServiceGetRequest) Query(key, value string) *tagServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *tagServiceGetRequest) Follow(follow string) *tagServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *tagServiceGetRequest) Send() (*tagServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagService.connection.URL(), p.tagService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.tagService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.tagService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &tagServiceGetResponse{tag: result}, nil
}

func (p *tagServiceGetRequest) MustSend() *tagServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.tagService.connection.URL(), p.tagService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.tagService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.tagService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &tagServiceGetResponse{tag: result}
}

//
// Gets the information about the tag.
// For example to retrieve the information about the tag with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/tags/123
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/123" id="123">
//   <name>root</name>
//   <description>root</description>
// </tag>
// ----
//
type tagServiceGetResponse struct {
	tag *Tag
}

func (p *tagServiceGetResponse) Tag() (*Tag, bool) {
	if p.tag != nil {
		return p.tag, true
	}
	return nil, false
}

func (p *tagServiceGetResponse) MustTag() *Tag {
	if p.tag == nil {
		panic("tag in response does not exist")
	}
	return p.tag
}

//
// Gets the information about the tag.
// For example to retrieve the information about the tag with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/tags/123
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/123" id="123">
//   <name>root</name>
//   <description>root</description>
// </tag>
// ----
//
func (p *tagService) Get() *tagServiceGetRequest {
	return &tagServiceGetRequest{tagService: p}
}

//
// Removes the tag from the system.
// For example to remove the tag with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/tags/123
// ....
//
type tagServiceRemoveRequest struct {
	tagService *tagService
	header     map[string]string
	query      map[string]string
	async      *bool
}

func (p *tagServiceRemoveRequest) Header(key, value string) *tagServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *tagServiceRemoveRequest) Query(key, value string) *tagServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *tagServiceRemoveRequest) Async(async bool) *tagServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *tagServiceRemoveRequest) Send() (*tagServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagService.connection.URL(), p.tagService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.tagService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.tagService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(tagServiceRemoveResponse), nil
}

func (p *tagServiceRemoveRequest) MustSend() *tagServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.tagService.connection.URL(), p.tagService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.tagService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.tagService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(tagServiceRemoveResponse)
}

//
// Removes the tag from the system.
// For example to remove the tag with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/tags/123
// ....
//
type tagServiceRemoveResponse struct {
}

//
// Removes the tag from the system.
// For example to remove the tag with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/tags/123
// ....
//
func (p *tagService) Remove() *tagServiceRemoveRequest {
	return &tagServiceRemoveRequest{tagService: p}
}

//
// Updates the tag entity.
// For example to update parent tag to tag with id `456` of the tag with id `123` send a request like this:
// ....
// PUT /ovirt-engine/api/tags/123
// ....
// With request body like:
// [source,xml]
// ----
// <tag>
//   <parent id="456"/>
// </tag>
// ----
// You may also specify a tag name instead of id. For example to update parent tag to tag with name `mytag`
// of the tag with id `123` send a request like this:
// [source,xml]
// ----
// <tag>
//   <parent>
//     <name>mytag</name>
//   </parent>
// </tag>
// ----
//
type tagServiceUpdateRequest struct {
	tagService *tagService
	header     map[string]string
	query      map[string]string
	async      *bool
	tag        *Tag
}

func (p *tagServiceUpdateRequest) Header(key, value string) *tagServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *tagServiceUpdateRequest) Query(key, value string) *tagServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *tagServiceUpdateRequest) Async(async bool) *tagServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *tagServiceUpdateRequest) Tag(tag *Tag) *tagServiceUpdateRequest {
	p.tag = tag
	return p
}

func (p *tagServiceUpdateRequest) Send() (*tagServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.tagService.connection.URL(), p.tagService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTagWriteOne(writer, p.tag, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.tagService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.tagService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &tagServiceUpdateResponse{tag: result}, nil
}

func (p *tagServiceUpdateRequest) MustSend() *tagServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.tagService.connection.URL(), p.tagService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTagWriteOne(writer, p.tag, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.tagService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.tagService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &tagServiceUpdateResponse{tag: result}
}

//
// Updates the tag entity.
// For example to update parent tag to tag with id `456` of the tag with id `123` send a request like this:
// ....
// PUT /ovirt-engine/api/tags/123
// ....
// With request body like:
// [source,xml]
// ----
// <tag>
//   <parent id="456"/>
// </tag>
// ----
// You may also specify a tag name instead of id. For example to update parent tag to tag with name `mytag`
// of the tag with id `123` send a request like this:
// [source,xml]
// ----
// <tag>
//   <parent>
//     <name>mytag</name>
//   </parent>
// </tag>
// ----
//
type tagServiceUpdateResponse struct {
	tag *Tag
}

func (p *tagServiceUpdateResponse) Tag() (*Tag, bool) {
	if p.tag != nil {
		return p.tag, true
	}
	return nil, false
}

func (p *tagServiceUpdateResponse) MustTag() *Tag {
	if p.tag == nil {
		panic("tag in response does not exist")
	}
	return p.tag
}

//
// Updates the tag entity.
// For example to update parent tag to tag with id `456` of the tag with id `123` send a request like this:
// ....
// PUT /ovirt-engine/api/tags/123
// ....
// With request body like:
// [source,xml]
// ----
// <tag>
//   <parent id="456"/>
// </tag>
// ----
// You may also specify a tag name instead of id. For example to update parent tag to tag with name `mytag`
// of the tag with id `123` send a request like this:
// [source,xml]
// ----
// <tag>
//   <parent>
//     <name>mytag</name>
//   </parent>
// </tag>
// ----
//
func (p *tagService) Update() *tagServiceUpdateRequest {
	return &tagServiceUpdateRequest{tagService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *tagService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *tagService) String() string {
	return fmt.Sprintf("tagService:%s", op.path)
}

//
//
type vmService struct {
	baseService
}

func NewVmService(connection *Connection, path string) *vmService {
	var result vmService
	result.connection = connection
	result.path = path
	return &result
}

//
// This operation stops any migration of a virtual machine to another physical host.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/cancelmigration
// ----
// The cancel migration action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceCancelMigrationRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *vmServiceCancelMigrationRequest) Header(key, value string) *vmServiceCancelMigrationRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceCancelMigrationRequest) Query(key, value string) *vmServiceCancelMigrationRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceCancelMigrationRequest) Async(async bool) *vmServiceCancelMigrationRequest {
	p.async = &async
	return p
}

func (p *vmServiceCancelMigrationRequest) Send() (*vmServiceCancelMigrationResponse, error) {
	rawURL := fmt.Sprintf("%s%s/cancelmigration", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceCancelMigrationResponse), nil
}

func (p *vmServiceCancelMigrationRequest) MustSend() *vmServiceCancelMigrationResponse {
	rawURL := fmt.Sprintf("%s%s/cancelmigration", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceCancelMigrationResponse)
}

//
// This operation stops any migration of a virtual machine to another physical host.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/cancelmigration
// ----
// The cancel migration action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceCancelMigrationResponse struct {
}

//
// This operation stops any migration of a virtual machine to another physical host.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/cancelmigration
// ----
// The cancel migration action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *vmService) CancelMigration() *vmServiceCancelMigrationRequest {
	return &vmServiceCancelMigrationRequest{vmService: p}
}

//
//
type vmServiceCloneRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
	vm        *Vm
}

func (p *vmServiceCloneRequest) Header(key, value string) *vmServiceCloneRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceCloneRequest) Query(key, value string) *vmServiceCloneRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceCloneRequest) Async(async bool) *vmServiceCloneRequest {
	p.async = &async
	return p
}

func (p *vmServiceCloneRequest) Vm(vm *Vm) *vmServiceCloneRequest {
	p.vm = vm
	return p
}

func (p *vmServiceCloneRequest) Send() (*vmServiceCloneResponse, error) {
	rawURL := fmt.Sprintf("%s%s/clone", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceCloneResponse), nil
}

func (p *vmServiceCloneRequest) MustSend() *vmServiceCloneResponse {
	rawURL := fmt.Sprintf("%s%s/clone", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceCloneResponse)
}

//
//
type vmServiceCloneResponse struct {
}

//
//
func (p *vmService) Clone() *vmServiceCloneRequest {
	return &vmServiceCloneRequest{vmService: p}
}

//
// Permanently restores the virtual machine to the state of the previewed snapshot.
// See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
//
type vmServiceCommitSnapshotRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *vmServiceCommitSnapshotRequest) Header(key, value string) *vmServiceCommitSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceCommitSnapshotRequest) Query(key, value string) *vmServiceCommitSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceCommitSnapshotRequest) Async(async bool) *vmServiceCommitSnapshotRequest {
	p.async = &async
	return p
}

func (p *vmServiceCommitSnapshotRequest) Send() (*vmServiceCommitSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/commitsnapshot", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceCommitSnapshotResponse), nil
}

func (p *vmServiceCommitSnapshotRequest) MustSend() *vmServiceCommitSnapshotResponse {
	rawURL := fmt.Sprintf("%s%s/commitsnapshot", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceCommitSnapshotResponse)
}

//
// Permanently restores the virtual machine to the state of the previewed snapshot.
// See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
//
type vmServiceCommitSnapshotResponse struct {
}

//
// Permanently restores the virtual machine to the state of the previewed snapshot.
// See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
//
func (p *vmService) CommitSnapshot() *vmServiceCommitSnapshotRequest {
	return &vmServiceCommitSnapshotRequest{vmService: p}
}

//
// Detaches a virtual machine from a pool.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/detach
// ----
// The detach action does not take any action specific parameters; therefore, the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceDetachRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *vmServiceDetachRequest) Header(key, value string) *vmServiceDetachRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceDetachRequest) Query(key, value string) *vmServiceDetachRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceDetachRequest) Async(async bool) *vmServiceDetachRequest {
	p.async = &async
	return p
}

func (p *vmServiceDetachRequest) Send() (*vmServiceDetachResponse, error) {
	rawURL := fmt.Sprintf("%s%s/detach", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceDetachResponse), nil
}

func (p *vmServiceDetachRequest) MustSend() *vmServiceDetachResponse {
	rawURL := fmt.Sprintf("%s%s/detach", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceDetachResponse)
}

//
// Detaches a virtual machine from a pool.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/detach
// ----
// The detach action does not take any action specific parameters; therefore, the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceDetachResponse struct {
}

//
// Detaches a virtual machine from a pool.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/detach
// ----
// The detach action does not take any action specific parameters; therefore, the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *vmService) Detach() *vmServiceDetachRequest {
	return &vmServiceDetachRequest{vmService: p}
}

//
// Exports the virtual machine.
// A virtual machine can be exported to an export domain.
// For example, to export virtual machine `123` to the export domain `myexport`:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <exclusive>true</exclusive>
//   <discard_snapshots>true</discard_snapshots>
// </action>
// ----
// Since version 4.2 of the engine it is also possible to export a virtual machine as a virtual appliance (OVA).
// For example, to export virtual machine `123` as an OVA file named `myvm.ova` that is placed in the directory `/home/ovirt/` on host `myhost`:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <host>
//     <name>myhost</name>
//   </host>
//   <directory>/home/ovirt</directory>
//   <filename>myvm.ova</filename>
// </action>
// ----
//
type vmServiceExportRequest struct {
	vmService        *vmService
	header           map[string]string
	query            map[string]string
	async            *bool
	discardSnapshots *bool
	exclusive        *bool
	storageDomain    *StorageDomain
}

func (p *vmServiceExportRequest) Header(key, value string) *vmServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceExportRequest) Query(key, value string) *vmServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceExportRequest) Async(async bool) *vmServiceExportRequest {
	p.async = &async
	return p
}

func (p *vmServiceExportRequest) DiscardSnapshots(discardSnapshots bool) *vmServiceExportRequest {
	p.discardSnapshots = &discardSnapshots
	return p
}

func (p *vmServiceExportRequest) Exclusive(exclusive bool) *vmServiceExportRequest {
	p.exclusive = &exclusive
	return p
}

func (p *vmServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *vmServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *vmServiceExportRequest) Send() (*vmServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.discardSnapshots != nil {
		actionBuilder.DiscardSnapshots(*p.discardSnapshots)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceExportResponse), nil
}

func (p *vmServiceExportRequest) MustSend() *vmServiceExportResponse {
	rawURL := fmt.Sprintf("%s%s/export", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.discardSnapshots != nil {
		actionBuilder.DiscardSnapshots(*p.discardSnapshots)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceExportResponse)
}

//
// Exports the virtual machine.
// A virtual machine can be exported to an export domain.
// For example, to export virtual machine `123` to the export domain `myexport`:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <exclusive>true</exclusive>
//   <discard_snapshots>true</discard_snapshots>
// </action>
// ----
// Since version 4.2 of the engine it is also possible to export a virtual machine as a virtual appliance (OVA).
// For example, to export virtual machine `123` as an OVA file named `myvm.ova` that is placed in the directory `/home/ovirt/` on host `myhost`:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <host>
//     <name>myhost</name>
//   </host>
//   <directory>/home/ovirt</directory>
//   <filename>myvm.ova</filename>
// </action>
// ----
//
type vmServiceExportResponse struct {
}

//
// Exports the virtual machine.
// A virtual machine can be exported to an export domain.
// For example, to export virtual machine `123` to the export domain `myexport`:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <exclusive>true</exclusive>
//   <discard_snapshots>true</discard_snapshots>
// </action>
// ----
// Since version 4.2 of the engine it is also possible to export a virtual machine as a virtual appliance (OVA).
// For example, to export virtual machine `123` as an OVA file named `myvm.ova` that is placed in the directory `/home/ovirt/` on host `myhost`:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <host>
//     <name>myhost</name>
//   </host>
//   <directory>/home/ovirt</directory>
//   <filename>myvm.ova</filename>
// </action>
// ----
//
func (p *vmService) Export() *vmServiceExportRequest {
	return &vmServiceExportRequest{vmService: p}
}

//
// Freezes virtual machine file systems.
// This operation freezes a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of
// a running virtual machine. Normally, this is done automatically by the manager, but this must be executed
// manually with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/freezefilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceFreezeFilesystemsRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *vmServiceFreezeFilesystemsRequest) Header(key, value string) *vmServiceFreezeFilesystemsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceFreezeFilesystemsRequest) Query(key, value string) *vmServiceFreezeFilesystemsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceFreezeFilesystemsRequest) Async(async bool) *vmServiceFreezeFilesystemsRequest {
	p.async = &async
	return p
}

func (p *vmServiceFreezeFilesystemsRequest) Send() (*vmServiceFreezeFilesystemsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/freezefilesystems", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceFreezeFilesystemsResponse), nil
}

func (p *vmServiceFreezeFilesystemsRequest) MustSend() *vmServiceFreezeFilesystemsResponse {
	rawURL := fmt.Sprintf("%s%s/freezefilesystems", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceFreezeFilesystemsResponse)
}

//
// Freezes virtual machine file systems.
// This operation freezes a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of
// a running virtual machine. Normally, this is done automatically by the manager, but this must be executed
// manually with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/freezefilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceFreezeFilesystemsResponse struct {
}

//
// Freezes virtual machine file systems.
// This operation freezes a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of
// a running virtual machine. Normally, this is done automatically by the manager, but this must be executed
// manually with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/freezefilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
//
func (p *vmService) FreezeFilesystems() *vmServiceFreezeFilesystemsRequest {
	return &vmServiceFreezeFilesystemsRequest{vmService: p}
}

//
// Retrieves the description of the virtual machine.
//
type vmServiceGetRequest struct {
	vmService  *vmService
	header     map[string]string
	query      map[string]string
	allContent *bool
	filter     *bool
	follow     *string
	nextRun    *bool
}

func (p *vmServiceGetRequest) Header(key, value string) *vmServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceGetRequest) Query(key, value string) *vmServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceGetRequest) AllContent(allContent bool) *vmServiceGetRequest {
	p.allContent = &allContent
	return p
}

func (p *vmServiceGetRequest) Filter(filter bool) *vmServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *vmServiceGetRequest) Follow(follow string) *vmServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vmServiceGetRequest) NextRun(nextRun bool) *vmServiceGetRequest {
	p.nextRun = &nextRun
	return p
}

func (p *vmServiceGetRequest) Send() (*vmServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmService.connection.URL(), p.vmService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.nextRun != nil {
		values["next_run"] = []string{fmt.Sprintf("%v", *p.nextRun)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmServiceGetResponse{vm: result}, nil
}

func (p *vmServiceGetRequest) MustSend() *vmServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmService.connection.URL(), p.vmService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.nextRun != nil {
		values["next_run"] = []string{fmt.Sprintf("%v", *p.nextRun)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmServiceGetResponse{vm: result}
}

//
// Retrieves the description of the virtual machine.
//
type vmServiceGetResponse struct {
	vm *Vm
}

func (p *vmServiceGetResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *vmServiceGetResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Retrieves the description of the virtual machine.
//
func (p *vmService) Get() *vmServiceGetRequest {
	return &vmServiceGetRequest{vmService: p}
}

//
// Initiates the automatic user logon to access a virtual machine from an external console.
// This action requires the `ovirt-guest-agent-gdm-plugin` and the `ovirt-guest-agent-pam-module` packages to be
// installed and the `ovirt-guest-agent` service to be running on the virtual machine.
// Users require the appropriate user permissions for the virtual machine in order to access the virtual machine
// from an external console.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/logon
// ----
// Request body:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceLogonRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *vmServiceLogonRequest) Header(key, value string) *vmServiceLogonRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceLogonRequest) Query(key, value string) *vmServiceLogonRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceLogonRequest) Async(async bool) *vmServiceLogonRequest {
	p.async = &async
	return p
}

func (p *vmServiceLogonRequest) Send() (*vmServiceLogonResponse, error) {
	rawURL := fmt.Sprintf("%s%s/logon", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceLogonResponse), nil
}

func (p *vmServiceLogonRequest) MustSend() *vmServiceLogonResponse {
	rawURL := fmt.Sprintf("%s%s/logon", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceLogonResponse)
}

//
// Initiates the automatic user logon to access a virtual machine from an external console.
// This action requires the `ovirt-guest-agent-gdm-plugin` and the `ovirt-guest-agent-pam-module` packages to be
// installed and the `ovirt-guest-agent` service to be running on the virtual machine.
// Users require the appropriate user permissions for the virtual machine in order to access the virtual machine
// from an external console.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/logon
// ----
// Request body:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceLogonResponse struct {
}

//
// Initiates the automatic user logon to access a virtual machine from an external console.
// This action requires the `ovirt-guest-agent-gdm-plugin` and the `ovirt-guest-agent-pam-module` packages to be
// installed and the `ovirt-guest-agent` service to be running on the virtual machine.
// Users require the appropriate user permissions for the virtual machine in order to access the virtual machine
// from an external console.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/logon
// ----
// Request body:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *vmService) Logon() *vmServiceLogonRequest {
	return &vmServiceLogonRequest{vmService: p}
}

//
// Sets the global maintenance mode on the hosted engine virtual machine.
// This action has no effect on other virtual machines.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/maintenance
// ----
// [source,xml]
// ----
// <action>
//   <maintenance_enabled>true<maintenance_enabled/>
// </action>
// ----
//
type vmServiceMaintenanceRequest struct {
	vmService          *vmService
	header             map[string]string
	query              map[string]string
	async              *bool
	maintenanceEnabled *bool
}

func (p *vmServiceMaintenanceRequest) Header(key, value string) *vmServiceMaintenanceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceMaintenanceRequest) Query(key, value string) *vmServiceMaintenanceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceMaintenanceRequest) Async(async bool) *vmServiceMaintenanceRequest {
	p.async = &async
	return p
}

func (p *vmServiceMaintenanceRequest) MaintenanceEnabled(maintenanceEnabled bool) *vmServiceMaintenanceRequest {
	p.maintenanceEnabled = &maintenanceEnabled
	return p
}

func (p *vmServiceMaintenanceRequest) Send() (*vmServiceMaintenanceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/maintenance", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.maintenanceEnabled != nil {
		actionBuilder.MaintenanceEnabled(*p.maintenanceEnabled)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceMaintenanceResponse), nil
}

func (p *vmServiceMaintenanceRequest) MustSend() *vmServiceMaintenanceResponse {
	rawURL := fmt.Sprintf("%s%s/maintenance", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.maintenanceEnabled != nil {
		actionBuilder.MaintenanceEnabled(*p.maintenanceEnabled)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceMaintenanceResponse)
}

//
// Sets the global maintenance mode on the hosted engine virtual machine.
// This action has no effect on other virtual machines.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/maintenance
// ----
// [source,xml]
// ----
// <action>
//   <maintenance_enabled>true<maintenance_enabled/>
// </action>
// ----
//
type vmServiceMaintenanceResponse struct {
}

//
// Sets the global maintenance mode on the hosted engine virtual machine.
// This action has no effect on other virtual machines.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/maintenance
// ----
// [source,xml]
// ----
// <action>
//   <maintenance_enabled>true<maintenance_enabled/>
// </action>
// ----
//
func (p *vmService) Maintenance() *vmServiceMaintenanceRequest {
	return &vmServiceMaintenanceRequest{vmService: p}
}

//
// Migrates a virtual machine to another physical host.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/migrate
// ----
// To specify a specific host to migrate the virtual machine to:
// [source,xml]
// ----
// <action>
//   <host id="2ab5e1da-b726-4274-bbf7-0a42b16a0fc3"/>
// </action>
// ----
//
type vmServiceMigrateRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
	cluster   *Cluster
	force     *bool
	host      *Host
}

func (p *vmServiceMigrateRequest) Header(key, value string) *vmServiceMigrateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceMigrateRequest) Query(key, value string) *vmServiceMigrateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceMigrateRequest) Async(async bool) *vmServiceMigrateRequest {
	p.async = &async
	return p
}

func (p *vmServiceMigrateRequest) Cluster(cluster *Cluster) *vmServiceMigrateRequest {
	p.cluster = cluster
	return p
}

func (p *vmServiceMigrateRequest) Force(force bool) *vmServiceMigrateRequest {
	p.force = &force
	return p
}

func (p *vmServiceMigrateRequest) Host(host *Host) *vmServiceMigrateRequest {
	p.host = host
	return p
}

func (p *vmServiceMigrateRequest) Send() (*vmServiceMigrateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/migrate", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceMigrateResponse), nil
}

func (p *vmServiceMigrateRequest) MustSend() *vmServiceMigrateResponse {
	rawURL := fmt.Sprintf("%s%s/migrate", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceMigrateResponse)
}

//
// Migrates a virtual machine to another physical host.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/migrate
// ----
// To specify a specific host to migrate the virtual machine to:
// [source,xml]
// ----
// <action>
//   <host id="2ab5e1da-b726-4274-bbf7-0a42b16a0fc3"/>
// </action>
// ----
//
type vmServiceMigrateResponse struct {
}

//
// Migrates a virtual machine to another physical host.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/migrate
// ----
// To specify a specific host to migrate the virtual machine to:
// [source,xml]
// ----
// <action>
//   <host id="2ab5e1da-b726-4274-bbf7-0a42b16a0fc3"/>
// </action>
// ----
//
func (p *vmService) Migrate() *vmServiceMigrateRequest {
	return &vmServiceMigrateRequest{vmService: p}
}

//
// Temporarily restores the virtual machine to the state of a snapshot.
// The snapshot is indicated with the `snapshot.id` parameter. It is restored temporarily, so that the content can
// be inspected. Once that inspection is finished, the state of the virtual machine can be made permanent, using the
// <<services/vm/methods/commit_snapshot, commit_snapshot>> method, or discarded using the
// <<services/vm/methods/undo_snapshot, undo_snapshot>> method.
//
type vmServicePreviewSnapshotRequest struct {
	vmService     *vmService
	header        map[string]string
	query         map[string]string
	async         *bool
	disks         *DiskSlice
	lease         *StorageDomainLease
	restoreMemory *bool
	snapshot      *Snapshot
	vm            *Vm
}

func (p *vmServicePreviewSnapshotRequest) Header(key, value string) *vmServicePreviewSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServicePreviewSnapshotRequest) Query(key, value string) *vmServicePreviewSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServicePreviewSnapshotRequest) Async(async bool) *vmServicePreviewSnapshotRequest {
	p.async = &async
	return p
}

func (p *vmServicePreviewSnapshotRequest) Disks(disks *DiskSlice) *vmServicePreviewSnapshotRequest {
	p.disks = disks
	return p
}

func (p *vmServicePreviewSnapshotRequest) DisksOfAny(anys ...*Disk) *vmServicePreviewSnapshotRequest {
	if p.disks == nil {
		p.disks = new(DiskSlice)
	}
	p.disks.slice = append(p.disks.slice, anys...)
	return p
}

func (p *vmServicePreviewSnapshotRequest) Lease(lease *StorageDomainLease) *vmServicePreviewSnapshotRequest {
	p.lease = lease
	return p
}

func (p *vmServicePreviewSnapshotRequest) RestoreMemory(restoreMemory bool) *vmServicePreviewSnapshotRequest {
	p.restoreMemory = &restoreMemory
	return p
}

func (p *vmServicePreviewSnapshotRequest) Snapshot(snapshot *Snapshot) *vmServicePreviewSnapshotRequest {
	p.snapshot = snapshot
	return p
}

func (p *vmServicePreviewSnapshotRequest) Vm(vm *Vm) *vmServicePreviewSnapshotRequest {
	p.vm = vm
	return p
}

func (p *vmServicePreviewSnapshotRequest) Send() (*vmServicePreviewSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/previewsnapshot", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Disks(p.disks)
	actionBuilder.Lease(p.lease)
	if p.restoreMemory != nil {
		actionBuilder.RestoreMemory(*p.restoreMemory)
	}
	actionBuilder.Snapshot(p.snapshot)
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServicePreviewSnapshotResponse), nil
}

func (p *vmServicePreviewSnapshotRequest) MustSend() *vmServicePreviewSnapshotResponse {
	rawURL := fmt.Sprintf("%s%s/previewsnapshot", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Disks(p.disks)
	actionBuilder.Lease(p.lease)
	if p.restoreMemory != nil {
		actionBuilder.RestoreMemory(*p.restoreMemory)
	}
	actionBuilder.Snapshot(p.snapshot)
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServicePreviewSnapshotResponse)
}

//
// Temporarily restores the virtual machine to the state of a snapshot.
// The snapshot is indicated with the `snapshot.id` parameter. It is restored temporarily, so that the content can
// be inspected. Once that inspection is finished, the state of the virtual machine can be made permanent, using the
// <<services/vm/methods/commit_snapshot, commit_snapshot>> method, or discarded using the
// <<services/vm/methods/undo_snapshot, undo_snapshot>> method.
//
type vmServicePreviewSnapshotResponse struct {
}

//
// Temporarily restores the virtual machine to the state of a snapshot.
// The snapshot is indicated with the `snapshot.id` parameter. It is restored temporarily, so that the content can
// be inspected. Once that inspection is finished, the state of the virtual machine can be made permanent, using the
// <<services/vm/methods/commit_snapshot, commit_snapshot>> method, or discarded using the
// <<services/vm/methods/undo_snapshot, undo_snapshot>> method.
//
func (p *vmService) PreviewSnapshot() *vmServicePreviewSnapshotRequest {
	return &vmServicePreviewSnapshotRequest{vmService: p}
}

//
// Sends a reboot request to a virtual machine.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/reboot
// ----
// The reboot action does not take any action specific parameters; therefore, the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceRebootRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *vmServiceRebootRequest) Header(key, value string) *vmServiceRebootRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceRebootRequest) Query(key, value string) *vmServiceRebootRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceRebootRequest) Async(async bool) *vmServiceRebootRequest {
	p.async = &async
	return p
}

func (p *vmServiceRebootRequest) Send() (*vmServiceRebootResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reboot", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceRebootResponse), nil
}

func (p *vmServiceRebootRequest) MustSend() *vmServiceRebootResponse {
	rawURL := fmt.Sprintf("%s%s/reboot", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceRebootResponse)
}

//
// Sends a reboot request to a virtual machine.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/reboot
// ----
// The reboot action does not take any action specific parameters; therefore, the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceRebootResponse struct {
}

//
// Sends a reboot request to a virtual machine.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/reboot
// ----
// The reboot action does not take any action specific parameters; therefore, the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *vmService) Reboot() *vmServiceRebootRequest {
	return &vmServiceRebootRequest{vmService: p}
}

//
// Removes the virtual machine, including the virtual disks attached to it.
// For example, to remove the virtual machine with identifier `123`:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123
// ----
//
type vmServiceRemoveRequest struct {
	vmService  *vmService
	header     map[string]string
	query      map[string]string
	async      *bool
	detachOnly *bool
	force      *bool
}

func (p *vmServiceRemoveRequest) Header(key, value string) *vmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceRemoveRequest) Query(key, value string) *vmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceRemoveRequest) Async(async bool) *vmServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *vmServiceRemoveRequest) DetachOnly(detachOnly bool) *vmServiceRemoveRequest {
	p.detachOnly = &detachOnly
	return p
}

func (p *vmServiceRemoveRequest) Force(force bool) *vmServiceRemoveRequest {
	p.force = &force
	return p
}

func (p *vmServiceRemoveRequest) Send() (*vmServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmService.connection.URL(), p.vmService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.detachOnly != nil {
		values["detach_only"] = []string{fmt.Sprintf("%v", *p.detachOnly)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(vmServiceRemoveResponse), nil
}

func (p *vmServiceRemoveRequest) MustSend() *vmServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmService.connection.URL(), p.vmService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.detachOnly != nil {
		values["detach_only"] = []string{fmt.Sprintf("%v", *p.detachOnly)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(vmServiceRemoveResponse)
}

//
// Removes the virtual machine, including the virtual disks attached to it.
// For example, to remove the virtual machine with identifier `123`:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123
// ----
//
type vmServiceRemoveResponse struct {
}

//
// Removes the virtual machine, including the virtual disks attached to it.
// For example, to remove the virtual machine with identifier `123`:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123
// ----
//
func (p *vmService) Remove() *vmServiceRemoveRequest {
	return &vmServiceRemoveRequest{vmService: p}
}

//
//
type vmServiceReorderMacAddressesRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *vmServiceReorderMacAddressesRequest) Header(key, value string) *vmServiceReorderMacAddressesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceReorderMacAddressesRequest) Query(key, value string) *vmServiceReorderMacAddressesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceReorderMacAddressesRequest) Async(async bool) *vmServiceReorderMacAddressesRequest {
	p.async = &async
	return p
}

func (p *vmServiceReorderMacAddressesRequest) Send() (*vmServiceReorderMacAddressesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reordermacaddresses", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceReorderMacAddressesResponse), nil
}

func (p *vmServiceReorderMacAddressesRequest) MustSend() *vmServiceReorderMacAddressesResponse {
	rawURL := fmt.Sprintf("%s%s/reordermacaddresses", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceReorderMacAddressesResponse)
}

//
//
type vmServiceReorderMacAddressesResponse struct {
}

//
//
func (p *vmService) ReorderMacAddresses() *vmServiceReorderMacAddressesRequest {
	return &vmServiceReorderMacAddressesRequest{vmService: p}
}

//
// This operation sends a shutdown request to a virtual machine.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/shutdown
// ----
// The shutdown action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceShutdownRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *vmServiceShutdownRequest) Header(key, value string) *vmServiceShutdownRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceShutdownRequest) Query(key, value string) *vmServiceShutdownRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceShutdownRequest) Async(async bool) *vmServiceShutdownRequest {
	p.async = &async
	return p
}

func (p *vmServiceShutdownRequest) Send() (*vmServiceShutdownResponse, error) {
	rawURL := fmt.Sprintf("%s%s/shutdown", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceShutdownResponse), nil
}

func (p *vmServiceShutdownRequest) MustSend() *vmServiceShutdownResponse {
	rawURL := fmt.Sprintf("%s%s/shutdown", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceShutdownResponse)
}

//
// This operation sends a shutdown request to a virtual machine.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/shutdown
// ----
// The shutdown action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceShutdownResponse struct {
}

//
// This operation sends a shutdown request to a virtual machine.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/shutdown
// ----
// The shutdown action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *vmService) Shutdown() *vmServiceShutdownRequest {
	return &vmServiceShutdownRequest{vmService: p}
}

//
// Starts the virtual machine.
// If the virtual environment is complete and the virtual machine contains all necessary components to function,
// it can be started.
// This example starts the virtual machine:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/start
// ----
// With a request body:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceStartRequest struct {
	vmService     *vmService
	header        map[string]string
	query         map[string]string
	async         *bool
	authorizedKey *AuthorizedKey
	filter        *bool
	pause         *bool
	useCloudInit  *bool
	useSysprep    *bool
	vm            *Vm
	volatile      *bool
}

func (p *vmServiceStartRequest) Header(key, value string) *vmServiceStartRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceStartRequest) Query(key, value string) *vmServiceStartRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceStartRequest) Async(async bool) *vmServiceStartRequest {
	p.async = &async
	return p
}

func (p *vmServiceStartRequest) AuthorizedKey(authorizedKey *AuthorizedKey) *vmServiceStartRequest {
	p.authorizedKey = authorizedKey
	return p
}

func (p *vmServiceStartRequest) Filter(filter bool) *vmServiceStartRequest {
	p.filter = &filter
	return p
}

func (p *vmServiceStartRequest) Pause(pause bool) *vmServiceStartRequest {
	p.pause = &pause
	return p
}

func (p *vmServiceStartRequest) UseCloudInit(useCloudInit bool) *vmServiceStartRequest {
	p.useCloudInit = &useCloudInit
	return p
}

func (p *vmServiceStartRequest) UseSysprep(useSysprep bool) *vmServiceStartRequest {
	p.useSysprep = &useSysprep
	return p
}

func (p *vmServiceStartRequest) Vm(vm *Vm) *vmServiceStartRequest {
	p.vm = vm
	return p
}

func (p *vmServiceStartRequest) Volatile(volatile bool) *vmServiceStartRequest {
	p.volatile = &volatile
	return p
}

func (p *vmServiceStartRequest) Send() (*vmServiceStartResponse, error) {
	rawURL := fmt.Sprintf("%s%s/start", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.AuthorizedKey(p.authorizedKey)
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	if p.pause != nil {
		actionBuilder.Pause(*p.pause)
	}
	if p.useCloudInit != nil {
		actionBuilder.UseCloudInit(*p.useCloudInit)
	}
	if p.useSysprep != nil {
		actionBuilder.UseSysprep(*p.useSysprep)
	}
	actionBuilder.Vm(p.vm)
	if p.volatile != nil {
		actionBuilder.Volatile(*p.volatile)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceStartResponse), nil
}

func (p *vmServiceStartRequest) MustSend() *vmServiceStartResponse {
	rawURL := fmt.Sprintf("%s%s/start", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.AuthorizedKey(p.authorizedKey)
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	if p.pause != nil {
		actionBuilder.Pause(*p.pause)
	}
	if p.useCloudInit != nil {
		actionBuilder.UseCloudInit(*p.useCloudInit)
	}
	if p.useSysprep != nil {
		actionBuilder.UseSysprep(*p.useSysprep)
	}
	actionBuilder.Vm(p.vm)
	if p.volatile != nil {
		actionBuilder.Volatile(*p.volatile)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceStartResponse)
}

//
// Starts the virtual machine.
// If the virtual environment is complete and the virtual machine contains all necessary components to function,
// it can be started.
// This example starts the virtual machine:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/start
// ----
// With a request body:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceStartResponse struct {
}

//
// Starts the virtual machine.
// If the virtual environment is complete and the virtual machine contains all necessary components to function,
// it can be started.
// This example starts the virtual machine:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/start
// ----
// With a request body:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *vmService) Start() *vmServiceStartRequest {
	return &vmServiceStartRequest{vmService: p}
}

//
// This operation forces a virtual machine to power-off.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/stop
// ----
// The stop action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceStopRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *vmServiceStopRequest) Header(key, value string) *vmServiceStopRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceStopRequest) Query(key, value string) *vmServiceStopRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceStopRequest) Async(async bool) *vmServiceStopRequest {
	p.async = &async
	return p
}

func (p *vmServiceStopRequest) Send() (*vmServiceStopResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stop", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceStopResponse), nil
}

func (p *vmServiceStopRequest) MustSend() *vmServiceStopResponse {
	rawURL := fmt.Sprintf("%s%s/stop", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceStopResponse)
}

//
// This operation forces a virtual machine to power-off.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/stop
// ----
// The stop action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceStopResponse struct {
}

//
// This operation forces a virtual machine to power-off.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/stop
// ----
// The stop action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *vmService) Stop() *vmServiceStopRequest {
	return &vmServiceStopRequest{vmService: p}
}

//
// This operation saves the virtual machine state to disk and stops it.
// Start a suspended virtual machine and restore the virtual machine state with the start action.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/suspend
// ----
// The suspend action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceSuspendRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *vmServiceSuspendRequest) Header(key, value string) *vmServiceSuspendRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceSuspendRequest) Query(key, value string) *vmServiceSuspendRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceSuspendRequest) Async(async bool) *vmServiceSuspendRequest {
	p.async = &async
	return p
}

func (p *vmServiceSuspendRequest) Send() (*vmServiceSuspendResponse, error) {
	rawURL := fmt.Sprintf("%s%s/suspend", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceSuspendResponse), nil
}

func (p *vmServiceSuspendRequest) MustSend() *vmServiceSuspendResponse {
	rawURL := fmt.Sprintf("%s%s/suspend", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceSuspendResponse)
}

//
// This operation saves the virtual machine state to disk and stops it.
// Start a suspended virtual machine and restore the virtual machine state with the start action.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/suspend
// ----
// The suspend action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceSuspendResponse struct {
}

//
// This operation saves the virtual machine state to disk and stops it.
// Start a suspended virtual machine and restore the virtual machine state with the start action.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/suspend
// ----
// The suspend action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *vmService) Suspend() *vmServiceSuspendRequest {
	return &vmServiceSuspendRequest{vmService: p}
}

//
// Thaws virtual machine file systems.
// This operation thaws a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of a
// running virtual machine. Normally, this is done automatically by the manager, but this must be executed manually
// with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /api/vms/123/thawfilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceThawFilesystemsRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *vmServiceThawFilesystemsRequest) Header(key, value string) *vmServiceThawFilesystemsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceThawFilesystemsRequest) Query(key, value string) *vmServiceThawFilesystemsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceThawFilesystemsRequest) Async(async bool) *vmServiceThawFilesystemsRequest {
	p.async = &async
	return p
}

func (p *vmServiceThawFilesystemsRequest) Send() (*vmServiceThawFilesystemsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/thawfilesystems", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceThawFilesystemsResponse), nil
}

func (p *vmServiceThawFilesystemsRequest) MustSend() *vmServiceThawFilesystemsResponse {
	rawURL := fmt.Sprintf("%s%s/thawfilesystems", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceThawFilesystemsResponse)
}

//
// Thaws virtual machine file systems.
// This operation thaws a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of a
// running virtual machine. Normally, this is done automatically by the manager, but this must be executed manually
// with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /api/vms/123/thawfilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
//
type vmServiceThawFilesystemsResponse struct {
}

//
// Thaws virtual machine file systems.
// This operation thaws a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of a
// running virtual machine. Normally, this is done automatically by the manager, but this must be executed manually
// with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /api/vms/123/thawfilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
//
func (p *vmService) ThawFilesystems() *vmServiceThawFilesystemsRequest {
	return &vmServiceThawFilesystemsRequest{vmService: p}
}

//
// Generates a time-sensitive authentication token for accessing a virtual machine's display.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// The response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
// [IMPORTANT]
// ====
// If the virtual machine is configured to support only one graphics protocol
// then the generated authentication token will be valid for that protocol.
// But if the virtual machine is configured to support multiple protocols,
// VNC and SPICE, then the authentication token will only be valid for
// the SPICE protocol.
// In order to obtain an authentication token for a specific protocol, for
// example for VNC, use the `ticket` method of the <<services/vm_graphics_console,
// service>>, which manages the graphics consoles of the virtual machine, by sending
// a request:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// ====
//
type vmServiceTicketRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
	ticket    *Ticket
}

func (p *vmServiceTicketRequest) Header(key, value string) *vmServiceTicketRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceTicketRequest) Query(key, value string) *vmServiceTicketRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceTicketRequest) Async(async bool) *vmServiceTicketRequest {
	p.async = &async
	return p
}

func (p *vmServiceTicketRequest) Ticket(ticket *Ticket) *vmServiceTicketRequest {
	p.ticket = ticket
	return p
}

func (p *vmServiceTicketRequest) Send() (*vmServiceTicketResponse, error) {
	rawURL := fmt.Sprintf("%s%s/ticket", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Ticket(p.ticket)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustTicket()
	return &vmServiceTicketResponse{ticket: result}, nil
}

func (p *vmServiceTicketRequest) MustSend() *vmServiceTicketResponse {
	rawURL := fmt.Sprintf("%s%s/ticket", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Ticket(p.ticket)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustTicket()
	return &vmServiceTicketResponse{ticket: result}
}

//
// Generates a time-sensitive authentication token for accessing a virtual machine's display.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// The response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
// [IMPORTANT]
// ====
// If the virtual machine is configured to support only one graphics protocol
// then the generated authentication token will be valid for that protocol.
// But if the virtual machine is configured to support multiple protocols,
// VNC and SPICE, then the authentication token will only be valid for
// the SPICE protocol.
// In order to obtain an authentication token for a specific protocol, for
// example for VNC, use the `ticket` method of the <<services/vm_graphics_console,
// service>>, which manages the graphics consoles of the virtual machine, by sending
// a request:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// ====
//
type vmServiceTicketResponse struct {
	ticket *Ticket
}

func (p *vmServiceTicketResponse) Ticket() (*Ticket, bool) {
	if p.ticket != nil {
		return p.ticket, true
	}
	return nil, false
}

func (p *vmServiceTicketResponse) MustTicket() *Ticket {
	if p.ticket == nil {
		panic("ticket in response does not exist")
	}
	return p.ticket
}

//
// Generates a time-sensitive authentication token for accessing a virtual machine's display.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// The response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
// [IMPORTANT]
// ====
// If the virtual machine is configured to support only one graphics protocol
// then the generated authentication token will be valid for that protocol.
// But if the virtual machine is configured to support multiple protocols,
// VNC and SPICE, then the authentication token will only be valid for
// the SPICE protocol.
// In order to obtain an authentication token for a specific protocol, for
// example for VNC, use the `ticket` method of the <<services/vm_graphics_console,
// service>>, which manages the graphics consoles of the virtual machine, by sending
// a request:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// ====
//
func (p *vmService) Ticket() *vmServiceTicketRequest {
	return &vmServiceTicketRequest{vmService: p}
}

//
// Exports a virtual machine to an export domain.
//
type vmServiceExportToExportDomainRequest struct {
	vmService        *vmService
	header           map[string]string
	query            map[string]string
	async            *bool
	discardSnapshots *bool
	exclusive        *bool
	storageDomain    *StorageDomain
}

func (p *vmServiceExportToExportDomainRequest) Header(key, value string) *vmServiceExportToExportDomainRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceExportToExportDomainRequest) Query(key, value string) *vmServiceExportToExportDomainRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceExportToExportDomainRequest) Async(async bool) *vmServiceExportToExportDomainRequest {
	p.async = &async
	return p
}

func (p *vmServiceExportToExportDomainRequest) DiscardSnapshots(discardSnapshots bool) *vmServiceExportToExportDomainRequest {
	p.discardSnapshots = &discardSnapshots
	return p
}

func (p *vmServiceExportToExportDomainRequest) Exclusive(exclusive bool) *vmServiceExportToExportDomainRequest {
	p.exclusive = &exclusive
	return p
}

func (p *vmServiceExportToExportDomainRequest) StorageDomain(storageDomain *StorageDomain) *vmServiceExportToExportDomainRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *vmServiceExportToExportDomainRequest) Send() (*vmServiceExportToExportDomainResponse, error) {
	rawURL := fmt.Sprintf("%s%s/toexportdomain", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.discardSnapshots != nil {
		actionBuilder.DiscardSnapshots(*p.discardSnapshots)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceExportToExportDomainResponse), nil
}

func (p *vmServiceExportToExportDomainRequest) MustSend() *vmServiceExportToExportDomainResponse {
	rawURL := fmt.Sprintf("%s%s/toexportdomain", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.discardSnapshots != nil {
		actionBuilder.DiscardSnapshots(*p.discardSnapshots)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceExportToExportDomainResponse)
}

//
// Exports a virtual machine to an export domain.
//
type vmServiceExportToExportDomainResponse struct {
}

//
// Exports a virtual machine to an export domain.
//
func (p *vmService) ExportToExportDomain() *vmServiceExportToExportDomainRequest {
	return &vmServiceExportToExportDomainRequest{vmService: p}
}

//
// Exports a virtual machine as an OVA file to a given path on a specified host.
//
type vmServiceExportToPathOnHostRequest struct {
	vmService        *vmService
	header           map[string]string
	query            map[string]string
	async            *bool
	directory        *string
	discardSnapshots *bool
	exclusive        *bool
	filename         *string
	host             *Host
	storageDomain    *StorageDomain
}

func (p *vmServiceExportToPathOnHostRequest) Header(key, value string) *vmServiceExportToPathOnHostRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceExportToPathOnHostRequest) Query(key, value string) *vmServiceExportToPathOnHostRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceExportToPathOnHostRequest) Async(async bool) *vmServiceExportToPathOnHostRequest {
	p.async = &async
	return p
}

func (p *vmServiceExportToPathOnHostRequest) Directory(directory string) *vmServiceExportToPathOnHostRequest {
	p.directory = &directory
	return p
}

func (p *vmServiceExportToPathOnHostRequest) DiscardSnapshots(discardSnapshots bool) *vmServiceExportToPathOnHostRequest {
	p.discardSnapshots = &discardSnapshots
	return p
}

func (p *vmServiceExportToPathOnHostRequest) Exclusive(exclusive bool) *vmServiceExportToPathOnHostRequest {
	p.exclusive = &exclusive
	return p
}

func (p *vmServiceExportToPathOnHostRequest) Filename(filename string) *vmServiceExportToPathOnHostRequest {
	p.filename = &filename
	return p
}

func (p *vmServiceExportToPathOnHostRequest) Host(host *Host) *vmServiceExportToPathOnHostRequest {
	p.host = host
	return p
}

func (p *vmServiceExportToPathOnHostRequest) StorageDomain(storageDomain *StorageDomain) *vmServiceExportToPathOnHostRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *vmServiceExportToPathOnHostRequest) Send() (*vmServiceExportToPathOnHostResponse, error) {
	rawURL := fmt.Sprintf("%s%s/topathonhost", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.directory != nil {
		actionBuilder.Directory(*p.directory)
	}
	if p.discardSnapshots != nil {
		actionBuilder.DiscardSnapshots(*p.discardSnapshots)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	if p.filename != nil {
		actionBuilder.Filename(*p.filename)
	}
	actionBuilder.Host(p.host)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceExportToPathOnHostResponse), nil
}

func (p *vmServiceExportToPathOnHostRequest) MustSend() *vmServiceExportToPathOnHostResponse {
	rawURL := fmt.Sprintf("%s%s/topathonhost", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.directory != nil {
		actionBuilder.Directory(*p.directory)
	}
	if p.discardSnapshots != nil {
		actionBuilder.DiscardSnapshots(*p.discardSnapshots)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	if p.filename != nil {
		actionBuilder.Filename(*p.filename)
	}
	actionBuilder.Host(p.host)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceExportToPathOnHostResponse)
}

//
// Exports a virtual machine as an OVA file to a given path on a specified host.
//
type vmServiceExportToPathOnHostResponse struct {
}

//
// Exports a virtual machine as an OVA file to a given path on a specified host.
//
func (p *vmService) ExportToPathOnHost() *vmServiceExportToPathOnHostRequest {
	return &vmServiceExportToPathOnHostRequest{vmService: p}
}

//
// Restores the virtual machine to the state it had before previewing the snapshot.
// See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
//
type vmServiceUndoSnapshotRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *vmServiceUndoSnapshotRequest) Header(key, value string) *vmServiceUndoSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceUndoSnapshotRequest) Query(key, value string) *vmServiceUndoSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceUndoSnapshotRequest) Async(async bool) *vmServiceUndoSnapshotRequest {
	p.async = &async
	return p
}

func (p *vmServiceUndoSnapshotRequest) Send() (*vmServiceUndoSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/undosnapshot", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmServiceUndoSnapshotResponse), nil
}

func (p *vmServiceUndoSnapshotRequest) MustSend() *vmServiceUndoSnapshotResponse {
	rawURL := fmt.Sprintf("%s%s/undosnapshot", p.vmService.connection.URL(), p.vmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmServiceUndoSnapshotResponse)
}

//
// Restores the virtual machine to the state it had before previewing the snapshot.
// See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
//
type vmServiceUndoSnapshotResponse struct {
}

//
// Restores the virtual machine to the state it had before previewing the snapshot.
// See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
//
func (p *vmService) UndoSnapshot() *vmServiceUndoSnapshotRequest {
	return &vmServiceUndoSnapshotRequest{vmService: p}
}

//
// Update the virtual machine in the system for the given virtual machine id.
//
type vmServiceUpdateRequest struct {
	vmService *vmService
	header    map[string]string
	query     map[string]string
	async     *bool
	nextRun   *bool
	vm        *Vm
}

func (p *vmServiceUpdateRequest) Header(key, value string) *vmServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmServiceUpdateRequest) Query(key, value string) *vmServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmServiceUpdateRequest) Async(async bool) *vmServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *vmServiceUpdateRequest) NextRun(nextRun bool) *vmServiceUpdateRequest {
	p.nextRun = &nextRun
	return p
}

func (p *vmServiceUpdateRequest) Vm(vm *Vm) *vmServiceUpdateRequest {
	p.vm = vm
	return p
}

func (p *vmServiceUpdateRequest) Send() (*vmServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmService.connection.URL(), p.vmService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.nextRun != nil {
		values["next_run"] = []string{fmt.Sprintf("%v", *p.nextRun)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmWriteOne(writer, p.vm, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmServiceUpdateResponse{vm: result}, nil
}

func (p *vmServiceUpdateRequest) MustSend() *vmServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmService.connection.URL(), p.vmService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.nextRun != nil {
		values["next_run"] = []string{fmt.Sprintf("%v", *p.nextRun)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmWriteOne(writer, p.vm, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmServiceUpdateResponse{vm: result}
}

//
// Update the virtual machine in the system for the given virtual machine id.
//
type vmServiceUpdateResponse struct {
	vm *Vm
}

func (p *vmServiceUpdateResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *vmServiceUpdateResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Update the virtual machine in the system for the given virtual machine id.
//
func (p *vmService) Update() *vmServiceUpdateRequest {
	return &vmServiceUpdateRequest{vmService: p}
}

//
// List of scheduling labels assigned to this virtual machine.
//
func (op *vmService) AffinityLabelsService() *assignedAffinityLabelsService {
	return NewAssignedAffinityLabelsService(op.connection, fmt.Sprintf("%s/affinitylabels", op.path))
}

//
//
func (op *vmService) ApplicationsService() *vmApplicationsService {
	return NewVmApplicationsService(op.connection, fmt.Sprintf("%s/applications", op.path))
}

//
//
func (op *vmService) CdromsService() *vmCdromsService {
	return NewVmCdromsService(op.connection, fmt.Sprintf("%s/cdroms", op.path))
}

//
// List of disks attached to this virtual machine.
//
func (op *vmService) DiskAttachmentsService() *diskAttachmentsService {
	return NewDiskAttachmentsService(op.connection, fmt.Sprintf("%s/diskattachments", op.path))
}

//
//
func (op *vmService) GraphicsConsolesService() *vmGraphicsConsolesService {
	return NewVmGraphicsConsolesService(op.connection, fmt.Sprintf("%s/graphicsconsoles", op.path))
}

//
//
func (op *vmService) HostDevicesService() *vmHostDevicesService {
	return NewVmHostDevicesService(op.connection, fmt.Sprintf("%s/hostdevices", op.path))
}

//
// Reference to the service that can show the applicable errata available on the virtual machine.
// This information is taken from Katello.
//
func (op *vmService) KatelloErrataService() *katelloErrataService {
	return NewKatelloErrataService(op.connection, fmt.Sprintf("%s/katelloerrata", op.path))
}

//
//
func (op *vmService) NicsService() *vmNicsService {
	return NewVmNicsService(op.connection, fmt.Sprintf("%s/nics", op.path))
}

//
//
func (op *vmService) NumaNodesService() *vmNumaNodesService {
	return NewVmNumaNodesService(op.connection, fmt.Sprintf("%s/numanodes", op.path))
}

//
//
func (op *vmService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *vmService) ReportedDevicesService() *vmReportedDevicesService {
	return NewVmReportedDevicesService(op.connection, fmt.Sprintf("%s/reporteddevices", op.path))
}

//
// Reference to the service that provides information about virtual machine user sessions.
//
func (op *vmService) SessionsService() *vmSessionsService {
	return NewVmSessionsService(op.connection, fmt.Sprintf("%s/sessions", op.path))
}

//
//
func (op *vmService) SnapshotsService() *snapshotsService {
	return NewSnapshotsService(op.connection, fmt.Sprintf("%s/snapshots", op.path))
}

//
//
func (op *vmService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
//
func (op *vmService) TagsService() *assignedTagsService {
	return NewAssignedTagsService(op.connection, fmt.Sprintf("%s/tags", op.path))
}

//
//
func (op *vmService) WatchdogsService() *vmWatchdogsService {
	return NewVmWatchdogsService(op.connection, fmt.Sprintf("%s/watchdogs", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitylabels" {
		return op.AffinityLabelsService(), nil
	}
	if strings.HasPrefix(path, "affinitylabels/") {
		return op.AffinityLabelsService().Service(path[15:])
	}
	if path == "applications" {
		return op.ApplicationsService(), nil
	}
	if strings.HasPrefix(path, "applications/") {
		return op.ApplicationsService().Service(path[13:])
	}
	if path == "cdroms" {
		return op.CdromsService(), nil
	}
	if strings.HasPrefix(path, "cdroms/") {
		return op.CdromsService().Service(path[7:])
	}
	if path == "diskattachments" {
		return op.DiskAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "diskattachments/") {
		return op.DiskAttachmentsService().Service(path[16:])
	}
	if path == "graphicsconsoles" {
		return op.GraphicsConsolesService(), nil
	}
	if strings.HasPrefix(path, "graphicsconsoles/") {
		return op.GraphicsConsolesService().Service(path[17:])
	}
	if path == "hostdevices" {
		return op.HostDevicesService(), nil
	}
	if strings.HasPrefix(path, "hostdevices/") {
		return op.HostDevicesService().Service(path[12:])
	}
	if path == "katelloerrata" {
		return op.KatelloErrataService(), nil
	}
	if strings.HasPrefix(path, "katelloerrata/") {
		return op.KatelloErrataService().Service(path[14:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "numanodes" {
		return op.NumaNodesService(), nil
	}
	if strings.HasPrefix(path, "numanodes/") {
		return op.NumaNodesService().Service(path[10:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "reporteddevices" {
		return op.ReportedDevicesService(), nil
	}
	if strings.HasPrefix(path, "reporteddevices/") {
		return op.ReportedDevicesService().Service(path[16:])
	}
	if path == "sessions" {
		return op.SessionsService(), nil
	}
	if strings.HasPrefix(path, "sessions/") {
		return op.SessionsService().Service(path[9:])
	}
	if path == "snapshots" {
		return op.SnapshotsService(), nil
	}
	if strings.HasPrefix(path, "snapshots/") {
		return op.SnapshotsService().Service(path[10:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "watchdogs" {
		return op.WatchdogsService(), nil
	}
	if strings.HasPrefix(path, "watchdogs/") {
		return op.WatchdogsService().Service(path[10:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vmService) String() string {
	return fmt.Sprintf("vmService:%s", op.path)
}

//
//
type hostHookService struct {
	baseService
}

func NewHostHookService(connection *Connection, path string) *hostHookService {
	var result hostHookService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type hostHookServiceGetRequest struct {
	hostHookService *hostHookService
	header          map[string]string
	query           map[string]string
	follow          *string
}

func (p *hostHookServiceGetRequest) Header(key, value string) *hostHookServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostHookServiceGetRequest) Query(key, value string) *hostHookServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostHookServiceGetRequest) Follow(follow string) *hostHookServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *hostHookServiceGetRequest) Send() (*hostHookServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostHookService.connection.URL(), p.hostHookService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostHookService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostHookService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHookReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &hostHookServiceGetResponse{hook: result}, nil
}

func (p *hostHookServiceGetRequest) MustSend() *hostHookServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostHookService.connection.URL(), p.hostHookService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostHookService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostHookService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHookReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &hostHookServiceGetResponse{hook: result}
}

//
//
type hostHookServiceGetResponse struct {
	hook *Hook
}

func (p *hostHookServiceGetResponse) Hook() (*Hook, bool) {
	if p.hook != nil {
		return p.hook, true
	}
	return nil, false
}

func (p *hostHookServiceGetResponse) MustHook() *Hook {
	if p.hook == nil {
		panic("hook in response does not exist")
	}
	return p.hook
}

//
//
func (p *hostHookService) Get() *hostHookServiceGetRequest {
	return &hostHookServiceGetRequest{hostHookService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *hostHookService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *hostHookService) String() string {
	return fmt.Sprintf("hostHookService:%s", op.path)
}

//
//
type imageService struct {
	baseService
}

func NewImageService(connection *Connection, path string) *imageService {
	var result imageService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type imageServiceGetRequest struct {
	imageService *imageService
	header       map[string]string
	query        map[string]string
	follow       *string
}

func (p *imageServiceGetRequest) Header(key, value string) *imageServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imageServiceGetRequest) Query(key, value string) *imageServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imageServiceGetRequest) Follow(follow string) *imageServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *imageServiceGetRequest) Send() (*imageServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imageService.connection.URL(), p.imageService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &imageServiceGetResponse{image: result}, nil
}

func (p *imageServiceGetRequest) MustSend() *imageServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.imageService.connection.URL(), p.imageService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &imageServiceGetResponse{image: result}
}

//
//
type imageServiceGetResponse struct {
	image *Image
}

func (p *imageServiceGetResponse) Image() (*Image, bool) {
	if p.image != nil {
		return p.image, true
	}
	return nil, false
}

func (p *imageServiceGetResponse) MustImage() *Image {
	if p.image == nil {
		panic("image in response does not exist")
	}
	return p.image
}

//
//
func (p *imageService) Get() *imageServiceGetRequest {
	return &imageServiceGetRequest{imageService: p}
}

//
// Imports an image.
// If the `import_as_template` parameter is `true` then the image will be imported as a template, otherwise it will
// be imported as a disk.
// When imported as a template, the name of the template can be specified by the optional `template.name`
// parameter. If that parameter is not specified, then the name of the template will be automatically assigned by the
// engine as `GlanceTemplate-x` (where `x` will be seven random hexadecimal characters).
// When imported as a disk, the name of the disk can be specified by the optional `disk.name` parameter. If
// that parameter is not specified, then the name of the disk will be automatically assigned by the engine as
// `GlanceDisk-x` (where `x` will be the seven hexadecimal characters of the image identifier).
// It is recommended to always explicitly specify the template or disk name, to avoid these automatic names
// generated by the engine.
//
type imageServiceImportRequest struct {
	imageService     *imageService
	header           map[string]string
	query            map[string]string
	async            *bool
	cluster          *Cluster
	disk             *Disk
	importAsTemplate *bool
	storageDomain    *StorageDomain
	template         *Template
}

func (p *imageServiceImportRequest) Header(key, value string) *imageServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imageServiceImportRequest) Query(key, value string) *imageServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imageServiceImportRequest) Async(async bool) *imageServiceImportRequest {
	p.async = &async
	return p
}

func (p *imageServiceImportRequest) Cluster(cluster *Cluster) *imageServiceImportRequest {
	p.cluster = cluster
	return p
}

func (p *imageServiceImportRequest) Disk(disk *Disk) *imageServiceImportRequest {
	p.disk = disk
	return p
}

func (p *imageServiceImportRequest) ImportAsTemplate(importAsTemplate bool) *imageServiceImportRequest {
	p.importAsTemplate = &importAsTemplate
	return p
}

func (p *imageServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *imageServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *imageServiceImportRequest) Template(template *Template) *imageServiceImportRequest {
	p.template = template
	return p
}

func (p *imageServiceImportRequest) Send() (*imageServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.imageService.connection.URL(), p.imageService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Disk(p.disk)
	if p.importAsTemplate != nil {
		actionBuilder.ImportAsTemplate(*p.importAsTemplate)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Template(p.template)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(imageServiceImportResponse), nil
}

func (p *imageServiceImportRequest) MustSend() *imageServiceImportResponse {
	rawURL := fmt.Sprintf("%s%s/import", p.imageService.connection.URL(), p.imageService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Disk(p.disk)
	if p.importAsTemplate != nil {
		actionBuilder.ImportAsTemplate(*p.importAsTemplate)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Template(p.template)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(imageServiceImportResponse)
}

//
// Imports an image.
// If the `import_as_template` parameter is `true` then the image will be imported as a template, otherwise it will
// be imported as a disk.
// When imported as a template, the name of the template can be specified by the optional `template.name`
// parameter. If that parameter is not specified, then the name of the template will be automatically assigned by the
// engine as `GlanceTemplate-x` (where `x` will be seven random hexadecimal characters).
// When imported as a disk, the name of the disk can be specified by the optional `disk.name` parameter. If
// that parameter is not specified, then the name of the disk will be automatically assigned by the engine as
// `GlanceDisk-x` (where `x` will be the seven hexadecimal characters of the image identifier).
// It is recommended to always explicitly specify the template or disk name, to avoid these automatic names
// generated by the engine.
//
type imageServiceImportResponse struct {
}

//
// Imports an image.
// If the `import_as_template` parameter is `true` then the image will be imported as a template, otherwise it will
// be imported as a disk.
// When imported as a template, the name of the template can be specified by the optional `template.name`
// parameter. If that parameter is not specified, then the name of the template will be automatically assigned by the
// engine as `GlanceTemplate-x` (where `x` will be seven random hexadecimal characters).
// When imported as a disk, the name of the disk can be specified by the optional `disk.name` parameter. If
// that parameter is not specified, then the name of the disk will be automatically assigned by the engine as
// `GlanceDisk-x` (where `x` will be the seven hexadecimal characters of the image identifier).
// It is recommended to always explicitly specify the template or disk name, to avoid these automatic names
// generated by the engine.
//
func (p *imageService) Import() *imageServiceImportRequest {
	return &imageServiceImportRequest{imageService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *imageService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *imageService) String() string {
	return fmt.Sprintf("imageService:%s", op.path)
}

//
// Manages the set of _quality of service_ configurations available in a data center.
//
type qossService struct {
	baseService
}

func NewQossService(connection *Connection, path string) *qossService {
	var result qossService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new QoS to the dataCenter.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/qoss
// ----
// The response will look as follows:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>123</name>
//   <description>123</description>
//   <max_iops>10</max_iops>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
type qossServiceAddRequest struct {
	qossService *qossService
	header      map[string]string
	query       map[string]string
	qos         *Qos
}

func (p *qossServiceAddRequest) Header(key, value string) *qossServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *qossServiceAddRequest) Query(key, value string) *qossServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *qossServiceAddRequest) Qos(qos *Qos) *qossServiceAddRequest {
	p.qos = qos
	return p
}

func (p *qossServiceAddRequest) Send() (*qossServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qossService.connection.URL(), p.qossService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQosWriteOne(writer, p.qos, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.qossService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.qossService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQosReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &qossServiceAddResponse{qos: result}, nil
}

func (p *qossServiceAddRequest) MustSend() *qossServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.qossService.connection.URL(), p.qossService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQosWriteOne(writer, p.qos, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.qossService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.qossService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQosReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &qossServiceAddResponse{qos: result}
}

//
// Add a new QoS to the dataCenter.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/qoss
// ----
// The response will look as follows:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>123</name>
//   <description>123</description>
//   <max_iops>10</max_iops>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
type qossServiceAddResponse struct {
	qos *Qos
}

func (p *qossServiceAddResponse) Qos() (*Qos, bool) {
	if p.qos != nil {
		return p.qos, true
	}
	return nil, false
}

func (p *qossServiceAddResponse) MustQos() *Qos {
	if p.qos == nil {
		panic("qos in response does not exist")
	}
	return p.qos
}

//
// Add a new QoS to the dataCenter.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/qoss
// ----
// The response will look as follows:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>123</name>
//   <description>123</description>
//   <max_iops>10</max_iops>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
func (p *qossService) Add() *qossServiceAddRequest {
	return &qossServiceAddRequest{qossService: p}
}

//
// Returns the list of _quality of service_ configurations available in the data center.
// [source]
// ----
// GET /ovirt-engine/api/datacenter/123/qoss
// ----
// You will get response which will look like this:
// [source, xml]
// ----
// <qoss>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/1" id="1">...</qos>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/2" id="2">...</qos>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/3" id="3">...</qos>
// </qoss>
// ----
// The returned list of quality of service configurations isn't guaranteed.
//
type qossServiceListRequest struct {
	qossService *qossService
	header      map[string]string
	query       map[string]string
	follow      *string
	max         *int64
}

func (p *qossServiceListRequest) Header(key, value string) *qossServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *qossServiceListRequest) Query(key, value string) *qossServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *qossServiceListRequest) Follow(follow string) *qossServiceListRequest {
	p.follow = &follow
	return p
}

func (p *qossServiceListRequest) Max(max int64) *qossServiceListRequest {
	p.max = &max
	return p
}

func (p *qossServiceListRequest) Send() (*qossServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qossService.connection.URL(), p.qossService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.qossService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.qossService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQosReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &qossServiceListResponse{qoss: result}, nil
}

func (p *qossServiceListRequest) MustSend() *qossServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.qossService.connection.URL(), p.qossService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.qossService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.qossService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQosReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &qossServiceListResponse{qoss: result}
}

//
// Returns the list of _quality of service_ configurations available in the data center.
// [source]
// ----
// GET /ovirt-engine/api/datacenter/123/qoss
// ----
// You will get response which will look like this:
// [source, xml]
// ----
// <qoss>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/1" id="1">...</qos>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/2" id="2">...</qos>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/3" id="3">...</qos>
// </qoss>
// ----
// The returned list of quality of service configurations isn't guaranteed.
//
type qossServiceListResponse struct {
	qoss *QosSlice
}

func (p *qossServiceListResponse) Qoss() (*QosSlice, bool) {
	if p.qoss != nil {
		return p.qoss, true
	}
	return nil, false
}

func (p *qossServiceListResponse) MustQoss() *QosSlice {
	if p.qoss == nil {
		panic("qoss in response does not exist")
	}
	return p.qoss
}

//
// Returns the list of _quality of service_ configurations available in the data center.
// [source]
// ----
// GET /ovirt-engine/api/datacenter/123/qoss
// ----
// You will get response which will look like this:
// [source, xml]
// ----
// <qoss>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/1" id="1">...</qos>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/2" id="2">...</qos>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/3" id="3">...</qos>
// </qoss>
// ----
// The returned list of quality of service configurations isn't guaranteed.
//
func (p *qossService) List() *qossServiceListRequest {
	return &qossServiceListRequest{qossService: p}
}

//
// A reference to a service managing a specific QoS.
//
func (op *qossService) QosService(id string) *qosService {
	return NewQosService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *qossService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.QosService(path), nil
	}
	return op.QosService(path[:index]).Service(path[index+1:])
}

func (op *qossService) String() string {
	return fmt.Sprintf("qossService:%s", op.path)
}

//
// A service to manage a bookmark.
//
type bookmarkService struct {
	baseService
}

func NewBookmarkService(connection *Connection, path string) *bookmarkService {
	var result bookmarkService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get a bookmark.
// An example for getting a bookmark:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks/123
// ----
// [source,xml]
// ----
// <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//   <name>example_vm</name>
//   <value>vm: name=example*</value>
// </bookmark>
// ----
//
type bookmarkServiceGetRequest struct {
	bookmarkService *bookmarkService
	header          map[string]string
	query           map[string]string
	follow          *string
}

func (p *bookmarkServiceGetRequest) Header(key, value string) *bookmarkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *bookmarkServiceGetRequest) Query(key, value string) *bookmarkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *bookmarkServiceGetRequest) Follow(follow string) *bookmarkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *bookmarkServiceGetRequest) Send() (*bookmarkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarkService.connection.URL(), p.bookmarkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.bookmarkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.bookmarkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBookmarkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &bookmarkServiceGetResponse{bookmark: result}, nil
}

func (p *bookmarkServiceGetRequest) MustSend() *bookmarkServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.bookmarkService.connection.URL(), p.bookmarkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.bookmarkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.bookmarkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBookmarkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &bookmarkServiceGetResponse{bookmark: result}
}

//
// Get a bookmark.
// An example for getting a bookmark:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks/123
// ----
// [source,xml]
// ----
// <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//   <name>example_vm</name>
//   <value>vm: name=example*</value>
// </bookmark>
// ----
//
type bookmarkServiceGetResponse struct {
	bookmark *Bookmark
}

func (p *bookmarkServiceGetResponse) Bookmark() (*Bookmark, bool) {
	if p.bookmark != nil {
		return p.bookmark, true
	}
	return nil, false
}

func (p *bookmarkServiceGetResponse) MustBookmark() *Bookmark {
	if p.bookmark == nil {
		panic("bookmark in response does not exist")
	}
	return p.bookmark
}

//
// Get a bookmark.
// An example for getting a bookmark:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks/123
// ----
// [source,xml]
// ----
// <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//   <name>example_vm</name>
//   <value>vm: name=example*</value>
// </bookmark>
// ----
//
func (p *bookmarkService) Get() *bookmarkServiceGetRequest {
	return &bookmarkServiceGetRequest{bookmarkService: p}
}

//
// Remove a bookmark.
// An example for removing a bookmark:
// [source]
// ----
// DELETE /ovirt-engine/api/bookmarks/123
// ----
//
type bookmarkServiceRemoveRequest struct {
	bookmarkService *bookmarkService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *bookmarkServiceRemoveRequest) Header(key, value string) *bookmarkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *bookmarkServiceRemoveRequest) Query(key, value string) *bookmarkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *bookmarkServiceRemoveRequest) Async(async bool) *bookmarkServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *bookmarkServiceRemoveRequest) Send() (*bookmarkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarkService.connection.URL(), p.bookmarkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.bookmarkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.bookmarkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(bookmarkServiceRemoveResponse), nil
}

func (p *bookmarkServiceRemoveRequest) MustSend() *bookmarkServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.bookmarkService.connection.URL(), p.bookmarkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.bookmarkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.bookmarkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(bookmarkServiceRemoveResponse)
}

//
// Remove a bookmark.
// An example for removing a bookmark:
// [source]
// ----
// DELETE /ovirt-engine/api/bookmarks/123
// ----
//
type bookmarkServiceRemoveResponse struct {
}

//
// Remove a bookmark.
// An example for removing a bookmark:
// [source]
// ----
// DELETE /ovirt-engine/api/bookmarks/123
// ----
//
func (p *bookmarkService) Remove() *bookmarkServiceRemoveRequest {
	return &bookmarkServiceRemoveRequest{bookmarkService: p}
}

//
// Update a bookmark.
// An example for updating a bookmark:
// [source]
// ----
// PUT /ovirt-engine/api/bookmarks/123
// ----
// With the request body:
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
//
type bookmarkServiceUpdateRequest struct {
	bookmarkService *bookmarkService
	header          map[string]string
	query           map[string]string
	async           *bool
	bookmark        *Bookmark
}

func (p *bookmarkServiceUpdateRequest) Header(key, value string) *bookmarkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *bookmarkServiceUpdateRequest) Query(key, value string) *bookmarkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *bookmarkServiceUpdateRequest) Async(async bool) *bookmarkServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *bookmarkServiceUpdateRequest) Bookmark(bookmark *Bookmark) *bookmarkServiceUpdateRequest {
	p.bookmark = bookmark
	return p
}

func (p *bookmarkServiceUpdateRequest) Send() (*bookmarkServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarkService.connection.URL(), p.bookmarkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLBookmarkWriteOne(writer, p.bookmark, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.bookmarkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.bookmarkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBookmarkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &bookmarkServiceUpdateResponse{bookmark: result}, nil
}

func (p *bookmarkServiceUpdateRequest) MustSend() *bookmarkServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.bookmarkService.connection.URL(), p.bookmarkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLBookmarkWriteOne(writer, p.bookmark, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.bookmarkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.bookmarkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBookmarkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &bookmarkServiceUpdateResponse{bookmark: result}
}

//
// Update a bookmark.
// An example for updating a bookmark:
// [source]
// ----
// PUT /ovirt-engine/api/bookmarks/123
// ----
// With the request body:
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
//
type bookmarkServiceUpdateResponse struct {
	bookmark *Bookmark
}

func (p *bookmarkServiceUpdateResponse) Bookmark() (*Bookmark, bool) {
	if p.bookmark != nil {
		return p.bookmark, true
	}
	return nil, false
}

func (p *bookmarkServiceUpdateResponse) MustBookmark() *Bookmark {
	if p.bookmark == nil {
		panic("bookmark in response does not exist")
	}
	return p.bookmark
}

//
// Update a bookmark.
// An example for updating a bookmark:
// [source]
// ----
// PUT /ovirt-engine/api/bookmarks/123
// ----
// With the request body:
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
//
func (p *bookmarkService) Update() *bookmarkServiceUpdateRequest {
	return &bookmarkServiceUpdateRequest{bookmarkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *bookmarkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *bookmarkService) String() string {
	return fmt.Sprintf("bookmarkService:%s", op.path)
}

//
//
type networkLabelService struct {
	baseService
}

func NewNetworkLabelService(connection *Connection, path string) *networkLabelService {
	var result networkLabelService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type networkLabelServiceGetRequest struct {
	networkLabelService *networkLabelService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *networkLabelServiceGetRequest) Header(key, value string) *networkLabelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkLabelServiceGetRequest) Query(key, value string) *networkLabelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkLabelServiceGetRequest) Follow(follow string) *networkLabelServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *networkLabelServiceGetRequest) Send() (*networkLabelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelService.connection.URL(), p.networkLabelService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &networkLabelServiceGetResponse{label: result}, nil
}

func (p *networkLabelServiceGetRequest) MustSend() *networkLabelServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelService.connection.URL(), p.networkLabelService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkLabelService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkLabelService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkLabelReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &networkLabelServiceGetResponse{label: result}
}

//
//
type networkLabelServiceGetResponse struct {
	label *NetworkLabel
}

func (p *networkLabelServiceGetResponse) Label() (*NetworkLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *networkLabelServiceGetResponse) MustLabel() *NetworkLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
//
func (p *networkLabelService) Get() *networkLabelServiceGetRequest {
	return &networkLabelServiceGetRequest{networkLabelService: p}
}

//
// Removes a label from a logical network.
// For example, to remove the label `exemplary` from a logical network having id `123` send the following request:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123/labels/exemplary
// ----
//
type networkLabelServiceRemoveRequest struct {
	networkLabelService *networkLabelService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *networkLabelServiceRemoveRequest) Header(key, value string) *networkLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkLabelServiceRemoveRequest) Query(key, value string) *networkLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkLabelServiceRemoveRequest) Async(async bool) *networkLabelServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *networkLabelServiceRemoveRequest) Send() (*networkLabelServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelService.connection.URL(), p.networkLabelService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(networkLabelServiceRemoveResponse), nil
}

func (p *networkLabelServiceRemoveRequest) MustSend() *networkLabelServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelService.connection.URL(), p.networkLabelService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkLabelService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkLabelService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(networkLabelServiceRemoveResponse)
}

//
// Removes a label from a logical network.
// For example, to remove the label `exemplary` from a logical network having id `123` send the following request:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123/labels/exemplary
// ----
//
type networkLabelServiceRemoveResponse struct {
}

//
// Removes a label from a logical network.
// For example, to remove the label `exemplary` from a logical network having id `123` send the following request:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123/labels/exemplary
// ----
//
func (p *networkLabelService) Remove() *networkLabelServiceRemoveRequest {
	return &networkLabelServiceRemoveRequest{networkLabelService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *networkLabelService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *networkLabelService) String() string {
	return fmt.Sprintf("networkLabelService:%s", op.path)
}

//
//
type storageServerConnectionService struct {
	baseService
}

func NewStorageServerConnectionService(connection *Connection, path string) *storageServerConnectionService {
	var result storageServerConnectionService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type storageServerConnectionServiceGetRequest struct {
	storageServerConnectionService *storageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
}

func (p *storageServerConnectionServiceGetRequest) Header(key, value string) *storageServerConnectionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionServiceGetRequest) Query(key, value string) *storageServerConnectionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionServiceGetRequest) Follow(follow string) *storageServerConnectionServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *storageServerConnectionServiceGetRequest) Send() (*storageServerConnectionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageServerConnectionServiceGetResponse{conection: result}, nil
}

func (p *storageServerConnectionServiceGetRequest) MustSend() *storageServerConnectionServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageServerConnectionServiceGetResponse{conection: result}
}

//
//
type storageServerConnectionServiceGetResponse struct {
	conection *StorageConnection
}

func (p *storageServerConnectionServiceGetResponse) Conection() (*StorageConnection, bool) {
	if p.conection != nil {
		return p.conection, true
	}
	return nil, false
}

func (p *storageServerConnectionServiceGetResponse) MustConection() *StorageConnection {
	if p.conection == nil {
		panic("conection in response does not exist")
	}
	return p.conection
}

//
//
func (p *storageServerConnectionService) Get() *storageServerConnectionServiceGetRequest {
	return &storageServerConnectionServiceGetRequest{storageServerConnectionService: p}
}

//
// Update the specified iSCSI storage connection in the system.
//
type storageServerConnectionServiceUpdateIscsiRequest struct {
	storageServerConnectionService *storageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *storageServerConnectionServiceUpdateIscsiRequest) Header(key, value string) *storageServerConnectionServiceUpdateIscsiRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionServiceUpdateIscsiRequest) Query(key, value string) *storageServerConnectionServiceUpdateIscsiRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionServiceUpdateIscsiRequest) Async(async bool) *storageServerConnectionServiceUpdateIscsiRequest {
	p.async = &async
	return p
}

func (p *storageServerConnectionServiceUpdateIscsiRequest) Connection(connection *StorageConnection) *storageServerConnectionServiceUpdateIscsiRequest {
	p.connection = connection
	return p
}

func (p *storageServerConnectionServiceUpdateIscsiRequest) Force(force bool) *storageServerConnectionServiceUpdateIscsiRequest {
	p.force = &force
	return p
}

func (p *storageServerConnectionServiceUpdateIscsiRequest) Send() (*storageServerConnectionServiceUpdateIscsiResponse, error) {
	rawURL := fmt.Sprintf("%s%s/iscsi", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &storageServerConnectionServiceUpdateIscsiResponse{connection: result}, nil
}

func (p *storageServerConnectionServiceUpdateIscsiRequest) MustSend() *storageServerConnectionServiceUpdateIscsiResponse {
	rawURL := fmt.Sprintf("%s%s/iscsi", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustConnection()
	return &storageServerConnectionServiceUpdateIscsiResponse{connection: result}
}

//
// Update the specified iSCSI storage connection in the system.
//
type storageServerConnectionServiceUpdateIscsiResponse struct {
	connection *StorageConnection
}

func (p *storageServerConnectionServiceUpdateIscsiResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *storageServerConnectionServiceUpdateIscsiResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Update the specified iSCSI storage connection in the system.
//
func (p *storageServerConnectionService) UpdateIscsi() *storageServerConnectionServiceUpdateIscsiRequest {
	return &storageServerConnectionServiceUpdateIscsiRequest{storageServerConnectionService: p}
}

//
// Update the specified local storage connection in the system.
//
type storageServerConnectionServiceUpdateLocalRequest struct {
	storageServerConnectionService *storageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *storageServerConnectionServiceUpdateLocalRequest) Header(key, value string) *storageServerConnectionServiceUpdateLocalRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionServiceUpdateLocalRequest) Query(key, value string) *storageServerConnectionServiceUpdateLocalRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionServiceUpdateLocalRequest) Async(async bool) *storageServerConnectionServiceUpdateLocalRequest {
	p.async = &async
	return p
}

func (p *storageServerConnectionServiceUpdateLocalRequest) Connection(connection *StorageConnection) *storageServerConnectionServiceUpdateLocalRequest {
	p.connection = connection
	return p
}

func (p *storageServerConnectionServiceUpdateLocalRequest) Force(force bool) *storageServerConnectionServiceUpdateLocalRequest {
	p.force = &force
	return p
}

func (p *storageServerConnectionServiceUpdateLocalRequest) Send() (*storageServerConnectionServiceUpdateLocalResponse, error) {
	rawURL := fmt.Sprintf("%s%s/local", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &storageServerConnectionServiceUpdateLocalResponse{connection: result}, nil
}

func (p *storageServerConnectionServiceUpdateLocalRequest) MustSend() *storageServerConnectionServiceUpdateLocalResponse {
	rawURL := fmt.Sprintf("%s%s/local", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustConnection()
	return &storageServerConnectionServiceUpdateLocalResponse{connection: result}
}

//
// Update the specified local storage connection in the system.
//
type storageServerConnectionServiceUpdateLocalResponse struct {
	connection *StorageConnection
}

func (p *storageServerConnectionServiceUpdateLocalResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *storageServerConnectionServiceUpdateLocalResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Update the specified local storage connection in the system.
//
func (p *storageServerConnectionService) UpdateLocal() *storageServerConnectionServiceUpdateLocalRequest {
	return &storageServerConnectionServiceUpdateLocalRequest{storageServerConnectionService: p}
}

//
// Update the specified nfs storage connection in the system.
//
type storageServerConnectionServiceUpdateNfsRequest struct {
	storageServerConnectionService *storageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *storageServerConnectionServiceUpdateNfsRequest) Header(key, value string) *storageServerConnectionServiceUpdateNfsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionServiceUpdateNfsRequest) Query(key, value string) *storageServerConnectionServiceUpdateNfsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionServiceUpdateNfsRequest) Async(async bool) *storageServerConnectionServiceUpdateNfsRequest {
	p.async = &async
	return p
}

func (p *storageServerConnectionServiceUpdateNfsRequest) Connection(connection *StorageConnection) *storageServerConnectionServiceUpdateNfsRequest {
	p.connection = connection
	return p
}

func (p *storageServerConnectionServiceUpdateNfsRequest) Force(force bool) *storageServerConnectionServiceUpdateNfsRequest {
	p.force = &force
	return p
}

func (p *storageServerConnectionServiceUpdateNfsRequest) Send() (*storageServerConnectionServiceUpdateNfsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/nfs", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &storageServerConnectionServiceUpdateNfsResponse{connection: result}, nil
}

func (p *storageServerConnectionServiceUpdateNfsRequest) MustSend() *storageServerConnectionServiceUpdateNfsResponse {
	rawURL := fmt.Sprintf("%s%s/nfs", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustConnection()
	return &storageServerConnectionServiceUpdateNfsResponse{connection: result}
}

//
// Update the specified nfs storage connection in the system.
//
type storageServerConnectionServiceUpdateNfsResponse struct {
	connection *StorageConnection
}

func (p *storageServerConnectionServiceUpdateNfsResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *storageServerConnectionServiceUpdateNfsResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Update the specified nfs storage connection in the system.
//
func (p *storageServerConnectionService) UpdateNfs() *storageServerConnectionServiceUpdateNfsRequest {
	return &storageServerConnectionServiceUpdateNfsRequest{storageServerConnectionService: p}
}

//
// Removes a storage connection.
// A storage connection can only be deleted if neither storage domain nor LUN disks reference it. The host name or
// id is optional; providing it disconnects (unmounts) the connection from that host.
//
type storageServerConnectionServiceRemoveRequest struct {
	storageServerConnectionService *storageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	host                           *string
}

func (p *storageServerConnectionServiceRemoveRequest) Header(key, value string) *storageServerConnectionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionServiceRemoveRequest) Query(key, value string) *storageServerConnectionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionServiceRemoveRequest) Async(async bool) *storageServerConnectionServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *storageServerConnectionServiceRemoveRequest) Host(host string) *storageServerConnectionServiceRemoveRequest {
	p.host = &host
	return p
}

func (p *storageServerConnectionServiceRemoveRequest) Send() (*storageServerConnectionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.host != nil {
		values["host"] = []string{fmt.Sprintf("%v", *p.host)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(storageServerConnectionServiceRemoveResponse), nil
}

func (p *storageServerConnectionServiceRemoveRequest) MustSend() *storageServerConnectionServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.host != nil {
		values["host"] = []string{fmt.Sprintf("%v", *p.host)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(storageServerConnectionServiceRemoveResponse)
}

//
// Removes a storage connection.
// A storage connection can only be deleted if neither storage domain nor LUN disks reference it. The host name or
// id is optional; providing it disconnects (unmounts) the connection from that host.
//
type storageServerConnectionServiceRemoveResponse struct {
}

//
// Removes a storage connection.
// A storage connection can only be deleted if neither storage domain nor LUN disks reference it. The host name or
// id is optional; providing it disconnects (unmounts) the connection from that host.
//
func (p *storageServerConnectionService) Remove() *storageServerConnectionServiceRemoveRequest {
	return &storageServerConnectionServiceRemoveRequest{storageServerConnectionService: p}
}

//
// Updates the storage connection.
// For example, to change the address of the storage server send a request like this:
// [source,xml]
// ----
// PUT /ovirt-engine/api/storageconnections/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <address>mynewnfs.example.com</address>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_connection>
// ----
//
type storageServerConnectionServiceUpdateRequest struct {
	storageServerConnectionService *storageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *storageServerConnectionServiceUpdateRequest) Header(key, value string) *storageServerConnectionServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionServiceUpdateRequest) Query(key, value string) *storageServerConnectionServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionServiceUpdateRequest) Async(async bool) *storageServerConnectionServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *storageServerConnectionServiceUpdateRequest) Connection(connection *StorageConnection) *storageServerConnectionServiceUpdateRequest {
	p.connection = connection
	return p
}

func (p *storageServerConnectionServiceUpdateRequest) Force(force bool) *storageServerConnectionServiceUpdateRequest {
	p.force = &force
	return p
}

func (p *storageServerConnectionServiceUpdateRequest) Send() (*storageServerConnectionServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionWriteOne(writer, p.connection, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageServerConnectionServiceUpdateResponse{connection: result}, nil
}

func (p *storageServerConnectionServiceUpdateRequest) MustSend() *storageServerConnectionServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionWriteOne(writer, p.connection, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageServerConnectionServiceUpdateResponse{connection: result}
}

//
// Updates the storage connection.
// For example, to change the address of the storage server send a request like this:
// [source,xml]
// ----
// PUT /ovirt-engine/api/storageconnections/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <address>mynewnfs.example.com</address>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_connection>
// ----
//
type storageServerConnectionServiceUpdateResponse struct {
	connection *StorageConnection
}

func (p *storageServerConnectionServiceUpdateResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *storageServerConnectionServiceUpdateResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Updates the storage connection.
// For example, to change the address of the storage server send a request like this:
// [source,xml]
// ----
// PUT /ovirt-engine/api/storageconnections/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <address>mynewnfs.example.com</address>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_connection>
// ----
//
func (p *storageServerConnectionService) Update() *storageServerConnectionServiceUpdateRequest {
	return &storageServerConnectionServiceUpdateRequest{storageServerConnectionService: p}
}

//
// Update the specified vfs storage connection in the system.
//
type storageServerConnectionServiceUpdateVfsRequest struct {
	storageServerConnectionService *storageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *storageServerConnectionServiceUpdateVfsRequest) Header(key, value string) *storageServerConnectionServiceUpdateVfsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionServiceUpdateVfsRequest) Query(key, value string) *storageServerConnectionServiceUpdateVfsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionServiceUpdateVfsRequest) Async(async bool) *storageServerConnectionServiceUpdateVfsRequest {
	p.async = &async
	return p
}

func (p *storageServerConnectionServiceUpdateVfsRequest) Connection(connection *StorageConnection) *storageServerConnectionServiceUpdateVfsRequest {
	p.connection = connection
	return p
}

func (p *storageServerConnectionServiceUpdateVfsRequest) Force(force bool) *storageServerConnectionServiceUpdateVfsRequest {
	p.force = &force
	return p
}

func (p *storageServerConnectionServiceUpdateVfsRequest) Send() (*storageServerConnectionServiceUpdateVfsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/vfs", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &storageServerConnectionServiceUpdateVfsResponse{connection: result}, nil
}

func (p *storageServerConnectionServiceUpdateVfsRequest) MustSend() *storageServerConnectionServiceUpdateVfsResponse {
	rawURL := fmt.Sprintf("%s%s/vfs", p.storageServerConnectionService.connection.URL(), p.storageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustConnection()
	return &storageServerConnectionServiceUpdateVfsResponse{connection: result}
}

//
// Update the specified vfs storage connection in the system.
//
type storageServerConnectionServiceUpdateVfsResponse struct {
	connection *StorageConnection
}

func (p *storageServerConnectionServiceUpdateVfsResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *storageServerConnectionServiceUpdateVfsResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Update the specified vfs storage connection in the system.
//
func (p *storageServerConnectionService) UpdateVfs() *storageServerConnectionServiceUpdateVfsRequest {
	return &storageServerConnectionServiceUpdateVfsRequest{storageServerConnectionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageServerConnectionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *storageServerConnectionService) String() string {
	return fmt.Sprintf("storageServerConnectionService:%s", op.path)
}

//
// A service to manage cluster networks.
//
type clusterNetworksService struct {
	baseService
}

func NewClusterNetworksService(connection *Connection, path string) *clusterNetworksService {
	var result clusterNetworksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Assigns the network to a cluster.
// Post a request like in the example below to assign the network to a cluster:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/networks
// ----
// Use the following example in its body:
// [source,xml]
// ----
// <network id="123" />
// ----
//
type clusterNetworksServiceAddRequest struct {
	clusterNetworksService *clusterNetworksService
	header                 map[string]string
	query                  map[string]string
	network                *Network
}

func (p *clusterNetworksServiceAddRequest) Header(key, value string) *clusterNetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterNetworksServiceAddRequest) Query(key, value string) *clusterNetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterNetworksServiceAddRequest) Network(network *Network) *clusterNetworksServiceAddRequest {
	p.network = network
	return p
}

func (p *clusterNetworksServiceAddRequest) Send() (*clusterNetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterNetworksService.connection.URL(), p.clusterNetworksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &clusterNetworksServiceAddResponse{network: result}, nil
}

func (p *clusterNetworksServiceAddRequest) MustSend() *clusterNetworksServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterNetworksService.connection.URL(), p.clusterNetworksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterNetworksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterNetworksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &clusterNetworksServiceAddResponse{network: result}
}

//
// Assigns the network to a cluster.
// Post a request like in the example below to assign the network to a cluster:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/networks
// ----
// Use the following example in its body:
// [source,xml]
// ----
// <network id="123" />
// ----
//
type clusterNetworksServiceAddResponse struct {
	network *Network
}

func (p *clusterNetworksServiceAddResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *clusterNetworksServiceAddResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Assigns the network to a cluster.
// Post a request like in the example below to assign the network to a cluster:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/networks
// ----
// Use the following example in its body:
// [source,xml]
// ----
// <network id="123" />
// ----
//
func (p *clusterNetworksService) Add() *clusterNetworksServiceAddRequest {
	return &clusterNetworksServiceAddRequest{clusterNetworksService: p}
}

//
// Lists the networks that are assigned to the cluster.
// The order of the returned clusters isn't guaranteed.
//
type clusterNetworksServiceListRequest struct {
	clusterNetworksService *clusterNetworksService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
	max                    *int64
}

func (p *clusterNetworksServiceListRequest) Header(key, value string) *clusterNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterNetworksServiceListRequest) Query(key, value string) *clusterNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterNetworksServiceListRequest) Follow(follow string) *clusterNetworksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *clusterNetworksServiceListRequest) Max(max int64) *clusterNetworksServiceListRequest {
	p.max = &max
	return p
}

func (p *clusterNetworksServiceListRequest) Send() (*clusterNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterNetworksService.connection.URL(), p.clusterNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &clusterNetworksServiceListResponse{networks: result}, nil
}

func (p *clusterNetworksServiceListRequest) MustSend() *clusterNetworksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterNetworksService.connection.URL(), p.clusterNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterNetworksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterNetworksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &clusterNetworksServiceListResponse{networks: result}
}

//
// Lists the networks that are assigned to the cluster.
// The order of the returned clusters isn't guaranteed.
//
type clusterNetworksServiceListResponse struct {
	networks *NetworkSlice
}

func (p *clusterNetworksServiceListResponse) Networks() (*NetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *clusterNetworksServiceListResponse) MustNetworks() *NetworkSlice {
	if p.networks == nil {
		panic("networks in response does not exist")
	}
	return p.networks
}

//
// Lists the networks that are assigned to the cluster.
// The order of the returned clusters isn't guaranteed.
//
func (p *clusterNetworksService) List() *clusterNetworksServiceListRequest {
	return &clusterNetworksServiceListRequest{clusterNetworksService: p}
}

//
// Access the cluster network service that manages the cluster network specified by an ID.
//
func (op *clusterNetworksService) NetworkService(id string) *clusterNetworkService {
	return NewClusterNetworkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *clusterNetworksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NetworkService(path), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *clusterNetworksService) String() string {
	return fmt.Sprintf("clusterNetworksService:%s", op.path)
}

//
// This service lists external providers.
//
type clusterExternalProvidersService struct {
	baseService
}

func NewClusterExternalProvidersService(connection *Connection, path string) *clusterExternalProvidersService {
	var result clusterExternalProvidersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of external providers.
// The order of the returned list of providers is not guaranteed.
//
type clusterExternalProvidersServiceListRequest struct {
	clusterExternalProvidersService *clusterExternalProvidersService
	header                          map[string]string
	query                           map[string]string
	follow                          *string
}

func (p *clusterExternalProvidersServiceListRequest) Header(key, value string) *clusterExternalProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterExternalProvidersServiceListRequest) Query(key, value string) *clusterExternalProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterExternalProvidersServiceListRequest) Follow(follow string) *clusterExternalProvidersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *clusterExternalProvidersServiceListRequest) Send() (*clusterExternalProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterExternalProvidersService.connection.URL(), p.clusterExternalProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterExternalProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterExternalProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalProviderReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &clusterExternalProvidersServiceListResponse{providers: result}, nil
}

func (p *clusterExternalProvidersServiceListRequest) MustSend() *clusterExternalProvidersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterExternalProvidersService.connection.URL(), p.clusterExternalProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterExternalProvidersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterExternalProvidersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalProviderReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &clusterExternalProvidersServiceListResponse{providers: result}
}

//
// Returns the list of external providers.
// The order of the returned list of providers is not guaranteed.
//
type clusterExternalProvidersServiceListResponse struct {
	providers *ExternalProviderSlice
}

func (p *clusterExternalProvidersServiceListResponse) Providers() (*ExternalProviderSlice, bool) {
	if p.providers != nil {
		return p.providers, true
	}
	return nil, false
}

func (p *clusterExternalProvidersServiceListResponse) MustProviders() *ExternalProviderSlice {
	if p.providers == nil {
		panic("providers in response does not exist")
	}
	return p.providers
}

//
// Returns the list of external providers.
// The order of the returned list of providers is not guaranteed.
//
func (p *clusterExternalProvidersService) List() *clusterExternalProvidersServiceListRequest {
	return &clusterExternalProvidersServiceListRequest{clusterExternalProvidersService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *clusterExternalProvidersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *clusterExternalProvidersService) String() string {
	return fmt.Sprintf("clusterExternalProvidersService:%s", op.path)
}

//
// Manages the set of CD-ROM devices of a virtual machine snapshot.
//
type snapshotCdromsService struct {
	baseService
}

func NewSnapshotCdromsService(connection *Connection, path string) *snapshotCdromsService {
	var result snapshotCdromsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of CD-ROM devices of the snapshot.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
type snapshotCdromsServiceListRequest struct {
	snapshotCdromsService *snapshotCdromsService
	header                map[string]string
	query                 map[string]string
	follow                *string
	max                   *int64
}

func (p *snapshotCdromsServiceListRequest) Header(key, value string) *snapshotCdromsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *snapshotCdromsServiceListRequest) Query(key, value string) *snapshotCdromsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *snapshotCdromsServiceListRequest) Follow(follow string) *snapshotCdromsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *snapshotCdromsServiceListRequest) Max(max int64) *snapshotCdromsServiceListRequest {
	p.max = &max
	return p
}

func (p *snapshotCdromsServiceListRequest) Send() (*snapshotCdromsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotCdromsService.connection.URL(), p.snapshotCdromsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotCdromsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotCdromsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &snapshotCdromsServiceListResponse{cdroms: result}, nil
}

func (p *snapshotCdromsServiceListRequest) MustSend() *snapshotCdromsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.snapshotCdromsService.connection.URL(), p.snapshotCdromsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotCdromsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotCdromsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &snapshotCdromsServiceListResponse{cdroms: result}
}

//
// Returns the list of CD-ROM devices of the snapshot.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
type snapshotCdromsServiceListResponse struct {
	cdroms *CdromSlice
}

func (p *snapshotCdromsServiceListResponse) Cdroms() (*CdromSlice, bool) {
	if p.cdroms != nil {
		return p.cdroms, true
	}
	return nil, false
}

func (p *snapshotCdromsServiceListResponse) MustCdroms() *CdromSlice {
	if p.cdroms == nil {
		panic("cdroms in response does not exist")
	}
	return p.cdroms
}

//
// Returns the list of CD-ROM devices of the snapshot.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
func (p *snapshotCdromsService) List() *snapshotCdromsServiceListRequest {
	return &snapshotCdromsServiceListRequest{snapshotCdromsService: p}
}

//
//
func (op *snapshotCdromsService) CdromService(id string) *snapshotCdromService {
	return NewSnapshotCdromService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *snapshotCdromsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.CdromService(path), nil
	}
	return op.CdromService(path[:index]).Service(path[index+1:])
}

func (op *snapshotCdromsService) String() string {
	return fmt.Sprintf("snapshotCdromsService:%s", op.path)
}

//
// A service to view specific certificate for external provider.
//
type externalProviderCertificateService struct {
	baseService
}

func NewExternalProviderCertificateService(connection *Connection, path string) *externalProviderCertificateService {
	var result externalProviderCertificateService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get specific certificate.
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/certificate/0
// ----
// And here is sample response:
// [source,xml]
// ----
// <certificate id="0">
//   <organization>provider.example.com</organization>
//   <subject>CN=provider.example.com</subject>
//   <content>...</content>
// </certificate>
// ----
//
type externalProviderCertificateServiceGetRequest struct {
	externalProviderCertificateService *externalProviderCertificateService
	header                             map[string]string
	query                              map[string]string
	follow                             *string
}

func (p *externalProviderCertificateServiceGetRequest) Header(key, value string) *externalProviderCertificateServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalProviderCertificateServiceGetRequest) Query(key, value string) *externalProviderCertificateServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalProviderCertificateServiceGetRequest) Follow(follow string) *externalProviderCertificateServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *externalProviderCertificateServiceGetRequest) Send() (*externalProviderCertificateServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalProviderCertificateService.connection.URL(), p.externalProviderCertificateService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalProviderCertificateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalProviderCertificateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCertificateReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &externalProviderCertificateServiceGetResponse{certificate: result}, nil
}

func (p *externalProviderCertificateServiceGetRequest) MustSend() *externalProviderCertificateServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalProviderCertificateService.connection.URL(), p.externalProviderCertificateService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalProviderCertificateService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalProviderCertificateService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCertificateReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &externalProviderCertificateServiceGetResponse{certificate: result}
}

//
// Get specific certificate.
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/certificate/0
// ----
// And here is sample response:
// [source,xml]
// ----
// <certificate id="0">
//   <organization>provider.example.com</organization>
//   <subject>CN=provider.example.com</subject>
//   <content>...</content>
// </certificate>
// ----
//
type externalProviderCertificateServiceGetResponse struct {
	certificate *Certificate
}

func (p *externalProviderCertificateServiceGetResponse) Certificate() (*Certificate, bool) {
	if p.certificate != nil {
		return p.certificate, true
	}
	return nil, false
}

func (p *externalProviderCertificateServiceGetResponse) MustCertificate() *Certificate {
	if p.certificate == nil {
		panic("certificate in response does not exist")
	}
	return p.certificate
}

//
// Get specific certificate.
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/certificate/0
// ----
// And here is sample response:
// [source,xml]
// ----
// <certificate id="0">
//   <organization>provider.example.com</organization>
//   <subject>CN=provider.example.com</subject>
//   <content>...</content>
// </certificate>
// ----
//
func (p *externalProviderCertificateService) Get() *externalProviderCertificateServiceGetRequest {
	return &externalProviderCertificateServiceGetRequest{externalProviderCertificateService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalProviderCertificateService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *externalProviderCertificateService) String() string {
	return fmt.Sprintf("externalProviderCertificateService:%s", op.path)
}

//
// Manages the set of snapshots of a storage domain or virtual machine.
//
type snapshotsService struct {
	baseService
}

func NewSnapshotsService(connection *Connection, path string) *snapshotsService {
	var result snapshotsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a virtual machine snapshot.
// For example, to create a new snapshot for virtual machine `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots
// ----
// With a request body like this:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
// </snapshot>
// ----
// For including only a sub-set of disks in the snapshots, add `disk_attachments` element to the
// request body. Note that disks which are not specified in `disk_attachments` element will not be a
// part of the snapshot. If an empty `disk_attachments` element is passed, the snapshot will include
// only the virtual machine configuration. If no `disk_attachments` element is passed, then all
// the disks will be included in the snapshot.
// For each disk, `image_id` element can be specified for setting the new active image id.
// This is used in order to restore a chain of images from backup. I.e. when restoring
// a disk with snapshots, the relevant `image_id` should be specified for each snapshot
// (so the identifiers of the disk snapshots are identical to the backup).
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="123">
//         <image_id>456</image_id>
//       </disk>
//     </disk_attachment>
//   </disk_attachments>
// </snapshot>
// ----
// [IMPORTANT]
// ====
// When a snapshot is created the default value for the <<types/snapshot/attributes/persist_memorystate,
// persist_memorystate>> attribute is `true`. That means that the content of the memory of the virtual
// machine will be included in the snapshot, and it also means that the virtual machine will be paused
// for a longer time. That can negatively affect applications that are very sensitive to timing (NTP
// servers, for example). In those cases make sure that you set the attribute to `false`:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
// ====
//
type snapshotsServiceAddRequest struct {
	snapshotsService *snapshotsService
	header           map[string]string
	query            map[string]string
	snapshot         *Snapshot
}

func (p *snapshotsServiceAddRequest) Header(key, value string) *snapshotsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *snapshotsServiceAddRequest) Query(key, value string) *snapshotsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *snapshotsServiceAddRequest) Snapshot(snapshot *Snapshot) *snapshotsServiceAddRequest {
	p.snapshot = snapshot
	return p
}

func (p *snapshotsServiceAddRequest) Send() (*snapshotsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotsService.connection.URL(), p.snapshotsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSnapshotWriteOne(writer, p.snapshot, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSnapshotReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &snapshotsServiceAddResponse{snapshot: result}, nil
}

func (p *snapshotsServiceAddRequest) MustSend() *snapshotsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.snapshotsService.connection.URL(), p.snapshotsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSnapshotWriteOne(writer, p.snapshot, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSnapshotReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &snapshotsServiceAddResponse{snapshot: result}
}

//
// Creates a virtual machine snapshot.
// For example, to create a new snapshot for virtual machine `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots
// ----
// With a request body like this:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
// </snapshot>
// ----
// For including only a sub-set of disks in the snapshots, add `disk_attachments` element to the
// request body. Note that disks which are not specified in `disk_attachments` element will not be a
// part of the snapshot. If an empty `disk_attachments` element is passed, the snapshot will include
// only the virtual machine configuration. If no `disk_attachments` element is passed, then all
// the disks will be included in the snapshot.
// For each disk, `image_id` element can be specified for setting the new active image id.
// This is used in order to restore a chain of images from backup. I.e. when restoring
// a disk with snapshots, the relevant `image_id` should be specified for each snapshot
// (so the identifiers of the disk snapshots are identical to the backup).
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="123">
//         <image_id>456</image_id>
//       </disk>
//     </disk_attachment>
//   </disk_attachments>
// </snapshot>
// ----
// [IMPORTANT]
// ====
// When a snapshot is created the default value for the <<types/snapshot/attributes/persist_memorystate,
// persist_memorystate>> attribute is `true`. That means that the content of the memory of the virtual
// machine will be included in the snapshot, and it also means that the virtual machine will be paused
// for a longer time. That can negatively affect applications that are very sensitive to timing (NTP
// servers, for example). In those cases make sure that you set the attribute to `false`:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
// ====
//
type snapshotsServiceAddResponse struct {
	snapshot *Snapshot
}

func (p *snapshotsServiceAddResponse) Snapshot() (*Snapshot, bool) {
	if p.snapshot != nil {
		return p.snapshot, true
	}
	return nil, false
}

func (p *snapshotsServiceAddResponse) MustSnapshot() *Snapshot {
	if p.snapshot == nil {
		panic("snapshot in response does not exist")
	}
	return p.snapshot
}

//
// Creates a virtual machine snapshot.
// For example, to create a new snapshot for virtual machine `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots
// ----
// With a request body like this:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
// </snapshot>
// ----
// For including only a sub-set of disks in the snapshots, add `disk_attachments` element to the
// request body. Note that disks which are not specified in `disk_attachments` element will not be a
// part of the snapshot. If an empty `disk_attachments` element is passed, the snapshot will include
// only the virtual machine configuration. If no `disk_attachments` element is passed, then all
// the disks will be included in the snapshot.
// For each disk, `image_id` element can be specified for setting the new active image id.
// This is used in order to restore a chain of images from backup. I.e. when restoring
// a disk with snapshots, the relevant `image_id` should be specified for each snapshot
// (so the identifiers of the disk snapshots are identical to the backup).
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="123">
//         <image_id>456</image_id>
//       </disk>
//     </disk_attachment>
//   </disk_attachments>
// </snapshot>
// ----
// [IMPORTANT]
// ====
// When a snapshot is created the default value for the <<types/snapshot/attributes/persist_memorystate,
// persist_memorystate>> attribute is `true`. That means that the content of the memory of the virtual
// machine will be included in the snapshot, and it also means that the virtual machine will be paused
// for a longer time. That can negatively affect applications that are very sensitive to timing (NTP
// servers, for example). In those cases make sure that you set the attribute to `false`:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
// ====
//
func (p *snapshotsService) Add() *snapshotsServiceAddRequest {
	return &snapshotsServiceAddRequest{snapshotsService: p}
}

//
// Returns the list of snapshots of the storage domain or virtual machine.
// The order of the returned list of snapshots isn't guaranteed.
//
type snapshotsServiceListRequest struct {
	snapshotsService *snapshotsService
	header           map[string]string
	query            map[string]string
	allContent       *bool
	follow           *string
	max              *int64
}

func (p *snapshotsServiceListRequest) Header(key, value string) *snapshotsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *snapshotsServiceListRequest) Query(key, value string) *snapshotsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *snapshotsServiceListRequest) AllContent(allContent bool) *snapshotsServiceListRequest {
	p.allContent = &allContent
	return p
}

func (p *snapshotsServiceListRequest) Follow(follow string) *snapshotsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *snapshotsServiceListRequest) Max(max int64) *snapshotsServiceListRequest {
	p.max = &max
	return p
}

func (p *snapshotsServiceListRequest) Send() (*snapshotsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotsService.connection.URL(), p.snapshotsService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSnapshotReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &snapshotsServiceListResponse{snapshots: result}, nil
}

func (p *snapshotsServiceListRequest) MustSend() *snapshotsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.snapshotsService.connection.URL(), p.snapshotsService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSnapshotReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &snapshotsServiceListResponse{snapshots: result}
}

//
// Returns the list of snapshots of the storage domain or virtual machine.
// The order of the returned list of snapshots isn't guaranteed.
//
type snapshotsServiceListResponse struct {
	snapshots *SnapshotSlice
}

func (p *snapshotsServiceListResponse) Snapshots() (*SnapshotSlice, bool) {
	if p.snapshots != nil {
		return p.snapshots, true
	}
	return nil, false
}

func (p *snapshotsServiceListResponse) MustSnapshots() *SnapshotSlice {
	if p.snapshots == nil {
		panic("snapshots in response does not exist")
	}
	return p.snapshots
}

//
// Returns the list of snapshots of the storage domain or virtual machine.
// The order of the returned list of snapshots isn't guaranteed.
//
func (p *snapshotsService) List() *snapshotsServiceListRequest {
	return &snapshotsServiceListRequest{snapshotsService: p}
}

//
//
func (op *snapshotsService) SnapshotService(id string) *snapshotService {
	return NewSnapshotService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *snapshotsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.SnapshotService(path), nil
	}
	return op.SnapshotService(path[:index]).Service(path[index+1:])
}

func (op *snapshotsService) String() string {
	return fmt.Sprintf("snapshotsService:%s", op.path)
}

//
//
type hostNumaNodeService struct {
	baseService
}

func NewHostNumaNodeService(connection *Connection, path string) *hostNumaNodeService {
	var result hostNumaNodeService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type hostNumaNodeServiceGetRequest struct {
	hostNumaNodeService *hostNumaNodeService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *hostNumaNodeServiceGetRequest) Header(key, value string) *hostNumaNodeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostNumaNodeServiceGetRequest) Query(key, value string) *hostNumaNodeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostNumaNodeServiceGetRequest) Follow(follow string) *hostNumaNodeServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *hostNumaNodeServiceGetRequest) Send() (*hostNumaNodeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostNumaNodeService.connection.URL(), p.hostNumaNodeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostNumaNodeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostNumaNodeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNumaNodeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &hostNumaNodeServiceGetResponse{node: result}, nil
}

func (p *hostNumaNodeServiceGetRequest) MustSend() *hostNumaNodeServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostNumaNodeService.connection.URL(), p.hostNumaNodeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostNumaNodeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostNumaNodeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNumaNodeReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &hostNumaNodeServiceGetResponse{node: result}
}

//
//
type hostNumaNodeServiceGetResponse struct {
	node *NumaNode
}

func (p *hostNumaNodeServiceGetResponse) Node() (*NumaNode, bool) {
	if p.node != nil {
		return p.node, true
	}
	return nil, false
}

func (p *hostNumaNodeServiceGetResponse) MustNode() *NumaNode {
	if p.node == nil {
		panic("node in response does not exist")
	}
	return p.node
}

//
//
func (p *hostNumaNodeService) Get() *hostNumaNodeServiceGetRequest {
	return &hostNumaNodeServiceGetRequest{hostNumaNodeService: p}
}

//
//
func (op *hostNumaNodeService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *hostNumaNodeService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *hostNumaNodeService) String() string {
	return fmt.Sprintf("hostNumaNodeService:%s", op.path)
}

//
//
type templateGraphicsConsoleService struct {
	baseService
}

func NewTemplateGraphicsConsoleService(connection *Connection, path string) *templateGraphicsConsoleService {
	var result templateGraphicsConsoleService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets graphics console configuration of the template.
//
type templateGraphicsConsoleServiceGetRequest struct {
	templateGraphicsConsoleService *templateGraphicsConsoleService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
}

func (p *templateGraphicsConsoleServiceGetRequest) Header(key, value string) *templateGraphicsConsoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateGraphicsConsoleServiceGetRequest) Query(key, value string) *templateGraphicsConsoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateGraphicsConsoleServiceGetRequest) Follow(follow string) *templateGraphicsConsoleServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *templateGraphicsConsoleServiceGetRequest) Send() (*templateGraphicsConsoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsoleService.connection.URL(), p.templateGraphicsConsoleService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateGraphicsConsoleServiceGetResponse{console: result}, nil
}

func (p *templateGraphicsConsoleServiceGetRequest) MustSend() *templateGraphicsConsoleServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsoleService.connection.URL(), p.templateGraphicsConsoleService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateGraphicsConsoleService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateGraphicsConsoleServiceGetResponse{console: result}
}

//
// Gets graphics console configuration of the template.
//
type templateGraphicsConsoleServiceGetResponse struct {
	console *GraphicsConsole
}

func (p *templateGraphicsConsoleServiceGetResponse) Console() (*GraphicsConsole, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

func (p *templateGraphicsConsoleServiceGetResponse) MustConsole() *GraphicsConsole {
	if p.console == nil {
		panic("console in response does not exist")
	}
	return p.console
}

//
// Gets graphics console configuration of the template.
//
func (p *templateGraphicsConsoleService) Get() *templateGraphicsConsoleServiceGetRequest {
	return &templateGraphicsConsoleServiceGetRequest{templateGraphicsConsoleService: p}
}

//
// Remove the graphics console from the template.
//
type templateGraphicsConsoleServiceRemoveRequest struct {
	templateGraphicsConsoleService *templateGraphicsConsoleService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
}

func (p *templateGraphicsConsoleServiceRemoveRequest) Header(key, value string) *templateGraphicsConsoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateGraphicsConsoleServiceRemoveRequest) Query(key, value string) *templateGraphicsConsoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateGraphicsConsoleServiceRemoveRequest) Async(async bool) *templateGraphicsConsoleServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *templateGraphicsConsoleServiceRemoveRequest) Send() (*templateGraphicsConsoleServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsoleService.connection.URL(), p.templateGraphicsConsoleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(templateGraphicsConsoleServiceRemoveResponse), nil
}

func (p *templateGraphicsConsoleServiceRemoveRequest) MustSend() *templateGraphicsConsoleServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsoleService.connection.URL(), p.templateGraphicsConsoleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateGraphicsConsoleService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(templateGraphicsConsoleServiceRemoveResponse)
}

//
// Remove the graphics console from the template.
//
type templateGraphicsConsoleServiceRemoveResponse struct {
}

//
// Remove the graphics console from the template.
//
func (p *templateGraphicsConsoleService) Remove() *templateGraphicsConsoleServiceRemoveRequest {
	return &templateGraphicsConsoleServiceRemoveRequest{templateGraphicsConsoleService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateGraphicsConsoleService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *templateGraphicsConsoleService) String() string {
	return fmt.Sprintf("templateGraphicsConsoleService:%s", op.path)
}

//
//
type vmGraphicsConsoleService struct {
	baseService
}

func NewVmGraphicsConsoleService(connection *Connection, path string) *vmGraphicsConsoleService {
	var result vmGraphicsConsoleService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the graphics console configuration of the virtual machine.
// IMPORTANT: By default, when the `current` parameter is not specified, the data returned
// corresponds to the next execution of the virtual machine. In the current implementation of
// the system this means that the `address` and `port` attributes will not be populated because
// the system does not know what address and port will be used for the next execution. Since in most
// cases those attributes are needed, it is strongly advised to aways explicitly include the
// `current` parameter with the value `true`.
//
type vmGraphicsConsoleServiceGetRequest struct {
	vmGraphicsConsoleService *vmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	current                  *bool
	follow                   *string
}

func (p *vmGraphicsConsoleServiceGetRequest) Header(key, value string) *vmGraphicsConsoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmGraphicsConsoleServiceGetRequest) Query(key, value string) *vmGraphicsConsoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmGraphicsConsoleServiceGetRequest) Current(current bool) *vmGraphicsConsoleServiceGetRequest {
	p.current = &current
	return p
}

func (p *vmGraphicsConsoleServiceGetRequest) Follow(follow string) *vmGraphicsConsoleServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vmGraphicsConsoleServiceGetRequest) Send() (*vmGraphicsConsoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsoleService.connection.URL(), p.vmGraphicsConsoleService.path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmGraphicsConsoleServiceGetResponse{console: result}, nil
}

func (p *vmGraphicsConsoleServiceGetRequest) MustSend() *vmGraphicsConsoleServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsoleService.connection.URL(), p.vmGraphicsConsoleService.path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmGraphicsConsoleServiceGetResponse{console: result}
}

//
// Retrieves the graphics console configuration of the virtual machine.
// IMPORTANT: By default, when the `current` parameter is not specified, the data returned
// corresponds to the next execution of the virtual machine. In the current implementation of
// the system this means that the `address` and `port` attributes will not be populated because
// the system does not know what address and port will be used for the next execution. Since in most
// cases those attributes are needed, it is strongly advised to aways explicitly include the
// `current` parameter with the value `true`.
//
type vmGraphicsConsoleServiceGetResponse struct {
	console *GraphicsConsole
}

func (p *vmGraphicsConsoleServiceGetResponse) Console() (*GraphicsConsole, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

func (p *vmGraphicsConsoleServiceGetResponse) MustConsole() *GraphicsConsole {
	if p.console == nil {
		panic("console in response does not exist")
	}
	return p.console
}

//
// Retrieves the graphics console configuration of the virtual machine.
// IMPORTANT: By default, when the `current` parameter is not specified, the data returned
// corresponds to the next execution of the virtual machine. In the current implementation of
// the system this means that the `address` and `port` attributes will not be populated because
// the system does not know what address and port will be used for the next execution. Since in most
// cases those attributes are needed, it is strongly advised to aways explicitly include the
// `current` parameter with the value `true`.
//
func (p *vmGraphicsConsoleService) Get() *vmGraphicsConsoleServiceGetRequest {
	return &vmGraphicsConsoleServiceGetRequest{vmGraphicsConsoleService: p}
}

//
//
type vmGraphicsConsoleServiceProxyTicketRequest struct {
	vmGraphicsConsoleService *vmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *vmGraphicsConsoleServiceProxyTicketRequest) Header(key, value string) *vmGraphicsConsoleServiceProxyTicketRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmGraphicsConsoleServiceProxyTicketRequest) Query(key, value string) *vmGraphicsConsoleServiceProxyTicketRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmGraphicsConsoleServiceProxyTicketRequest) Async(async bool) *vmGraphicsConsoleServiceProxyTicketRequest {
	p.async = &async
	return p
}

func (p *vmGraphicsConsoleServiceProxyTicketRequest) Send() (*vmGraphicsConsoleServiceProxyTicketResponse, error) {
	rawURL := fmt.Sprintf("%s%s/proxyticket", p.vmGraphicsConsoleService.connection.URL(), p.vmGraphicsConsoleService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustProxyTicket()
	return &vmGraphicsConsoleServiceProxyTicketResponse{proxyTicket: result}, nil
}

func (p *vmGraphicsConsoleServiceProxyTicketRequest) MustSend() *vmGraphicsConsoleServiceProxyTicketResponse {
	rawURL := fmt.Sprintf("%s%s/proxyticket", p.vmGraphicsConsoleService.connection.URL(), p.vmGraphicsConsoleService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustProxyTicket()
	return &vmGraphicsConsoleServiceProxyTicketResponse{proxyTicket: result}
}

//
//
type vmGraphicsConsoleServiceProxyTicketResponse struct {
	proxyTicket *ProxyTicket
}

func (p *vmGraphicsConsoleServiceProxyTicketResponse) ProxyTicket() (*ProxyTicket, bool) {
	if p.proxyTicket != nil {
		return p.proxyTicket, true
	}
	return nil, false
}

func (p *vmGraphicsConsoleServiceProxyTicketResponse) MustProxyTicket() *ProxyTicket {
	if p.proxyTicket == nil {
		panic("proxyTicket in response does not exist")
	}
	return p.proxyTicket
}

//
//
func (p *vmGraphicsConsoleService) ProxyTicket() *vmGraphicsConsoleServiceProxyTicketRequest {
	return &vmGraphicsConsoleServiceProxyTicketRequest{vmGraphicsConsoleService: p}
}

//
// Generates the file which is compatible with `remote-viewer` client.
// Use the following request to generate remote viewer connection file of the graphics console.
// Note that this action generates the file only if virtual machine is running.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/remoteviewerconnectionfile
// ----
// The `remoteviewerconnectionfile` action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// The response contains the file, which can be used with `remote-viewer` client.
// [source,xml]
// ----
// <action>
//   <remote_viewer_connection_file>
//     [virt-viewer]
//     type=spice
//     host=192.168.1.101
//     port=-1
//     password=123456789
//     delete-this-file=1
//     fullscreen=0
//     toggle-fullscreen=shift+f11
//     release-cursor=shift+f12
//     secure-attention=ctrl+alt+end
//     tls-port=5900
//     enable-smartcard=0
//     enable-usb-autoshare=0
//     usb-filter=null
//     tls-ciphers=DEFAULT
//     host-subject=O=local,CN=example.com
//     ca=...
//   </remote_viewer_connection_file>
// </action>
// ----
// E.g., to fetch the content of remote viewer connection file and save it into temporary file, user can use
// oVirt Python SDK as follows:
// [source,python]
// ----
// # Find the virtual machine:
// vm = vms_service.list(search='name=myvm')[0]
// # Locate the service that manages the virtual machine, as that is where
// # the locators are defined:
// vm_service = vms_service.vm_service(vm.id)
// # Find the graphic console of the virtual machine:
// graphics_consoles_service = vm_service.graphics_consoles_service()
// graphics_console = graphics_consoles_service.list()[0]
// # Generate the remote viewer connection file:
// console_service = graphics_consoles_service.console_service(graphics_console.id)
// remote_viewer_connection_file = console_service.remote_viewer_connection_file()
// # Write the content to file "/tmp/remote_viewer_connection_file.vv"
// path = "/tmp/remote_viewer_connection_file.vv"
// with open(path, "w") as f:
//     f.write(remote_viewer_connection_file)
// ----
// When you create the remote viewer connection file, then you can connect to virtual machine graphic console,
// as follows:
// [source,bash]
// ----
// #!/bin/sh -ex
// remote-viewer --ovirt-ca-file=/etc/pki/ovirt-engine/ca.pem /tmp/remote_viewer_connection_file.vv
// ----
//
type vmGraphicsConsoleServiceRemoteViewerConnectionFileRequest struct {
	vmGraphicsConsoleService *vmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
}

func (p *vmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) Header(key, value string) *vmGraphicsConsoleServiceRemoteViewerConnectionFileRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) Query(key, value string) *vmGraphicsConsoleServiceRemoteViewerConnectionFileRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) Send() (*vmGraphicsConsoleServiceRemoteViewerConnectionFileResponse, error) {
	rawURL := fmt.Sprintf("%s%s/remoteviewerconnectionfile", p.vmGraphicsConsoleService.connection.URL(), p.vmGraphicsConsoleService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustRemoteViewerConnectionFile()
	return &vmGraphicsConsoleServiceRemoteViewerConnectionFileResponse{remoteViewerConnectionFile: &result}, nil
}

func (p *vmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) MustSend() *vmGraphicsConsoleServiceRemoteViewerConnectionFileResponse {
	rawURL := fmt.Sprintf("%s%s/remoteviewerconnectionfile", p.vmGraphicsConsoleService.connection.URL(), p.vmGraphicsConsoleService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustRemoteViewerConnectionFile()
	return &vmGraphicsConsoleServiceRemoteViewerConnectionFileResponse{remoteViewerConnectionFile: &result}
}

//
// Generates the file which is compatible with `remote-viewer` client.
// Use the following request to generate remote viewer connection file of the graphics console.
// Note that this action generates the file only if virtual machine is running.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/remoteviewerconnectionfile
// ----
// The `remoteviewerconnectionfile` action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// The response contains the file, which can be used with `remote-viewer` client.
// [source,xml]
// ----
// <action>
//   <remote_viewer_connection_file>
//     [virt-viewer]
//     type=spice
//     host=192.168.1.101
//     port=-1
//     password=123456789
//     delete-this-file=1
//     fullscreen=0
//     toggle-fullscreen=shift+f11
//     release-cursor=shift+f12
//     secure-attention=ctrl+alt+end
//     tls-port=5900
//     enable-smartcard=0
//     enable-usb-autoshare=0
//     usb-filter=null
//     tls-ciphers=DEFAULT
//     host-subject=O=local,CN=example.com
//     ca=...
//   </remote_viewer_connection_file>
// </action>
// ----
// E.g., to fetch the content of remote viewer connection file and save it into temporary file, user can use
// oVirt Python SDK as follows:
// [source,python]
// ----
// # Find the virtual machine:
// vm = vms_service.list(search='name=myvm')[0]
// # Locate the service that manages the virtual machine, as that is where
// # the locators are defined:
// vm_service = vms_service.vm_service(vm.id)
// # Find the graphic console of the virtual machine:
// graphics_consoles_service = vm_service.graphics_consoles_service()
// graphics_console = graphics_consoles_service.list()[0]
// # Generate the remote viewer connection file:
// console_service = graphics_consoles_service.console_service(graphics_console.id)
// remote_viewer_connection_file = console_service.remote_viewer_connection_file()
// # Write the content to file "/tmp/remote_viewer_connection_file.vv"
// path = "/tmp/remote_viewer_connection_file.vv"
// with open(path, "w") as f:
//     f.write(remote_viewer_connection_file)
// ----
// When you create the remote viewer connection file, then you can connect to virtual machine graphic console,
// as follows:
// [source,bash]
// ----
// #!/bin/sh -ex
// remote-viewer --ovirt-ca-file=/etc/pki/ovirt-engine/ca.pem /tmp/remote_viewer_connection_file.vv
// ----
//
type vmGraphicsConsoleServiceRemoteViewerConnectionFileResponse struct {
	remoteViewerConnectionFile *string
}

func (p *vmGraphicsConsoleServiceRemoteViewerConnectionFileResponse) RemoteViewerConnectionFile() (string, bool) {
	if p.remoteViewerConnectionFile != nil {
		return *p.remoteViewerConnectionFile, true
	}
	var zero string
	return zero, false
}

func (p *vmGraphicsConsoleServiceRemoteViewerConnectionFileResponse) MustRemoteViewerConnectionFile() string {
	if p.remoteViewerConnectionFile == nil {
		panic("remoteViewerConnectionFile in response does not exist")
	}
	return *p.remoteViewerConnectionFile
}

//
// Generates the file which is compatible with `remote-viewer` client.
// Use the following request to generate remote viewer connection file of the graphics console.
// Note that this action generates the file only if virtual machine is running.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/remoteviewerconnectionfile
// ----
// The `remoteviewerconnectionfile` action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// The response contains the file, which can be used with `remote-viewer` client.
// [source,xml]
// ----
// <action>
//   <remote_viewer_connection_file>
//     [virt-viewer]
//     type=spice
//     host=192.168.1.101
//     port=-1
//     password=123456789
//     delete-this-file=1
//     fullscreen=0
//     toggle-fullscreen=shift+f11
//     release-cursor=shift+f12
//     secure-attention=ctrl+alt+end
//     tls-port=5900
//     enable-smartcard=0
//     enable-usb-autoshare=0
//     usb-filter=null
//     tls-ciphers=DEFAULT
//     host-subject=O=local,CN=example.com
//     ca=...
//   </remote_viewer_connection_file>
// </action>
// ----
// E.g., to fetch the content of remote viewer connection file and save it into temporary file, user can use
// oVirt Python SDK as follows:
// [source,python]
// ----
// # Find the virtual machine:
// vm = vms_service.list(search='name=myvm')[0]
// # Locate the service that manages the virtual machine, as that is where
// # the locators are defined:
// vm_service = vms_service.vm_service(vm.id)
// # Find the graphic console of the virtual machine:
// graphics_consoles_service = vm_service.graphics_consoles_service()
// graphics_console = graphics_consoles_service.list()[0]
// # Generate the remote viewer connection file:
// console_service = graphics_consoles_service.console_service(graphics_console.id)
// remote_viewer_connection_file = console_service.remote_viewer_connection_file()
// # Write the content to file "/tmp/remote_viewer_connection_file.vv"
// path = "/tmp/remote_viewer_connection_file.vv"
// with open(path, "w") as f:
//     f.write(remote_viewer_connection_file)
// ----
// When you create the remote viewer connection file, then you can connect to virtual machine graphic console,
// as follows:
// [source,bash]
// ----
// #!/bin/sh -ex
// remote-viewer --ovirt-ca-file=/etc/pki/ovirt-engine/ca.pem /tmp/remote_viewer_connection_file.vv
// ----
//
func (p *vmGraphicsConsoleService) RemoteViewerConnectionFile() *vmGraphicsConsoleServiceRemoteViewerConnectionFileRequest {
	return &vmGraphicsConsoleServiceRemoteViewerConnectionFileRequest{vmGraphicsConsoleService: p}
}

//
// Remove the graphics console from the virtual machine.
//
type vmGraphicsConsoleServiceRemoveRequest struct {
	vmGraphicsConsoleService *vmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *vmGraphicsConsoleServiceRemoveRequest) Header(key, value string) *vmGraphicsConsoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmGraphicsConsoleServiceRemoveRequest) Query(key, value string) *vmGraphicsConsoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmGraphicsConsoleServiceRemoveRequest) Async(async bool) *vmGraphicsConsoleServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *vmGraphicsConsoleServiceRemoveRequest) Send() (*vmGraphicsConsoleServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsoleService.connection.URL(), p.vmGraphicsConsoleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(vmGraphicsConsoleServiceRemoveResponse), nil
}

func (p *vmGraphicsConsoleServiceRemoveRequest) MustSend() *vmGraphicsConsoleServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmGraphicsConsoleService.connection.URL(), p.vmGraphicsConsoleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(vmGraphicsConsoleServiceRemoveResponse)
}

//
// Remove the graphics console from the virtual machine.
//
type vmGraphicsConsoleServiceRemoveResponse struct {
}

//
// Remove the graphics console from the virtual machine.
//
func (p *vmGraphicsConsoleService) Remove() *vmGraphicsConsoleServiceRemoveRequest {
	return &vmGraphicsConsoleServiceRemoveRequest{vmGraphicsConsoleService: p}
}

//
// Generates a time-sensitive authentication token for accessing this virtual machine's console.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// In any case, the response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
//
type vmGraphicsConsoleServiceTicketRequest struct {
	vmGraphicsConsoleService *vmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	ticket                   *Ticket
}

func (p *vmGraphicsConsoleServiceTicketRequest) Header(key, value string) *vmGraphicsConsoleServiceTicketRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmGraphicsConsoleServiceTicketRequest) Query(key, value string) *vmGraphicsConsoleServiceTicketRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmGraphicsConsoleServiceTicketRequest) Ticket(ticket *Ticket) *vmGraphicsConsoleServiceTicketRequest {
	p.ticket = ticket
	return p
}

func (p *vmGraphicsConsoleServiceTicketRequest) Send() (*vmGraphicsConsoleServiceTicketResponse, error) {
	rawURL := fmt.Sprintf("%s%s/ticket", p.vmGraphicsConsoleService.connection.URL(), p.vmGraphicsConsoleService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Ticket(p.ticket)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustTicket()
	return &vmGraphicsConsoleServiceTicketResponse{ticket: result}, nil
}

func (p *vmGraphicsConsoleServiceTicketRequest) MustSend() *vmGraphicsConsoleServiceTicketResponse {
	rawURL := fmt.Sprintf("%s%s/ticket", p.vmGraphicsConsoleService.connection.URL(), p.vmGraphicsConsoleService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Ticket(p.ticket)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustTicket()
	return &vmGraphicsConsoleServiceTicketResponse{ticket: result}
}

//
// Generates a time-sensitive authentication token for accessing this virtual machine's console.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// In any case, the response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
//
type vmGraphicsConsoleServiceTicketResponse struct {
	ticket *Ticket
}

func (p *vmGraphicsConsoleServiceTicketResponse) Ticket() (*Ticket, bool) {
	if p.ticket != nil {
		return p.ticket, true
	}
	return nil, false
}

func (p *vmGraphicsConsoleServiceTicketResponse) MustTicket() *Ticket {
	if p.ticket == nil {
		panic("ticket in response does not exist")
	}
	return p.ticket
}

//
// Generates a time-sensitive authentication token for accessing this virtual machine's console.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// In any case, the response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
//
func (p *vmGraphicsConsoleService) Ticket() *vmGraphicsConsoleServiceTicketRequest {
	return &vmGraphicsConsoleServiceTicketRequest{vmGraphicsConsoleService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmGraphicsConsoleService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vmGraphicsConsoleService) String() string {
	return fmt.Sprintf("vmGraphicsConsoleService:%s", op.path)
}

//
//
type quotaClusterLimitService struct {
	baseService
}

func NewQuotaClusterLimitService(connection *Connection, path string) *quotaClusterLimitService {
	var result quotaClusterLimitService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type quotaClusterLimitServiceGetRequest struct {
	quotaClusterLimitService *quotaClusterLimitService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *quotaClusterLimitServiceGetRequest) Header(key, value string) *quotaClusterLimitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotaClusterLimitServiceGetRequest) Query(key, value string) *quotaClusterLimitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotaClusterLimitServiceGetRequest) Follow(follow string) *quotaClusterLimitServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *quotaClusterLimitServiceGetRequest) Send() (*quotaClusterLimitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitService.connection.URL(), p.quotaClusterLimitService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaClusterLimitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaClusterLimitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &quotaClusterLimitServiceGetResponse{limit: result}, nil
}

func (p *quotaClusterLimitServiceGetRequest) MustSend() *quotaClusterLimitServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitService.connection.URL(), p.quotaClusterLimitService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaClusterLimitService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaClusterLimitReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &quotaClusterLimitServiceGetResponse{limit: result}
}

//
//
type quotaClusterLimitServiceGetResponse struct {
	limit *QuotaClusterLimit
}

func (p *quotaClusterLimitServiceGetResponse) Limit() (*QuotaClusterLimit, bool) {
	if p.limit != nil {
		return p.limit, true
	}
	return nil, false
}

func (p *quotaClusterLimitServiceGetResponse) MustLimit() *QuotaClusterLimit {
	if p.limit == nil {
		panic("limit in response does not exist")
	}
	return p.limit
}

//
//
func (p *quotaClusterLimitService) Get() *quotaClusterLimitServiceGetRequest {
	return &quotaClusterLimitServiceGetRequest{quotaClusterLimitService: p}
}

//
//
type quotaClusterLimitServiceRemoveRequest struct {
	quotaClusterLimitService *quotaClusterLimitService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *quotaClusterLimitServiceRemoveRequest) Header(key, value string) *quotaClusterLimitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotaClusterLimitServiceRemoveRequest) Query(key, value string) *quotaClusterLimitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotaClusterLimitServiceRemoveRequest) Async(async bool) *quotaClusterLimitServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *quotaClusterLimitServiceRemoveRequest) Send() (*quotaClusterLimitServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitService.connection.URL(), p.quotaClusterLimitService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaClusterLimitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(quotaClusterLimitServiceRemoveResponse), nil
}

func (p *quotaClusterLimitServiceRemoveRequest) MustSend() *quotaClusterLimitServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitService.connection.URL(), p.quotaClusterLimitService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaClusterLimitService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(quotaClusterLimitServiceRemoveResponse)
}

//
//
type quotaClusterLimitServiceRemoveResponse struct {
}

//
//
func (p *quotaClusterLimitService) Remove() *quotaClusterLimitServiceRemoveRequest {
	return &quotaClusterLimitServiceRemoveRequest{quotaClusterLimitService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *quotaClusterLimitService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *quotaClusterLimitService) String() string {
	return fmt.Sprintf("quotaClusterLimitService:%s", op.path)
}

//
//
type qosService struct {
	baseService
}

func NewQosService(connection *Connection, path string) *qosService {
	var result qosService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get specified QoS in the data center.
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/qoss/123
// ----
// You will get response like this one below:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>123</name>
//   <description>123</description>
//   <max_iops>1</max_iops>
//   <max_throughput>1</max_throughput>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
type qosServiceGetRequest struct {
	qosService *qosService
	header     map[string]string
	query      map[string]string
	follow     *string
}

func (p *qosServiceGetRequest) Header(key, value string) *qosServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *qosServiceGetRequest) Query(key, value string) *qosServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *qosServiceGetRequest) Follow(follow string) *qosServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *qosServiceGetRequest) Send() (*qosServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qosService.connection.URL(), p.qosService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.qosService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.qosService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQosReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &qosServiceGetResponse{qos: result}, nil
}

func (p *qosServiceGetRequest) MustSend() *qosServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.qosService.connection.URL(), p.qosService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.qosService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.qosService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQosReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &qosServiceGetResponse{qos: result}
}

//
// Get specified QoS in the data center.
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/qoss/123
// ----
// You will get response like this one below:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>123</name>
//   <description>123</description>
//   <max_iops>1</max_iops>
//   <max_throughput>1</max_throughput>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
type qosServiceGetResponse struct {
	qos *Qos
}

func (p *qosServiceGetResponse) Qos() (*Qos, bool) {
	if p.qos != nil {
		return p.qos, true
	}
	return nil, false
}

func (p *qosServiceGetResponse) MustQos() *Qos {
	if p.qos == nil {
		panic("qos in response does not exist")
	}
	return p.qos
}

//
// Get specified QoS in the data center.
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/qoss/123
// ----
// You will get response like this one below:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>123</name>
//   <description>123</description>
//   <max_iops>1</max_iops>
//   <max_throughput>1</max_throughput>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
func (p *qosService) Get() *qosServiceGetRequest {
	return &qosServiceGetRequest{qosService: p}
}

//
// Remove specified QoS from datacenter.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/qoss/123
// ----
//
type qosServiceRemoveRequest struct {
	qosService *qosService
	header     map[string]string
	query      map[string]string
	async      *bool
}

func (p *qosServiceRemoveRequest) Header(key, value string) *qosServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *qosServiceRemoveRequest) Query(key, value string) *qosServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *qosServiceRemoveRequest) Async(async bool) *qosServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *qosServiceRemoveRequest) Send() (*qosServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qosService.connection.URL(), p.qosService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.qosService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.qosService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(qosServiceRemoveResponse), nil
}

func (p *qosServiceRemoveRequest) MustSend() *qosServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.qosService.connection.URL(), p.qosService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.qosService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.qosService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(qosServiceRemoveResponse)
}

//
// Remove specified QoS from datacenter.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/qoss/123
// ----
//
type qosServiceRemoveResponse struct {
}

//
// Remove specified QoS from datacenter.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/qoss/123
// ----
//
func (p *qosService) Remove() *qosServiceRemoveRequest {
	return &qosServiceRemoveRequest{qosService: p}
}

//
// Update the specified QoS in the dataCenter.
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/qoss/123
// ----
// For example with curl:
// [source]
// ----
// curl -u admin@internal:123456 -X PUT -H "content-type: application/xml" -d \
// "<qos><name>321</name><description>321</description><max_iops>10</max_iops></qos>" \
// https://engine/ovirt-engine/api/datacenters/123/qoss/123
// ----
// You will receive response like this:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>321</name>
//   <description>321</description>
//   <max_iops>10</max_iops>
//   <max_throughput>1</max_throughput>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
type qosServiceUpdateRequest struct {
	qosService *qosService
	header     map[string]string
	query      map[string]string
	async      *bool
	qos        *Qos
}

func (p *qosServiceUpdateRequest) Header(key, value string) *qosServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *qosServiceUpdateRequest) Query(key, value string) *qosServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *qosServiceUpdateRequest) Async(async bool) *qosServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *qosServiceUpdateRequest) Qos(qos *Qos) *qosServiceUpdateRequest {
	p.qos = qos
	return p
}

func (p *qosServiceUpdateRequest) Send() (*qosServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.qosService.connection.URL(), p.qosService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQosWriteOne(writer, p.qos, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.qosService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.qosService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQosReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &qosServiceUpdateResponse{qos: result}, nil
}

func (p *qosServiceUpdateRequest) MustSend() *qosServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.qosService.connection.URL(), p.qosService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQosWriteOne(writer, p.qos, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.qosService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.qosService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQosReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &qosServiceUpdateResponse{qos: result}
}

//
// Update the specified QoS in the dataCenter.
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/qoss/123
// ----
// For example with curl:
// [source]
// ----
// curl -u admin@internal:123456 -X PUT -H "content-type: application/xml" -d \
// "<qos><name>321</name><description>321</description><max_iops>10</max_iops></qos>" \
// https://engine/ovirt-engine/api/datacenters/123/qoss/123
// ----
// You will receive response like this:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>321</name>
//   <description>321</description>
//   <max_iops>10</max_iops>
//   <max_throughput>1</max_throughput>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
type qosServiceUpdateResponse struct {
	qos *Qos
}

func (p *qosServiceUpdateResponse) Qos() (*Qos, bool) {
	if p.qos != nil {
		return p.qos, true
	}
	return nil, false
}

func (p *qosServiceUpdateResponse) MustQos() *Qos {
	if p.qos == nil {
		panic("qos in response does not exist")
	}
	return p.qos
}

//
// Update the specified QoS in the dataCenter.
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/qoss/123
// ----
// For example with curl:
// [source]
// ----
// curl -u admin@internal:123456 -X PUT -H "content-type: application/xml" -d \
// "<qos><name>321</name><description>321</description><max_iops>10</max_iops></qos>" \
// https://engine/ovirt-engine/api/datacenters/123/qoss/123
// ----
// You will receive response like this:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>321</name>
//   <description>321</description>
//   <max_iops>10</max_iops>
//   <max_throughput>1</max_throughput>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
func (p *qosService) Update() *qosServiceUpdateRequest {
	return &qosServiceUpdateRequest{qosService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *qosService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *qosService) String() string {
	return fmt.Sprintf("qosService:%s", op.path)
}

//
// A service to manage the network interfaces of a host.
//
type hostNicsService struct {
	baseService
}

func NewHostNicsService(connection *Connection, path string) *hostNicsService {
	var result hostNicsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of network interfaces of the host.
// The order of the returned list of network interfaces isn't guaranteed.
//
type hostNicsServiceListRequest struct {
	hostNicsService *hostNicsService
	header          map[string]string
	query           map[string]string
	follow          *string
	max             *int64
}

func (p *hostNicsServiceListRequest) Header(key, value string) *hostNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostNicsServiceListRequest) Query(key, value string) *hostNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostNicsServiceListRequest) Follow(follow string) *hostNicsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *hostNicsServiceListRequest) Max(max int64) *hostNicsServiceListRequest {
	p.max = &max
	return p
}

func (p *hostNicsServiceListRequest) Send() (*hostNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostNicsService.connection.URL(), p.hostNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostNicReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &hostNicsServiceListResponse{nics: result}, nil
}

func (p *hostNicsServiceListRequest) MustSend() *hostNicsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostNicsService.connection.URL(), p.hostNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostNicsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostNicsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostNicReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &hostNicsServiceListResponse{nics: result}
}

//
// Returns the list of network interfaces of the host.
// The order of the returned list of network interfaces isn't guaranteed.
//
type hostNicsServiceListResponse struct {
	nics *HostNicSlice
}

func (p *hostNicsServiceListResponse) Nics() (*HostNicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *hostNicsServiceListResponse) MustNics() *HostNicSlice {
	if p.nics == nil {
		panic("nics in response does not exist")
	}
	return p.nics
}

//
// Returns the list of network interfaces of the host.
// The order of the returned list of network interfaces isn't guaranteed.
//
func (p *hostNicsService) List() *hostNicsServiceListRequest {
	return &hostNicsServiceListRequest{hostNicsService: p}
}

//
// Reference to the service that manages a single network interface.
//
func (op *hostNicsService) NicService(id string) *hostNicService {
	return NewHostNicService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *hostNicsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NicService(path), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *hostNicsService) String() string {
	return fmt.Sprintf("hostNicsService:%s", op.path)
}

//
// A service to list all external network providers provisioned by the system on the host.
//
type externalNetworkProviderConfigurationsService struct {
	baseService
}

func NewExternalNetworkProviderConfigurationsService(connection *Connection, path string) *externalNetworkProviderConfigurationsService {
	var result externalNetworkProviderConfigurationsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of all external network providers on the host.
// The order of the returned list of networks is not guaranteed.
//
type externalNetworkProviderConfigurationsServiceListRequest struct {
	externalNetworkProviderConfigurationsService *externalNetworkProviderConfigurationsService
	header                                       map[string]string
	query                                        map[string]string
	follow                                       *string
}

func (p *externalNetworkProviderConfigurationsServiceListRequest) Header(key, value string) *externalNetworkProviderConfigurationsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalNetworkProviderConfigurationsServiceListRequest) Query(key, value string) *externalNetworkProviderConfigurationsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalNetworkProviderConfigurationsServiceListRequest) Follow(follow string) *externalNetworkProviderConfigurationsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *externalNetworkProviderConfigurationsServiceListRequest) Send() (*externalNetworkProviderConfigurationsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalNetworkProviderConfigurationsService.connection.URL(), p.externalNetworkProviderConfigurationsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalNetworkProviderConfigurationsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalNetworkProviderConfigurationsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalNetworkProviderConfigurationReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &externalNetworkProviderConfigurationsServiceListResponse{configurations: result}, nil
}

func (p *externalNetworkProviderConfigurationsServiceListRequest) MustSend() *externalNetworkProviderConfigurationsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalNetworkProviderConfigurationsService.connection.URL(), p.externalNetworkProviderConfigurationsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalNetworkProviderConfigurationsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalNetworkProviderConfigurationsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalNetworkProviderConfigurationReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &externalNetworkProviderConfigurationsServiceListResponse{configurations: result}
}

//
// Returns the list of all external network providers on the host.
// The order of the returned list of networks is not guaranteed.
//
type externalNetworkProviderConfigurationsServiceListResponse struct {
	configurations *ExternalNetworkProviderConfigurationSlice
}

func (p *externalNetworkProviderConfigurationsServiceListResponse) Configurations() (*ExternalNetworkProviderConfigurationSlice, bool) {
	if p.configurations != nil {
		return p.configurations, true
	}
	return nil, false
}

func (p *externalNetworkProviderConfigurationsServiceListResponse) MustConfigurations() *ExternalNetworkProviderConfigurationSlice {
	if p.configurations == nil {
		panic("configurations in response does not exist")
	}
	return p.configurations
}

//
// Returns the list of all external network providers on the host.
// The order of the returned list of networks is not guaranteed.
//
func (p *externalNetworkProviderConfigurationsService) List() *externalNetworkProviderConfigurationsServiceListRequest {
	return &externalNetworkProviderConfigurationsServiceListRequest{externalNetworkProviderConfigurationsService: p}
}

//
//
func (op *externalNetworkProviderConfigurationsService) ConfigurationService(id string) *externalNetworkProviderConfigurationService {
	return NewExternalNetworkProviderConfigurationService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalNetworkProviderConfigurationsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ConfigurationService(path), nil
	}
	return op.ConfigurationService(path[:index]).Service(path[index+1:])
}

func (op *externalNetworkProviderConfigurationsService) String() string {
	return fmt.Sprintf("externalNetworkProviderConfigurationsService:%s", op.path)
}

//
//
type templateNicService struct {
	baseService
}

func NewTemplateNicService(connection *Connection, path string) *templateNicService {
	var result templateNicService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type templateNicServiceGetRequest struct {
	templateNicService *templateNicService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *templateNicServiceGetRequest) Header(key, value string) *templateNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateNicServiceGetRequest) Query(key, value string) *templateNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateNicServiceGetRequest) Follow(follow string) *templateNicServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *templateNicServiceGetRequest) Send() (*templateNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicService.connection.URL(), p.templateNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateNicServiceGetResponse{nic: result}, nil
}

func (p *templateNicServiceGetRequest) MustSend() *templateNicServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateNicService.connection.URL(), p.templateNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateNicServiceGetResponse{nic: result}
}

//
//
type templateNicServiceGetResponse struct {
	nic *Nic
}

func (p *templateNicServiceGetResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *templateNicServiceGetResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
//
func (p *templateNicService) Get() *templateNicServiceGetRequest {
	return &templateNicServiceGetRequest{templateNicService: p}
}

//
//
type templateNicServiceRemoveRequest struct {
	templateNicService *templateNicService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *templateNicServiceRemoveRequest) Header(key, value string) *templateNicServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateNicServiceRemoveRequest) Query(key, value string) *templateNicServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateNicServiceRemoveRequest) Async(async bool) *templateNicServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *templateNicServiceRemoveRequest) Send() (*templateNicServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicService.connection.URL(), p.templateNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(templateNicServiceRemoveResponse), nil
}

func (p *templateNicServiceRemoveRequest) MustSend() *templateNicServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateNicService.connection.URL(), p.templateNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(templateNicServiceRemoveResponse)
}

//
//
type templateNicServiceRemoveResponse struct {
}

//
//
func (p *templateNicService) Remove() *templateNicServiceRemoveRequest {
	return &templateNicServiceRemoveRequest{templateNicService: p}
}

//
// Update the specified network interface card attached to the template.
//
type templateNicServiceUpdateRequest struct {
	templateNicService *templateNicService
	header             map[string]string
	query              map[string]string
	async              *bool
	nic                *Nic
}

func (p *templateNicServiceUpdateRequest) Header(key, value string) *templateNicServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateNicServiceUpdateRequest) Query(key, value string) *templateNicServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateNicServiceUpdateRequest) Async(async bool) *templateNicServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *templateNicServiceUpdateRequest) Nic(nic *Nic) *templateNicServiceUpdateRequest {
	p.nic = nic
	return p
}

func (p *templateNicServiceUpdateRequest) Send() (*templateNicServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateNicService.connection.URL(), p.templateNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateNicServiceUpdateResponse{nic: result}, nil
}

func (p *templateNicServiceUpdateRequest) MustSend() *templateNicServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateNicService.connection.URL(), p.templateNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateNicServiceUpdateResponse{nic: result}
}

//
// Update the specified network interface card attached to the template.
//
type templateNicServiceUpdateResponse struct {
	nic *Nic
}

func (p *templateNicServiceUpdateResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *templateNicServiceUpdateResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Update the specified network interface card attached to the template.
//
func (p *templateNicService) Update() *templateNicServiceUpdateRequest {
	return &templateNicServiceUpdateRequest{templateNicService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateNicService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *templateNicService) String() string {
	return fmt.Sprintf("templateNicService:%s", op.path)
}

//
// A service to manage bookmarks.
//
type bookmarksService struct {
	baseService
}

func NewBookmarksService(connection *Connection, path string) *bookmarksService {
	var result bookmarksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adding a new bookmark.
// Example of adding a bookmark:
// [source]
// ----
// POST /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
//
type bookmarksServiceAddRequest struct {
	bookmarksService *bookmarksService
	header           map[string]string
	query            map[string]string
	bookmark         *Bookmark
}

func (p *bookmarksServiceAddRequest) Header(key, value string) *bookmarksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *bookmarksServiceAddRequest) Query(key, value string) *bookmarksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *bookmarksServiceAddRequest) Bookmark(bookmark *Bookmark) *bookmarksServiceAddRequest {
	p.bookmark = bookmark
	return p
}

func (p *bookmarksServiceAddRequest) Send() (*bookmarksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarksService.connection.URL(), p.bookmarksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLBookmarkWriteOne(writer, p.bookmark, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.bookmarksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.bookmarksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBookmarkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &bookmarksServiceAddResponse{bookmark: result}, nil
}

func (p *bookmarksServiceAddRequest) MustSend() *bookmarksServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.bookmarksService.connection.URL(), p.bookmarksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLBookmarkWriteOne(writer, p.bookmark, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.bookmarksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.bookmarksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBookmarkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &bookmarksServiceAddResponse{bookmark: result}
}

//
// Adding a new bookmark.
// Example of adding a bookmark:
// [source]
// ----
// POST /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
//
type bookmarksServiceAddResponse struct {
	bookmark *Bookmark
}

func (p *bookmarksServiceAddResponse) Bookmark() (*Bookmark, bool) {
	if p.bookmark != nil {
		return p.bookmark, true
	}
	return nil, false
}

func (p *bookmarksServiceAddResponse) MustBookmark() *Bookmark {
	if p.bookmark == nil {
		panic("bookmark in response does not exist")
	}
	return p.bookmark
}

//
// Adding a new bookmark.
// Example of adding a bookmark:
// [source]
// ----
// POST /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
//
func (p *bookmarksService) Add() *bookmarksServiceAddRequest {
	return &bookmarksServiceAddRequest{bookmarksService: p}
}

//
// Listing all the available bookmarks.
// Example of listing bookmarks:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmarks>
//   <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//     <name>database</name>
//     <value>vm: name=database*</value>
//   </bookmark>
//   <bookmark href="/ovirt-engine/api/bookmarks/456" id="456">
//     <name>example</name>
//     <value>vm: name=example*</value>
//   </bookmark>
// </bookmarks>
// ----
// The order of the returned bookmarks isn't guaranteed.
//
type bookmarksServiceListRequest struct {
	bookmarksService *bookmarksService
	header           map[string]string
	query            map[string]string
	follow           *string
	max              *int64
}

func (p *bookmarksServiceListRequest) Header(key, value string) *bookmarksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *bookmarksServiceListRequest) Query(key, value string) *bookmarksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *bookmarksServiceListRequest) Follow(follow string) *bookmarksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *bookmarksServiceListRequest) Max(max int64) *bookmarksServiceListRequest {
	p.max = &max
	return p
}

func (p *bookmarksServiceListRequest) Send() (*bookmarksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.bookmarksService.connection.URL(), p.bookmarksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.bookmarksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.bookmarksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBookmarkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &bookmarksServiceListResponse{bookmarks: result}, nil
}

func (p *bookmarksServiceListRequest) MustSend() *bookmarksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.bookmarksService.connection.URL(), p.bookmarksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.bookmarksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.bookmarksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBookmarkReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &bookmarksServiceListResponse{bookmarks: result}
}

//
// Listing all the available bookmarks.
// Example of listing bookmarks:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmarks>
//   <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//     <name>database</name>
//     <value>vm: name=database*</value>
//   </bookmark>
//   <bookmark href="/ovirt-engine/api/bookmarks/456" id="456">
//     <name>example</name>
//     <value>vm: name=example*</value>
//   </bookmark>
// </bookmarks>
// ----
// The order of the returned bookmarks isn't guaranteed.
//
type bookmarksServiceListResponse struct {
	bookmarks *BookmarkSlice
}

func (p *bookmarksServiceListResponse) Bookmarks() (*BookmarkSlice, bool) {
	if p.bookmarks != nil {
		return p.bookmarks, true
	}
	return nil, false
}

func (p *bookmarksServiceListResponse) MustBookmarks() *BookmarkSlice {
	if p.bookmarks == nil {
		panic("bookmarks in response does not exist")
	}
	return p.bookmarks
}

//
// Listing all the available bookmarks.
// Example of listing bookmarks:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmarks>
//   <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//     <name>database</name>
//     <value>vm: name=database*</value>
//   </bookmark>
//   <bookmark href="/ovirt-engine/api/bookmarks/456" id="456">
//     <name>example</name>
//     <value>vm: name=example*</value>
//   </bookmark>
// </bookmarks>
// ----
// The order of the returned bookmarks isn't guaranteed.
//
func (p *bookmarksService) List() *bookmarksServiceListRequest {
	return &bookmarksServiceListRequest{bookmarksService: p}
}

//
// A reference to the service managing a specific bookmark.
//
func (op *bookmarksService) BookmarkService(id string) *bookmarkService {
	return NewBookmarkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *bookmarksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.BookmarkService(path), nil
	}
	return op.BookmarkService(path[:index]).Service(path[index+1:])
}

func (op *bookmarksService) String() string {
	return fmt.Sprintf("bookmarksService:%s", op.path)
}

//
// Manages the set of disks of an snapshot.
//
type snapshotDisksService struct {
	baseService
}

func NewSnapshotDisksService(connection *Connection, path string) *snapshotDisksService {
	var result snapshotDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of disks of the snapshot.
// The order of the returned list of disks isn't guaranteed.
//
type snapshotDisksServiceListRequest struct {
	snapshotDisksService *snapshotDisksService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *snapshotDisksServiceListRequest) Header(key, value string) *snapshotDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *snapshotDisksServiceListRequest) Query(key, value string) *snapshotDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *snapshotDisksServiceListRequest) Follow(follow string) *snapshotDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *snapshotDisksServiceListRequest) Max(max int64) *snapshotDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *snapshotDisksServiceListRequest) Send() (*snapshotDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotDisksService.connection.URL(), p.snapshotDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &snapshotDisksServiceListResponse{disks: result}, nil
}

func (p *snapshotDisksServiceListRequest) MustSend() *snapshotDisksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.snapshotDisksService.connection.URL(), p.snapshotDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotDisksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotDisksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &snapshotDisksServiceListResponse{disks: result}
}

//
// Returns the list of disks of the snapshot.
// The order of the returned list of disks isn't guaranteed.
//
type snapshotDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *snapshotDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *snapshotDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Returns the list of disks of the snapshot.
// The order of the returned list of disks isn't guaranteed.
//
func (p *snapshotDisksService) List() *snapshotDisksServiceListRequest {
	return &snapshotDisksServiceListRequest{snapshotDisksService: p}
}

//
//
func (op *snapshotDisksService) DiskService(id string) *snapshotDiskService {
	return NewSnapshotDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *snapshotDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *snapshotDisksService) String() string {
	return fmt.Sprintf("snapshotDisksService:%s", op.path)
}

//
//
type assignedCpuProfilesService struct {
	baseService
}

func NewAssignedCpuProfilesService(connection *Connection, path string) *assignedCpuProfilesService {
	var result assignedCpuProfilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new cpu profile for the cluster.
//
type assignedCpuProfilesServiceAddRequest struct {
	assignedCpuProfilesService *assignedCpuProfilesService
	header                     map[string]string
	query                      map[string]string
	profile                    *CpuProfile
}

func (p *assignedCpuProfilesServiceAddRequest) Header(key, value string) *assignedCpuProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedCpuProfilesServiceAddRequest) Query(key, value string) *assignedCpuProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedCpuProfilesServiceAddRequest) Profile(profile *CpuProfile) *assignedCpuProfilesServiceAddRequest {
	p.profile = profile
	return p
}

func (p *assignedCpuProfilesServiceAddRequest) Send() (*assignedCpuProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfilesService.connection.URL(), p.assignedCpuProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCpuProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedCpuProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &assignedCpuProfilesServiceAddResponse{profile: result}, nil
}

func (p *assignedCpuProfilesServiceAddRequest) MustSend() *assignedCpuProfilesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfilesService.connection.URL(), p.assignedCpuProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCpuProfileWriteOne(writer, p.profile, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedCpuProfilesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfilesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &assignedCpuProfilesServiceAddResponse{profile: result}
}

//
// Add a new cpu profile for the cluster.
//
type assignedCpuProfilesServiceAddResponse struct {
	profile *CpuProfile
}

func (p *assignedCpuProfilesServiceAddResponse) Profile() (*CpuProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *assignedCpuProfilesServiceAddResponse) MustProfile() *CpuProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Add a new cpu profile for the cluster.
//
func (p *assignedCpuProfilesService) Add() *assignedCpuProfilesServiceAddRequest {
	return &assignedCpuProfilesServiceAddRequest{assignedCpuProfilesService: p}
}

//
// List the CPU profiles assigned to the cluster.
// The order of the returned CPU profiles isn't guaranteed.
//
type assignedCpuProfilesServiceListRequest struct {
	assignedCpuProfilesService *assignedCpuProfilesService
	header                     map[string]string
	query                      map[string]string
	follow                     *string
	max                        *int64
}

func (p *assignedCpuProfilesServiceListRequest) Header(key, value string) *assignedCpuProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedCpuProfilesServiceListRequest) Query(key, value string) *assignedCpuProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedCpuProfilesServiceListRequest) Follow(follow string) *assignedCpuProfilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *assignedCpuProfilesServiceListRequest) Max(max int64) *assignedCpuProfilesServiceListRequest {
	p.max = &max
	return p
}

func (p *assignedCpuProfilesServiceListRequest) Send() (*assignedCpuProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfilesService.connection.URL(), p.assignedCpuProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedCpuProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &assignedCpuProfilesServiceListResponse{profiles: result}, nil
}

func (p *assignedCpuProfilesServiceListRequest) MustSend() *assignedCpuProfilesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedCpuProfilesService.connection.URL(), p.assignedCpuProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedCpuProfilesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedCpuProfilesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &assignedCpuProfilesServiceListResponse{profiles: result}
}

//
// List the CPU profiles assigned to the cluster.
// The order of the returned CPU profiles isn't guaranteed.
//
type assignedCpuProfilesServiceListResponse struct {
	profiles *CpuProfileSlice
}

func (p *assignedCpuProfilesServiceListResponse) Profiles() (*CpuProfileSlice, bool) {
	if p.profiles != nil {
		return p.profiles, true
	}
	return nil, false
}

func (p *assignedCpuProfilesServiceListResponse) MustProfiles() *CpuProfileSlice {
	if p.profiles == nil {
		panic("profiles in response does not exist")
	}
	return p.profiles
}

//
// List the CPU profiles assigned to the cluster.
// The order of the returned CPU profiles isn't guaranteed.
//
func (p *assignedCpuProfilesService) List() *assignedCpuProfilesServiceListRequest {
	return &assignedCpuProfilesServiceListRequest{assignedCpuProfilesService: p}
}

//
//
func (op *assignedCpuProfilesService) ProfileService(id string) *assignedCpuProfileService {
	return NewAssignedCpuProfileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *assignedCpuProfilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProfileService(path), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *assignedCpuProfilesService) String() string {
	return fmt.Sprintf("assignedCpuProfilesService:%s", op.path)
}

//
// This service manages a collection of parameters for network filters.
//
type nicNetworkFilterParametersService struct {
	baseService
}

func NewNicNetworkFilterParametersService(connection *Connection, path string) *nicNetworkFilterParametersService {
	var result nicNetworkFilterParametersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a network filter parameter.
// For example, to add the parameter for the network filter on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/789/nics/456/networkfilterparameters
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>IP</name>
//   <value>10.0.1.2</value>
// </network_filter_parameter>
// ----
//
type nicNetworkFilterParametersServiceAddRequest struct {
	nicNetworkFilterParametersService *nicNetworkFilterParametersService
	header                            map[string]string
	query                             map[string]string
	parameter                         *NetworkFilterParameter
}

func (p *nicNetworkFilterParametersServiceAddRequest) Header(key, value string) *nicNetworkFilterParametersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *nicNetworkFilterParametersServiceAddRequest) Query(key, value string) *nicNetworkFilterParametersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *nicNetworkFilterParametersServiceAddRequest) Parameter(parameter *NetworkFilterParameter) *nicNetworkFilterParametersServiceAddRequest {
	p.parameter = parameter
	return p
}

func (p *nicNetworkFilterParametersServiceAddRequest) Send() (*nicNetworkFilterParametersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.nicNetworkFilterParametersService.connection.URL(), p.nicNetworkFilterParametersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkFilterParameterWriteOne(writer, p.parameter, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.nicNetworkFilterParametersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.nicNetworkFilterParametersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterParameterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &nicNetworkFilterParametersServiceAddResponse{parameter: result}, nil
}

func (p *nicNetworkFilterParametersServiceAddRequest) MustSend() *nicNetworkFilterParametersServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.nicNetworkFilterParametersService.connection.URL(), p.nicNetworkFilterParametersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkFilterParameterWriteOne(writer, p.parameter, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.nicNetworkFilterParametersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.nicNetworkFilterParametersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterParameterReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &nicNetworkFilterParametersServiceAddResponse{parameter: result}
}

//
// Add a network filter parameter.
// For example, to add the parameter for the network filter on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/789/nics/456/networkfilterparameters
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>IP</name>
//   <value>10.0.1.2</value>
// </network_filter_parameter>
// ----
//
type nicNetworkFilterParametersServiceAddResponse struct {
	parameter *NetworkFilterParameter
}

func (p *nicNetworkFilterParametersServiceAddResponse) Parameter() (*NetworkFilterParameter, bool) {
	if p.parameter != nil {
		return p.parameter, true
	}
	return nil, false
}

func (p *nicNetworkFilterParametersServiceAddResponse) MustParameter() *NetworkFilterParameter {
	if p.parameter == nil {
		panic("parameter in response does not exist")
	}
	return p.parameter
}

//
// Add a network filter parameter.
// For example, to add the parameter for the network filter on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/789/nics/456/networkfilterparameters
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>IP</name>
//   <value>10.0.1.2</value>
// </network_filter_parameter>
// ----
//
func (p *nicNetworkFilterParametersService) Add() *nicNetworkFilterParametersServiceAddRequest {
	return &nicNetworkFilterParametersServiceAddRequest{nicNetworkFilterParametersService: p}
}

//
// Retrieves the representations of the network filter parameters.
// The order of the returned list of network filters isn't guaranteed.
//
type nicNetworkFilterParametersServiceListRequest struct {
	nicNetworkFilterParametersService *nicNetworkFilterParametersService
	header                            map[string]string
	query                             map[string]string
	follow                            *string
}

func (p *nicNetworkFilterParametersServiceListRequest) Header(key, value string) *nicNetworkFilterParametersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *nicNetworkFilterParametersServiceListRequest) Query(key, value string) *nicNetworkFilterParametersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *nicNetworkFilterParametersServiceListRequest) Follow(follow string) *nicNetworkFilterParametersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *nicNetworkFilterParametersServiceListRequest) Send() (*nicNetworkFilterParametersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.nicNetworkFilterParametersService.connection.URL(), p.nicNetworkFilterParametersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.nicNetworkFilterParametersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.nicNetworkFilterParametersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterParameterReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &nicNetworkFilterParametersServiceListResponse{parameters: result}, nil
}

func (p *nicNetworkFilterParametersServiceListRequest) MustSend() *nicNetworkFilterParametersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.nicNetworkFilterParametersService.connection.URL(), p.nicNetworkFilterParametersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.nicNetworkFilterParametersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.nicNetworkFilterParametersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterParameterReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &nicNetworkFilterParametersServiceListResponse{parameters: result}
}

//
// Retrieves the representations of the network filter parameters.
// The order of the returned list of network filters isn't guaranteed.
//
type nicNetworkFilterParametersServiceListResponse struct {
	parameters *NetworkFilterParameterSlice
}

func (p *nicNetworkFilterParametersServiceListResponse) Parameters() (*NetworkFilterParameterSlice, bool) {
	if p.parameters != nil {
		return p.parameters, true
	}
	return nil, false
}

func (p *nicNetworkFilterParametersServiceListResponse) MustParameters() *NetworkFilterParameterSlice {
	if p.parameters == nil {
		panic("parameters in response does not exist")
	}
	return p.parameters
}

//
// Retrieves the representations of the network filter parameters.
// The order of the returned list of network filters isn't guaranteed.
//
func (p *nicNetworkFilterParametersService) List() *nicNetworkFilterParametersServiceListRequest {
	return &nicNetworkFilterParametersServiceListRequest{nicNetworkFilterParametersService: p}
}

//
// Reference to the service that manages a specific network filter parameter.
//
func (op *nicNetworkFilterParametersService) ParameterService(id string) *nicNetworkFilterParameterService {
	return NewNicNetworkFilterParameterService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *nicNetworkFilterParametersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ParameterService(path), nil
	}
	return op.ParameterService(path[:index]).Service(path[index+1:])
}

func (op *nicNetworkFilterParametersService) String() string {
	return fmt.Sprintf("nicNetworkFilterParametersService:%s", op.path)
}

//
// This service manages the attachment of a disk to a template.
//
type templateDiskAttachmentService struct {
	baseService
}

func NewTemplateDiskAttachmentService(connection *Connection, path string) *templateDiskAttachmentService {
	var result templateDiskAttachmentService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the details of the attachment.
//
type templateDiskAttachmentServiceGetRequest struct {
	templateDiskAttachmentService *templateDiskAttachmentService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
}

func (p *templateDiskAttachmentServiceGetRequest) Header(key, value string) *templateDiskAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateDiskAttachmentServiceGetRequest) Query(key, value string) *templateDiskAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateDiskAttachmentServiceGetRequest) Follow(follow string) *templateDiskAttachmentServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *templateDiskAttachmentServiceGetRequest) Send() (*templateDiskAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskAttachmentService.connection.URL(), p.templateDiskAttachmentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateDiskAttachmentServiceGetResponse{attachment: result}, nil
}

func (p *templateDiskAttachmentServiceGetRequest) MustSend() *templateDiskAttachmentServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskAttachmentService.connection.URL(), p.templateDiskAttachmentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskAttachmentService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskAttachmentService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateDiskAttachmentServiceGetResponse{attachment: result}
}

//
// Returns the details of the attachment.
//
type templateDiskAttachmentServiceGetResponse struct {
	attachment *DiskAttachment
}

func (p *templateDiskAttachmentServiceGetResponse) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *templateDiskAttachmentServiceGetResponse) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
// Returns the details of the attachment.
//
func (p *templateDiskAttachmentService) Get() *templateDiskAttachmentServiceGetRequest {
	return &templateDiskAttachmentServiceGetRequest{templateDiskAttachmentService: p}
}

//
// Removes the disk from the template. The disk will only be removed if there are other existing copies of the
// disk on other storage domains.
// A storage domain has to be specified to determine which of the copies should be removed (template disks can
// have copies on multiple storage domains).
// [source]
// ----
// DELETE /ovirt-engine/api/templates/{template:id}/diskattachments/{attachment:id}?storage_domain=072fbaa1-08f3-4a40-9f34-a5ca22dd1d74
// ----
//
type templateDiskAttachmentServiceRemoveRequest struct {
	templateDiskAttachmentService *templateDiskAttachmentService
	header                        map[string]string
	query                         map[string]string
	force                         *bool
	storageDomain                 *string
}

func (p *templateDiskAttachmentServiceRemoveRequest) Header(key, value string) *templateDiskAttachmentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateDiskAttachmentServiceRemoveRequest) Query(key, value string) *templateDiskAttachmentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateDiskAttachmentServiceRemoveRequest) Force(force bool) *templateDiskAttachmentServiceRemoveRequest {
	p.force = &force
	return p
}

func (p *templateDiskAttachmentServiceRemoveRequest) StorageDomain(storageDomain string) *templateDiskAttachmentServiceRemoveRequest {
	p.storageDomain = &storageDomain
	return p
}

func (p *templateDiskAttachmentServiceRemoveRequest) Send() (*templateDiskAttachmentServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskAttachmentService.connection.URL(), p.templateDiskAttachmentService.path)
	values := make(url.Values)
	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.storageDomain != nil {
		values["storage_domain"] = []string{fmt.Sprintf("%v", *p.storageDomain)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(templateDiskAttachmentServiceRemoveResponse), nil
}

func (p *templateDiskAttachmentServiceRemoveRequest) MustSend() *templateDiskAttachmentServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskAttachmentService.connection.URL(), p.templateDiskAttachmentService.path)
	values := make(url.Values)
	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.storageDomain != nil {
		values["storage_domain"] = []string{fmt.Sprintf("%v", *p.storageDomain)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskAttachmentService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskAttachmentService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(templateDiskAttachmentServiceRemoveResponse)
}

//
// Removes the disk from the template. The disk will only be removed if there are other existing copies of the
// disk on other storage domains.
// A storage domain has to be specified to determine which of the copies should be removed (template disks can
// have copies on multiple storage domains).
// [source]
// ----
// DELETE /ovirt-engine/api/templates/{template:id}/diskattachments/{attachment:id}?storage_domain=072fbaa1-08f3-4a40-9f34-a5ca22dd1d74
// ----
//
type templateDiskAttachmentServiceRemoveResponse struct {
}

//
// Removes the disk from the template. The disk will only be removed if there are other existing copies of the
// disk on other storage domains.
// A storage domain has to be specified to determine which of the copies should be removed (template disks can
// have copies on multiple storage domains).
// [source]
// ----
// DELETE /ovirt-engine/api/templates/{template:id}/diskattachments/{attachment:id}?storage_domain=072fbaa1-08f3-4a40-9f34-a5ca22dd1d74
// ----
//
func (p *templateDiskAttachmentService) Remove() *templateDiskAttachmentServiceRemoveRequest {
	return &templateDiskAttachmentServiceRemoveRequest{templateDiskAttachmentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateDiskAttachmentService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *templateDiskAttachmentService) String() string {
	return fmt.Sprintf("templateDiskAttachmentService:%s", op.path)
}

//
//
type virtualFunctionAllowedNetworkService struct {
	baseService
}

func NewVirtualFunctionAllowedNetworkService(connection *Connection, path string) *virtualFunctionAllowedNetworkService {
	var result virtualFunctionAllowedNetworkService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type virtualFunctionAllowedNetworkServiceGetRequest struct {
	virtualFunctionAllowedNetworkService *virtualFunctionAllowedNetworkService
	header                               map[string]string
	query                                map[string]string
	follow                               *string
}

func (p *virtualFunctionAllowedNetworkServiceGetRequest) Header(key, value string) *virtualFunctionAllowedNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *virtualFunctionAllowedNetworkServiceGetRequest) Query(key, value string) *virtualFunctionAllowedNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *virtualFunctionAllowedNetworkServiceGetRequest) Follow(follow string) *virtualFunctionAllowedNetworkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *virtualFunctionAllowedNetworkServiceGetRequest) Send() (*virtualFunctionAllowedNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworkService.connection.URL(), p.virtualFunctionAllowedNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.virtualFunctionAllowedNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &virtualFunctionAllowedNetworkServiceGetResponse{network: result}, nil
}

func (p *virtualFunctionAllowedNetworkServiceGetRequest) MustSend() *virtualFunctionAllowedNetworkServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworkService.connection.URL(), p.virtualFunctionAllowedNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.virtualFunctionAllowedNetworkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &virtualFunctionAllowedNetworkServiceGetResponse{network: result}
}

//
//
type virtualFunctionAllowedNetworkServiceGetResponse struct {
	network *Network
}

func (p *virtualFunctionAllowedNetworkServiceGetResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *virtualFunctionAllowedNetworkServiceGetResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
//
func (p *virtualFunctionAllowedNetworkService) Get() *virtualFunctionAllowedNetworkServiceGetRequest {
	return &virtualFunctionAllowedNetworkServiceGetRequest{virtualFunctionAllowedNetworkService: p}
}

//
//
type virtualFunctionAllowedNetworkServiceRemoveRequest struct {
	virtualFunctionAllowedNetworkService *virtualFunctionAllowedNetworkService
	header                               map[string]string
	query                                map[string]string
	async                                *bool
}

func (p *virtualFunctionAllowedNetworkServiceRemoveRequest) Header(key, value string) *virtualFunctionAllowedNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *virtualFunctionAllowedNetworkServiceRemoveRequest) Query(key, value string) *virtualFunctionAllowedNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *virtualFunctionAllowedNetworkServiceRemoveRequest) Async(async bool) *virtualFunctionAllowedNetworkServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *virtualFunctionAllowedNetworkServiceRemoveRequest) Send() (*virtualFunctionAllowedNetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworkService.connection.URL(), p.virtualFunctionAllowedNetworkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.virtualFunctionAllowedNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(virtualFunctionAllowedNetworkServiceRemoveResponse), nil
}

func (p *virtualFunctionAllowedNetworkServiceRemoveRequest) MustSend() *virtualFunctionAllowedNetworkServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworkService.connection.URL(), p.virtualFunctionAllowedNetworkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.virtualFunctionAllowedNetworkService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworkService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(virtualFunctionAllowedNetworkServiceRemoveResponse)
}

//
//
type virtualFunctionAllowedNetworkServiceRemoveResponse struct {
}

//
//
func (p *virtualFunctionAllowedNetworkService) Remove() *virtualFunctionAllowedNetworkServiceRemoveRequest {
	return &virtualFunctionAllowedNetworkServiceRemoveRequest{virtualFunctionAllowedNetworkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *virtualFunctionAllowedNetworkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *virtualFunctionAllowedNetworkService) String() string {
	return fmt.Sprintf("virtualFunctionAllowedNetworkService:%s", op.path)
}

//
// Manages the ser of labels attached to a network or to a host NIC.
//
type networkLabelsService struct {
	baseService
}

func NewNetworkLabelsService(connection *Connection, path string) *networkLabelsService {
	var result networkLabelsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Attaches label to logical network.
// You can attach labels to a logical network to automate the association of that logical network with physical host
// network interfaces to which the same label has been attached.
// For example, to attach the label `mylabel` to a logical network having id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks/123/labels
// ----
// With a request body like this:
// [source,xml]
// ----
// <label id="mylabel"/>
// ----
//
type networkLabelsServiceAddRequest struct {
	networkLabelsService *networkLabelsService
	header               map[string]string
	query                map[string]string
	label                *NetworkLabel
}

func (p *networkLabelsServiceAddRequest) Header(key, value string) *networkLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkLabelsServiceAddRequest) Query(key, value string) *networkLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkLabelsServiceAddRequest) Label(label *NetworkLabel) *networkLabelsServiceAddRequest {
	p.label = label
	return p
}

func (p *networkLabelsServiceAddRequest) Send() (*networkLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelsService.connection.URL(), p.networkLabelsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkLabelWriteOne(writer, p.label, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &networkLabelsServiceAddResponse{label: result}, nil
}

func (p *networkLabelsServiceAddRequest) MustSend() *networkLabelsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelsService.connection.URL(), p.networkLabelsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkLabelWriteOne(writer, p.label, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkLabelsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkLabelsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkLabelReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &networkLabelsServiceAddResponse{label: result}
}

//
// Attaches label to logical network.
// You can attach labels to a logical network to automate the association of that logical network with physical host
// network interfaces to which the same label has been attached.
// For example, to attach the label `mylabel` to a logical network having id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks/123/labels
// ----
// With a request body like this:
// [source,xml]
// ----
// <label id="mylabel"/>
// ----
//
type networkLabelsServiceAddResponse struct {
	label *NetworkLabel
}

func (p *networkLabelsServiceAddResponse) Label() (*NetworkLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *networkLabelsServiceAddResponse) MustLabel() *NetworkLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Attaches label to logical network.
// You can attach labels to a logical network to automate the association of that logical network with physical host
// network interfaces to which the same label has been attached.
// For example, to attach the label `mylabel` to a logical network having id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks/123/labels
// ----
// With a request body like this:
// [source,xml]
// ----
// <label id="mylabel"/>
// ----
//
func (p *networkLabelsService) Add() *networkLabelsServiceAddRequest {
	return &networkLabelsServiceAddRequest{networkLabelsService: p}
}

//
// Returns the list of labels attached to the network or host NIC.
// The order of the returned list of labels isn't guaranteed.
//
type networkLabelsServiceListRequest struct {
	networkLabelsService *networkLabelsService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *networkLabelsServiceListRequest) Header(key, value string) *networkLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkLabelsServiceListRequest) Query(key, value string) *networkLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkLabelsServiceListRequest) Follow(follow string) *networkLabelsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *networkLabelsServiceListRequest) Max(max int64) *networkLabelsServiceListRequest {
	p.max = &max
	return p
}

func (p *networkLabelsServiceListRequest) Send() (*networkLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelsService.connection.URL(), p.networkLabelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkLabelReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &networkLabelsServiceListResponse{labels: result}, nil
}

func (p *networkLabelsServiceListRequest) MustSend() *networkLabelsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkLabelsService.connection.URL(), p.networkLabelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkLabelsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkLabelsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkLabelReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &networkLabelsServiceListResponse{labels: result}
}

//
// Returns the list of labels attached to the network or host NIC.
// The order of the returned list of labels isn't guaranteed.
//
type networkLabelsServiceListResponse struct {
	labels *NetworkLabelSlice
}

func (p *networkLabelsServiceListResponse) Labels() (*NetworkLabelSlice, bool) {
	if p.labels != nil {
		return p.labels, true
	}
	return nil, false
}

func (p *networkLabelsServiceListResponse) MustLabels() *NetworkLabelSlice {
	if p.labels == nil {
		panic("labels in response does not exist")
	}
	return p.labels
}

//
// Returns the list of labels attached to the network or host NIC.
// The order of the returned list of labels isn't guaranteed.
//
func (p *networkLabelsService) List() *networkLabelsServiceListRequest {
	return &networkLabelsServiceListRequest{networkLabelsService: p}
}

//
//
func (op *networkLabelsService) LabelService(id string) *networkLabelService {
	return NewNetworkLabelService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *networkLabelsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LabelService(path), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *networkLabelsService) String() string {
	return fmt.Sprintf("networkLabelsService:%s", op.path)
}

//
// A service to manage clusters.
//
type clustersService struct {
	baseService
}

func NewClustersService(connection *Connection, path string) *clustersService {
	var result clustersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new cluster.
// This requires the `name`, `cpu.type`, and `data_center` attributes. Identify the data center with either the `id`
// or `name` attribute.
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Penryn Family</type>
//   </cpu>
//   <data_center id="123"/>
// </cluster>
// ----
// To create a cluster with an external network provider to be deployed on
// every host that is added to the cluster, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body containing a reference to the desired provider:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Penryn Family</type>
//   </cpu>
//   <data_center id="123"/>
//   <external_network_providers>
//     <external_provider name="ovirt-provider-ovn"/>
//   </external_network_providers>
// </cluster>
// ----
//
type clustersServiceAddRequest struct {
	clustersService *clustersService
	header          map[string]string
	query           map[string]string
	cluster         *Cluster
}

func (p *clustersServiceAddRequest) Header(key, value string) *clustersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clustersServiceAddRequest) Query(key, value string) *clustersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clustersServiceAddRequest) Cluster(cluster *Cluster) *clustersServiceAddRequest {
	p.cluster = cluster
	return p
}

func (p *clustersServiceAddRequest) Send() (*clustersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clustersService.connection.URL(), p.clustersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLClusterWriteOne(writer, p.cluster, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clustersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clustersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &clustersServiceAddResponse{cluster: result}, nil
}

func (p *clustersServiceAddRequest) MustSend() *clustersServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.clustersService.connection.URL(), p.clustersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLClusterWriteOne(writer, p.cluster, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clustersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clustersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &clustersServiceAddResponse{cluster: result}
}

//
// Creates a new cluster.
// This requires the `name`, `cpu.type`, and `data_center` attributes. Identify the data center with either the `id`
// or `name` attribute.
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Penryn Family</type>
//   </cpu>
//   <data_center id="123"/>
// </cluster>
// ----
// To create a cluster with an external network provider to be deployed on
// every host that is added to the cluster, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body containing a reference to the desired provider:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Penryn Family</type>
//   </cpu>
//   <data_center id="123"/>
//   <external_network_providers>
//     <external_provider name="ovirt-provider-ovn"/>
//   </external_network_providers>
// </cluster>
// ----
//
type clustersServiceAddResponse struct {
	cluster *Cluster
}

func (p *clustersServiceAddResponse) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

func (p *clustersServiceAddResponse) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("cluster in response does not exist")
	}
	return p.cluster
}

//
// Creates a new cluster.
// This requires the `name`, `cpu.type`, and `data_center` attributes. Identify the data center with either the `id`
// or `name` attribute.
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Penryn Family</type>
//   </cpu>
//   <data_center id="123"/>
// </cluster>
// ----
// To create a cluster with an external network provider to be deployed on
// every host that is added to the cluster, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body containing a reference to the desired provider:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Penryn Family</type>
//   </cpu>
//   <data_center id="123"/>
//   <external_network_providers>
//     <external_provider name="ovirt-provider-ovn"/>
//   </external_network_providers>
// </cluster>
// ----
//
func (p *clustersService) Add() *clustersServiceAddRequest {
	return &clustersServiceAddRequest{clustersService: p}
}

//
// Returns the list of clusters of the system.
// The order of the returned clusters is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type clustersServiceListRequest struct {
	clustersService *clustersService
	header          map[string]string
	query           map[string]string
	caseSensitive   *bool
	filter          *bool
	follow          *string
	max             *int64
	search          *string
}

func (p *clustersServiceListRequest) Header(key, value string) *clustersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clustersServiceListRequest) Query(key, value string) *clustersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clustersServiceListRequest) CaseSensitive(caseSensitive bool) *clustersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *clustersServiceListRequest) Filter(filter bool) *clustersServiceListRequest {
	p.filter = &filter
	return p
}

func (p *clustersServiceListRequest) Follow(follow string) *clustersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *clustersServiceListRequest) Max(max int64) *clustersServiceListRequest {
	p.max = &max
	return p
}

func (p *clustersServiceListRequest) Search(search string) *clustersServiceListRequest {
	p.search = &search
	return p
}

func (p *clustersServiceListRequest) Send() (*clustersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clustersService.connection.URL(), p.clustersService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clustersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clustersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &clustersServiceListResponse{clusters: result}, nil
}

func (p *clustersServiceListRequest) MustSend() *clustersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.clustersService.connection.URL(), p.clustersService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clustersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clustersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &clustersServiceListResponse{clusters: result}
}

//
// Returns the list of clusters of the system.
// The order of the returned clusters is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type clustersServiceListResponse struct {
	clusters *ClusterSlice
}

func (p *clustersServiceListResponse) Clusters() (*ClusterSlice, bool) {
	if p.clusters != nil {
		return p.clusters, true
	}
	return nil, false
}

func (p *clustersServiceListResponse) MustClusters() *ClusterSlice {
	if p.clusters == nil {
		panic("clusters in response does not exist")
	}
	return p.clusters
}

//
// Returns the list of clusters of the system.
// The order of the returned clusters is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
func (p *clustersService) List() *clustersServiceListRequest {
	return &clustersServiceListRequest{clustersService: p}
}

//
// A reference to the service that manages a specific cluster.
//
func (op *clustersService) ClusterService(id string) *clusterService {
	return NewClusterService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *clustersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ClusterService(path), nil
	}
	return op.ClusterService(path[:index]).Service(path[index+1:])
}

func (op *clustersService) String() string {
	return fmt.Sprintf("clustersService:%s", op.path)
}

//
// This service represents one label to entity assignment
// when accessed using the entities/affinitylabels subcollection.
//
type assignedAffinityLabelService struct {
	baseService
}

func NewAssignedAffinityLabelService(connection *Connection, path string) *assignedAffinityLabelService {
	var result assignedAffinityLabelService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves details about the attached label.
//
type assignedAffinityLabelServiceGetRequest struct {
	assignedAffinityLabelService *assignedAffinityLabelService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
}

func (p *assignedAffinityLabelServiceGetRequest) Header(key, value string) *assignedAffinityLabelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedAffinityLabelServiceGetRequest) Query(key, value string) *assignedAffinityLabelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedAffinityLabelServiceGetRequest) Follow(follow string) *assignedAffinityLabelServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *assignedAffinityLabelServiceGetRequest) Send() (*assignedAffinityLabelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelService.connection.URL(), p.assignedAffinityLabelService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedAffinityLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &assignedAffinityLabelServiceGetResponse{label: result}, nil
}

func (p *assignedAffinityLabelServiceGetRequest) MustSend() *assignedAffinityLabelServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelService.connection.URL(), p.assignedAffinityLabelService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedAffinityLabelService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &assignedAffinityLabelServiceGetResponse{label: result}
}

//
// Retrieves details about the attached label.
//
type assignedAffinityLabelServiceGetResponse struct {
	label *AffinityLabel
}

func (p *assignedAffinityLabelServiceGetResponse) Label() (*AffinityLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *assignedAffinityLabelServiceGetResponse) MustLabel() *AffinityLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Retrieves details about the attached label.
//
func (p *assignedAffinityLabelService) Get() *assignedAffinityLabelServiceGetRequest {
	return &assignedAffinityLabelServiceGetRequest{assignedAffinityLabelService: p}
}

//
// Removes the label from an entity. Does not touch the label itself.
//
type assignedAffinityLabelServiceRemoveRequest struct {
	assignedAffinityLabelService *assignedAffinityLabelService
	header                       map[string]string
	query                        map[string]string
}

func (p *assignedAffinityLabelServiceRemoveRequest) Header(key, value string) *assignedAffinityLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedAffinityLabelServiceRemoveRequest) Query(key, value string) *assignedAffinityLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedAffinityLabelServiceRemoveRequest) Send() (*assignedAffinityLabelServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelService.connection.URL(), p.assignedAffinityLabelService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedAffinityLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(assignedAffinityLabelServiceRemoveResponse), nil
}

func (p *assignedAffinityLabelServiceRemoveRequest) MustSend() *assignedAffinityLabelServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedAffinityLabelService.connection.URL(), p.assignedAffinityLabelService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedAffinityLabelService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedAffinityLabelService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(assignedAffinityLabelServiceRemoveResponse)
}

//
// Removes the label from an entity. Does not touch the label itself.
//
type assignedAffinityLabelServiceRemoveResponse struct {
}

//
// Removes the label from an entity. Does not touch the label itself.
//
func (p *assignedAffinityLabelService) Remove() *assignedAffinityLabelServiceRemoveRequest {
	return &assignedAffinityLabelServiceRemoveRequest{assignedAffinityLabelService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *assignedAffinityLabelService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *assignedAffinityLabelService) String() string {
	return fmt.Sprintf("assignedAffinityLabelService:%s", op.path)
}

//
//
type weightService struct {
	baseService
}

func NewWeightService(connection *Connection, path string) *weightService {
	var result weightService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type weightServiceGetRequest struct {
	weightService *weightService
	header        map[string]string
	query         map[string]string
	filter        *bool
	follow        *string
}

func (p *weightServiceGetRequest) Header(key, value string) *weightServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *weightServiceGetRequest) Query(key, value string) *weightServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *weightServiceGetRequest) Filter(filter bool) *weightServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *weightServiceGetRequest) Follow(follow string) *weightServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *weightServiceGetRequest) Send() (*weightServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.weightService.connection.URL(), p.weightService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.weightService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.weightService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWeightReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &weightServiceGetResponse{weight: result}, nil
}

func (p *weightServiceGetRequest) MustSend() *weightServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.weightService.connection.URL(), p.weightService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.weightService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.weightService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWeightReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &weightServiceGetResponse{weight: result}
}

//
//
type weightServiceGetResponse struct {
	weight *Weight
}

func (p *weightServiceGetResponse) Weight() (*Weight, bool) {
	if p.weight != nil {
		return p.weight, true
	}
	return nil, false
}

func (p *weightServiceGetResponse) MustWeight() *Weight {
	if p.weight == nil {
		panic("weight in response does not exist")
	}
	return p.weight
}

//
//
func (p *weightService) Get() *weightServiceGetRequest {
	return &weightServiceGetRequest{weightService: p}
}

//
//
type weightServiceRemoveRequest struct {
	weightService *weightService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *weightServiceRemoveRequest) Header(key, value string) *weightServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *weightServiceRemoveRequest) Query(key, value string) *weightServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *weightServiceRemoveRequest) Async(async bool) *weightServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *weightServiceRemoveRequest) Send() (*weightServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.weightService.connection.URL(), p.weightService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.weightService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.weightService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(weightServiceRemoveResponse), nil
}

func (p *weightServiceRemoveRequest) MustSend() *weightServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.weightService.connection.URL(), p.weightService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.weightService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.weightService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(weightServiceRemoveResponse)
}

//
//
type weightServiceRemoveResponse struct {
}

//
//
func (p *weightService) Remove() *weightServiceRemoveRequest {
	return &weightServiceRemoveRequest{weightService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *weightService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *weightService) String() string {
	return fmt.Sprintf("weightService:%s", op.path)
}

//
//
type diskProfileService struct {
	baseService
}

func NewDiskProfileService(connection *Connection, path string) *diskProfileService {
	var result diskProfileService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type diskProfileServiceGetRequest struct {
	diskProfileService *diskProfileService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *diskProfileServiceGetRequest) Header(key, value string) *diskProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskProfileServiceGetRequest) Query(key, value string) *diskProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskProfileServiceGetRequest) Follow(follow string) *diskProfileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *diskProfileServiceGetRequest) Send() (*diskProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfileService.connection.URL(), p.diskProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &diskProfileServiceGetResponse{profile: result}, nil
}

func (p *diskProfileServiceGetRequest) MustSend() *diskProfileServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskProfileService.connection.URL(), p.diskProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &diskProfileServiceGetResponse{profile: result}
}

//
//
type diskProfileServiceGetResponse struct {
	profile *DiskProfile
}

func (p *diskProfileServiceGetResponse) Profile() (*DiskProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *diskProfileServiceGetResponse) MustProfile() *DiskProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
//
func (p *diskProfileService) Get() *diskProfileServiceGetRequest {
	return &diskProfileServiceGetRequest{diskProfileService: p}
}

//
//
type diskProfileServiceRemoveRequest struct {
	diskProfileService *diskProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *diskProfileServiceRemoveRequest) Header(key, value string) *diskProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskProfileServiceRemoveRequest) Query(key, value string) *diskProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskProfileServiceRemoveRequest) Async(async bool) *diskProfileServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *diskProfileServiceRemoveRequest) Send() (*diskProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfileService.connection.URL(), p.diskProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(diskProfileServiceRemoveResponse), nil
}

func (p *diskProfileServiceRemoveRequest) MustSend() *diskProfileServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskProfileService.connection.URL(), p.diskProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(diskProfileServiceRemoveResponse)
}

//
//
type diskProfileServiceRemoveResponse struct {
}

//
//
func (p *diskProfileService) Remove() *diskProfileServiceRemoveRequest {
	return &diskProfileServiceRemoveRequest{diskProfileService: p}
}

//
// Update the specified disk profile in the system.
//
type diskProfileServiceUpdateRequest struct {
	diskProfileService *diskProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
	profile            *DiskProfile
}

func (p *diskProfileServiceUpdateRequest) Header(key, value string) *diskProfileServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskProfileServiceUpdateRequest) Query(key, value string) *diskProfileServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskProfileServiceUpdateRequest) Async(async bool) *diskProfileServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *diskProfileServiceUpdateRequest) Profile(profile *DiskProfile) *diskProfileServiceUpdateRequest {
	p.profile = profile
	return p
}

func (p *diskProfileServiceUpdateRequest) Send() (*diskProfileServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskProfileService.connection.URL(), p.diskProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &diskProfileServiceUpdateResponse{profile: result}, nil
}

func (p *diskProfileServiceUpdateRequest) MustSend() *diskProfileServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskProfileService.connection.URL(), p.diskProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskProfileWriteOne(writer, p.profile, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &diskProfileServiceUpdateResponse{profile: result}
}

//
// Update the specified disk profile in the system.
//
type diskProfileServiceUpdateResponse struct {
	profile *DiskProfile
}

func (p *diskProfileServiceUpdateResponse) Profile() (*DiskProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *diskProfileServiceUpdateResponse) MustProfile() *DiskProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Update the specified disk profile in the system.
//
func (p *diskProfileService) Update() *diskProfileServiceUpdateRequest {
	return &diskProfileServiceUpdateRequest{diskProfileService: p}
}

//
//
func (op *diskProfileService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *diskProfileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *diskProfileService) String() string {
	return fmt.Sprintf("diskProfileService:%s", op.path)
}

//
// Manages the set of storage domains of the system.
//
type storageDomainsService struct {
	baseService
}

func NewStorageDomainsService(connection *Connection, path string) *storageDomainsService {
	var result storageDomainsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a new storage domain.
// Creation of a new <<types/storage_domain,StorageDomain>> requires the `name`, `type`, `host` and `storage`
// attributes. Identify the `host` attribute with the `id` or `name` attributes. In oVirt 3.6 and later you can
// enable the wipe after delete option by default on the storage domain. To configure this, specify
// `wipe_after_delete` in the POST request. This option can be edited after the domain is created, but doing so will
// not change the wipe after delete property of disks that already exist.
// To add a new storage domain with specified `name`, `type`, `storage.type`, `storage.address` and `storage.path`
// and by using a host with an id `123`, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains
// ----
// With a request body as follows:
// [source,xml]
// ----
// <storage_domain>
//   <name>mydata</name>
//   <type>data</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/exports/mydata</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new NFS ISO storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myisos</name>
//   <type>iso</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/export/myisos</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new iSCSI storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myiscsi</name>
//   <type>data</type>
//   <storage>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="3600144f09dbd050000004eedbd340001"/>
//       <logical_unit id="3600144f09dbd050000004eedbd340002"/>
//     </logical_units>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
//
type storageDomainsServiceAddRequest struct {
	storageDomainsService *storageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *storageDomainsServiceAddRequest) Header(key, value string) *storageDomainsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainsServiceAddRequest) Query(key, value string) *storageDomainsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainsServiceAddRequest) StorageDomain(storageDomain *StorageDomain) *storageDomainsServiceAddRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *storageDomainsServiceAddRequest) Send() (*storageDomainsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageDomainWriteOne(writer, p.storageDomain, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageDomainsServiceAddResponse{storageDomain: result}, nil
}

func (p *storageDomainsServiceAddRequest) MustSend() *storageDomainsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageDomainWriteOne(writer, p.storageDomain, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageDomainsServiceAddResponse{storageDomain: result}
}

//
// Adds a new storage domain.
// Creation of a new <<types/storage_domain,StorageDomain>> requires the `name`, `type`, `host` and `storage`
// attributes. Identify the `host` attribute with the `id` or `name` attributes. In oVirt 3.6 and later you can
// enable the wipe after delete option by default on the storage domain. To configure this, specify
// `wipe_after_delete` in the POST request. This option can be edited after the domain is created, but doing so will
// not change the wipe after delete property of disks that already exist.
// To add a new storage domain with specified `name`, `type`, `storage.type`, `storage.address` and `storage.path`
// and by using a host with an id `123`, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains
// ----
// With a request body as follows:
// [source,xml]
// ----
// <storage_domain>
//   <name>mydata</name>
//   <type>data</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/exports/mydata</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new NFS ISO storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myisos</name>
//   <type>iso</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/export/myisos</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new iSCSI storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myiscsi</name>
//   <type>data</type>
//   <storage>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="3600144f09dbd050000004eedbd340001"/>
//       <logical_unit id="3600144f09dbd050000004eedbd340002"/>
//     </logical_units>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
//
type storageDomainsServiceAddResponse struct {
	storageDomain *StorageDomain
}

func (p *storageDomainsServiceAddResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *storageDomainsServiceAddResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Adds a new storage domain.
// Creation of a new <<types/storage_domain,StorageDomain>> requires the `name`, `type`, `host` and `storage`
// attributes. Identify the `host` attribute with the `id` or `name` attributes. In oVirt 3.6 and later you can
// enable the wipe after delete option by default on the storage domain. To configure this, specify
// `wipe_after_delete` in the POST request. This option can be edited after the domain is created, but doing so will
// not change the wipe after delete property of disks that already exist.
// To add a new storage domain with specified `name`, `type`, `storage.type`, `storage.address` and `storage.path`
// and by using a host with an id `123`, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains
// ----
// With a request body as follows:
// [source,xml]
// ----
// <storage_domain>
//   <name>mydata</name>
//   <type>data</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/exports/mydata</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new NFS ISO storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myisos</name>
//   <type>iso</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/export/myisos</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new iSCSI storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myiscsi</name>
//   <type>data</type>
//   <storage>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="3600144f09dbd050000004eedbd340001"/>
//       <logical_unit id="3600144f09dbd050000004eedbd340002"/>
//     </logical_units>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
//
func (p *storageDomainsService) Add() *storageDomainsServiceAddRequest {
	return &storageDomainsServiceAddRequest{storageDomainsService: p}
}

//
// Import an existing block storage domain to the system using the targets already connected to the host.
//
type storageDomainsServiceAddBlockDomainRequest struct {
	storageDomainsService *storageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *storageDomainsServiceAddBlockDomainRequest) Header(key, value string) *storageDomainsServiceAddBlockDomainRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainsServiceAddBlockDomainRequest) Query(key, value string) *storageDomainsServiceAddBlockDomainRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainsServiceAddBlockDomainRequest) StorageDomain(storageDomain *StorageDomain) *storageDomainsServiceAddBlockDomainRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *storageDomainsServiceAddBlockDomainRequest) Send() (*storageDomainsServiceAddBlockDomainResponse, error) {
	rawURL := fmt.Sprintf("%s%s/blockdomain", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustStorageDomain()
	return &storageDomainsServiceAddBlockDomainResponse{storageDomain: result}, nil
}

func (p *storageDomainsServiceAddBlockDomainRequest) MustSend() *storageDomainsServiceAddBlockDomainResponse {
	rawURL := fmt.Sprintf("%s%s/blockdomain", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustStorageDomain()
	return &storageDomainsServiceAddBlockDomainResponse{storageDomain: result}
}

//
// Import an existing block storage domain to the system using the targets already connected to the host.
//
type storageDomainsServiceAddBlockDomainResponse struct {
	storageDomain *StorageDomain
}

func (p *storageDomainsServiceAddBlockDomainResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *storageDomainsServiceAddBlockDomainResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Import an existing block storage domain to the system using the targets already connected to the host.
//
func (p *storageDomainsService) AddBlockDomain() *storageDomainsServiceAddBlockDomainRequest {
	return &storageDomainsServiceAddBlockDomainRequest{storageDomainsService: p}
}

//
// Add a new storage domain to the system using the storage on the given host and path.
//
type storageDomainsServiceAddByPathRequest struct {
	storageDomainsService *storageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *storageDomainsServiceAddByPathRequest) Header(key, value string) *storageDomainsServiceAddByPathRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainsServiceAddByPathRequest) Query(key, value string) *storageDomainsServiceAddByPathRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainsServiceAddByPathRequest) StorageDomain(storageDomain *StorageDomain) *storageDomainsServiceAddByPathRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *storageDomainsServiceAddByPathRequest) Send() (*storageDomainsServiceAddByPathResponse, error) {
	rawURL := fmt.Sprintf("%s%s/bypath", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustStorageDomain()
	return &storageDomainsServiceAddByPathResponse{storageDomain: result}, nil
}

func (p *storageDomainsServiceAddByPathRequest) MustSend() *storageDomainsServiceAddByPathResponse {
	rawURL := fmt.Sprintf("%s%s/bypath", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustStorageDomain()
	return &storageDomainsServiceAddByPathResponse{storageDomain: result}
}

//
// Add a new storage domain to the system using the storage on the given host and path.
//
type storageDomainsServiceAddByPathResponse struct {
	storageDomain *StorageDomain
}

func (p *storageDomainsServiceAddByPathResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *storageDomainsServiceAddByPathResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Add a new storage domain to the system using the storage on the given host and path.
//
func (p *storageDomainsService) AddByPath() *storageDomainsServiceAddByPathRequest {
	return &storageDomainsServiceAddByPathRequest{storageDomainsService: p}
}

//
// Add a new storage domain to the system using a direct lun.
//
type storageDomainsServiceAddDirectLunRequest struct {
	storageDomainsService *storageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *storageDomainsServiceAddDirectLunRequest) Header(key, value string) *storageDomainsServiceAddDirectLunRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainsServiceAddDirectLunRequest) Query(key, value string) *storageDomainsServiceAddDirectLunRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainsServiceAddDirectLunRequest) StorageDomain(storageDomain *StorageDomain) *storageDomainsServiceAddDirectLunRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *storageDomainsServiceAddDirectLunRequest) Send() (*storageDomainsServiceAddDirectLunResponse, error) {
	rawURL := fmt.Sprintf("%s%s/directlun", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustStorageDomain()
	return &storageDomainsServiceAddDirectLunResponse{storageDomain: result}, nil
}

func (p *storageDomainsServiceAddDirectLunRequest) MustSend() *storageDomainsServiceAddDirectLunResponse {
	rawURL := fmt.Sprintf("%s%s/directlun", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustStorageDomain()
	return &storageDomainsServiceAddDirectLunResponse{storageDomain: result}
}

//
// Add a new storage domain to the system using a direct lun.
//
type storageDomainsServiceAddDirectLunResponse struct {
	storageDomain *StorageDomain
}

func (p *storageDomainsServiceAddDirectLunResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *storageDomainsServiceAddDirectLunResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Add a new storage domain to the system using a direct lun.
//
func (p *storageDomainsService) AddDirectLun() *storageDomainsServiceAddDirectLunRequest {
	return &storageDomainsServiceAddDirectLunRequest{storageDomainsService: p}
}

//
// Add a new storage domain to the system using the gluster or posixfs storage.
//
type storageDomainsServiceAddGlusterOrPostfsRequest struct {
	storageDomainsService *storageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *storageDomainsServiceAddGlusterOrPostfsRequest) Header(key, value string) *storageDomainsServiceAddGlusterOrPostfsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainsServiceAddGlusterOrPostfsRequest) Query(key, value string) *storageDomainsServiceAddGlusterOrPostfsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainsServiceAddGlusterOrPostfsRequest) StorageDomain(storageDomain *StorageDomain) *storageDomainsServiceAddGlusterOrPostfsRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *storageDomainsServiceAddGlusterOrPostfsRequest) Send() (*storageDomainsServiceAddGlusterOrPostfsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/glusterorpostfs", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustStorageDomain()
	return &storageDomainsServiceAddGlusterOrPostfsResponse{storageDomain: result}, nil
}

func (p *storageDomainsServiceAddGlusterOrPostfsRequest) MustSend() *storageDomainsServiceAddGlusterOrPostfsResponse {
	rawURL := fmt.Sprintf("%s%s/glusterorpostfs", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustStorageDomain()
	return &storageDomainsServiceAddGlusterOrPostfsResponse{storageDomain: result}
}

//
// Add a new storage domain to the system using the gluster or posixfs storage.
//
type storageDomainsServiceAddGlusterOrPostfsResponse struct {
	storageDomain *StorageDomain
}

func (p *storageDomainsServiceAddGlusterOrPostfsResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *storageDomainsServiceAddGlusterOrPostfsResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Add a new storage domain to the system using the gluster or posixfs storage.
//
func (p *storageDomainsService) AddGlusterOrPostfs() *storageDomainsServiceAddGlusterOrPostfsRequest {
	return &storageDomainsServiceAddGlusterOrPostfsRequest{storageDomainsService: p}
}

//
// Returns the list of storage domains of the system.
// The order of the returned list of storage domains is guaranteed only if the `sortby` clause is included
// in the `search` parameter.
//
type storageDomainsServiceListRequest struct {
	storageDomainsService *storageDomainsService
	header                map[string]string
	query                 map[string]string
	caseSensitive         *bool
	filter                *bool
	follow                *string
	max                   *int64
	search                *string
}

func (p *storageDomainsServiceListRequest) Header(key, value string) *storageDomainsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainsServiceListRequest) Query(key, value string) *storageDomainsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainsServiceListRequest) CaseSensitive(caseSensitive bool) *storageDomainsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *storageDomainsServiceListRequest) Filter(filter bool) *storageDomainsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *storageDomainsServiceListRequest) Follow(follow string) *storageDomainsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainsServiceListRequest) Max(max int64) *storageDomainsServiceListRequest {
	p.max = &max
	return p
}

func (p *storageDomainsServiceListRequest) Search(search string) *storageDomainsServiceListRequest {
	p.search = &search
	return p
}

func (p *storageDomainsServiceListRequest) Send() (*storageDomainsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &storageDomainsServiceListResponse{storageDomains: result}, nil
}

func (p *storageDomainsServiceListRequest) MustSend() *storageDomainsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &storageDomainsServiceListResponse{storageDomains: result}
}

//
// Returns the list of storage domains of the system.
// The order of the returned list of storage domains is guaranteed only if the `sortby` clause is included
// in the `search` parameter.
//
type storageDomainsServiceListResponse struct {
	storageDomains *StorageDomainSlice
}

func (p *storageDomainsServiceListResponse) StorageDomains() (*StorageDomainSlice, bool) {
	if p.storageDomains != nil {
		return p.storageDomains, true
	}
	return nil, false
}

func (p *storageDomainsServiceListResponse) MustStorageDomains() *StorageDomainSlice {
	if p.storageDomains == nil {
		panic("storageDomains in response does not exist")
	}
	return p.storageDomains
}

//
// Returns the list of storage domains of the system.
// The order of the returned list of storage domains is guaranteed only if the `sortby` clause is included
// in the `search` parameter.
//
func (p *storageDomainsService) List() *storageDomainsServiceListRequest {
	return &storageDomainsServiceListRequest{storageDomainsService: p}
}

//
// Add a new storage domain to the system using the storage on the localhost at the given path.
//
type storageDomainsServiceAddLocalRequest struct {
	storageDomainsService *storageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *storageDomainsServiceAddLocalRequest) Header(key, value string) *storageDomainsServiceAddLocalRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainsServiceAddLocalRequest) Query(key, value string) *storageDomainsServiceAddLocalRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainsServiceAddLocalRequest) StorageDomain(storageDomain *StorageDomain) *storageDomainsServiceAddLocalRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *storageDomainsServiceAddLocalRequest) Send() (*storageDomainsServiceAddLocalResponse, error) {
	rawURL := fmt.Sprintf("%s%s/local", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustStorageDomain()
	return &storageDomainsServiceAddLocalResponse{storageDomain: result}, nil
}

func (p *storageDomainsServiceAddLocalRequest) MustSend() *storageDomainsServiceAddLocalResponse {
	rawURL := fmt.Sprintf("%s%s/local", p.storageDomainsService.connection.URL(), p.storageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustStorageDomain()
	return &storageDomainsServiceAddLocalResponse{storageDomain: result}
}

//
// Add a new storage domain to the system using the storage on the localhost at the given path.
//
type storageDomainsServiceAddLocalResponse struct {
	storageDomain *StorageDomain
}

func (p *storageDomainsServiceAddLocalResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *storageDomainsServiceAddLocalResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Add a new storage domain to the system using the storage on the localhost at the given path.
//
func (p *storageDomainsService) AddLocal() *storageDomainsServiceAddLocalRequest {
	return &storageDomainsServiceAddLocalRequest{storageDomainsService: p}
}

//
//
func (op *storageDomainsService) StorageDomainService(id string) *storageDomainService {
	return NewStorageDomainService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StorageDomainService(path), nil
	}
	return op.StorageDomainService(path[:index]).Service(path[index+1:])
}

func (op *storageDomainsService) String() string {
	return fmt.Sprintf("storageDomainsService:%s", op.path)
}

//
// Provides information about the additional features that are enabled for this cluster.
// The features that are enabled are the available features for the cluster level
//
type clusterEnabledFeaturesService struct {
	baseService
}

func NewClusterEnabledFeaturesService(connection *Connection, path string) *clusterEnabledFeaturesService {
	var result clusterEnabledFeaturesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Enable an additional feature for a cluster.
// For example, to enable a feature `456` on cluster `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/enabledfeatures
// ----
// The request body should look like this:
// [source,xml]
// ----
// <cluster_feature id="456"/>
// ----
//
type clusterEnabledFeaturesServiceAddRequest struct {
	clusterEnabledFeaturesService *clusterEnabledFeaturesService
	header                        map[string]string
	query                         map[string]string
	feature                       *ClusterFeature
}

func (p *clusterEnabledFeaturesServiceAddRequest) Header(key, value string) *clusterEnabledFeaturesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterEnabledFeaturesServiceAddRequest) Query(key, value string) *clusterEnabledFeaturesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterEnabledFeaturesServiceAddRequest) Feature(feature *ClusterFeature) *clusterEnabledFeaturesServiceAddRequest {
	p.feature = feature
	return p
}

func (p *clusterEnabledFeaturesServiceAddRequest) Send() (*clusterEnabledFeaturesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterEnabledFeaturesService.connection.URL(), p.clusterEnabledFeaturesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLClusterFeatureWriteOne(writer, p.feature, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterEnabledFeaturesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterEnabledFeaturesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &clusterEnabledFeaturesServiceAddResponse{feature: result}, nil
}

func (p *clusterEnabledFeaturesServiceAddRequest) MustSend() *clusterEnabledFeaturesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterEnabledFeaturesService.connection.URL(), p.clusterEnabledFeaturesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLClusterFeatureWriteOne(writer, p.feature, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterEnabledFeaturesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterEnabledFeaturesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &clusterEnabledFeaturesServiceAddResponse{feature: result}
}

//
// Enable an additional feature for a cluster.
// For example, to enable a feature `456` on cluster `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/enabledfeatures
// ----
// The request body should look like this:
// [source,xml]
// ----
// <cluster_feature id="456"/>
// ----
//
type clusterEnabledFeaturesServiceAddResponse struct {
	feature *ClusterFeature
}

func (p *clusterEnabledFeaturesServiceAddResponse) Feature() (*ClusterFeature, bool) {
	if p.feature != nil {
		return p.feature, true
	}
	return nil, false
}

func (p *clusterEnabledFeaturesServiceAddResponse) MustFeature() *ClusterFeature {
	if p.feature == nil {
		panic("feature in response does not exist")
	}
	return p.feature
}

//
// Enable an additional feature for a cluster.
// For example, to enable a feature `456` on cluster `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/enabledfeatures
// ----
// The request body should look like this:
// [source,xml]
// ----
// <cluster_feature id="456"/>
// ----
//
func (p *clusterEnabledFeaturesService) Add() *clusterEnabledFeaturesServiceAddRequest {
	return &clusterEnabledFeaturesServiceAddRequest{clusterEnabledFeaturesService: p}
}

//
// Lists the additional features enabled for the cluster.
// For example, to get the features enabled for cluster `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123/enabledfeatures
// ----
// This will return a list of features:
// [source,xml]
// ----
// <enabled_features>
//   <cluster_feature id="123">
//      <name>test_feature</name>
//   </cluster_feature>
//   ...
// </enabled_features>
// ----
//
type clusterEnabledFeaturesServiceListRequest struct {
	clusterEnabledFeaturesService *clusterEnabledFeaturesService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
}

func (p *clusterEnabledFeaturesServiceListRequest) Header(key, value string) *clusterEnabledFeaturesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterEnabledFeaturesServiceListRequest) Query(key, value string) *clusterEnabledFeaturesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterEnabledFeaturesServiceListRequest) Follow(follow string) *clusterEnabledFeaturesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *clusterEnabledFeaturesServiceListRequest) Send() (*clusterEnabledFeaturesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterEnabledFeaturesService.connection.URL(), p.clusterEnabledFeaturesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterEnabledFeaturesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterEnabledFeaturesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &clusterEnabledFeaturesServiceListResponse{features: result}, nil
}

func (p *clusterEnabledFeaturesServiceListRequest) MustSend() *clusterEnabledFeaturesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterEnabledFeaturesService.connection.URL(), p.clusterEnabledFeaturesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterEnabledFeaturesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterEnabledFeaturesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &clusterEnabledFeaturesServiceListResponse{features: result}
}

//
// Lists the additional features enabled for the cluster.
// For example, to get the features enabled for cluster `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123/enabledfeatures
// ----
// This will return a list of features:
// [source,xml]
// ----
// <enabled_features>
//   <cluster_feature id="123">
//      <name>test_feature</name>
//   </cluster_feature>
//   ...
// </enabled_features>
// ----
//
type clusterEnabledFeaturesServiceListResponse struct {
	features *ClusterFeatureSlice
}

func (p *clusterEnabledFeaturesServiceListResponse) Features() (*ClusterFeatureSlice, bool) {
	if p.features != nil {
		return p.features, true
	}
	return nil, false
}

func (p *clusterEnabledFeaturesServiceListResponse) MustFeatures() *ClusterFeatureSlice {
	if p.features == nil {
		panic("features in response does not exist")
	}
	return p.features
}

//
// Lists the additional features enabled for the cluster.
// For example, to get the features enabled for cluster `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123/enabledfeatures
// ----
// This will return a list of features:
// [source,xml]
// ----
// <enabled_features>
//   <cluster_feature id="123">
//      <name>test_feature</name>
//   </cluster_feature>
//   ...
// </enabled_features>
// ----
//
func (p *clusterEnabledFeaturesService) List() *clusterEnabledFeaturesServiceListRequest {
	return &clusterEnabledFeaturesServiceListRequest{clusterEnabledFeaturesService: p}
}

//
// A reference to the service that provides information about a specific
// feature enabled for the cluster.
//
func (op *clusterEnabledFeaturesService) FeatureService(id string) *clusterEnabledFeatureService {
	return NewClusterEnabledFeatureService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *clusterEnabledFeaturesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.FeatureService(path), nil
	}
	return op.FeatureService(path[:index]).Service(path[index+1:])
}

func (op *clusterEnabledFeaturesService) String() string {
	return fmt.Sprintf("clusterEnabledFeaturesService:%s", op.path)
}

//
//
type snapshotCdromService struct {
	baseService
}

func NewSnapshotCdromService(connection *Connection, path string) *snapshotCdromService {
	var result snapshotCdromService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type snapshotCdromServiceGetRequest struct {
	snapshotCdromService *snapshotCdromService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *snapshotCdromServiceGetRequest) Header(key, value string) *snapshotCdromServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *snapshotCdromServiceGetRequest) Query(key, value string) *snapshotCdromServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *snapshotCdromServiceGetRequest) Follow(follow string) *snapshotCdromServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *snapshotCdromServiceGetRequest) Send() (*snapshotCdromServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotCdromService.connection.URL(), p.snapshotCdromService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotCdromService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotCdromService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &snapshotCdromServiceGetResponse{cdrom: result}, nil
}

func (p *snapshotCdromServiceGetRequest) MustSend() *snapshotCdromServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.snapshotCdromService.connection.URL(), p.snapshotCdromService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotCdromService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotCdromService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &snapshotCdromServiceGetResponse{cdrom: result}
}

//
//
type snapshotCdromServiceGetResponse struct {
	cdrom *Cdrom
}

func (p *snapshotCdromServiceGetResponse) Cdrom() (*Cdrom, bool) {
	if p.cdrom != nil {
		return p.cdrom, true
	}
	return nil, false
}

func (p *snapshotCdromServiceGetResponse) MustCdrom() *Cdrom {
	if p.cdrom == nil {
		panic("cdrom in response does not exist")
	}
	return p.cdrom
}

//
//
func (p *snapshotCdromService) Get() *snapshotCdromServiceGetRequest {
	return &snapshotCdromServiceGetRequest{snapshotCdromService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *snapshotCdromService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *snapshotCdromService) String() string {
	return fmt.Sprintf("snapshotCdromService:%s", op.path)
}

//
// Manages the set of quota limits configured for a cluster.
//
type quotaClusterLimitsService struct {
	baseService
}

func NewQuotaClusterLimitsService(connection *Connection, path string) *quotaClusterLimitsService {
	var result quotaClusterLimitsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a cluster limit to a specified Quota.
//
type quotaClusterLimitsServiceAddRequest struct {
	quotaClusterLimitsService *quotaClusterLimitsService
	header                    map[string]string
	query                     map[string]string
	limit                     *QuotaClusterLimit
}

func (p *quotaClusterLimitsServiceAddRequest) Header(key, value string) *quotaClusterLimitsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotaClusterLimitsServiceAddRequest) Query(key, value string) *quotaClusterLimitsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotaClusterLimitsServiceAddRequest) Limit(limit *QuotaClusterLimit) *quotaClusterLimitsServiceAddRequest {
	p.limit = limit
	return p
}

func (p *quotaClusterLimitsServiceAddRequest) Send() (*quotaClusterLimitsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitsService.connection.URL(), p.quotaClusterLimitsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQuotaClusterLimitWriteOne(writer, p.limit, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaClusterLimitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaClusterLimitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &quotaClusterLimitsServiceAddResponse{limit: result}, nil
}

func (p *quotaClusterLimitsServiceAddRequest) MustSend() *quotaClusterLimitsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitsService.connection.URL(), p.quotaClusterLimitsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQuotaClusterLimitWriteOne(writer, p.limit, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaClusterLimitsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaClusterLimitReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &quotaClusterLimitsServiceAddResponse{limit: result}
}

//
// Add a cluster limit to a specified Quota.
//
type quotaClusterLimitsServiceAddResponse struct {
	limit *QuotaClusterLimit
}

func (p *quotaClusterLimitsServiceAddResponse) Limit() (*QuotaClusterLimit, bool) {
	if p.limit != nil {
		return p.limit, true
	}
	return nil, false
}

func (p *quotaClusterLimitsServiceAddResponse) MustLimit() *QuotaClusterLimit {
	if p.limit == nil {
		panic("limit in response does not exist")
	}
	return p.limit
}

//
// Add a cluster limit to a specified Quota.
//
func (p *quotaClusterLimitsService) Add() *quotaClusterLimitsServiceAddRequest {
	return &quotaClusterLimitsServiceAddRequest{quotaClusterLimitsService: p}
}

//
// Returns the set of quota limits configured for the cluster.
// The returned list of quota limits isn't guaranteed.
//
type quotaClusterLimitsServiceListRequest struct {
	quotaClusterLimitsService *quotaClusterLimitsService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
}

func (p *quotaClusterLimitsServiceListRequest) Header(key, value string) *quotaClusterLimitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotaClusterLimitsServiceListRequest) Query(key, value string) *quotaClusterLimitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotaClusterLimitsServiceListRequest) Follow(follow string) *quotaClusterLimitsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *quotaClusterLimitsServiceListRequest) Max(max int64) *quotaClusterLimitsServiceListRequest {
	p.max = &max
	return p
}

func (p *quotaClusterLimitsServiceListRequest) Send() (*quotaClusterLimitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitsService.connection.URL(), p.quotaClusterLimitsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaClusterLimitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaClusterLimitReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &quotaClusterLimitsServiceListResponse{limits: result}, nil
}

func (p *quotaClusterLimitsServiceListRequest) MustSend() *quotaClusterLimitsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotaClusterLimitsService.connection.URL(), p.quotaClusterLimitsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaClusterLimitsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaClusterLimitsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaClusterLimitReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &quotaClusterLimitsServiceListResponse{limits: result}
}

//
// Returns the set of quota limits configured for the cluster.
// The returned list of quota limits isn't guaranteed.
//
type quotaClusterLimitsServiceListResponse struct {
	limits *QuotaClusterLimitSlice
}

func (p *quotaClusterLimitsServiceListResponse) Limits() (*QuotaClusterLimitSlice, bool) {
	if p.limits != nil {
		return p.limits, true
	}
	return nil, false
}

func (p *quotaClusterLimitsServiceListResponse) MustLimits() *QuotaClusterLimitSlice {
	if p.limits == nil {
		panic("limits in response does not exist")
	}
	return p.limits
}

//
// Returns the set of quota limits configured for the cluster.
// The returned list of quota limits isn't guaranteed.
//
func (p *quotaClusterLimitsService) List() *quotaClusterLimitsServiceListRequest {
	return &quotaClusterLimitsServiceListRequest{quotaClusterLimitsService: p}
}

//
//
func (op *quotaClusterLimitsService) LimitService(id string) *quotaClusterLimitService {
	return NewQuotaClusterLimitService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *quotaClusterLimitsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LimitService(path), nil
	}
	return op.LimitService(path[:index]).Service(path[index+1:])
}

func (op *quotaClusterLimitsService) String() string {
	return fmt.Sprintf("quotaClusterLimitsService:%s", op.path)
}

//
// A service to manage fence agents for a specific host.
//
type fenceAgentsService struct {
	baseService
}

func NewFenceAgentsService(connection *Connection, path string) *fenceAgentsService {
	var result fenceAgentsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new fencing-agent to the host.
//
type fenceAgentsServiceAddRequest struct {
	fenceAgentsService *fenceAgentsService
	header             map[string]string
	query              map[string]string
	agent              *Agent
}

func (p *fenceAgentsServiceAddRequest) Header(key, value string) *fenceAgentsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *fenceAgentsServiceAddRequest) Query(key, value string) *fenceAgentsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *fenceAgentsServiceAddRequest) Agent(agent *Agent) *fenceAgentsServiceAddRequest {
	p.agent = agent
	return p
}

func (p *fenceAgentsServiceAddRequest) Send() (*fenceAgentsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentsService.connection.URL(), p.fenceAgentsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAgentWriteOne(writer, p.agent, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.fenceAgentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.fenceAgentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAgentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &fenceAgentsServiceAddResponse{agent: result}, nil
}

func (p *fenceAgentsServiceAddRequest) MustSend() *fenceAgentsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentsService.connection.URL(), p.fenceAgentsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAgentWriteOne(writer, p.agent, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.fenceAgentsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.fenceAgentsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAgentReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &fenceAgentsServiceAddResponse{agent: result}
}

//
// Add a new fencing-agent to the host.
//
type fenceAgentsServiceAddResponse struct {
	agent *Agent
}

func (p *fenceAgentsServiceAddResponse) Agent() (*Agent, bool) {
	if p.agent != nil {
		return p.agent, true
	}
	return nil, false
}

func (p *fenceAgentsServiceAddResponse) MustAgent() *Agent {
	if p.agent == nil {
		panic("agent in response does not exist")
	}
	return p.agent
}

//
// Add a new fencing-agent to the host.
//
func (p *fenceAgentsService) Add() *fenceAgentsServiceAddRequest {
	return &fenceAgentsServiceAddRequest{fenceAgentsService: p}
}

//
// Returns the list of fencing agents configured for the host.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/fenceagents
// ----
// And here is sample response:
// [source,xml]
// ----
// <agents>
//   <agent id="0">
//     <type>apc</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <port>9</port>
//     <options>name1=value1, name2=value2</options>
//   </agent>
// </agents>
// ----
// The order of the returned list of fencing agents isn't guaranteed.
//
type fenceAgentsServiceListRequest struct {
	fenceAgentsService *fenceAgentsService
	header             map[string]string
	query              map[string]string
	follow             *string
	max                *int64
}

func (p *fenceAgentsServiceListRequest) Header(key, value string) *fenceAgentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *fenceAgentsServiceListRequest) Query(key, value string) *fenceAgentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *fenceAgentsServiceListRequest) Follow(follow string) *fenceAgentsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *fenceAgentsServiceListRequest) Max(max int64) *fenceAgentsServiceListRequest {
	p.max = &max
	return p
}

func (p *fenceAgentsServiceListRequest) Send() (*fenceAgentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentsService.connection.URL(), p.fenceAgentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.fenceAgentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.fenceAgentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAgentReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &fenceAgentsServiceListResponse{agents: result}, nil
}

func (p *fenceAgentsServiceListRequest) MustSend() *fenceAgentsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentsService.connection.URL(), p.fenceAgentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.fenceAgentsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.fenceAgentsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAgentReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &fenceAgentsServiceListResponse{agents: result}
}

//
// Returns the list of fencing agents configured for the host.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/fenceagents
// ----
// And here is sample response:
// [source,xml]
// ----
// <agents>
//   <agent id="0">
//     <type>apc</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <port>9</port>
//     <options>name1=value1, name2=value2</options>
//   </agent>
// </agents>
// ----
// The order of the returned list of fencing agents isn't guaranteed.
//
type fenceAgentsServiceListResponse struct {
	agents *AgentSlice
}

func (p *fenceAgentsServiceListResponse) Agents() (*AgentSlice, bool) {
	if p.agents != nil {
		return p.agents, true
	}
	return nil, false
}

func (p *fenceAgentsServiceListResponse) MustAgents() *AgentSlice {
	if p.agents == nil {
		panic("agents in response does not exist")
	}
	return p.agents
}

//
// Returns the list of fencing agents configured for the host.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/fenceagents
// ----
// And here is sample response:
// [source,xml]
// ----
// <agents>
//   <agent id="0">
//     <type>apc</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <port>9</port>
//     <options>name1=value1, name2=value2</options>
//   </agent>
// </agents>
// ----
// The order of the returned list of fencing agents isn't guaranteed.
//
func (p *fenceAgentsService) List() *fenceAgentsServiceListRequest {
	return &fenceAgentsServiceListRequest{fenceAgentsService: p}
}

//
// Reference to service that manages a specific fence agent
// for this host.
//
func (op *fenceAgentsService) AgentService(id string) *fenceAgentService {
	return NewFenceAgentService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *fenceAgentsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.AgentService(path), nil
	}
	return op.AgentService(path[:index]).Service(path[index+1:])
}

func (op *fenceAgentsService) String() string {
	return fmt.Sprintf("fenceAgentsService:%s", op.path)
}

//
//
type instanceTypeWatchdogService struct {
	baseService
}

func NewInstanceTypeWatchdogService(connection *Connection, path string) *instanceTypeWatchdogService {
	var result instanceTypeWatchdogService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets watchdog configuration of the instance type.
//
type instanceTypeWatchdogServiceGetRequest struct {
	instanceTypeWatchdogService *instanceTypeWatchdogService
	header                      map[string]string
	query                       map[string]string
	follow                      *string
}

func (p *instanceTypeWatchdogServiceGetRequest) Header(key, value string) *instanceTypeWatchdogServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeWatchdogServiceGetRequest) Query(key, value string) *instanceTypeWatchdogServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeWatchdogServiceGetRequest) Follow(follow string) *instanceTypeWatchdogServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *instanceTypeWatchdogServiceGetRequest) Send() (*instanceTypeWatchdogServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogService.connection.URL(), p.instanceTypeWatchdogService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &instanceTypeWatchdogServiceGetResponse{watchdog: result}, nil
}

func (p *instanceTypeWatchdogServiceGetRequest) MustSend() *instanceTypeWatchdogServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogService.connection.URL(), p.instanceTypeWatchdogService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeWatchdogService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &instanceTypeWatchdogServiceGetResponse{watchdog: result}
}

//
// Gets watchdog configuration of the instance type.
//
type instanceTypeWatchdogServiceGetResponse struct {
	watchdog *Watchdog
}

func (p *instanceTypeWatchdogServiceGetResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *instanceTypeWatchdogServiceGetResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Gets watchdog configuration of the instance type.
//
func (p *instanceTypeWatchdogService) Get() *instanceTypeWatchdogServiceGetRequest {
	return &instanceTypeWatchdogServiceGetRequest{instanceTypeWatchdogService: p}
}

//
// Remove a watchdog from the instance type.
//
type instanceTypeWatchdogServiceRemoveRequest struct {
	instanceTypeWatchdogService *instanceTypeWatchdogService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *instanceTypeWatchdogServiceRemoveRequest) Header(key, value string) *instanceTypeWatchdogServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeWatchdogServiceRemoveRequest) Query(key, value string) *instanceTypeWatchdogServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeWatchdogServiceRemoveRequest) Async(async bool) *instanceTypeWatchdogServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *instanceTypeWatchdogServiceRemoveRequest) Send() (*instanceTypeWatchdogServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogService.connection.URL(), p.instanceTypeWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(instanceTypeWatchdogServiceRemoveResponse), nil
}

func (p *instanceTypeWatchdogServiceRemoveRequest) MustSend() *instanceTypeWatchdogServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogService.connection.URL(), p.instanceTypeWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeWatchdogService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(instanceTypeWatchdogServiceRemoveResponse)
}

//
// Remove a watchdog from the instance type.
//
type instanceTypeWatchdogServiceRemoveResponse struct {
}

//
// Remove a watchdog from the instance type.
//
func (p *instanceTypeWatchdogService) Remove() *instanceTypeWatchdogServiceRemoveRequest {
	return &instanceTypeWatchdogServiceRemoveRequest{instanceTypeWatchdogService: p}
}

//
// Updates the watchdog configuration of the instance type.
//
type instanceTypeWatchdogServiceUpdateRequest struct {
	instanceTypeWatchdogService *instanceTypeWatchdogService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
	watchdog                    *Watchdog
}

func (p *instanceTypeWatchdogServiceUpdateRequest) Header(key, value string) *instanceTypeWatchdogServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeWatchdogServiceUpdateRequest) Query(key, value string) *instanceTypeWatchdogServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeWatchdogServiceUpdateRequest) Async(async bool) *instanceTypeWatchdogServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *instanceTypeWatchdogServiceUpdateRequest) Watchdog(watchdog *Watchdog) *instanceTypeWatchdogServiceUpdateRequest {
	p.watchdog = watchdog
	return p
}

func (p *instanceTypeWatchdogServiceUpdateRequest) Send() (*instanceTypeWatchdogServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogService.connection.URL(), p.instanceTypeWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &instanceTypeWatchdogServiceUpdateResponse{watchdog: result}, nil
}

func (p *instanceTypeWatchdogServiceUpdateRequest) MustSend() *instanceTypeWatchdogServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogService.connection.URL(), p.instanceTypeWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeWatchdogService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &instanceTypeWatchdogServiceUpdateResponse{watchdog: result}
}

//
// Updates the watchdog configuration of the instance type.
//
type instanceTypeWatchdogServiceUpdateResponse struct {
	watchdog *Watchdog
}

func (p *instanceTypeWatchdogServiceUpdateResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *instanceTypeWatchdogServiceUpdateResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Updates the watchdog configuration of the instance type.
//
func (p *instanceTypeWatchdogService) Update() *instanceTypeWatchdogServiceUpdateRequest {
	return &instanceTypeWatchdogServiceUpdateRequest{instanceTypeWatchdogService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *instanceTypeWatchdogService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *instanceTypeWatchdogService) String() string {
	return fmt.Sprintf("instanceTypeWatchdogService:%s", op.path)
}

//
// Represents a permission sub-collection, scoped by user, group or some entity type.
//
type assignedPermissionsService struct {
	baseService
}

func NewAssignedPermissionsService(connection *Connection, path string) *assignedPermissionsService {
	var result assignedPermissionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
//
type assignedPermissionsServiceAddRequest struct {
	assignedPermissionsService *assignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *assignedPermissionsServiceAddRequest) Header(key, value string) *assignedPermissionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedPermissionsServiceAddRequest) Query(key, value string) *assignedPermissionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedPermissionsServiceAddRequest) Permission(permission *Permission) *assignedPermissionsServiceAddRequest {
	p.permission = permission
	return p
}

func (p *assignedPermissionsServiceAddRequest) Send() (*assignedPermissionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLPermissionWriteOne(writer, p.permission, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &assignedPermissionsServiceAddResponse{permission: result}, nil
}

func (p *assignedPermissionsServiceAddRequest) MustSend() *assignedPermissionsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLPermissionWriteOne(writer, p.permission, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &assignedPermissionsServiceAddResponse{permission: result}
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
//
type assignedPermissionsServiceAddResponse struct {
	permission *Permission
}

func (p *assignedPermissionsServiceAddResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *assignedPermissionsServiceAddResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
//
func (p *assignedPermissionsService) Add() *assignedPermissionsServiceAddRequest {
	return &assignedPermissionsServiceAddRequest{assignedPermissionsService: p}
}

//
// Add a new permission on the cluster to the group in the system.
//
type assignedPermissionsServiceAddClusterPermissionRequest struct {
	assignedPermissionsService *assignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *assignedPermissionsServiceAddClusterPermissionRequest) Header(key, value string) *assignedPermissionsServiceAddClusterPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedPermissionsServiceAddClusterPermissionRequest) Query(key, value string) *assignedPermissionsServiceAddClusterPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedPermissionsServiceAddClusterPermissionRequest) Permission(permission *Permission) *assignedPermissionsServiceAddClusterPermissionRequest {
	p.permission = permission
	return p
}

func (p *assignedPermissionsServiceAddClusterPermissionRequest) Send() (*assignedPermissionsServiceAddClusterPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/clusterpermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddClusterPermissionResponse{permission: result}, nil
}

func (p *assignedPermissionsServiceAddClusterPermissionRequest) MustSend() *assignedPermissionsServiceAddClusterPermissionResponse {
	rawURL := fmt.Sprintf("%s%s/clusterpermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddClusterPermissionResponse{permission: result}
}

//
// Add a new permission on the cluster to the group in the system.
//
type assignedPermissionsServiceAddClusterPermissionResponse struct {
	permission *Permission
}

func (p *assignedPermissionsServiceAddClusterPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *assignedPermissionsServiceAddClusterPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the cluster to the group in the system.
//
func (p *assignedPermissionsService) AddClusterPermission() *assignedPermissionsServiceAddClusterPermissionRequest {
	return &assignedPermissionsServiceAddClusterPermissionRequest{assignedPermissionsService: p}
}

//
// Add a new permission on the data center to the group in the system.
//
type assignedPermissionsServiceAddDataCenterPermissionRequest struct {
	assignedPermissionsService *assignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *assignedPermissionsServiceAddDataCenterPermissionRequest) Header(key, value string) *assignedPermissionsServiceAddDataCenterPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedPermissionsServiceAddDataCenterPermissionRequest) Query(key, value string) *assignedPermissionsServiceAddDataCenterPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedPermissionsServiceAddDataCenterPermissionRequest) Permission(permission *Permission) *assignedPermissionsServiceAddDataCenterPermissionRequest {
	p.permission = permission
	return p
}

func (p *assignedPermissionsServiceAddDataCenterPermissionRequest) Send() (*assignedPermissionsServiceAddDataCenterPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/datacenterpermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddDataCenterPermissionResponse{permission: result}, nil
}

func (p *assignedPermissionsServiceAddDataCenterPermissionRequest) MustSend() *assignedPermissionsServiceAddDataCenterPermissionResponse {
	rawURL := fmt.Sprintf("%s%s/datacenterpermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddDataCenterPermissionResponse{permission: result}
}

//
// Add a new permission on the data center to the group in the system.
//
type assignedPermissionsServiceAddDataCenterPermissionResponse struct {
	permission *Permission
}

func (p *assignedPermissionsServiceAddDataCenterPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *assignedPermissionsServiceAddDataCenterPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the data center to the group in the system.
//
func (p *assignedPermissionsService) AddDataCenterPermission() *assignedPermissionsServiceAddDataCenterPermissionRequest {
	return &assignedPermissionsServiceAddDataCenterPermissionRequest{assignedPermissionsService: p}
}

//
// Add a new group level permission for a given virtual machine.
//
type assignedPermissionsServiceAddGroupLevelRequest struct {
	assignedPermissionsService *assignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *assignedPermissionsServiceAddGroupLevelRequest) Header(key, value string) *assignedPermissionsServiceAddGroupLevelRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedPermissionsServiceAddGroupLevelRequest) Query(key, value string) *assignedPermissionsServiceAddGroupLevelRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedPermissionsServiceAddGroupLevelRequest) Permission(permission *Permission) *assignedPermissionsServiceAddGroupLevelRequest {
	p.permission = permission
	return p
}

func (p *assignedPermissionsServiceAddGroupLevelRequest) Send() (*assignedPermissionsServiceAddGroupLevelResponse, error) {
	rawURL := fmt.Sprintf("%s%s/grouplevel", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddGroupLevelResponse{permission: result}, nil
}

func (p *assignedPermissionsServiceAddGroupLevelRequest) MustSend() *assignedPermissionsServiceAddGroupLevelResponse {
	rawURL := fmt.Sprintf("%s%s/grouplevel", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddGroupLevelResponse{permission: result}
}

//
// Add a new group level permission for a given virtual machine.
//
type assignedPermissionsServiceAddGroupLevelResponse struct {
	permission *Permission
}

func (p *assignedPermissionsServiceAddGroupLevelResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *assignedPermissionsServiceAddGroupLevelResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new group level permission for a given virtual machine.
//
func (p *assignedPermissionsService) AddGroupLevel() *assignedPermissionsServiceAddGroupLevelRequest {
	return &assignedPermissionsServiceAddGroupLevelRequest{assignedPermissionsService: p}
}

//
// Add a new permission on the host to the group in the system.
//
type assignedPermissionsServiceAddHostPermissionRequest struct {
	assignedPermissionsService *assignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *assignedPermissionsServiceAddHostPermissionRequest) Header(key, value string) *assignedPermissionsServiceAddHostPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedPermissionsServiceAddHostPermissionRequest) Query(key, value string) *assignedPermissionsServiceAddHostPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedPermissionsServiceAddHostPermissionRequest) Permission(permission *Permission) *assignedPermissionsServiceAddHostPermissionRequest {
	p.permission = permission
	return p
}

func (p *assignedPermissionsServiceAddHostPermissionRequest) Send() (*assignedPermissionsServiceAddHostPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/hostpermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddHostPermissionResponse{permission: result}, nil
}

func (p *assignedPermissionsServiceAddHostPermissionRequest) MustSend() *assignedPermissionsServiceAddHostPermissionResponse {
	rawURL := fmt.Sprintf("%s%s/hostpermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddHostPermissionResponse{permission: result}
}

//
// Add a new permission on the host to the group in the system.
//
type assignedPermissionsServiceAddHostPermissionResponse struct {
	permission *Permission
}

func (p *assignedPermissionsServiceAddHostPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *assignedPermissionsServiceAddHostPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the host to the group in the system.
//
func (p *assignedPermissionsService) AddHostPermission() *assignedPermissionsServiceAddHostPermissionRequest {
	return &assignedPermissionsServiceAddHostPermissionRequest{assignedPermissionsService: p}
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
// The order of the returned permissions isn't guaranteed.
//
type assignedPermissionsServiceListRequest struct {
	assignedPermissionsService *assignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	follow                     *string
}

func (p *assignedPermissionsServiceListRequest) Header(key, value string) *assignedPermissionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedPermissionsServiceListRequest) Query(key, value string) *assignedPermissionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedPermissionsServiceListRequest) Follow(follow string) *assignedPermissionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *assignedPermissionsServiceListRequest) Send() (*assignedPermissionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &assignedPermissionsServiceListResponse{permissions: result}, nil
}

func (p *assignedPermissionsServiceListRequest) MustSend() *assignedPermissionsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &assignedPermissionsServiceListResponse{permissions: result}
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
// The order of the returned permissions isn't guaranteed.
//
type assignedPermissionsServiceListResponse struct {
	permissions *PermissionSlice
}

func (p *assignedPermissionsServiceListResponse) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *assignedPermissionsServiceListResponse) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("permissions in response does not exist")
	}
	return p.permissions
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
// The order of the returned permissions isn't guaranteed.
//
func (p *assignedPermissionsService) List() *assignedPermissionsServiceListRequest {
	return &assignedPermissionsServiceListRequest{assignedPermissionsService: p}
}

//
// Add a new permission on the storage domain to the group in the system.
//
type assignedPermissionsServiceAddStorageDomainPermissionRequest struct {
	assignedPermissionsService *assignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *assignedPermissionsServiceAddStorageDomainPermissionRequest) Header(key, value string) *assignedPermissionsServiceAddStorageDomainPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedPermissionsServiceAddStorageDomainPermissionRequest) Query(key, value string) *assignedPermissionsServiceAddStorageDomainPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedPermissionsServiceAddStorageDomainPermissionRequest) Permission(permission *Permission) *assignedPermissionsServiceAddStorageDomainPermissionRequest {
	p.permission = permission
	return p
}

func (p *assignedPermissionsServiceAddStorageDomainPermissionRequest) Send() (*assignedPermissionsServiceAddStorageDomainPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/storagedomainpermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddStorageDomainPermissionResponse{permission: result}, nil
}

func (p *assignedPermissionsServiceAddStorageDomainPermissionRequest) MustSend() *assignedPermissionsServiceAddStorageDomainPermissionResponse {
	rawURL := fmt.Sprintf("%s%s/storagedomainpermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddStorageDomainPermissionResponse{permission: result}
}

//
// Add a new permission on the storage domain to the group in the system.
//
type assignedPermissionsServiceAddStorageDomainPermissionResponse struct {
	permission *Permission
}

func (p *assignedPermissionsServiceAddStorageDomainPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *assignedPermissionsServiceAddStorageDomainPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the storage domain to the group in the system.
//
func (p *assignedPermissionsService) AddStorageDomainPermission() *assignedPermissionsServiceAddStorageDomainPermissionRequest {
	return &assignedPermissionsServiceAddStorageDomainPermissionRequest{assignedPermissionsService: p}
}

//
// Add a new permission on the template to the group in the system.
//
type assignedPermissionsServiceAddTemplatePermissionRequest struct {
	assignedPermissionsService *assignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *assignedPermissionsServiceAddTemplatePermissionRequest) Header(key, value string) *assignedPermissionsServiceAddTemplatePermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedPermissionsServiceAddTemplatePermissionRequest) Query(key, value string) *assignedPermissionsServiceAddTemplatePermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedPermissionsServiceAddTemplatePermissionRequest) Permission(permission *Permission) *assignedPermissionsServiceAddTemplatePermissionRequest {
	p.permission = permission
	return p
}

func (p *assignedPermissionsServiceAddTemplatePermissionRequest) Send() (*assignedPermissionsServiceAddTemplatePermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/templatepermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddTemplatePermissionResponse{permission: result}, nil
}

func (p *assignedPermissionsServiceAddTemplatePermissionRequest) MustSend() *assignedPermissionsServiceAddTemplatePermissionResponse {
	rawURL := fmt.Sprintf("%s%s/templatepermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddTemplatePermissionResponse{permission: result}
}

//
// Add a new permission on the template to the group in the system.
//
type assignedPermissionsServiceAddTemplatePermissionResponse struct {
	permission *Permission
}

func (p *assignedPermissionsServiceAddTemplatePermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *assignedPermissionsServiceAddTemplatePermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the template to the group in the system.
//
func (p *assignedPermissionsService) AddTemplatePermission() *assignedPermissionsServiceAddTemplatePermissionRequest {
	return &assignedPermissionsServiceAddTemplatePermissionRequest{assignedPermissionsService: p}
}

//
// Add a new user level permission for a given virtual machine.
//
type assignedPermissionsServiceAddUserLevelRequest struct {
	assignedPermissionsService *assignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *assignedPermissionsServiceAddUserLevelRequest) Header(key, value string) *assignedPermissionsServiceAddUserLevelRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedPermissionsServiceAddUserLevelRequest) Query(key, value string) *assignedPermissionsServiceAddUserLevelRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedPermissionsServiceAddUserLevelRequest) Permission(permission *Permission) *assignedPermissionsServiceAddUserLevelRequest {
	p.permission = permission
	return p
}

func (p *assignedPermissionsServiceAddUserLevelRequest) Send() (*assignedPermissionsServiceAddUserLevelResponse, error) {
	rawURL := fmt.Sprintf("%s%s/userlevel", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddUserLevelResponse{permission: result}, nil
}

func (p *assignedPermissionsServiceAddUserLevelRequest) MustSend() *assignedPermissionsServiceAddUserLevelResponse {
	rawURL := fmt.Sprintf("%s%s/userlevel", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddUserLevelResponse{permission: result}
}

//
// Add a new user level permission for a given virtual machine.
//
type assignedPermissionsServiceAddUserLevelResponse struct {
	permission *Permission
}

func (p *assignedPermissionsServiceAddUserLevelResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *assignedPermissionsServiceAddUserLevelResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new user level permission for a given virtual machine.
//
func (p *assignedPermissionsService) AddUserLevel() *assignedPermissionsServiceAddUserLevelRequest {
	return &assignedPermissionsServiceAddUserLevelRequest{assignedPermissionsService: p}
}

//
// Add a new permission on the vm to the group in the system.
//
type assignedPermissionsServiceAddVmPermissionRequest struct {
	assignedPermissionsService *assignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *assignedPermissionsServiceAddVmPermissionRequest) Header(key, value string) *assignedPermissionsServiceAddVmPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedPermissionsServiceAddVmPermissionRequest) Query(key, value string) *assignedPermissionsServiceAddVmPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedPermissionsServiceAddVmPermissionRequest) Permission(permission *Permission) *assignedPermissionsServiceAddVmPermissionRequest {
	p.permission = permission
	return p
}

func (p *assignedPermissionsServiceAddVmPermissionRequest) Send() (*assignedPermissionsServiceAddVmPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/vmpermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddVmPermissionResponse{permission: result}, nil
}

func (p *assignedPermissionsServiceAddVmPermissionRequest) MustSend() *assignedPermissionsServiceAddVmPermissionResponse {
	rawURL := fmt.Sprintf("%s%s/vmpermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddVmPermissionResponse{permission: result}
}

//
// Add a new permission on the vm to the group in the system.
//
type assignedPermissionsServiceAddVmPermissionResponse struct {
	permission *Permission
}

func (p *assignedPermissionsServiceAddVmPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *assignedPermissionsServiceAddVmPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the vm to the group in the system.
//
func (p *assignedPermissionsService) AddVmPermission() *assignedPermissionsServiceAddVmPermissionRequest {
	return &assignedPermissionsServiceAddVmPermissionRequest{assignedPermissionsService: p}
}

//
// Add a new permission on the vm pool to the group in the system.
//
type assignedPermissionsServiceAddVmPoolPermissionRequest struct {
	assignedPermissionsService *assignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *assignedPermissionsServiceAddVmPoolPermissionRequest) Header(key, value string) *assignedPermissionsServiceAddVmPoolPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedPermissionsServiceAddVmPoolPermissionRequest) Query(key, value string) *assignedPermissionsServiceAddVmPoolPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedPermissionsServiceAddVmPoolPermissionRequest) Permission(permission *Permission) *assignedPermissionsServiceAddVmPoolPermissionRequest {
	p.permission = permission
	return p
}

func (p *assignedPermissionsServiceAddVmPoolPermissionRequest) Send() (*assignedPermissionsServiceAddVmPoolPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/vmpoolpermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddVmPoolPermissionResponse{permission: result}, nil
}

func (p *assignedPermissionsServiceAddVmPoolPermissionRequest) MustSend() *assignedPermissionsServiceAddVmPoolPermissionResponse {
	rawURL := fmt.Sprintf("%s%s/vmpoolpermission", p.assignedPermissionsService.connection.URL(), p.assignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedPermissionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedPermissionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustPermission()
	return &assignedPermissionsServiceAddVmPoolPermissionResponse{permission: result}
}

//
// Add a new permission on the vm pool to the group in the system.
//
type assignedPermissionsServiceAddVmPoolPermissionResponse struct {
	permission *Permission
}

func (p *assignedPermissionsServiceAddVmPoolPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *assignedPermissionsServiceAddVmPoolPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the vm pool to the group in the system.
//
func (p *assignedPermissionsService) AddVmPoolPermission() *assignedPermissionsServiceAddVmPoolPermissionRequest {
	return &assignedPermissionsServiceAddVmPoolPermissionRequest{assignedPermissionsService: p}
}

//
// Sub-resource locator method, returns individual permission resource on which the remainder of the URI is
// dispatched.
//
func (op *assignedPermissionsService) PermissionService(id string) *permissionService {
	return NewPermissionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *assignedPermissionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.PermissionService(path), nil
	}
	return op.PermissionService(path[:index]).Service(path[index+1:])
}

func (op *assignedPermissionsService) String() string {
	return fmt.Sprintf("assignedPermissionsService:%s", op.path)
}

//
// A service to manage a specific permit of the role.
//
type permitService struct {
	baseService
}

func NewPermitService(connection *Connection, path string) *permitService {
	var result permitService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the information about the permit of the role.
// For example to retrieve the information about the permit with the id `456` of the role with the id `123`
// send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits/456
// ....
// [source,xml]
// ----
// <permit href="/ovirt-engine/api/roles/123/permits/456" id="456">
//   <name>change_vm_cd</name>
//   <administrative>false</administrative>
//   <role href="/ovirt-engine/api/roles/123" id="123"/>
// </permit>
// ----
//
type permitServiceGetRequest struct {
	permitService *permitService
	header        map[string]string
	query         map[string]string
	follow        *string
}

func (p *permitServiceGetRequest) Header(key, value string) *permitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *permitServiceGetRequest) Query(key, value string) *permitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *permitServiceGetRequest) Follow(follow string) *permitServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *permitServiceGetRequest) Send() (*permitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permitService.connection.URL(), p.permitService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.permitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.permitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &permitServiceGetResponse{permit: result}, nil
}

func (p *permitServiceGetRequest) MustSend() *permitServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.permitService.connection.URL(), p.permitService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.permitService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.permitService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermitReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &permitServiceGetResponse{permit: result}
}

//
// Gets the information about the permit of the role.
// For example to retrieve the information about the permit with the id `456` of the role with the id `123`
// send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits/456
// ....
// [source,xml]
// ----
// <permit href="/ovirt-engine/api/roles/123/permits/456" id="456">
//   <name>change_vm_cd</name>
//   <administrative>false</administrative>
//   <role href="/ovirt-engine/api/roles/123" id="123"/>
// </permit>
// ----
//
type permitServiceGetResponse struct {
	permit *Permit
}

func (p *permitServiceGetResponse) Permit() (*Permit, bool) {
	if p.permit != nil {
		return p.permit, true
	}
	return nil, false
}

func (p *permitServiceGetResponse) MustPermit() *Permit {
	if p.permit == nil {
		panic("permit in response does not exist")
	}
	return p.permit
}

//
// Gets the information about the permit of the role.
// For example to retrieve the information about the permit with the id `456` of the role with the id `123`
// send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits/456
// ....
// [source,xml]
// ----
// <permit href="/ovirt-engine/api/roles/123/permits/456" id="456">
//   <name>change_vm_cd</name>
//   <administrative>false</administrative>
//   <role href="/ovirt-engine/api/roles/123" id="123"/>
// </permit>
// ----
//
func (p *permitService) Get() *permitServiceGetRequest {
	return &permitServiceGetRequest{permitService: p}
}

//
// Removes the permit from the role.
// For example to remove the permit with id `456` from the role with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/roles/123/permits/456
// ....
//
type permitServiceRemoveRequest struct {
	permitService *permitService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *permitServiceRemoveRequest) Header(key, value string) *permitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *permitServiceRemoveRequest) Query(key, value string) *permitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *permitServiceRemoveRequest) Async(async bool) *permitServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *permitServiceRemoveRequest) Send() (*permitServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permitService.connection.URL(), p.permitService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.permitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.permitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(permitServiceRemoveResponse), nil
}

func (p *permitServiceRemoveRequest) MustSend() *permitServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.permitService.connection.URL(), p.permitService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.permitService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.permitService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(permitServiceRemoveResponse)
}

//
// Removes the permit from the role.
// For example to remove the permit with id `456` from the role with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/roles/123/permits/456
// ....
//
type permitServiceRemoveResponse struct {
}

//
// Removes the permit from the role.
// For example to remove the permit with id `456` from the role with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/roles/123/permits/456
// ....
//
func (p *permitService) Remove() *permitServiceRemoveRequest {
	return &permitServiceRemoveRequest{permitService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *permitService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *permitService) String() string {
	return fmt.Sprintf("permitService:%s", op.path)
}

//
//
type systemService struct {
	baseService
}

func NewSystemService(connection *Connection, path string) *systemService {
	var result systemService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns basic information describing the API, like the product name, the version number and a summary of the
// number of relevant objects.
// [source]
// ----
// GET /ovirt-engine/api
// ----
// We get following response:
// [source,xml]
// ----
// <api>
//   <link rel="capabilities" href="/api/capabilities"/>
//   <link rel="clusters" href="/api/clusters"/>
//   <link rel="clusters/search" href="/api/clusters?search={query}"/>
//   <link rel="datacenters" href="/api/datacenters"/>
//   <link rel="datacenters/search" href="/api/datacenters?search={query}"/>
//   <link rel="events" href="/api/events"/>
//   <link rel="events/search" href="/api/events?search={query}"/>
//   <link rel="hosts" href="/api/hosts"/>
//   <link rel="hosts/search" href="/api/hosts?search={query}"/>
//   <link rel="networks" href="/api/networks"/>
//   <link rel="roles" href="/api/roles"/>
//   <link rel="storagedomains" href="/api/storagedomains"/>
//   <link rel="storagedomains/search" href="/api/storagedomains?search={query}"/>
//   <link rel="tags" href="/api/tags"/>
//   <link rel="templates" href="/api/templates"/>
//   <link rel="templates/search" href="/api/templates?search={query}"/>
//   <link rel="users" href="/api/users"/>
//   <link rel="groups" href="/api/groups"/>
//   <link rel="domains" href="/api/domains"/>
//   <link rel="vmpools" href="/api/vmpools"/>
//   <link rel="vmpools/search" href="/api/vmpools?search={query}"/>
//   <link rel="vms" href="/api/vms"/>
//   <link rel="vms/search" href="/api/vms?search={query}"/>
//   <product_info>
//     <name>oVirt Engine</name>
//     <vendor>ovirt.org</vendor>
//     <version>
//       <build>4</build>
//       <full_version>4.0.4</full_version>
//       <major>4</major>
//       <minor>0</minor>
//       <revision>0</revision>
//     </version>
//   </product_info>
//   <special_objects>
//     <blank_template href="/ovirt-engine/api/templates/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//     <root_tag href="/ovirt-engine/api/tags/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//   </special_objects>
//   <summary>
//     <hosts>
//       <active>0</active>
//       <total>0</total>
//     </hosts>
//     <storage_domains>
//       <active>0</active>
//       <total>1</total>
//     </storage_domains>
//     <users>
//       <active>1</active>
//       <total>1</total>
//     </users>
//     <vms>
//       <active>0</active>
//       <total>0</total>
//     </vms>
//   </summary>
//   <time>2016-09-14T12:00:48.132+02:00</time>
// </api>
// ----
// The entry point provides a user with links to the collections in a
// virtualization environment. The `rel` attribute of each collection link
// provides a reference point for each link.
// The entry point also contains other data such as `product_info`,
// `special_objects` and `summary`.
//
type systemServiceGetRequest struct {
	systemService *systemService
	header        map[string]string
	query         map[string]string
	follow        *string
}

func (p *systemServiceGetRequest) Header(key, value string) *systemServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemServiceGetRequest) Query(key, value string) *systemServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemServiceGetRequest) Follow(follow string) *systemServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *systemServiceGetRequest) Send() (*systemServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.systemService.connection.URL(), p.systemService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLApiReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &systemServiceGetResponse{api: result}, nil
}

func (p *systemServiceGetRequest) MustSend() *systemServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.systemService.connection.URL(), p.systemService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLApiReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &systemServiceGetResponse{api: result}
}

//
// Returns basic information describing the API, like the product name, the version number and a summary of the
// number of relevant objects.
// [source]
// ----
// GET /ovirt-engine/api
// ----
// We get following response:
// [source,xml]
// ----
// <api>
//   <link rel="capabilities" href="/api/capabilities"/>
//   <link rel="clusters" href="/api/clusters"/>
//   <link rel="clusters/search" href="/api/clusters?search={query}"/>
//   <link rel="datacenters" href="/api/datacenters"/>
//   <link rel="datacenters/search" href="/api/datacenters?search={query}"/>
//   <link rel="events" href="/api/events"/>
//   <link rel="events/search" href="/api/events?search={query}"/>
//   <link rel="hosts" href="/api/hosts"/>
//   <link rel="hosts/search" href="/api/hosts?search={query}"/>
//   <link rel="networks" href="/api/networks"/>
//   <link rel="roles" href="/api/roles"/>
//   <link rel="storagedomains" href="/api/storagedomains"/>
//   <link rel="storagedomains/search" href="/api/storagedomains?search={query}"/>
//   <link rel="tags" href="/api/tags"/>
//   <link rel="templates" href="/api/templates"/>
//   <link rel="templates/search" href="/api/templates?search={query}"/>
//   <link rel="users" href="/api/users"/>
//   <link rel="groups" href="/api/groups"/>
//   <link rel="domains" href="/api/domains"/>
//   <link rel="vmpools" href="/api/vmpools"/>
//   <link rel="vmpools/search" href="/api/vmpools?search={query}"/>
//   <link rel="vms" href="/api/vms"/>
//   <link rel="vms/search" href="/api/vms?search={query}"/>
//   <product_info>
//     <name>oVirt Engine</name>
//     <vendor>ovirt.org</vendor>
//     <version>
//       <build>4</build>
//       <full_version>4.0.4</full_version>
//       <major>4</major>
//       <minor>0</minor>
//       <revision>0</revision>
//     </version>
//   </product_info>
//   <special_objects>
//     <blank_template href="/ovirt-engine/api/templates/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//     <root_tag href="/ovirt-engine/api/tags/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//   </special_objects>
//   <summary>
//     <hosts>
//       <active>0</active>
//       <total>0</total>
//     </hosts>
//     <storage_domains>
//       <active>0</active>
//       <total>1</total>
//     </storage_domains>
//     <users>
//       <active>1</active>
//       <total>1</total>
//     </users>
//     <vms>
//       <active>0</active>
//       <total>0</total>
//     </vms>
//   </summary>
//   <time>2016-09-14T12:00:48.132+02:00</time>
// </api>
// ----
// The entry point provides a user with links to the collections in a
// virtualization environment. The `rel` attribute of each collection link
// provides a reference point for each link.
// The entry point also contains other data such as `product_info`,
// `special_objects` and `summary`.
//
type systemServiceGetResponse struct {
	api *Api
}

func (p *systemServiceGetResponse) Api() (*Api, bool) {
	if p.api != nil {
		return p.api, true
	}
	return nil, false
}

func (p *systemServiceGetResponse) MustApi() *Api {
	if p.api == nil {
		panic("api in response does not exist")
	}
	return p.api
}

//
// Returns basic information describing the API, like the product name, the version number and a summary of the
// number of relevant objects.
// [source]
// ----
// GET /ovirt-engine/api
// ----
// We get following response:
// [source,xml]
// ----
// <api>
//   <link rel="capabilities" href="/api/capabilities"/>
//   <link rel="clusters" href="/api/clusters"/>
//   <link rel="clusters/search" href="/api/clusters?search={query}"/>
//   <link rel="datacenters" href="/api/datacenters"/>
//   <link rel="datacenters/search" href="/api/datacenters?search={query}"/>
//   <link rel="events" href="/api/events"/>
//   <link rel="events/search" href="/api/events?search={query}"/>
//   <link rel="hosts" href="/api/hosts"/>
//   <link rel="hosts/search" href="/api/hosts?search={query}"/>
//   <link rel="networks" href="/api/networks"/>
//   <link rel="roles" href="/api/roles"/>
//   <link rel="storagedomains" href="/api/storagedomains"/>
//   <link rel="storagedomains/search" href="/api/storagedomains?search={query}"/>
//   <link rel="tags" href="/api/tags"/>
//   <link rel="templates" href="/api/templates"/>
//   <link rel="templates/search" href="/api/templates?search={query}"/>
//   <link rel="users" href="/api/users"/>
//   <link rel="groups" href="/api/groups"/>
//   <link rel="domains" href="/api/domains"/>
//   <link rel="vmpools" href="/api/vmpools"/>
//   <link rel="vmpools/search" href="/api/vmpools?search={query}"/>
//   <link rel="vms" href="/api/vms"/>
//   <link rel="vms/search" href="/api/vms?search={query}"/>
//   <product_info>
//     <name>oVirt Engine</name>
//     <vendor>ovirt.org</vendor>
//     <version>
//       <build>4</build>
//       <full_version>4.0.4</full_version>
//       <major>4</major>
//       <minor>0</minor>
//       <revision>0</revision>
//     </version>
//   </product_info>
//   <special_objects>
//     <blank_template href="/ovirt-engine/api/templates/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//     <root_tag href="/ovirt-engine/api/tags/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//   </special_objects>
//   <summary>
//     <hosts>
//       <active>0</active>
//       <total>0</total>
//     </hosts>
//     <storage_domains>
//       <active>0</active>
//       <total>1</total>
//     </storage_domains>
//     <users>
//       <active>1</active>
//       <total>1</total>
//     </users>
//     <vms>
//       <active>0</active>
//       <total>0</total>
//     </vms>
//   </summary>
//   <time>2016-09-14T12:00:48.132+02:00</time>
// </api>
// ----
// The entry point provides a user with links to the collections in a
// virtualization environment. The `rel` attribute of each collection link
// provides a reference point for each link.
// The entry point also contains other data such as `product_info`,
// `special_objects` and `summary`.
//
func (p *systemService) Get() *systemServiceGetRequest {
	return &systemServiceGetRequest{systemService: p}
}

//
//
type systemServiceReloadConfigurationsRequest struct {
	systemService *systemService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *systemServiceReloadConfigurationsRequest) Header(key, value string) *systemServiceReloadConfigurationsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemServiceReloadConfigurationsRequest) Query(key, value string) *systemServiceReloadConfigurationsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemServiceReloadConfigurationsRequest) Async(async bool) *systemServiceReloadConfigurationsRequest {
	p.async = &async
	return p
}

func (p *systemServiceReloadConfigurationsRequest) Send() (*systemServiceReloadConfigurationsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reloadconfigurations", p.systemService.connection.URL(), p.systemService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(systemServiceReloadConfigurationsResponse), nil
}

func (p *systemServiceReloadConfigurationsRequest) MustSend() *systemServiceReloadConfigurationsResponse {
	rawURL := fmt.Sprintf("%s%s/reloadconfigurations", p.systemService.connection.URL(), p.systemService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(systemServiceReloadConfigurationsResponse)
}

//
//
type systemServiceReloadConfigurationsResponse struct {
}

//
//
func (p *systemService) ReloadConfigurations() *systemServiceReloadConfigurationsRequest {
	return &systemServiceReloadConfigurationsRequest{systemService: p}
}

//
// List all known affinity labels.
//
func (op *systemService) AffinityLabelsService() *affinityLabelsService {
	return NewAffinityLabelsService(op.connection, fmt.Sprintf("%s/affinitylabels", op.path))
}

//
//
func (op *systemService) BookmarksService() *bookmarksService {
	return NewBookmarksService(op.connection, fmt.Sprintf("%s/bookmarks", op.path))
}

//
// Reference to the service that provides information about the cluster levels supported by the system.
//
func (op *systemService) ClusterLevelsService() *clusterLevelsService {
	return NewClusterLevelsService(op.connection, fmt.Sprintf("%s/clusterlevels", op.path))
}

//
//
func (op *systemService) ClustersService() *clustersService {
	return NewClustersService(op.connection, fmt.Sprintf("%s/clusters", op.path))
}

//
//
func (op *systemService) CpuProfilesService() *cpuProfilesService {
	return NewCpuProfilesService(op.connection, fmt.Sprintf("%s/cpuprofiles", op.path))
}

//
//
func (op *systemService) DataCentersService() *dataCentersService {
	return NewDataCentersService(op.connection, fmt.Sprintf("%s/datacenters", op.path))
}

//
//
func (op *systemService) DiskProfilesService() *diskProfilesService {
	return NewDiskProfilesService(op.connection, fmt.Sprintf("%s/diskprofiles", op.path))
}

//
//
func (op *systemService) DisksService() *disksService {
	return NewDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
//
func (op *systemService) DomainsService() *domainsService {
	return NewDomainsService(op.connection, fmt.Sprintf("%s/domains", op.path))
}

//
//
func (op *systemService) EventsService() *eventsService {
	return NewEventsService(op.connection, fmt.Sprintf("%s/events", op.path))
}

//
//
func (op *systemService) ExternalHostProvidersService() *externalHostProvidersService {
	return NewExternalHostProvidersService(op.connection, fmt.Sprintf("%s/externalhostproviders", op.path))
}

//
// Reference to service facilitating import of external virtual machines.
//
func (op *systemService) ExternalVmImportsService() *externalVmImportsService {
	return NewExternalVmImportsService(op.connection, fmt.Sprintf("%s/externalvmimports", op.path))
}

//
//
func (op *systemService) GroupsService() *groupsService {
	return NewGroupsService(op.connection, fmt.Sprintf("%s/groups", op.path))
}

//
//
func (op *systemService) HostsService() *hostsService {
	return NewHostsService(op.connection, fmt.Sprintf("%s/hosts", op.path))
}

//
//
func (op *systemService) IconsService() *iconsService {
	return NewIconsService(op.connection, fmt.Sprintf("%s/icons", op.path))
}

//
// List of all image transfers being performed for image I/O in oVirt.
//
func (op *systemService) ImageTransfersService() *imageTransfersService {
	return NewImageTransfersService(op.connection, fmt.Sprintf("%s/imagetransfers", op.path))
}

//
//
func (op *systemService) InstanceTypesService() *instanceTypesService {
	return NewInstanceTypesService(op.connection, fmt.Sprintf("%s/instancetypes", op.path))
}

//
// List all the jobs monitored by the engine.
//
func (op *systemService) JobsService() *jobsService {
	return NewJobsService(op.connection, fmt.Sprintf("%s/jobs", op.path))
}

//
// List the available Katello errata assigned to the engine.
//
func (op *systemService) KatelloErrataService() *engineKatelloErrataService {
	return NewEngineKatelloErrataService(op.connection, fmt.Sprintf("%s/katelloerrata", op.path))
}

//
//
func (op *systemService) MacPoolsService() *macPoolsService {
	return NewMacPoolsService(op.connection, fmt.Sprintf("%s/macpools", op.path))
}

//
// Network filters will enhance the admin ability to manage the network packets traffic from/to the participated
// VMs.
//
func (op *systemService) NetworkFiltersService() *networkFiltersService {
	return NewNetworkFiltersService(op.connection, fmt.Sprintf("%s/networkfilters", op.path))
}

//
//
func (op *systemService) NetworksService() *networksService {
	return NewNetworksService(op.connection, fmt.Sprintf("%s/networks", op.path))
}

//
//
func (op *systemService) OpenstackImageProvidersService() *openstackImageProvidersService {
	return NewOpenstackImageProvidersService(op.connection, fmt.Sprintf("%s/openstackimageproviders", op.path))
}

//
//
func (op *systemService) OpenstackNetworkProvidersService() *openstackNetworkProvidersService {
	return NewOpenstackNetworkProvidersService(op.connection, fmt.Sprintf("%s/openstacknetworkproviders", op.path))
}

//
//
func (op *systemService) OpenstackVolumeProvidersService() *openstackVolumeProvidersService {
	return NewOpenstackVolumeProvidersService(op.connection, fmt.Sprintf("%s/openstackvolumeproviders", op.path))
}

//
//
func (op *systemService) OperatingSystemsService() *operatingSystemsService {
	return NewOperatingSystemsService(op.connection, fmt.Sprintf("%s/operatingsystems", op.path))
}

//
// Reference to the service that provides values of configuration options of the system.
//
func (op *systemService) OptionsService() *systemOptionsService {
	return NewSystemOptionsService(op.connection, fmt.Sprintf("%s/options", op.path))
}

//
//
func (op *systemService) PermissionsService() *systemPermissionsService {
	return NewSystemPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *systemService) RolesService() *rolesService {
	return NewRolesService(op.connection, fmt.Sprintf("%s/roles", op.path))
}

//
//
func (op *systemService) SchedulingPoliciesService() *schedulingPoliciesService {
	return NewSchedulingPoliciesService(op.connection, fmt.Sprintf("%s/schedulingpolicies", op.path))
}

//
//
func (op *systemService) SchedulingPolicyUnitsService() *schedulingPolicyUnitsService {
	return NewSchedulingPolicyUnitsService(op.connection, fmt.Sprintf("%s/schedulingpolicyunits", op.path))
}

//
//
func (op *systemService) StorageConnectionsService() *storageServerConnectionsService {
	return NewStorageServerConnectionsService(op.connection, fmt.Sprintf("%s/storageconnections", op.path))
}

//
//
func (op *systemService) StorageDomainsService() *storageDomainsService {
	return NewStorageDomainsService(op.connection, fmt.Sprintf("%s/storagedomains", op.path))
}

//
//
func (op *systemService) TagsService() *tagsService {
	return NewTagsService(op.connection, fmt.Sprintf("%s/tags", op.path))
}

//
//
func (op *systemService) TemplatesService() *templatesService {
	return NewTemplatesService(op.connection, fmt.Sprintf("%s/templates", op.path))
}

//
//
func (op *systemService) UsersService() *usersService {
	return NewUsersService(op.connection, fmt.Sprintf("%s/users", op.path))
}

//
//
func (op *systemService) VmPoolsService() *vmPoolsService {
	return NewVmPoolsService(op.connection, fmt.Sprintf("%s/vmpools", op.path))
}

//
//
func (op *systemService) VmsService() *vmsService {
	return NewVmsService(op.connection, fmt.Sprintf("%s/vms", op.path))
}

//
//
func (op *systemService) VnicProfilesService() *vnicProfilesService {
	return NewVnicProfilesService(op.connection, fmt.Sprintf("%s/vnicprofiles", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *systemService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitylabels" {
		return op.AffinityLabelsService(), nil
	}
	if strings.HasPrefix(path, "affinitylabels/") {
		return op.AffinityLabelsService().Service(path[15:])
	}
	if path == "bookmarks" {
		return op.BookmarksService(), nil
	}
	if strings.HasPrefix(path, "bookmarks/") {
		return op.BookmarksService().Service(path[10:])
	}
	if path == "clusterlevels" {
		return op.ClusterLevelsService(), nil
	}
	if strings.HasPrefix(path, "clusterlevels/") {
		return op.ClusterLevelsService().Service(path[14:])
	}
	if path == "clusters" {
		return op.ClustersService(), nil
	}
	if strings.HasPrefix(path, "clusters/") {
		return op.ClustersService().Service(path[9:])
	}
	if path == "cpuprofiles" {
		return op.CpuProfilesService(), nil
	}
	if strings.HasPrefix(path, "cpuprofiles/") {
		return op.CpuProfilesService().Service(path[12:])
	}
	if path == "datacenters" {
		return op.DataCentersService(), nil
	}
	if strings.HasPrefix(path, "datacenters/") {
		return op.DataCentersService().Service(path[12:])
	}
	if path == "diskprofiles" {
		return op.DiskProfilesService(), nil
	}
	if strings.HasPrefix(path, "diskprofiles/") {
		return op.DiskProfilesService().Service(path[13:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	if path == "domains" {
		return op.DomainsService(), nil
	}
	if strings.HasPrefix(path, "domains/") {
		return op.DomainsService().Service(path[8:])
	}
	if path == "events" {
		return op.EventsService(), nil
	}
	if strings.HasPrefix(path, "events/") {
		return op.EventsService().Service(path[7:])
	}
	if path == "externalhostproviders" {
		return op.ExternalHostProvidersService(), nil
	}
	if strings.HasPrefix(path, "externalhostproviders/") {
		return op.ExternalHostProvidersService().Service(path[22:])
	}
	if path == "externalvmimports" {
		return op.ExternalVmImportsService(), nil
	}
	if strings.HasPrefix(path, "externalvmimports/") {
		return op.ExternalVmImportsService().Service(path[18:])
	}
	if path == "groups" {
		return op.GroupsService(), nil
	}
	if strings.HasPrefix(path, "groups/") {
		return op.GroupsService().Service(path[7:])
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	if path == "icons" {
		return op.IconsService(), nil
	}
	if strings.HasPrefix(path, "icons/") {
		return op.IconsService().Service(path[6:])
	}
	if path == "imagetransfers" {
		return op.ImageTransfersService(), nil
	}
	if strings.HasPrefix(path, "imagetransfers/") {
		return op.ImageTransfersService().Service(path[15:])
	}
	if path == "instancetypes" {
		return op.InstanceTypesService(), nil
	}
	if strings.HasPrefix(path, "instancetypes/") {
		return op.InstanceTypesService().Service(path[14:])
	}
	if path == "jobs" {
		return op.JobsService(), nil
	}
	if strings.HasPrefix(path, "jobs/") {
		return op.JobsService().Service(path[5:])
	}
	if path == "katelloerrata" {
		return op.KatelloErrataService(), nil
	}
	if strings.HasPrefix(path, "katelloerrata/") {
		return op.KatelloErrataService().Service(path[14:])
	}
	if path == "macpools" {
		return op.MacPoolsService(), nil
	}
	if strings.HasPrefix(path, "macpools/") {
		return op.MacPoolsService().Service(path[9:])
	}
	if path == "networkfilters" {
		return op.NetworkFiltersService(), nil
	}
	if strings.HasPrefix(path, "networkfilters/") {
		return op.NetworkFiltersService().Service(path[15:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "openstackimageproviders" {
		return op.OpenstackImageProvidersService(), nil
	}
	if strings.HasPrefix(path, "openstackimageproviders/") {
		return op.OpenstackImageProvidersService().Service(path[24:])
	}
	if path == "openstacknetworkproviders" {
		return op.OpenstackNetworkProvidersService(), nil
	}
	if strings.HasPrefix(path, "openstacknetworkproviders/") {
		return op.OpenstackNetworkProvidersService().Service(path[26:])
	}
	if path == "openstackvolumeproviders" {
		return op.OpenstackVolumeProvidersService(), nil
	}
	if strings.HasPrefix(path, "openstackvolumeproviders/") {
		return op.OpenstackVolumeProvidersService().Service(path[25:])
	}
	if path == "operatingsystems" {
		return op.OperatingSystemsService(), nil
	}
	if strings.HasPrefix(path, "operatingsystems/") {
		return op.OperatingSystemsService().Service(path[17:])
	}
	if path == "options" {
		return op.OptionsService(), nil
	}
	if strings.HasPrefix(path, "options/") {
		return op.OptionsService().Service(path[8:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "roles" {
		return op.RolesService(), nil
	}
	if strings.HasPrefix(path, "roles/") {
		return op.RolesService().Service(path[6:])
	}
	if path == "schedulingpolicies" {
		return op.SchedulingPoliciesService(), nil
	}
	if strings.HasPrefix(path, "schedulingpolicies/") {
		return op.SchedulingPoliciesService().Service(path[19:])
	}
	if path == "schedulingpolicyunits" {
		return op.SchedulingPolicyUnitsService(), nil
	}
	if strings.HasPrefix(path, "schedulingpolicyunits/") {
		return op.SchedulingPolicyUnitsService().Service(path[22:])
	}
	if path == "storageconnections" {
		return op.StorageConnectionsService(), nil
	}
	if strings.HasPrefix(path, "storageconnections/") {
		return op.StorageConnectionsService().Service(path[19:])
	}
	if path == "storagedomains" {
		return op.StorageDomainsService(), nil
	}
	if strings.HasPrefix(path, "storagedomains/") {
		return op.StorageDomainsService().Service(path[15:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "templates" {
		return op.TemplatesService(), nil
	}
	if strings.HasPrefix(path, "templates/") {
		return op.TemplatesService().Service(path[10:])
	}
	if path == "users" {
		return op.UsersService(), nil
	}
	if strings.HasPrefix(path, "users/") {
		return op.UsersService().Service(path[6:])
	}
	if path == "vmpools" {
		return op.VmPoolsService(), nil
	}
	if strings.HasPrefix(path, "vmpools/") {
		return op.VmPoolsService().Service(path[8:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	if path == "vnicprofiles" {
		return op.VnicProfilesService(), nil
	}
	if strings.HasPrefix(path, "vnicprofiles/") {
		return op.VnicProfilesService().Service(path[13:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *systemService) String() string {
	return fmt.Sprintf("systemService:%s", op.path)
}

//
// A service managing a watchdog on virtual machines.
//
type vmWatchdogService struct {
	baseService
}

func NewVmWatchdogService(connection *Connection, path string) *vmWatchdogService {
	var result vmWatchdogService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the information about the watchdog.
//
type vmWatchdogServiceGetRequest struct {
	vmWatchdogService *vmWatchdogService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *vmWatchdogServiceGetRequest) Header(key, value string) *vmWatchdogServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmWatchdogServiceGetRequest) Query(key, value string) *vmWatchdogServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmWatchdogServiceGetRequest) Follow(follow string) *vmWatchdogServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vmWatchdogServiceGetRequest) Send() (*vmWatchdogServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogService.connection.URL(), p.vmWatchdogService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmWatchdogServiceGetResponse{watchdog: result}, nil
}

func (p *vmWatchdogServiceGetRequest) MustSend() *vmWatchdogServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogService.connection.URL(), p.vmWatchdogService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmWatchdogService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmWatchdogService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmWatchdogServiceGetResponse{watchdog: result}
}

//
// Returns the information about the watchdog.
//
type vmWatchdogServiceGetResponse struct {
	watchdog *Watchdog
}

func (p *vmWatchdogServiceGetResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *vmWatchdogServiceGetResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Returns the information about the watchdog.
//
func (p *vmWatchdogService) Get() *vmWatchdogServiceGetRequest {
	return &vmWatchdogServiceGetRequest{vmWatchdogService: p}
}

//
// Removes the watchdog from the virtual machine.
// For example, to remove a watchdog from a virtual machine, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000
// ----
//
type vmWatchdogServiceRemoveRequest struct {
	vmWatchdogService *vmWatchdogService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *vmWatchdogServiceRemoveRequest) Header(key, value string) *vmWatchdogServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmWatchdogServiceRemoveRequest) Query(key, value string) *vmWatchdogServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmWatchdogServiceRemoveRequest) Async(async bool) *vmWatchdogServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *vmWatchdogServiceRemoveRequest) Send() (*vmWatchdogServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogService.connection.URL(), p.vmWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(vmWatchdogServiceRemoveResponse), nil
}

func (p *vmWatchdogServiceRemoveRequest) MustSend() *vmWatchdogServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogService.connection.URL(), p.vmWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmWatchdogService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmWatchdogService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(vmWatchdogServiceRemoveResponse)
}

//
// Removes the watchdog from the virtual machine.
// For example, to remove a watchdog from a virtual machine, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000
// ----
//
type vmWatchdogServiceRemoveResponse struct {
}

//
// Removes the watchdog from the virtual machine.
// For example, to remove a watchdog from a virtual machine, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000
// ----
//
func (p *vmWatchdogService) Remove() *vmWatchdogServiceRemoveRequest {
	return &vmWatchdogServiceRemoveRequest{vmWatchdogService: p}
}

//
// Updates the information about the watchdog.
// You can update the information using `action` and `model` elements.
// For example, to update a watchdog, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>reset</action>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>reset</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
//
type vmWatchdogServiceUpdateRequest struct {
	vmWatchdogService *vmWatchdogService
	header            map[string]string
	query             map[string]string
	async             *bool
	watchdog          *Watchdog
}

func (p *vmWatchdogServiceUpdateRequest) Header(key, value string) *vmWatchdogServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmWatchdogServiceUpdateRequest) Query(key, value string) *vmWatchdogServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmWatchdogServiceUpdateRequest) Async(async bool) *vmWatchdogServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *vmWatchdogServiceUpdateRequest) Watchdog(watchdog *Watchdog) *vmWatchdogServiceUpdateRequest {
	p.watchdog = watchdog
	return p
}

func (p *vmWatchdogServiceUpdateRequest) Send() (*vmWatchdogServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogService.connection.URL(), p.vmWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmWatchdogServiceUpdateResponse{watchdog: result}, nil
}

func (p *vmWatchdogServiceUpdateRequest) MustSend() *vmWatchdogServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogService.connection.URL(), p.vmWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmWatchdogService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmWatchdogService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmWatchdogServiceUpdateResponse{watchdog: result}
}

//
// Updates the information about the watchdog.
// You can update the information using `action` and `model` elements.
// For example, to update a watchdog, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>reset</action>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>reset</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
//
type vmWatchdogServiceUpdateResponse struct {
	watchdog *Watchdog
}

func (p *vmWatchdogServiceUpdateResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *vmWatchdogServiceUpdateResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Updates the information about the watchdog.
// You can update the information using `action` and `model` elements.
// For example, to update a watchdog, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>reset</action>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>reset</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
//
func (p *vmWatchdogService) Update() *vmWatchdogServiceUpdateRequest {
	return &vmWatchdogServiceUpdateRequest{vmWatchdogService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmWatchdogService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vmWatchdogService) String() string {
	return fmt.Sprintf("vmWatchdogService:%s", op.path)
}

//
//
type unmanagedNetworksService struct {
	baseService
}

func NewUnmanagedNetworksService(connection *Connection, path string) *unmanagedNetworksService {
	var result unmanagedNetworksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of unmanaged networks of the host.
// The order of the returned list of networks isn't guaranteed.
//
type unmanagedNetworksServiceListRequest struct {
	unmanagedNetworksService *unmanagedNetworksService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
	max                      *int64
}

func (p *unmanagedNetworksServiceListRequest) Header(key, value string) *unmanagedNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *unmanagedNetworksServiceListRequest) Query(key, value string) *unmanagedNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *unmanagedNetworksServiceListRequest) Follow(follow string) *unmanagedNetworksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *unmanagedNetworksServiceListRequest) Max(max int64) *unmanagedNetworksServiceListRequest {
	p.max = &max
	return p
}

func (p *unmanagedNetworksServiceListRequest) Send() (*unmanagedNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.unmanagedNetworksService.connection.URL(), p.unmanagedNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.unmanagedNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.unmanagedNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUnmanagedNetworkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &unmanagedNetworksServiceListResponse{networks: result}, nil
}

func (p *unmanagedNetworksServiceListRequest) MustSend() *unmanagedNetworksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.unmanagedNetworksService.connection.URL(), p.unmanagedNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.unmanagedNetworksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.unmanagedNetworksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUnmanagedNetworkReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &unmanagedNetworksServiceListResponse{networks: result}
}

//
// Returns the list of unmanaged networks of the host.
// The order of the returned list of networks isn't guaranteed.
//
type unmanagedNetworksServiceListResponse struct {
	networks *UnmanagedNetworkSlice
}

func (p *unmanagedNetworksServiceListResponse) Networks() (*UnmanagedNetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *unmanagedNetworksServiceListResponse) MustNetworks() *UnmanagedNetworkSlice {
	if p.networks == nil {
		panic("networks in response does not exist")
	}
	return p.networks
}

//
// Returns the list of unmanaged networks of the host.
// The order of the returned list of networks isn't guaranteed.
//
func (p *unmanagedNetworksService) List() *unmanagedNetworksServiceListRequest {
	return &unmanagedNetworksServiceListRequest{unmanagedNetworksService: p}
}

//
//
func (op *unmanagedNetworksService) UnmanagedNetworkService(id string) *unmanagedNetworkService {
	return NewUnmanagedNetworkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *unmanagedNetworksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.UnmanagedNetworkService(path), nil
	}
	return op.UnmanagedNetworkService(path[:index]).Service(path[index+1:])
}

func (op *unmanagedNetworksService) String() string {
	return fmt.Sprintf("unmanagedNetworksService:%s", op.path)
}

//
//
type hostNumaNodesService struct {
	baseService
}

func NewHostNumaNodesService(connection *Connection, path string) *hostNumaNodesService {
	var result hostNumaNodesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of NUMA nodes of the host.
// The order of the returned list of NUMA nodes isn't guaranteed.
//
type hostNumaNodesServiceListRequest struct {
	hostNumaNodesService *hostNumaNodesService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *hostNumaNodesServiceListRequest) Header(key, value string) *hostNumaNodesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostNumaNodesServiceListRequest) Query(key, value string) *hostNumaNodesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostNumaNodesServiceListRequest) Follow(follow string) *hostNumaNodesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *hostNumaNodesServiceListRequest) Max(max int64) *hostNumaNodesServiceListRequest {
	p.max = &max
	return p
}

func (p *hostNumaNodesServiceListRequest) Send() (*hostNumaNodesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostNumaNodesService.connection.URL(), p.hostNumaNodesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostNumaNodesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostNumaNodesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNumaNodeReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &hostNumaNodesServiceListResponse{nodes: result}, nil
}

func (p *hostNumaNodesServiceListRequest) MustSend() *hostNumaNodesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostNumaNodesService.connection.URL(), p.hostNumaNodesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostNumaNodesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostNumaNodesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNumaNodeReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &hostNumaNodesServiceListResponse{nodes: result}
}

//
// Returns the list of NUMA nodes of the host.
// The order of the returned list of NUMA nodes isn't guaranteed.
//
type hostNumaNodesServiceListResponse struct {
	nodes *NumaNodeSlice
}

func (p *hostNumaNodesServiceListResponse) Nodes() (*NumaNodeSlice, bool) {
	if p.nodes != nil {
		return p.nodes, true
	}
	return nil, false
}

func (p *hostNumaNodesServiceListResponse) MustNodes() *NumaNodeSlice {
	if p.nodes == nil {
		panic("nodes in response does not exist")
	}
	return p.nodes
}

//
// Returns the list of NUMA nodes of the host.
// The order of the returned list of NUMA nodes isn't guaranteed.
//
func (p *hostNumaNodesService) List() *hostNumaNodesServiceListRequest {
	return &hostNumaNodesServiceListRequest{hostNumaNodesService: p}
}

//
//
func (op *hostNumaNodesService) NodeService(id string) *hostNumaNodeService {
	return NewHostNumaNodeService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *hostNumaNodesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NodeService(path), nil
	}
	return op.NodeService(path[:index]).Service(path[index+1:])
}

func (op *hostNumaNodesService) String() string {
	return fmt.Sprintf("hostNumaNodesService:%s", op.path)
}

//
//
type filterService struct {
	baseService
}

func NewFilterService(connection *Connection, path string) *filterService {
	var result filterService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type filterServiceGetRequest struct {
	filterService *filterService
	header        map[string]string
	query         map[string]string
	filter        *bool
	follow        *string
}

func (p *filterServiceGetRequest) Header(key, value string) *filterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *filterServiceGetRequest) Query(key, value string) *filterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *filterServiceGetRequest) Filter(filter bool) *filterServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *filterServiceGetRequest) Follow(follow string) *filterServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *filterServiceGetRequest) Send() (*filterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filterService.connection.URL(), p.filterService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.filterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.filterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFilterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &filterServiceGetResponse{result: result}, nil
}

func (p *filterServiceGetRequest) MustSend() *filterServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.filterService.connection.URL(), p.filterService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.filterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.filterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFilterReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &filterServiceGetResponse{result: result}
}

//
//
type filterServiceGetResponse struct {
	result *Filter
}

func (p *filterServiceGetResponse) Result() (*Filter, bool) {
	if p.result != nil {
		return p.result, true
	}
	return nil, false
}

func (p *filterServiceGetResponse) MustResult() *Filter {
	if p.result == nil {
		panic("result in response does not exist")
	}
	return p.result
}

//
//
func (p *filterService) Get() *filterServiceGetRequest {
	return &filterServiceGetRequest{filterService: p}
}

//
//
type filterServiceRemoveRequest struct {
	filterService *filterService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *filterServiceRemoveRequest) Header(key, value string) *filterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *filterServiceRemoveRequest) Query(key, value string) *filterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *filterServiceRemoveRequest) Async(async bool) *filterServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *filterServiceRemoveRequest) Send() (*filterServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.filterService.connection.URL(), p.filterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.filterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.filterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(filterServiceRemoveResponse), nil
}

func (p *filterServiceRemoveRequest) MustSend() *filterServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.filterService.connection.URL(), p.filterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.filterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.filterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(filterServiceRemoveResponse)
}

//
//
type filterServiceRemoveResponse struct {
}

//
//
func (p *filterService) Remove() *filterServiceRemoveRequest {
	return &filterServiceRemoveRequest{filterService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *filterService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *filterService) String() string {
	return fmt.Sprintf("filterService:%s", op.path)
}

//
//
type storageServerConnectionExtensionService struct {
	baseService
}

func NewStorageServerConnectionExtensionService(connection *Connection, path string) *storageServerConnectionExtensionService {
	var result storageServerConnectionExtensionService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type storageServerConnectionExtensionServiceGetRequest struct {
	storageServerConnectionExtensionService *storageServerConnectionExtensionService
	header                                  map[string]string
	query                                   map[string]string
	follow                                  *string
}

func (p *storageServerConnectionExtensionServiceGetRequest) Header(key, value string) *storageServerConnectionExtensionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionExtensionServiceGetRequest) Query(key, value string) *storageServerConnectionExtensionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionExtensionServiceGetRequest) Follow(follow string) *storageServerConnectionExtensionServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *storageServerConnectionExtensionServiceGetRequest) Send() (*storageServerConnectionExtensionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionService.connection.URL(), p.storageServerConnectionExtensionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionExtensionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionExtensionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageServerConnectionExtensionServiceGetResponse{extension: result}, nil
}

func (p *storageServerConnectionExtensionServiceGetRequest) MustSend() *storageServerConnectionExtensionServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionService.connection.URL(), p.storageServerConnectionExtensionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionExtensionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionExtensionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageServerConnectionExtensionServiceGetResponse{extension: result}
}

//
//
type storageServerConnectionExtensionServiceGetResponse struct {
	extension *StorageConnectionExtension
}

func (p *storageServerConnectionExtensionServiceGetResponse) Extension() (*StorageConnectionExtension, bool) {
	if p.extension != nil {
		return p.extension, true
	}
	return nil, false
}

func (p *storageServerConnectionExtensionServiceGetResponse) MustExtension() *StorageConnectionExtension {
	if p.extension == nil {
		panic("extension in response does not exist")
	}
	return p.extension
}

//
//
func (p *storageServerConnectionExtensionService) Get() *storageServerConnectionExtensionServiceGetRequest {
	return &storageServerConnectionExtensionServiceGetRequest{storageServerConnectionExtensionService: p}
}

//
//
type storageServerConnectionExtensionServiceRemoveRequest struct {
	storageServerConnectionExtensionService *storageServerConnectionExtensionService
	header                                  map[string]string
	query                                   map[string]string
	async                                   *bool
}

func (p *storageServerConnectionExtensionServiceRemoveRequest) Header(key, value string) *storageServerConnectionExtensionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionExtensionServiceRemoveRequest) Query(key, value string) *storageServerConnectionExtensionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionExtensionServiceRemoveRequest) Async(async bool) *storageServerConnectionExtensionServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *storageServerConnectionExtensionServiceRemoveRequest) Send() (*storageServerConnectionExtensionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionService.connection.URL(), p.storageServerConnectionExtensionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionExtensionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(storageServerConnectionExtensionServiceRemoveResponse), nil
}

func (p *storageServerConnectionExtensionServiceRemoveRequest) MustSend() *storageServerConnectionExtensionServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionService.connection.URL(), p.storageServerConnectionExtensionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionExtensionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(storageServerConnectionExtensionServiceRemoveResponse)
}

//
//
type storageServerConnectionExtensionServiceRemoveResponse struct {
}

//
//
func (p *storageServerConnectionExtensionService) Remove() *storageServerConnectionExtensionServiceRemoveRequest {
	return &storageServerConnectionExtensionServiceRemoveRequest{storageServerConnectionExtensionService: p}
}

//
// Update a storage server connection extension for the given host.
// To update the storage connection `456` of host `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123/storageconnectionextensions/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
type storageServerConnectionExtensionServiceUpdateRequest struct {
	storageServerConnectionExtensionService *storageServerConnectionExtensionService
	header                                  map[string]string
	query                                   map[string]string
	async                                   *bool
	extension                               *StorageConnectionExtension
}

func (p *storageServerConnectionExtensionServiceUpdateRequest) Header(key, value string) *storageServerConnectionExtensionServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionExtensionServiceUpdateRequest) Query(key, value string) *storageServerConnectionExtensionServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionExtensionServiceUpdateRequest) Async(async bool) *storageServerConnectionExtensionServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *storageServerConnectionExtensionServiceUpdateRequest) Extension(extension *StorageConnectionExtension) *storageServerConnectionExtensionServiceUpdateRequest {
	p.extension = extension
	return p
}

func (p *storageServerConnectionExtensionServiceUpdateRequest) Send() (*storageServerConnectionExtensionServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionService.connection.URL(), p.storageServerConnectionExtensionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionExtensionWriteOne(writer, p.extension, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionExtensionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionExtensionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageServerConnectionExtensionServiceUpdateResponse{extension: result}, nil
}

func (p *storageServerConnectionExtensionServiceUpdateRequest) MustSend() *storageServerConnectionExtensionServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionService.connection.URL(), p.storageServerConnectionExtensionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionExtensionWriteOne(writer, p.extension, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionExtensionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionExtensionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageServerConnectionExtensionServiceUpdateResponse{extension: result}
}

//
// Update a storage server connection extension for the given host.
// To update the storage connection `456` of host `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123/storageconnectionextensions/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
type storageServerConnectionExtensionServiceUpdateResponse struct {
	extension *StorageConnectionExtension
}

func (p *storageServerConnectionExtensionServiceUpdateResponse) Extension() (*StorageConnectionExtension, bool) {
	if p.extension != nil {
		return p.extension, true
	}
	return nil, false
}

func (p *storageServerConnectionExtensionServiceUpdateResponse) MustExtension() *StorageConnectionExtension {
	if p.extension == nil {
		panic("extension in response does not exist")
	}
	return p.extension
}

//
// Update a storage server connection extension for the given host.
// To update the storage connection `456` of host `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123/storageconnectionextensions/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
func (p *storageServerConnectionExtensionService) Update() *storageServerConnectionExtensionServiceUpdateRequest {
	return &storageServerConnectionExtensionServiceUpdateRequest{storageServerConnectionExtensionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageServerConnectionExtensionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *storageServerConnectionExtensionService) String() string {
	return fmt.Sprintf("storageServerConnectionExtensionService:%s", op.path)
}

//
// A service to manage a data center.
//
type dataCenterService struct {
	baseService
}

func NewDataCenterService(connection *Connection, path string) *dataCenterService {
	var result dataCenterService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get a data center.
// An example of getting a data center:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123
// ----
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <storage_format>v3</storage_format>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//    </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <mac_pool href="/ovirt-engine/api/macpools/456" id="456"/>
// </data_center>
// ----
//
type dataCenterServiceGetRequest struct {
	dataCenterService *dataCenterService
	header            map[string]string
	query             map[string]string
	filter            *bool
	follow            *string
}

func (p *dataCenterServiceGetRequest) Header(key, value string) *dataCenterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *dataCenterServiceGetRequest) Query(key, value string) *dataCenterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *dataCenterServiceGetRequest) Filter(filter bool) *dataCenterServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *dataCenterServiceGetRequest) Follow(follow string) *dataCenterServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *dataCenterServiceGetRequest) Send() (*dataCenterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterService.connection.URL(), p.dataCenterService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDataCenterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &dataCenterServiceGetResponse{dataCenter: result}, nil
}

func (p *dataCenterServiceGetRequest) MustSend() *dataCenterServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterService.connection.URL(), p.dataCenterService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDataCenterReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &dataCenterServiceGetResponse{dataCenter: result}
}

//
// Get a data center.
// An example of getting a data center:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123
// ----
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <storage_format>v3</storage_format>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//    </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <mac_pool href="/ovirt-engine/api/macpools/456" id="456"/>
// </data_center>
// ----
//
type dataCenterServiceGetResponse struct {
	dataCenter *DataCenter
}

func (p *dataCenterServiceGetResponse) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *dataCenterServiceGetResponse) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("dataCenter in response does not exist")
	}
	return p.dataCenter
}

//
// Get a data center.
// An example of getting a data center:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123
// ----
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <storage_format>v3</storage_format>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//    </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <mac_pool href="/ovirt-engine/api/macpools/456" id="456"/>
// </data_center>
// ----
//
func (p *dataCenterService) Get() *dataCenterServiceGetRequest {
	return &dataCenterServiceGetRequest{dataCenterService: p}
}

//
// Removes the data center.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123
// ----
// Without any special parameters, the storage domains attached to the data center are detached and then removed
// from the storage. If something fails when performing this operation, for example if there is no host available to
// remove the storage domains from the storage, the complete operation will fail.
// If the `force` parameter is `true` then the operation will always succeed, even if something fails while removing
// one storage domain, for example. The failure is just ignored and the data center is removed from the database
// anyway.
//
type dataCenterServiceRemoveRequest struct {
	dataCenterService *dataCenterService
	header            map[string]string
	query             map[string]string
	async             *bool
	force             *bool
}

func (p *dataCenterServiceRemoveRequest) Header(key, value string) *dataCenterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *dataCenterServiceRemoveRequest) Query(key, value string) *dataCenterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *dataCenterServiceRemoveRequest) Async(async bool) *dataCenterServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *dataCenterServiceRemoveRequest) Force(force bool) *dataCenterServiceRemoveRequest {
	p.force = &force
	return p
}

func (p *dataCenterServiceRemoveRequest) Send() (*dataCenterServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterService.connection.URL(), p.dataCenterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(dataCenterServiceRemoveResponse), nil
}

func (p *dataCenterServiceRemoveRequest) MustSend() *dataCenterServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterService.connection.URL(), p.dataCenterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(dataCenterServiceRemoveResponse)
}

//
// Removes the data center.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123
// ----
// Without any special parameters, the storage domains attached to the data center are detached and then removed
// from the storage. If something fails when performing this operation, for example if there is no host available to
// remove the storage domains from the storage, the complete operation will fail.
// If the `force` parameter is `true` then the operation will always succeed, even if something fails while removing
// one storage domain, for example. The failure is just ignored and the data center is removed from the database
// anyway.
//
type dataCenterServiceRemoveResponse struct {
}

//
// Removes the data center.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123
// ----
// Without any special parameters, the storage domains attached to the data center are detached and then removed
// from the storage. If something fails when performing this operation, for example if there is no host available to
// remove the storage domains from the storage, the complete operation will fail.
// If the `force` parameter is `true` then the operation will always succeed, even if something fails while removing
// one storage domain, for example. The failure is just ignored and the data center is removed from the database
// anyway.
//
func (p *dataCenterService) Remove() *dataCenterServiceRemoveRequest {
	return &dataCenterServiceRemoveRequest{dataCenterService: p}
}

//
// Updates the data center.
// The `name`, `description`, `storage_type`, `version`, `storage_format` and `mac_pool` elements are updatable
// post-creation. For example, to change the name and description of data center `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>myupdatedname</name>
//   <description>An updated description for the data center</description>
// </data_center>
// ----
//
type dataCenterServiceUpdateRequest struct {
	dataCenterService *dataCenterService
	header            map[string]string
	query             map[string]string
	async             *bool
	dataCenter        *DataCenter
}

func (p *dataCenterServiceUpdateRequest) Header(key, value string) *dataCenterServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *dataCenterServiceUpdateRequest) Query(key, value string) *dataCenterServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *dataCenterServiceUpdateRequest) Async(async bool) *dataCenterServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *dataCenterServiceUpdateRequest) DataCenter(dataCenter *DataCenter) *dataCenterServiceUpdateRequest {
	p.dataCenter = dataCenter
	return p
}

func (p *dataCenterServiceUpdateRequest) Send() (*dataCenterServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterService.connection.URL(), p.dataCenterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDataCenterWriteOne(writer, p.dataCenter, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDataCenterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &dataCenterServiceUpdateResponse{dataCenter: result}, nil
}

func (p *dataCenterServiceUpdateRequest) MustSend() *dataCenterServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterService.connection.URL(), p.dataCenterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDataCenterWriteOne(writer, p.dataCenter, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDataCenterReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &dataCenterServiceUpdateResponse{dataCenter: result}
}

//
// Updates the data center.
// The `name`, `description`, `storage_type`, `version`, `storage_format` and `mac_pool` elements are updatable
// post-creation. For example, to change the name and description of data center `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>myupdatedname</name>
//   <description>An updated description for the data center</description>
// </data_center>
// ----
//
type dataCenterServiceUpdateResponse struct {
	dataCenter *DataCenter
}

func (p *dataCenterServiceUpdateResponse) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *dataCenterServiceUpdateResponse) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("dataCenter in response does not exist")
	}
	return p.dataCenter
}

//
// Updates the data center.
// The `name`, `description`, `storage_type`, `version`, `storage_format` and `mac_pool` elements are updatable
// post-creation. For example, to change the name and description of data center `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>myupdatedname</name>
//   <description>An updated description for the data center</description>
// </data_center>
// ----
//
func (p *dataCenterService) Update() *dataCenterServiceUpdateRequest {
	return &dataCenterServiceUpdateRequest{dataCenterService: p}
}

//
//
func (op *dataCenterService) ClustersService() *clustersService {
	return NewClustersService(op.connection, fmt.Sprintf("%s/clusters", op.path))
}

//
// Reference to the iSCSI bonds service.
//
func (op *dataCenterService) IscsiBondsService() *iscsiBondsService {
	return NewIscsiBondsService(op.connection, fmt.Sprintf("%s/iscsibonds", op.path))
}

//
// Returns a reference to the service, that manages the networks, that are associated with the data center.
//
func (op *dataCenterService) NetworksService() *dataCenterNetworksService {
	return NewDataCenterNetworksService(op.connection, fmt.Sprintf("%s/networks", op.path))
}

//
// Reference to the permissions service.
//
func (op *dataCenterService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Reference to the QOSs service.
//
func (op *dataCenterService) QossService() *qossService {
	return NewQossService(op.connection, fmt.Sprintf("%s/qoss", op.path))
}

//
// Reference to the quotas service.
//
func (op *dataCenterService) QuotasService() *quotasService {
	return NewQuotasService(op.connection, fmt.Sprintf("%s/quotas", op.path))
}

//
// Attach and detach storage domains to and from a data center.
// For attaching a single storage domain we should use the following POST request:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>data1</name>
// </storage_domain>
// ----
// For detaching a single storage domain we should use the following DELETE request:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/storagedomains/123
// ----
//
func (op *dataCenterService) StorageDomainsService() *attachedStorageDomainsService {
	return NewAttachedStorageDomainsService(op.connection, fmt.Sprintf("%s/storagedomains", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *dataCenterService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "clusters" {
		return op.ClustersService(), nil
	}
	if strings.HasPrefix(path, "clusters/") {
		return op.ClustersService().Service(path[9:])
	}
	if path == "iscsibonds" {
		return op.IscsiBondsService(), nil
	}
	if strings.HasPrefix(path, "iscsibonds/") {
		return op.IscsiBondsService().Service(path[11:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "qoss" {
		return op.QossService(), nil
	}
	if strings.HasPrefix(path, "qoss/") {
		return op.QossService().Service(path[5:])
	}
	if path == "quotas" {
		return op.QuotasService(), nil
	}
	if strings.HasPrefix(path, "quotas/") {
		return op.QuotasService().Service(path[7:])
	}
	if path == "storagedomains" {
		return op.StorageDomainsService(), nil
	}
	if strings.HasPrefix(path, "storagedomains/") {
		return op.StorageDomainsService().Service(path[15:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *dataCenterService) String() string {
	return fmt.Sprintf("dataCenterService:%s", op.path)
}

//
// Provides information about the cluster features that are supported by a cluster level.
//
type clusterFeaturesService struct {
	baseService
}

func NewClusterFeaturesService(connection *Connection, path string) *clusterFeaturesService {
	var result clusterFeaturesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Lists the cluster features supported by the cluster level.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures
// ----
// This will return a list of cluster features supported by the cluster level:
// [source,xml]
// ----
// <cluster_features>
//   <cluster_feature id="123">
//      <name>test_feature</name>
//   </cluster_feature>
//   ...
// </cluster_features>
// ----
//
type clusterFeaturesServiceListRequest struct {
	clusterFeaturesService *clusterFeaturesService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *clusterFeaturesServiceListRequest) Header(key, value string) *clusterFeaturesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterFeaturesServiceListRequest) Query(key, value string) *clusterFeaturesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterFeaturesServiceListRequest) Follow(follow string) *clusterFeaturesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *clusterFeaturesServiceListRequest) Send() (*clusterFeaturesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterFeaturesService.connection.URL(), p.clusterFeaturesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterFeaturesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterFeaturesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &clusterFeaturesServiceListResponse{features: result}, nil
}

func (p *clusterFeaturesServiceListRequest) MustSend() *clusterFeaturesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterFeaturesService.connection.URL(), p.clusterFeaturesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterFeaturesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterFeaturesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &clusterFeaturesServiceListResponse{features: result}
}

//
// Lists the cluster features supported by the cluster level.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures
// ----
// This will return a list of cluster features supported by the cluster level:
// [source,xml]
// ----
// <cluster_features>
//   <cluster_feature id="123">
//      <name>test_feature</name>
//   </cluster_feature>
//   ...
// </cluster_features>
// ----
//
type clusterFeaturesServiceListResponse struct {
	features *ClusterFeatureSlice
}

func (p *clusterFeaturesServiceListResponse) Features() (*ClusterFeatureSlice, bool) {
	if p.features != nil {
		return p.features, true
	}
	return nil, false
}

func (p *clusterFeaturesServiceListResponse) MustFeatures() *ClusterFeatureSlice {
	if p.features == nil {
		panic("features in response does not exist")
	}
	return p.features
}

//
// Lists the cluster features supported by the cluster level.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures
// ----
// This will return a list of cluster features supported by the cluster level:
// [source,xml]
// ----
// <cluster_features>
//   <cluster_feature id="123">
//      <name>test_feature</name>
//   </cluster_feature>
//   ...
// </cluster_features>
// ----
//
func (p *clusterFeaturesService) List() *clusterFeaturesServiceListRequest {
	return &clusterFeaturesServiceListRequest{clusterFeaturesService: p}
}

//
// Reference to the service that provides information about a specific feature.
//
func (op *clusterFeaturesService) FeatureService(id string) *clusterFeatureService {
	return NewClusterFeatureService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *clusterFeaturesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.FeatureService(path), nil
	}
	return op.FeatureService(path[:index]).Service(path[index+1:])
}

func (op *clusterFeaturesService) String() string {
	return fmt.Sprintf("clusterFeaturesService:%s", op.path)
}

//
// Provides capability to import external virtual machines.
//
type externalVmImportsService struct {
	baseService
}

func NewExternalVmImportsService(connection *Connection, path string) *externalVmImportsService {
	var result externalVmImportsService
	result.connection = connection
	result.path = path
	return &result
}

//
// This operation is used to import a virtual machine from external hypervisor, such as KVM, XEN or VMware.
// For example import of a virtual machine from VMware can be facilitated using the following request:
// [source]
// ----
// POST /externalvmimports
// ----
// With request body of type <<types/external_vm_import,ExternalVmImport>>, for example:
// [source,xml]
// ----
// <external_vm_import>
//   <vm>
//     <name>my_vm</name>
//   </vm>
//   <cluster id="360014051136c20574f743bdbd28177fd" />
//   <storage_domain id="8bb5ade5-e988-4000-8b93-dbfc6717fe50" />
//   <name>vm_name_as_is_in_vmware</name>
//   <sparse>true</sparse>
//   <username>vmware_user</username>
//   <password>123456</password>
//   <provider>VMWARE</provider>
//   <url>vpx://wmware_user@vcenter-host/DataCenter/Cluster/esxi-host?no_verify=1</url>
//   <drivers_iso id="virtio-win-1.6.7.iso" />
// </external_vm_import>
// ----
//
type externalVmImportsServiceAddRequest struct {
	externalVmImportsService *externalVmImportsService
	header                   map[string]string
	query                    map[string]string
	import_                  *ExternalVmImport
}

func (p *externalVmImportsServiceAddRequest) Header(key, value string) *externalVmImportsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalVmImportsServiceAddRequest) Query(key, value string) *externalVmImportsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalVmImportsServiceAddRequest) Import(import_ *ExternalVmImport) *externalVmImportsServiceAddRequest {
	p.import_ = import_
	return p
}

func (p *externalVmImportsServiceAddRequest) Send() (*externalVmImportsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalVmImportsService.connection.URL(), p.externalVmImportsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLExternalVmImportWriteOne(writer, p.import_, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalVmImportsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalVmImportsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalVmImportReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &externalVmImportsServiceAddResponse{import_: result}, nil
}

func (p *externalVmImportsServiceAddRequest) MustSend() *externalVmImportsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalVmImportsService.connection.URL(), p.externalVmImportsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLExternalVmImportWriteOne(writer, p.import_, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalVmImportsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalVmImportsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalVmImportReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &externalVmImportsServiceAddResponse{import_: result}
}

//
// This operation is used to import a virtual machine from external hypervisor, such as KVM, XEN or VMware.
// For example import of a virtual machine from VMware can be facilitated using the following request:
// [source]
// ----
// POST /externalvmimports
// ----
// With request body of type <<types/external_vm_import,ExternalVmImport>>, for example:
// [source,xml]
// ----
// <external_vm_import>
//   <vm>
//     <name>my_vm</name>
//   </vm>
//   <cluster id="360014051136c20574f743bdbd28177fd" />
//   <storage_domain id="8bb5ade5-e988-4000-8b93-dbfc6717fe50" />
//   <name>vm_name_as_is_in_vmware</name>
//   <sparse>true</sparse>
//   <username>vmware_user</username>
//   <password>123456</password>
//   <provider>VMWARE</provider>
//   <url>vpx://wmware_user@vcenter-host/DataCenter/Cluster/esxi-host?no_verify=1</url>
//   <drivers_iso id="virtio-win-1.6.7.iso" />
// </external_vm_import>
// ----
//
type externalVmImportsServiceAddResponse struct {
	import_ *ExternalVmImport
}

func (p *externalVmImportsServiceAddResponse) Import() (*ExternalVmImport, bool) {
	if p.import_ != nil {
		return p.import_, true
	}
	return nil, false
}

func (p *externalVmImportsServiceAddResponse) MustImport() *ExternalVmImport {
	if p.import_ == nil {
		panic("import_ in response does not exist")
	}
	return p.import_
}

//
// This operation is used to import a virtual machine from external hypervisor, such as KVM, XEN or VMware.
// For example import of a virtual machine from VMware can be facilitated using the following request:
// [source]
// ----
// POST /externalvmimports
// ----
// With request body of type <<types/external_vm_import,ExternalVmImport>>, for example:
// [source,xml]
// ----
// <external_vm_import>
//   <vm>
//     <name>my_vm</name>
//   </vm>
//   <cluster id="360014051136c20574f743bdbd28177fd" />
//   <storage_domain id="8bb5ade5-e988-4000-8b93-dbfc6717fe50" />
//   <name>vm_name_as_is_in_vmware</name>
//   <sparse>true</sparse>
//   <username>vmware_user</username>
//   <password>123456</password>
//   <provider>VMWARE</provider>
//   <url>vpx://wmware_user@vcenter-host/DataCenter/Cluster/esxi-host?no_verify=1</url>
//   <drivers_iso id="virtio-win-1.6.7.iso" />
// </external_vm_import>
// ----
//
func (p *externalVmImportsService) Add() *externalVmImportsServiceAddRequest {
	return &externalVmImportsServiceAddRequest{externalVmImportsService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalVmImportsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *externalVmImportsService) String() string {
	return fmt.Sprintf("externalVmImportsService:%s", op.path)
}

//
//
type hostHooksService struct {
	baseService
}

func NewHostHooksService(connection *Connection, path string) *hostHooksService {
	var result hostHooksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of hooks configured for the host.
// The order of the returned list of hooks isn't guranteed.
//
type hostHooksServiceListRequest struct {
	hostHooksService *hostHooksService
	header           map[string]string
	query            map[string]string
	follow           *string
	max              *int64
}

func (p *hostHooksServiceListRequest) Header(key, value string) *hostHooksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *hostHooksServiceListRequest) Query(key, value string) *hostHooksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *hostHooksServiceListRequest) Follow(follow string) *hostHooksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *hostHooksServiceListRequest) Max(max int64) *hostHooksServiceListRequest {
	p.max = &max
	return p
}

func (p *hostHooksServiceListRequest) Send() (*hostHooksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.hostHooksService.connection.URL(), p.hostHooksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostHooksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostHooksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHookReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &hostHooksServiceListResponse{hooks: result}, nil
}

func (p *hostHooksServiceListRequest) MustSend() *hostHooksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.hostHooksService.connection.URL(), p.hostHooksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.hostHooksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.hostHooksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHookReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &hostHooksServiceListResponse{hooks: result}
}

//
// Returns the list of hooks configured for the host.
// The order of the returned list of hooks isn't guranteed.
//
type hostHooksServiceListResponse struct {
	hooks *HookSlice
}

func (p *hostHooksServiceListResponse) Hooks() (*HookSlice, bool) {
	if p.hooks != nil {
		return p.hooks, true
	}
	return nil, false
}

func (p *hostHooksServiceListResponse) MustHooks() *HookSlice {
	if p.hooks == nil {
		panic("hooks in response does not exist")
	}
	return p.hooks
}

//
// Returns the list of hooks configured for the host.
// The order of the returned list of hooks isn't guranteed.
//
func (p *hostHooksService) List() *hostHooksServiceListRequest {
	return &hostHooksServiceListRequest{hostHooksService: p}
}

//
//
func (op *hostHooksService) HookService(id string) *hostHookService {
	return NewHostHookService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *hostHooksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HookService(path), nil
	}
	return op.HookService(path[:index]).Service(path[index+1:])
}

func (op *hostHooksService) String() string {
	return fmt.Sprintf("hostHooksService:%s", op.path)
}

//
// Manages the collection of disk snapshots available in an storage domain.
//
type diskSnapshotsService struct {
	baseService
}

func NewDiskSnapshotsService(connection *Connection, path string) *diskSnapshotsService {
	var result diskSnapshotsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of disk snapshots of the storage domain.
// The order of the returned list of disk snapshots isn't guaranteed.
//
type diskSnapshotsServiceListRequest struct {
	diskSnapshotsService *diskSnapshotsService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *diskSnapshotsServiceListRequest) Header(key, value string) *diskSnapshotsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskSnapshotsServiceListRequest) Query(key, value string) *diskSnapshotsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskSnapshotsServiceListRequest) Follow(follow string) *diskSnapshotsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *diskSnapshotsServiceListRequest) Max(max int64) *diskSnapshotsServiceListRequest {
	p.max = &max
	return p
}

func (p *diskSnapshotsServiceListRequest) Send() (*diskSnapshotsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskSnapshotsService.connection.URL(), p.diskSnapshotsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskSnapshotsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskSnapshotsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskSnapshotReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &diskSnapshotsServiceListResponse{snapshots: result}, nil
}

func (p *diskSnapshotsServiceListRequest) MustSend() *diskSnapshotsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskSnapshotsService.connection.URL(), p.diskSnapshotsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskSnapshotsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskSnapshotsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskSnapshotReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &diskSnapshotsServiceListResponse{snapshots: result}
}

//
// Returns the list of disk snapshots of the storage domain.
// The order of the returned list of disk snapshots isn't guaranteed.
//
type diskSnapshotsServiceListResponse struct {
	snapshots *DiskSnapshotSlice
}

func (p *diskSnapshotsServiceListResponse) Snapshots() (*DiskSnapshotSlice, bool) {
	if p.snapshots != nil {
		return p.snapshots, true
	}
	return nil, false
}

func (p *diskSnapshotsServiceListResponse) MustSnapshots() *DiskSnapshotSlice {
	if p.snapshots == nil {
		panic("snapshots in response does not exist")
	}
	return p.snapshots
}

//
// Returns the list of disk snapshots of the storage domain.
// The order of the returned list of disk snapshots isn't guaranteed.
//
func (p *diskSnapshotsService) List() *diskSnapshotsServiceListRequest {
	return &diskSnapshotsServiceListRequest{diskSnapshotsService: p}
}

//
//
func (op *diskSnapshotsService) SnapshotService(id string) *diskSnapshotService {
	return NewDiskSnapshotService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *diskSnapshotsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.SnapshotService(path), nil
	}
	return op.SnapshotService(path[:index]).Service(path[index+1:])
}

func (op *diskSnapshotsService) String() string {
	return fmt.Sprintf("diskSnapshotsService:%s", op.path)
}

//
//
type instanceTypeGraphicsConsolesService struct {
	baseService
}

func NewInstanceTypeGraphicsConsolesService(connection *Connection, path string) *instanceTypeGraphicsConsolesService {
	var result instanceTypeGraphicsConsolesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add new graphics console to the instance type.
//
type instanceTypeGraphicsConsolesServiceAddRequest struct {
	instanceTypeGraphicsConsolesService *instanceTypeGraphicsConsolesService
	header                              map[string]string
	query                               map[string]string
	console                             *GraphicsConsole
}

func (p *instanceTypeGraphicsConsolesServiceAddRequest) Header(key, value string) *instanceTypeGraphicsConsolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeGraphicsConsolesServiceAddRequest) Query(key, value string) *instanceTypeGraphicsConsolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeGraphicsConsolesServiceAddRequest) Console(console *GraphicsConsole) *instanceTypeGraphicsConsolesServiceAddRequest {
	p.console = console
	return p
}

func (p *instanceTypeGraphicsConsolesServiceAddRequest) Send() (*instanceTypeGraphicsConsolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsolesService.connection.URL(), p.instanceTypeGraphicsConsolesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGraphicsConsoleWriteOne(writer, p.console, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeGraphicsConsolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &instanceTypeGraphicsConsolesServiceAddResponse{console: result}, nil
}

func (p *instanceTypeGraphicsConsolesServiceAddRequest) MustSend() *instanceTypeGraphicsConsolesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsolesService.connection.URL(), p.instanceTypeGraphicsConsolesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGraphicsConsoleWriteOne(writer, p.console, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeGraphicsConsolesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &instanceTypeGraphicsConsolesServiceAddResponse{console: result}
}

//
// Add new graphics console to the instance type.
//
type instanceTypeGraphicsConsolesServiceAddResponse struct {
	console *GraphicsConsole
}

func (p *instanceTypeGraphicsConsolesServiceAddResponse) Console() (*GraphicsConsole, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

func (p *instanceTypeGraphicsConsolesServiceAddResponse) MustConsole() *GraphicsConsole {
	if p.console == nil {
		panic("console in response does not exist")
	}
	return p.console
}

//
// Add new graphics console to the instance type.
//
func (p *instanceTypeGraphicsConsolesService) Add() *instanceTypeGraphicsConsolesServiceAddRequest {
	return &instanceTypeGraphicsConsolesServiceAddRequest{instanceTypeGraphicsConsolesService: p}
}

//
// Lists all the configured graphics consoles of the instance type.
// The order of the returned list of graphics consoles isn't guaranteed.
//
type instanceTypeGraphicsConsolesServiceListRequest struct {
	instanceTypeGraphicsConsolesService *instanceTypeGraphicsConsolesService
	header                              map[string]string
	query                               map[string]string
	follow                              *string
	max                                 *int64
}

func (p *instanceTypeGraphicsConsolesServiceListRequest) Header(key, value string) *instanceTypeGraphicsConsolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeGraphicsConsolesServiceListRequest) Query(key, value string) *instanceTypeGraphicsConsolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeGraphicsConsolesServiceListRequest) Follow(follow string) *instanceTypeGraphicsConsolesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *instanceTypeGraphicsConsolesServiceListRequest) Max(max int64) *instanceTypeGraphicsConsolesServiceListRequest {
	p.max = &max
	return p
}

func (p *instanceTypeGraphicsConsolesServiceListRequest) Send() (*instanceTypeGraphicsConsolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsolesService.connection.URL(), p.instanceTypeGraphicsConsolesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeGraphicsConsolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &instanceTypeGraphicsConsolesServiceListResponse{consoles: result}, nil
}

func (p *instanceTypeGraphicsConsolesServiceListRequest) MustSend() *instanceTypeGraphicsConsolesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsolesService.connection.URL(), p.instanceTypeGraphicsConsolesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeGraphicsConsolesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &instanceTypeGraphicsConsolesServiceListResponse{consoles: result}
}

//
// Lists all the configured graphics consoles of the instance type.
// The order of the returned list of graphics consoles isn't guaranteed.
//
type instanceTypeGraphicsConsolesServiceListResponse struct {
	consoles *GraphicsConsoleSlice
}

func (p *instanceTypeGraphicsConsolesServiceListResponse) Consoles() (*GraphicsConsoleSlice, bool) {
	if p.consoles != nil {
		return p.consoles, true
	}
	return nil, false
}

func (p *instanceTypeGraphicsConsolesServiceListResponse) MustConsoles() *GraphicsConsoleSlice {
	if p.consoles == nil {
		panic("consoles in response does not exist")
	}
	return p.consoles
}

//
// Lists all the configured graphics consoles of the instance type.
// The order of the returned list of graphics consoles isn't guaranteed.
//
func (p *instanceTypeGraphicsConsolesService) List() *instanceTypeGraphicsConsolesServiceListRequest {
	return &instanceTypeGraphicsConsolesServiceListRequest{instanceTypeGraphicsConsolesService: p}
}

//
// Returns a reference to the service that manages a specific instance type graphics console.
//
func (op *instanceTypeGraphicsConsolesService) ConsoleService(id string) *instanceTypeGraphicsConsoleService {
	return NewInstanceTypeGraphicsConsoleService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *instanceTypeGraphicsConsolesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ConsoleService(path), nil
	}
	return op.ConsoleService(path[:index]).Service(path[index+1:])
}

func (op *instanceTypeGraphicsConsolesService) String() string {
	return fmt.Sprintf("instanceTypeGraphicsConsolesService:%s", op.path)
}

//
// This service represents list of hosts that have a specific
// label when accessed through the affinitylabels/hosts
// subcollection.
//
type affinityLabelHostsService struct {
	baseService
}

func NewAffinityLabelHostsService(connection *Connection, path string) *affinityLabelHostsService {
	var result affinityLabelHostsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a label to a host.
//
type affinityLabelHostsServiceAddRequest struct {
	affinityLabelHostsService *affinityLabelHostsService
	header                    map[string]string
	query                     map[string]string
	host                      *Host
}

func (p *affinityLabelHostsServiceAddRequest) Header(key, value string) *affinityLabelHostsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelHostsServiceAddRequest) Query(key, value string) *affinityLabelHostsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelHostsServiceAddRequest) Host(host *Host) *affinityLabelHostsServiceAddRequest {
	p.host = host
	return p
}

func (p *affinityLabelHostsServiceAddRequest) Send() (*affinityLabelHostsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostsService.connection.URL(), p.affinityLabelHostsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostWriteOne(writer, p.host, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelHostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &affinityLabelHostsServiceAddResponse{host: result}, nil
}

func (p *affinityLabelHostsServiceAddRequest) MustSend() *affinityLabelHostsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostsService.connection.URL(), p.affinityLabelHostsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostWriteOne(writer, p.host, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelHostsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &affinityLabelHostsServiceAddResponse{host: result}
}

//
// Add a label to a host.
//
type affinityLabelHostsServiceAddResponse struct {
	host *Host
}

func (p *affinityLabelHostsServiceAddResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *affinityLabelHostsServiceAddResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Add a label to a host.
//
func (p *affinityLabelHostsService) Add() *affinityLabelHostsServiceAddRequest {
	return &affinityLabelHostsServiceAddRequest{affinityLabelHostsService: p}
}

//
// List all hosts with the label.
// The order of the returned hosts isn't guaranteed.
//
type affinityLabelHostsServiceListRequest struct {
	affinityLabelHostsService *affinityLabelHostsService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
}

func (p *affinityLabelHostsServiceListRequest) Header(key, value string) *affinityLabelHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelHostsServiceListRequest) Query(key, value string) *affinityLabelHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelHostsServiceListRequest) Follow(follow string) *affinityLabelHostsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *affinityLabelHostsServiceListRequest) Send() (*affinityLabelHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostsService.connection.URL(), p.affinityLabelHostsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelHostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &affinityLabelHostsServiceListResponse{hosts: result}, nil
}

func (p *affinityLabelHostsServiceListRequest) MustSend() *affinityLabelHostsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelHostsService.connection.URL(), p.affinityLabelHostsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelHostsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelHostsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &affinityLabelHostsServiceListResponse{hosts: result}
}

//
// List all hosts with the label.
// The order of the returned hosts isn't guaranteed.
//
type affinityLabelHostsServiceListResponse struct {
	hosts *HostSlice
}

func (p *affinityLabelHostsServiceListResponse) Hosts() (*HostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *affinityLabelHostsServiceListResponse) MustHosts() *HostSlice {
	if p.hosts == nil {
		panic("hosts in response does not exist")
	}
	return p.hosts
}

//
// List all hosts with the label.
// The order of the returned hosts isn't guaranteed.
//
func (p *affinityLabelHostsService) List() *affinityLabelHostsServiceListRequest {
	return &affinityLabelHostsServiceListRequest{affinityLabelHostsService: p}
}

//
// A link to the specific label-host assignment to
// allow label removal.
//
func (op *affinityLabelHostsService) HostService(id string) *affinityLabelHostService {
	return NewAffinityLabelHostService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *affinityLabelHostsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HostService(path), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *affinityLabelHostsService) String() string {
	return fmt.Sprintf("affinityLabelHostsService:%s", op.path)
}

//
//
type storageDomainVmService struct {
	baseService
}

func NewStorageDomainVmService(connection *Connection, path string) *storageDomainVmService {
	var result storageDomainVmService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type storageDomainVmServiceGetRequest struct {
	storageDomainVmService *storageDomainVmService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *storageDomainVmServiceGetRequest) Header(key, value string) *storageDomainVmServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainVmServiceGetRequest) Query(key, value string) *storageDomainVmServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainVmServiceGetRequest) Follow(follow string) *storageDomainVmServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainVmServiceGetRequest) Send() (*storageDomainVmServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmService.connection.URL(), p.storageDomainVmService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageDomainVmServiceGetResponse{vm: result}, nil
}

func (p *storageDomainVmServiceGetRequest) MustSend() *storageDomainVmServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmService.connection.URL(), p.storageDomainVmService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageDomainVmServiceGetResponse{vm: result}
}

//
//
type storageDomainVmServiceGetResponse struct {
	vm *Vm
}

func (p *storageDomainVmServiceGetResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *storageDomainVmServiceGetResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
//
func (p *storageDomainVmService) Get() *storageDomainVmServiceGetRequest {
	return &storageDomainVmServiceGetRequest{storageDomainVmService: p}
}

//
// Imports a virtual machine from an export storage domain.
// For example, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/vms/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// To import a virtual machine as a new entity add the `clone` parameter:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <clone>true</clone>
//   <vm>
//     <name>myvm</name>
//   </vm>
// </action>
// ----
// Include an optional `disks` parameter to choose which disks to import. For example, to import the disks
// of the template that have the identifiers `123` and `456` send the following request body:
// [source,xml]
// ----
// <action>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <vm>
//     <name>myvm</name>
//   </vm>
//   <disks>
//     <disk id="123"/>
//     <disk id="456"/>
//   </disks>
// </action>
// ----
// If you register an entity without specifying the cluster ID or name,
// the cluster name from the entity's OVF will be used (unless the register request also includes the
// cluster mapping).
//
type storageDomainVmServiceImportRequest struct {
	storageDomainVmService *storageDomainVmService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
	clone                  *bool
	cluster                *Cluster
	collapseSnapshots      *bool
	exclusive              *bool
	storageDomain          *StorageDomain
	vm                     *Vm
}

func (p *storageDomainVmServiceImportRequest) Header(key, value string) *storageDomainVmServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainVmServiceImportRequest) Query(key, value string) *storageDomainVmServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainVmServiceImportRequest) Async(async bool) *storageDomainVmServiceImportRequest {
	p.async = &async
	return p
}

func (p *storageDomainVmServiceImportRequest) Clone(clone bool) *storageDomainVmServiceImportRequest {
	p.clone = &clone
	return p
}

func (p *storageDomainVmServiceImportRequest) Cluster(cluster *Cluster) *storageDomainVmServiceImportRequest {
	p.cluster = cluster
	return p
}

func (p *storageDomainVmServiceImportRequest) CollapseSnapshots(collapseSnapshots bool) *storageDomainVmServiceImportRequest {
	p.collapseSnapshots = &collapseSnapshots
	return p
}

func (p *storageDomainVmServiceImportRequest) Exclusive(exclusive bool) *storageDomainVmServiceImportRequest {
	p.exclusive = &exclusive
	return p
}

func (p *storageDomainVmServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *storageDomainVmServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *storageDomainVmServiceImportRequest) Vm(vm *Vm) *storageDomainVmServiceImportRequest {
	p.vm = vm
	return p
}

func (p *storageDomainVmServiceImportRequest) Send() (*storageDomainVmServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.storageDomainVmService.connection.URL(), p.storageDomainVmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	actionBuilder.Cluster(p.cluster)
	if p.collapseSnapshots != nil {
		actionBuilder.CollapseSnapshots(*p.collapseSnapshots)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(storageDomainVmServiceImportResponse), nil
}

func (p *storageDomainVmServiceImportRequest) MustSend() *storageDomainVmServiceImportResponse {
	rawURL := fmt.Sprintf("%s%s/import", p.storageDomainVmService.connection.URL(), p.storageDomainVmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	actionBuilder.Cluster(p.cluster)
	if p.collapseSnapshots != nil {
		actionBuilder.CollapseSnapshots(*p.collapseSnapshots)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(storageDomainVmServiceImportResponse)
}

//
// Imports a virtual machine from an export storage domain.
// For example, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/vms/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// To import a virtual machine as a new entity add the `clone` parameter:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <clone>true</clone>
//   <vm>
//     <name>myvm</name>
//   </vm>
// </action>
// ----
// Include an optional `disks` parameter to choose which disks to import. For example, to import the disks
// of the template that have the identifiers `123` and `456` send the following request body:
// [source,xml]
// ----
// <action>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <vm>
//     <name>myvm</name>
//   </vm>
//   <disks>
//     <disk id="123"/>
//     <disk id="456"/>
//   </disks>
// </action>
// ----
// If you register an entity without specifying the cluster ID or name,
// the cluster name from the entity's OVF will be used (unless the register request also includes the
// cluster mapping).
//
type storageDomainVmServiceImportResponse struct {
}

//
// Imports a virtual machine from an export storage domain.
// For example, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/vms/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// To import a virtual machine as a new entity add the `clone` parameter:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <clone>true</clone>
//   <vm>
//     <name>myvm</name>
//   </vm>
// </action>
// ----
// Include an optional `disks` parameter to choose which disks to import. For example, to import the disks
// of the template that have the identifiers `123` and `456` send the following request body:
// [source,xml]
// ----
// <action>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <vm>
//     <name>myvm</name>
//   </vm>
//   <disks>
//     <disk id="123"/>
//     <disk id="456"/>
//   </disks>
// </action>
// ----
// If you register an entity without specifying the cluster ID or name,
// the cluster name from the entity's OVF will be used (unless the register request also includes the
// cluster mapping).
//
func (p *storageDomainVmService) Import() *storageDomainVmServiceImportRequest {
	return &storageDomainVmServiceImportRequest{storageDomainVmService: p}
}

//
//
type storageDomainVmServiceRegisterRequest struct {
	storageDomainVmService    *storageDomainVmService
	header                    map[string]string
	query                     map[string]string
	allowPartialImport        *bool
	async                     *bool
	clone                     *bool
	cluster                   *Cluster
	reassignBadMacs           *bool
	registrationConfiguration *RegistrationConfiguration
	vm                        *Vm
	vnicProfileMappings       *VnicProfileMappingSlice
}

func (p *storageDomainVmServiceRegisterRequest) Header(key, value string) *storageDomainVmServiceRegisterRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainVmServiceRegisterRequest) Query(key, value string) *storageDomainVmServiceRegisterRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainVmServiceRegisterRequest) AllowPartialImport(allowPartialImport bool) *storageDomainVmServiceRegisterRequest {
	p.allowPartialImport = &allowPartialImport
	return p
}

func (p *storageDomainVmServiceRegisterRequest) Async(async bool) *storageDomainVmServiceRegisterRequest {
	p.async = &async
	return p
}

func (p *storageDomainVmServiceRegisterRequest) Clone(clone bool) *storageDomainVmServiceRegisterRequest {
	p.clone = &clone
	return p
}

func (p *storageDomainVmServiceRegisterRequest) Cluster(cluster *Cluster) *storageDomainVmServiceRegisterRequest {
	p.cluster = cluster
	return p
}

func (p *storageDomainVmServiceRegisterRequest) ReassignBadMacs(reassignBadMacs bool) *storageDomainVmServiceRegisterRequest {
	p.reassignBadMacs = &reassignBadMacs
	return p
}

func (p *storageDomainVmServiceRegisterRequest) RegistrationConfiguration(registrationConfiguration *RegistrationConfiguration) *storageDomainVmServiceRegisterRequest {
	p.registrationConfiguration = registrationConfiguration
	return p
}

func (p *storageDomainVmServiceRegisterRequest) Vm(vm *Vm) *storageDomainVmServiceRegisterRequest {
	p.vm = vm
	return p
}

func (p *storageDomainVmServiceRegisterRequest) VnicProfileMappings(vnicProfileMappings *VnicProfileMappingSlice) *storageDomainVmServiceRegisterRequest {
	p.vnicProfileMappings = vnicProfileMappings
	return p
}

func (p *storageDomainVmServiceRegisterRequest) VnicProfileMappingsOfAny(anys ...*VnicProfileMapping) *storageDomainVmServiceRegisterRequest {
	if p.vnicProfileMappings == nil {
		p.vnicProfileMappings = new(VnicProfileMappingSlice)
	}
	p.vnicProfileMappings.slice = append(p.vnicProfileMappings.slice, anys...)
	return p
}

func (p *storageDomainVmServiceRegisterRequest) Send() (*storageDomainVmServiceRegisterResponse, error) {
	rawURL := fmt.Sprintf("%s%s/register", p.storageDomainVmService.connection.URL(), p.storageDomainVmService.path)
	actionBuilder := NewActionBuilder()
	if p.allowPartialImport != nil {
		actionBuilder.AllowPartialImport(*p.allowPartialImport)
	}
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	actionBuilder.Cluster(p.cluster)
	if p.reassignBadMacs != nil {
		actionBuilder.ReassignBadMacs(*p.reassignBadMacs)
	}
	actionBuilder.RegistrationConfiguration(p.registrationConfiguration)
	actionBuilder.Vm(p.vm)
	actionBuilder.VnicProfileMappings(p.vnicProfileMappings)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(storageDomainVmServiceRegisterResponse), nil
}

func (p *storageDomainVmServiceRegisterRequest) MustSend() *storageDomainVmServiceRegisterResponse {
	rawURL := fmt.Sprintf("%s%s/register", p.storageDomainVmService.connection.URL(), p.storageDomainVmService.path)
	actionBuilder := NewActionBuilder()
	if p.allowPartialImport != nil {
		actionBuilder.AllowPartialImport(*p.allowPartialImport)
	}
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	actionBuilder.Cluster(p.cluster)
	if p.reassignBadMacs != nil {
		actionBuilder.ReassignBadMacs(*p.reassignBadMacs)
	}
	actionBuilder.RegistrationConfiguration(p.registrationConfiguration)
	actionBuilder.Vm(p.vm)
	actionBuilder.VnicProfileMappings(p.vnicProfileMappings)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(storageDomainVmServiceRegisterResponse)
}

//
//
type storageDomainVmServiceRegisterResponse struct {
}

//
//
func (p *storageDomainVmService) Register() *storageDomainVmServiceRegisterRequest {
	return &storageDomainVmServiceRegisterRequest{storageDomainVmService: p}
}

//
// Deletes a virtual machine from an export storage domain.
// For example, to delete the virtual machine `456` from the storage domain `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/storagedomains/123/vms/456
// ----
//
type storageDomainVmServiceRemoveRequest struct {
	storageDomainVmService *storageDomainVmService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *storageDomainVmServiceRemoveRequest) Header(key, value string) *storageDomainVmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainVmServiceRemoveRequest) Query(key, value string) *storageDomainVmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainVmServiceRemoveRequest) Async(async bool) *storageDomainVmServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *storageDomainVmServiceRemoveRequest) Send() (*storageDomainVmServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmService.connection.URL(), p.storageDomainVmService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(storageDomainVmServiceRemoveResponse), nil
}

func (p *storageDomainVmServiceRemoveRequest) MustSend() *storageDomainVmServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmService.connection.URL(), p.storageDomainVmService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(storageDomainVmServiceRemoveResponse)
}

//
// Deletes a virtual machine from an export storage domain.
// For example, to delete the virtual machine `456` from the storage domain `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/storagedomains/123/vms/456
// ----
//
type storageDomainVmServiceRemoveResponse struct {
}

//
// Deletes a virtual machine from an export storage domain.
// For example, to delete the virtual machine `456` from the storage domain `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/storagedomains/123/vms/456
// ----
//
func (p *storageDomainVmService) Remove() *storageDomainVmServiceRemoveRequest {
	return &storageDomainVmServiceRemoveRequest{storageDomainVmService: p}
}

//
// Returns a reference to the service that manages the disk attachments of the virtual machine.
//
func (op *storageDomainVmService) DiskAttachmentsService() *storageDomainVmDiskAttachmentsService {
	return NewStorageDomainVmDiskAttachmentsService(op.connection, fmt.Sprintf("%s/diskattachments", op.path))
}

//
//
func (op *storageDomainVmService) DisksService() *storageDomainContentDisksService {
	return NewStorageDomainContentDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainVmService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "diskattachments" {
		return op.DiskAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "diskattachments/") {
		return op.DiskAttachmentsService().Service(path[16:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *storageDomainVmService) String() string {
	return fmt.Sprintf("storageDomainVmService:%s", op.path)
}

//
//
type quotaService struct {
	baseService
}

func NewQuotaService(connection *Connection, path string) *quotaService {
	var result quotaService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves a quota.
// An example of retrieving a quota:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota id="456">
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
//   <cluster_hard_limit_pct>20</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>80</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
type quotaServiceGetRequest struct {
	quotaService *quotaService
	header       map[string]string
	query        map[string]string
	follow       *string
}

func (p *quotaServiceGetRequest) Header(key, value string) *quotaServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotaServiceGetRequest) Query(key, value string) *quotaServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotaServiceGetRequest) Follow(follow string) *quotaServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *quotaServiceGetRequest) Send() (*quotaServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaService.connection.URL(), p.quotaService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &quotaServiceGetResponse{quota: result}, nil
}

func (p *quotaServiceGetRequest) MustSend() *quotaServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotaService.connection.URL(), p.quotaService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &quotaServiceGetResponse{quota: result}
}

//
// Retrieves a quota.
// An example of retrieving a quota:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota id="456">
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
//   <cluster_hard_limit_pct>20</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>80</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
type quotaServiceGetResponse struct {
	quota *Quota
}

func (p *quotaServiceGetResponse) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

func (p *quotaServiceGetResponse) MustQuota() *Quota {
	if p.quota == nil {
		panic("quota in response does not exist")
	}
	return p.quota
}

//
// Retrieves a quota.
// An example of retrieving a quota:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota id="456">
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
//   <cluster_hard_limit_pct>20</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>80</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
func (p *quotaService) Get() *quotaServiceGetRequest {
	return &quotaServiceGetRequest{quotaService: p}
}

//
// Delete a quota.
// An example of deleting a quota:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123-456/quotas/654-321
// -0472718ab224 HTTP/1.1
// Accept: application/xml
// Content-type: application/xml
// ----
//
type quotaServiceRemoveRequest struct {
	quotaService *quotaService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *quotaServiceRemoveRequest) Header(key, value string) *quotaServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotaServiceRemoveRequest) Query(key, value string) *quotaServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotaServiceRemoveRequest) Async(async bool) *quotaServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *quotaServiceRemoveRequest) Send() (*quotaServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaService.connection.URL(), p.quotaService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(quotaServiceRemoveResponse), nil
}

func (p *quotaServiceRemoveRequest) MustSend() *quotaServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotaService.connection.URL(), p.quotaService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(quotaServiceRemoveResponse)
}

//
// Delete a quota.
// An example of deleting a quota:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123-456/quotas/654-321
// -0472718ab224 HTTP/1.1
// Accept: application/xml
// Content-type: application/xml
// ----
//
type quotaServiceRemoveResponse struct {
}

//
// Delete a quota.
// An example of deleting a quota:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123-456/quotas/654-321
// -0472718ab224 HTTP/1.1
// Accept: application/xml
// Content-type: application/xml
// ----
//
func (p *quotaService) Remove() *quotaServiceRemoveRequest {
	return &quotaServiceRemoveRequest{quotaService: p}
}

//
// Updates a quota.
// An example of updating a quota:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota>
//   <cluster_hard_limit_pct>30</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>70</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
type quotaServiceUpdateRequest struct {
	quotaService *quotaService
	header       map[string]string
	query        map[string]string
	async        *bool
	quota        *Quota
}

func (p *quotaServiceUpdateRequest) Header(key, value string) *quotaServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotaServiceUpdateRequest) Query(key, value string) *quotaServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotaServiceUpdateRequest) Async(async bool) *quotaServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *quotaServiceUpdateRequest) Quota(quota *Quota) *quotaServiceUpdateRequest {
	p.quota = quota
	return p
}

func (p *quotaServiceUpdateRequest) Send() (*quotaServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotaService.connection.URL(), p.quotaService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQuotaWriteOne(writer, p.quota, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &quotaServiceUpdateResponse{quota: result}, nil
}

func (p *quotaServiceUpdateRequest) MustSend() *quotaServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotaService.connection.URL(), p.quotaService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQuotaWriteOne(writer, p.quota, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotaService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotaService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &quotaServiceUpdateResponse{quota: result}
}

//
// Updates a quota.
// An example of updating a quota:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota>
//   <cluster_hard_limit_pct>30</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>70</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
type quotaServiceUpdateResponse struct {
	quota *Quota
}

func (p *quotaServiceUpdateResponse) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

func (p *quotaServiceUpdateResponse) MustQuota() *Quota {
	if p.quota == nil {
		panic("quota in response does not exist")
	}
	return p.quota
}

//
// Updates a quota.
// An example of updating a quota:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota>
//   <cluster_hard_limit_pct>30</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>70</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
func (p *quotaService) Update() *quotaServiceUpdateRequest {
	return &quotaServiceUpdateRequest{quotaService: p}
}

//
//
func (op *quotaService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *quotaService) QuotaClusterLimitsService() *quotaClusterLimitsService {
	return NewQuotaClusterLimitsService(op.connection, fmt.Sprintf("%s/quotaclusterlimits", op.path))
}

//
//
func (op *quotaService) QuotaStorageLimitsService() *quotaStorageLimitsService {
	return NewQuotaStorageLimitsService(op.connection, fmt.Sprintf("%s/quotastoragelimits", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *quotaService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "quotaclusterlimits" {
		return op.QuotaClusterLimitsService(), nil
	}
	if strings.HasPrefix(path, "quotaclusterlimits/") {
		return op.QuotaClusterLimitsService().Service(path[19:])
	}
	if path == "quotastoragelimits" {
		return op.QuotaStorageLimitsService(), nil
	}
	if strings.HasPrefix(path, "quotastoragelimits/") {
		return op.QuotaStorageLimitsService().Service(path[19:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *quotaService) String() string {
	return fmt.Sprintf("quotaService:%s", op.path)
}

//
// Provides information about the capabilities of different cluster levels supported by the engine. Version 4.0 of the
// engine supports levels 4.0 and 3.6. Each of these levels support different sets of CPU types, for example. This
// service provides that information.
//
type clusterLevelsService struct {
	baseService
}

func NewClusterLevelsService(connection *Connection, path string) *clusterLevelsService {
	var result clusterLevelsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Lists the cluster levels supported by the system.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels
// ----
// This will return a list of available cluster levels.
// [source,xml]
// ----
// <cluster_levels>
//   <cluster_level id="4.0">
//      ...
//   </cluster_level>
//   ...
// </cluster_levels>
// ----
// The order of the returned cluster levels isn't guaranteed.
//
type clusterLevelsServiceListRequest struct {
	clusterLevelsService *clusterLevelsService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *clusterLevelsServiceListRequest) Header(key, value string) *clusterLevelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterLevelsServiceListRequest) Query(key, value string) *clusterLevelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterLevelsServiceListRequest) Follow(follow string) *clusterLevelsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *clusterLevelsServiceListRequest) Send() (*clusterLevelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterLevelsService.connection.URL(), p.clusterLevelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterLevelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterLevelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterLevelReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &clusterLevelsServiceListResponse{levels: result}, nil
}

func (p *clusterLevelsServiceListRequest) MustSend() *clusterLevelsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterLevelsService.connection.URL(), p.clusterLevelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterLevelsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterLevelsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterLevelReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &clusterLevelsServiceListResponse{levels: result}
}

//
// Lists the cluster levels supported by the system.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels
// ----
// This will return a list of available cluster levels.
// [source,xml]
// ----
// <cluster_levels>
//   <cluster_level id="4.0">
//      ...
//   </cluster_level>
//   ...
// </cluster_levels>
// ----
// The order of the returned cluster levels isn't guaranteed.
//
type clusterLevelsServiceListResponse struct {
	levels *ClusterLevelSlice
}

func (p *clusterLevelsServiceListResponse) Levels() (*ClusterLevelSlice, bool) {
	if p.levels != nil {
		return p.levels, true
	}
	return nil, false
}

func (p *clusterLevelsServiceListResponse) MustLevels() *ClusterLevelSlice {
	if p.levels == nil {
		panic("levels in response does not exist")
	}
	return p.levels
}

//
// Lists the cluster levels supported by the system.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels
// ----
// This will return a list of available cluster levels.
// [source,xml]
// ----
// <cluster_levels>
//   <cluster_level id="4.0">
//      ...
//   </cluster_level>
//   ...
// </cluster_levels>
// ----
// The order of the returned cluster levels isn't guaranteed.
//
func (p *clusterLevelsService) List() *clusterLevelsServiceListRequest {
	return &clusterLevelsServiceListRequest{clusterLevelsService: p}
}

//
// Reference to the service that provides information about an specific cluster level.
//
func (op *clusterLevelsService) LevelService(id string) *clusterLevelService {
	return NewClusterLevelService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *clusterLevelsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LevelService(path), nil
	}
	return op.LevelService(path[:index]).Service(path[index+1:])
}

func (op *clusterLevelsService) String() string {
	return fmt.Sprintf("clusterLevelsService:%s", op.path)
}

//
// Represents a feature enabled for the cluster level
//
type clusterFeatureService struct {
	baseService
}

func NewClusterFeatureService(connection *Connection, path string) *clusterFeatureService {
	var result clusterFeatureService
	result.connection = connection
	result.path = path
	return &result
}

//
// Provides the information about the a cluster feature supported by a cluster level.
// For example, to find details of the cluster feature `456` for cluster level 4.1, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures/456
// ----
// That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
// [source,xml]
// ----
// <cluster_feature id="456">
//   <name>libgfapi_supported</name>
// </cluster_feature>
// ----
//
type clusterFeatureServiceGetRequest struct {
	clusterFeatureService *clusterFeatureService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *clusterFeatureServiceGetRequest) Header(key, value string) *clusterFeatureServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterFeatureServiceGetRequest) Query(key, value string) *clusterFeatureServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterFeatureServiceGetRequest) Follow(follow string) *clusterFeatureServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *clusterFeatureServiceGetRequest) Send() (*clusterFeatureServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterFeatureService.connection.URL(), p.clusterFeatureService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterFeatureService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterFeatureService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &clusterFeatureServiceGetResponse{feature: result}, nil
}

func (p *clusterFeatureServiceGetRequest) MustSend() *clusterFeatureServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterFeatureService.connection.URL(), p.clusterFeatureService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterFeatureService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterFeatureService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &clusterFeatureServiceGetResponse{feature: result}
}

//
// Provides the information about the a cluster feature supported by a cluster level.
// For example, to find details of the cluster feature `456` for cluster level 4.1, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures/456
// ----
// That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
// [source,xml]
// ----
// <cluster_feature id="456">
//   <name>libgfapi_supported</name>
// </cluster_feature>
// ----
//
type clusterFeatureServiceGetResponse struct {
	feature *ClusterFeature
}

func (p *clusterFeatureServiceGetResponse) Feature() (*ClusterFeature, bool) {
	if p.feature != nil {
		return p.feature, true
	}
	return nil, false
}

func (p *clusterFeatureServiceGetResponse) MustFeature() *ClusterFeature {
	if p.feature == nil {
		panic("feature in response does not exist")
	}
	return p.feature
}

//
// Provides the information about the a cluster feature supported by a cluster level.
// For example, to find details of the cluster feature `456` for cluster level 4.1, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures/456
// ----
// That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
// [source,xml]
// ----
// <cluster_feature id="456">
//   <name>libgfapi_supported</name>
// </cluster_feature>
// ----
//
func (p *clusterFeatureService) Get() *clusterFeatureServiceGetRequest {
	return &clusterFeatureServiceGetRequest{clusterFeatureService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *clusterFeatureService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *clusterFeatureService) String() string {
	return fmt.Sprintf("clusterFeatureService:%s", op.path)
}

//
// This service manages the set of disks attached to a virtual machine. Each attached disk is represented by a
// <<types/disk_attachment,DiskAttachment>>, containing the bootable flag, the disk interface and the reference to
// the disk.
//
type diskAttachmentsService struct {
	baseService
}

func NewDiskAttachmentsService(connection *Connection, path string) *diskAttachmentsService {
	var result diskAttachmentsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a new disk attachment to the virtual machine. The `attachment` parameter can contain just a reference, if
// the disk already exists:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk id="123"/>
// </disk_attachment>
// ----
// Or it can contain the complete representation of the disk, if the disk doesn't exist yet:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
// In this case the disk will be created and then attached to the virtual machine.
// In both cases, use the following URL for a virtual machine with an id `345`:
// [source]
// ----
// POST /ovirt-engine/api/vms/345/diskattachments
// ----
// IMPORTANT: The server accepts requests that don't contain the `active` attribute, but the effect is
// undefined. In some cases the disk will be automatically activated and in other cases it won't. To
// avoid issues it is strongly recommended to always include the `active` attribute with the desired
// value.
//
type diskAttachmentsServiceAddRequest struct {
	diskAttachmentsService *diskAttachmentsService
	header                 map[string]string
	query                  map[string]string
	attachment             *DiskAttachment
}

func (p *diskAttachmentsServiceAddRequest) Header(key, value string) *diskAttachmentsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskAttachmentsServiceAddRequest) Query(key, value string) *diskAttachmentsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskAttachmentsServiceAddRequest) Attachment(attachment *DiskAttachment) *diskAttachmentsServiceAddRequest {
	p.attachment = attachment
	return p
}

func (p *diskAttachmentsServiceAddRequest) Send() (*diskAttachmentsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentsService.connection.URL(), p.diskAttachmentsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskAttachmentWriteOne(writer, p.attachment, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &diskAttachmentsServiceAddResponse{attachment: result}, nil
}

func (p *diskAttachmentsServiceAddRequest) MustSend() *diskAttachmentsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentsService.connection.URL(), p.diskAttachmentsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskAttachmentWriteOne(writer, p.attachment, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &diskAttachmentsServiceAddResponse{attachment: result}
}

//
// Adds a new disk attachment to the virtual machine. The `attachment` parameter can contain just a reference, if
// the disk already exists:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk id="123"/>
// </disk_attachment>
// ----
// Or it can contain the complete representation of the disk, if the disk doesn't exist yet:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
// In this case the disk will be created and then attached to the virtual machine.
// In both cases, use the following URL for a virtual machine with an id `345`:
// [source]
// ----
// POST /ovirt-engine/api/vms/345/diskattachments
// ----
// IMPORTANT: The server accepts requests that don't contain the `active` attribute, but the effect is
// undefined. In some cases the disk will be automatically activated and in other cases it won't. To
// avoid issues it is strongly recommended to always include the `active` attribute with the desired
// value.
//
type diskAttachmentsServiceAddResponse struct {
	attachment *DiskAttachment
}

func (p *diskAttachmentsServiceAddResponse) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *diskAttachmentsServiceAddResponse) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
// Adds a new disk attachment to the virtual machine. The `attachment` parameter can contain just a reference, if
// the disk already exists:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk id="123"/>
// </disk_attachment>
// ----
// Or it can contain the complete representation of the disk, if the disk doesn't exist yet:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
// In this case the disk will be created and then attached to the virtual machine.
// In both cases, use the following URL for a virtual machine with an id `345`:
// [source]
// ----
// POST /ovirt-engine/api/vms/345/diskattachments
// ----
// IMPORTANT: The server accepts requests that don't contain the `active` attribute, but the effect is
// undefined. In some cases the disk will be automatically activated and in other cases it won't. To
// avoid issues it is strongly recommended to always include the `active` attribute with the desired
// value.
//
func (p *diskAttachmentsService) Add() *diskAttachmentsServiceAddRequest {
	return &diskAttachmentsServiceAddRequest{diskAttachmentsService: p}
}

//
// List the disk that are attached to the virtual machine.
// The order of the returned list of disks attachments isn't guaranteed.
//
type diskAttachmentsServiceListRequest struct {
	diskAttachmentsService *diskAttachmentsService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *diskAttachmentsServiceListRequest) Header(key, value string) *diskAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskAttachmentsServiceListRequest) Query(key, value string) *diskAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskAttachmentsServiceListRequest) Follow(follow string) *diskAttachmentsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *diskAttachmentsServiceListRequest) Send() (*diskAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentsService.connection.URL(), p.diskAttachmentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &diskAttachmentsServiceListResponse{attachments: result}, nil
}

func (p *diskAttachmentsServiceListRequest) MustSend() *diskAttachmentsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentsService.connection.URL(), p.diskAttachmentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &diskAttachmentsServiceListResponse{attachments: result}
}

//
// List the disk that are attached to the virtual machine.
// The order of the returned list of disks attachments isn't guaranteed.
//
type diskAttachmentsServiceListResponse struct {
	attachments *DiskAttachmentSlice
}

func (p *diskAttachmentsServiceListResponse) Attachments() (*DiskAttachmentSlice, bool) {
	if p.attachments != nil {
		return p.attachments, true
	}
	return nil, false
}

func (p *diskAttachmentsServiceListResponse) MustAttachments() *DiskAttachmentSlice {
	if p.attachments == nil {
		panic("attachments in response does not exist")
	}
	return p.attachments
}

//
// List the disk that are attached to the virtual machine.
// The order of the returned list of disks attachments isn't guaranteed.
//
func (p *diskAttachmentsService) List() *diskAttachmentsServiceListRequest {
	return &diskAttachmentsServiceListRequest{diskAttachmentsService: p}
}

//
//
type diskAttachmentsServiceAddProvidingDiskIdRequest struct {
	diskAttachmentsService *diskAttachmentsService
	header                 map[string]string
	query                  map[string]string
	attachment             *DiskAttachment
}

func (p *diskAttachmentsServiceAddProvidingDiskIdRequest) Header(key, value string) *diskAttachmentsServiceAddProvidingDiskIdRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskAttachmentsServiceAddProvidingDiskIdRequest) Query(key, value string) *diskAttachmentsServiceAddProvidingDiskIdRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskAttachmentsServiceAddProvidingDiskIdRequest) Attachment(attachment *DiskAttachment) *diskAttachmentsServiceAddProvidingDiskIdRequest {
	p.attachment = attachment
	return p
}

func (p *diskAttachmentsServiceAddProvidingDiskIdRequest) Send() (*diskAttachmentsServiceAddProvidingDiskIdResponse, error) {
	rawURL := fmt.Sprintf("%s%s/providingdiskid", p.diskAttachmentsService.connection.URL(), p.diskAttachmentsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Attachment(p.attachment)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustAttachment()
	return &diskAttachmentsServiceAddProvidingDiskIdResponse{attachment: result}, nil
}

func (p *diskAttachmentsServiceAddProvidingDiskIdRequest) MustSend() *diskAttachmentsServiceAddProvidingDiskIdResponse {
	rawURL := fmt.Sprintf("%s%s/providingdiskid", p.diskAttachmentsService.connection.URL(), p.diskAttachmentsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Attachment(p.attachment)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustAttachment()
	return &diskAttachmentsServiceAddProvidingDiskIdResponse{attachment: result}
}

//
//
type diskAttachmentsServiceAddProvidingDiskIdResponse struct {
	attachment *DiskAttachment
}

func (p *diskAttachmentsServiceAddProvidingDiskIdResponse) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *diskAttachmentsServiceAddProvidingDiskIdResponse) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
//
func (p *diskAttachmentsService) AddProvidingDiskId() *diskAttachmentsServiceAddProvidingDiskIdRequest {
	return &diskAttachmentsServiceAddProvidingDiskIdRequest{diskAttachmentsService: p}
}

//
//
type diskAttachmentsServiceAddSignature1Request struct {
	diskAttachmentsService *diskAttachmentsService
	header                 map[string]string
	query                  map[string]string
	attachment             *DiskAttachment
}

func (p *diskAttachmentsServiceAddSignature1Request) Header(key, value string) *diskAttachmentsServiceAddSignature1Request {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskAttachmentsServiceAddSignature1Request) Query(key, value string) *diskAttachmentsServiceAddSignature1Request {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskAttachmentsServiceAddSignature1Request) Attachment(attachment *DiskAttachment) *diskAttachmentsServiceAddSignature1Request {
	p.attachment = attachment
	return p
}

func (p *diskAttachmentsServiceAddSignature1Request) Send() (*diskAttachmentsServiceAddSignature1Response, error) {
	rawURL := fmt.Sprintf("%s%s/signature1", p.diskAttachmentsService.connection.URL(), p.diskAttachmentsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Attachment(p.attachment)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustAttachment()
	return &diskAttachmentsServiceAddSignature1Response{attachment: result}, nil
}

func (p *diskAttachmentsServiceAddSignature1Request) MustSend() *diskAttachmentsServiceAddSignature1Response {
	rawURL := fmt.Sprintf("%s%s/signature1", p.diskAttachmentsService.connection.URL(), p.diskAttachmentsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Attachment(p.attachment)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustAttachment()
	return &diskAttachmentsServiceAddSignature1Response{attachment: result}
}

//
//
type diskAttachmentsServiceAddSignature1Response struct {
	attachment *DiskAttachment
}

func (p *diskAttachmentsServiceAddSignature1Response) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *diskAttachmentsServiceAddSignature1Response) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
//
func (p *diskAttachmentsService) AddSignature1() *diskAttachmentsServiceAddSignature1Request {
	return &diskAttachmentsServiceAddSignature1Request{diskAttachmentsService: p}
}

//
// Reference to the service that manages a specific attachment.
//
func (op *diskAttachmentsService) AttachmentService(id string) *diskAttachmentService {
	return NewDiskAttachmentService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *diskAttachmentsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.AttachmentService(path), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *diskAttachmentsService) String() string {
	return fmt.Sprintf("diskAttachmentsService:%s", op.path)
}

//
// This service manages a single virtual machine to affinity group assignment.
//
type affinityGroupVmService struct {
	baseService
}

func NewAffinityGroupVmService(connection *Connection, path string) *affinityGroupVmService {
	var result affinityGroupVmService
	result.connection = connection
	result.path = path
	return &result
}

//
// Remove this virtual machine from the affinity group.
//
type affinityGroupVmServiceRemoveRequest struct {
	affinityGroupVmService *affinityGroupVmService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *affinityGroupVmServiceRemoveRequest) Header(key, value string) *affinityGroupVmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityGroupVmServiceRemoveRequest) Query(key, value string) *affinityGroupVmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityGroupVmServiceRemoveRequest) Async(async bool) *affinityGroupVmServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *affinityGroupVmServiceRemoveRequest) Send() (*affinityGroupVmServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupVmService.connection.URL(), p.affinityGroupVmService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(affinityGroupVmServiceRemoveResponse), nil
}

func (p *affinityGroupVmServiceRemoveRequest) MustSend() *affinityGroupVmServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupVmService.connection.URL(), p.affinityGroupVmService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupVmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupVmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(affinityGroupVmServiceRemoveResponse)
}

//
// Remove this virtual machine from the affinity group.
//
type affinityGroupVmServiceRemoveResponse struct {
}

//
// Remove this virtual machine from the affinity group.
//
func (p *affinityGroupVmService) Remove() *affinityGroupVmServiceRemoveRequest {
	return &affinityGroupVmServiceRemoveRequest{affinityGroupVmService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *affinityGroupVmService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *affinityGroupVmService) String() string {
	return fmt.Sprintf("affinityGroupVmService:%s", op.path)
}

//
// Manages the collection of disks available inside an storage domain that is attached to a data center.
//
type attachedStorageDomainDisksService struct {
	baseService
}

func NewAttachedStorageDomainDisksService(connection *Connection, path string) *attachedStorageDomainDisksService {
	var result attachedStorageDomainDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
//
type attachedStorageDomainDisksServiceAddRequest struct {
	attachedStorageDomainDisksService *attachedStorageDomainDisksService
	header                            map[string]string
	query                             map[string]string
	disk                              *Disk
	unregistered                      *bool
}

func (p *attachedStorageDomainDisksServiceAddRequest) Header(key, value string) *attachedStorageDomainDisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainDisksServiceAddRequest) Query(key, value string) *attachedStorageDomainDisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainDisksServiceAddRequest) Disk(disk *Disk) *attachedStorageDomainDisksServiceAddRequest {
	p.disk = disk
	return p
}

func (p *attachedStorageDomainDisksServiceAddRequest) Unregistered(unregistered bool) *attachedStorageDomainDisksServiceAddRequest {
	p.unregistered = &unregistered
	return p
}

func (p *attachedStorageDomainDisksServiceAddRequest) Send() (*attachedStorageDomainDisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDisksService.connection.URL(), p.attachedStorageDomainDisksService.path)
	values := make(url.Values)
	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &attachedStorageDomainDisksServiceAddResponse{disk: result}, nil
}

func (p *attachedStorageDomainDisksServiceAddRequest) MustSend() *attachedStorageDomainDisksServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDisksService.connection.URL(), p.attachedStorageDomainDisksService.path)
	values := make(url.Values)
	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDisksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDisksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &attachedStorageDomainDisksServiceAddResponse{disk: result}
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
//
type attachedStorageDomainDisksServiceAddResponse struct {
	disk *Disk
}

func (p *attachedStorageDomainDisksServiceAddResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *attachedStorageDomainDisksServiceAddResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
//
func (p *attachedStorageDomainDisksService) Add() *attachedStorageDomainDisksServiceAddRequest {
	return &attachedStorageDomainDisksServiceAddRequest{attachedStorageDomainDisksService: p}
}

//
// Retrieve the list of disks that are available in the storage domain.
//
type attachedStorageDomainDisksServiceListRequest struct {
	attachedStorageDomainDisksService *attachedStorageDomainDisksService
	header                            map[string]string
	query                             map[string]string
	follow                            *string
	max                               *int64
}

func (p *attachedStorageDomainDisksServiceListRequest) Header(key, value string) *attachedStorageDomainDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainDisksServiceListRequest) Query(key, value string) *attachedStorageDomainDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainDisksServiceListRequest) Follow(follow string) *attachedStorageDomainDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *attachedStorageDomainDisksServiceListRequest) Max(max int64) *attachedStorageDomainDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *attachedStorageDomainDisksServiceListRequest) Send() (*attachedStorageDomainDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDisksService.connection.URL(), p.attachedStorageDomainDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &attachedStorageDomainDisksServiceListResponse{disks: result}, nil
}

func (p *attachedStorageDomainDisksServiceListRequest) MustSend() *attachedStorageDomainDisksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainDisksService.connection.URL(), p.attachedStorageDomainDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainDisksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainDisksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &attachedStorageDomainDisksServiceListResponse{disks: result}
}

//
// Retrieve the list of disks that are available in the storage domain.
//
type attachedStorageDomainDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *attachedStorageDomainDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *attachedStorageDomainDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Retrieve the list of disks that are available in the storage domain.
//
func (p *attachedStorageDomainDisksService) List() *attachedStorageDomainDisksServiceListRequest {
	return &attachedStorageDomainDisksServiceListRequest{attachedStorageDomainDisksService: p}
}

//
// Reference to the service that manages a specific disk.
//
func (op *attachedStorageDomainDisksService) DiskService(id string) *attachedStorageDomainDiskService {
	return NewAttachedStorageDomainDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *attachedStorageDomainDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *attachedStorageDomainDisksService) String() string {
	return fmt.Sprintf("attachedStorageDomainDisksService:%s", op.path)
}

//
// Represents a permits sub-collection of the specific role.
//
type permitsService struct {
	baseService
}

func NewPermitsService(connection *Connection, path string) *permitsService {
	var result permitsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a permit to the role. The permit name can be retrieved from the <<services/cluster_levels>> service.
// For example to assign a permit `create_vm` to the role with id `123` send a request like this:
// ....
// POST /ovirt-engine/api/roles/123/permits
// ....
// With a request body like this:
// [source,xml]
// ----
// <permit>
//   <name>create_vm</name>
// </permit>
// ----
//
type permitsServiceAddRequest struct {
	permitsService *permitsService
	header         map[string]string
	query          map[string]string
	permit         *Permit
}

func (p *permitsServiceAddRequest) Header(key, value string) *permitsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *permitsServiceAddRequest) Query(key, value string) *permitsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *permitsServiceAddRequest) Permit(permit *Permit) *permitsServiceAddRequest {
	p.permit = permit
	return p
}

func (p *permitsServiceAddRequest) Send() (*permitsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permitsService.connection.URL(), p.permitsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLPermitWriteOne(writer, p.permit, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.permitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.permitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &permitsServiceAddResponse{permit: result}, nil
}

func (p *permitsServiceAddRequest) MustSend() *permitsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.permitsService.connection.URL(), p.permitsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLPermitWriteOne(writer, p.permit, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.permitsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.permitsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermitReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &permitsServiceAddResponse{permit: result}
}

//
// Adds a permit to the role. The permit name can be retrieved from the <<services/cluster_levels>> service.
// For example to assign a permit `create_vm` to the role with id `123` send a request like this:
// ....
// POST /ovirt-engine/api/roles/123/permits
// ....
// With a request body like this:
// [source,xml]
// ----
// <permit>
//   <name>create_vm</name>
// </permit>
// ----
//
type permitsServiceAddResponse struct {
	permit *Permit
}

func (p *permitsServiceAddResponse) Permit() (*Permit, bool) {
	if p.permit != nil {
		return p.permit, true
	}
	return nil, false
}

func (p *permitsServiceAddResponse) MustPermit() *Permit {
	if p.permit == nil {
		panic("permit in response does not exist")
	}
	return p.permit
}

//
// Adds a permit to the role. The permit name can be retrieved from the <<services/cluster_levels>> service.
// For example to assign a permit `create_vm` to the role with id `123` send a request like this:
// ....
// POST /ovirt-engine/api/roles/123/permits
// ....
// With a request body like this:
// [source,xml]
// ----
// <permit>
//   <name>create_vm</name>
// </permit>
// ----
//
func (p *permitsService) Add() *permitsServiceAddRequest {
	return &permitsServiceAddRequest{permitsService: p}
}

//
// List the permits of the role.
// For example to list the permits of the role with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits
// ....
// [source,xml]
// ----
// <permits>
//   <permit href="/ovirt-engine/api/roles/123/permits/5" id="5">
//     <name>change_vm_cd</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
//   <permit href="/ovirt-engine/api/roles/123/permits/7" id="7">
//     <name>connect_to_vm</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
// </permits>
// ----
// The order of the returned list of permits isn't guaranteed.
//
type permitsServiceListRequest struct {
	permitsService *permitsService
	header         map[string]string
	query          map[string]string
	follow         *string
	max            *int64
}

func (p *permitsServiceListRequest) Header(key, value string) *permitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *permitsServiceListRequest) Query(key, value string) *permitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *permitsServiceListRequest) Follow(follow string) *permitsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *permitsServiceListRequest) Max(max int64) *permitsServiceListRequest {
	p.max = &max
	return p
}

func (p *permitsServiceListRequest) Send() (*permitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.permitsService.connection.URL(), p.permitsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.permitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.permitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermitReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &permitsServiceListResponse{permits: result}, nil
}

func (p *permitsServiceListRequest) MustSend() *permitsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.permitsService.connection.URL(), p.permitsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.permitsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.permitsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermitReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &permitsServiceListResponse{permits: result}
}

//
// List the permits of the role.
// For example to list the permits of the role with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits
// ....
// [source,xml]
// ----
// <permits>
//   <permit href="/ovirt-engine/api/roles/123/permits/5" id="5">
//     <name>change_vm_cd</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
//   <permit href="/ovirt-engine/api/roles/123/permits/7" id="7">
//     <name>connect_to_vm</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
// </permits>
// ----
// The order of the returned list of permits isn't guaranteed.
//
type permitsServiceListResponse struct {
	permits *PermitSlice
}

func (p *permitsServiceListResponse) Permits() (*PermitSlice, bool) {
	if p.permits != nil {
		return p.permits, true
	}
	return nil, false
}

func (p *permitsServiceListResponse) MustPermits() *PermitSlice {
	if p.permits == nil {
		panic("permits in response does not exist")
	}
	return p.permits
}

//
// List the permits of the role.
// For example to list the permits of the role with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits
// ....
// [source,xml]
// ----
// <permits>
//   <permit href="/ovirt-engine/api/roles/123/permits/5" id="5">
//     <name>change_vm_cd</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
//   <permit href="/ovirt-engine/api/roles/123/permits/7" id="7">
//     <name>connect_to_vm</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
// </permits>
// ----
// The order of the returned list of permits isn't guaranteed.
//
func (p *permitsService) List() *permitsServiceListRequest {
	return &permitsServiceListRequest{permitsService: p}
}

//
// Sub-resource locator method, returns individual permit resource on which the remainder of the URI is dispatched.
//
func (op *permitsService) PermitService(id string) *permitService {
	return NewPermitService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *permitsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.PermitService(path), nil
	}
	return op.PermitService(path[:index]).Service(path[index+1:])
}

func (op *permitsService) String() string {
	return fmt.Sprintf("permitsService:%s", op.path)
}

//
// This service manages a vNIC profile.
//
type vnicProfileService struct {
	baseService
}

func NewVnicProfileService(connection *Connection, path string) *vnicProfileService {
	var result vnicProfileService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves details about a vNIC profile.
//
type vnicProfileServiceGetRequest struct {
	vnicProfileService *vnicProfileService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *vnicProfileServiceGetRequest) Header(key, value string) *vnicProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vnicProfileServiceGetRequest) Query(key, value string) *vnicProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vnicProfileServiceGetRequest) Follow(follow string) *vnicProfileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vnicProfileServiceGetRequest) Send() (*vnicProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfileService.connection.URL(), p.vnicProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vnicProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vnicProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vnicProfileServiceGetResponse{profile: result}, nil
}

func (p *vnicProfileServiceGetRequest) MustSend() *vnicProfileServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfileService.connection.URL(), p.vnicProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vnicProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vnicProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vnicProfileServiceGetResponse{profile: result}
}

//
// Retrieves details about a vNIC profile.
//
type vnicProfileServiceGetResponse struct {
	profile *VnicProfile
}

func (p *vnicProfileServiceGetResponse) Profile() (*VnicProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *vnicProfileServiceGetResponse) MustProfile() *VnicProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Retrieves details about a vNIC profile.
//
func (p *vnicProfileService) Get() *vnicProfileServiceGetRequest {
	return &vnicProfileServiceGetRequest{vnicProfileService: p}
}

//
// Removes the vNIC profile.
//
type vnicProfileServiceRemoveRequest struct {
	vnicProfileService *vnicProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *vnicProfileServiceRemoveRequest) Header(key, value string) *vnicProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vnicProfileServiceRemoveRequest) Query(key, value string) *vnicProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vnicProfileServiceRemoveRequest) Async(async bool) *vnicProfileServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *vnicProfileServiceRemoveRequest) Send() (*vnicProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfileService.connection.URL(), p.vnicProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vnicProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vnicProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(vnicProfileServiceRemoveResponse), nil
}

func (p *vnicProfileServiceRemoveRequest) MustSend() *vnicProfileServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfileService.connection.URL(), p.vnicProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vnicProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vnicProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(vnicProfileServiceRemoveResponse)
}

//
// Removes the vNIC profile.
//
type vnicProfileServiceRemoveResponse struct {
}

//
// Removes the vNIC profile.
//
func (p *vnicProfileService) Remove() *vnicProfileServiceRemoveRequest {
	return &vnicProfileServiceRemoveRequest{vnicProfileService: p}
}

//
// Updates details of a vNIC profile.
//
type vnicProfileServiceUpdateRequest struct {
	vnicProfileService *vnicProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
	profile            *VnicProfile
}

func (p *vnicProfileServiceUpdateRequest) Header(key, value string) *vnicProfileServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vnicProfileServiceUpdateRequest) Query(key, value string) *vnicProfileServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vnicProfileServiceUpdateRequest) Async(async bool) *vnicProfileServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *vnicProfileServiceUpdateRequest) Profile(profile *VnicProfile) *vnicProfileServiceUpdateRequest {
	p.profile = profile
	return p
}

func (p *vnicProfileServiceUpdateRequest) Send() (*vnicProfileServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfileService.connection.URL(), p.vnicProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVnicProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vnicProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vnicProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vnicProfileServiceUpdateResponse{profile: result}, nil
}

func (p *vnicProfileServiceUpdateRequest) MustSend() *vnicProfileServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.vnicProfileService.connection.URL(), p.vnicProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVnicProfileWriteOne(writer, p.profile, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vnicProfileService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vnicProfileService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vnicProfileServiceUpdateResponse{profile: result}
}

//
// Updates details of a vNIC profile.
//
type vnicProfileServiceUpdateResponse struct {
	profile *VnicProfile
}

func (p *vnicProfileServiceUpdateResponse) Profile() (*VnicProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *vnicProfileServiceUpdateResponse) MustProfile() *VnicProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Updates details of a vNIC profile.
//
func (p *vnicProfileService) Update() *vnicProfileServiceUpdateRequest {
	return &vnicProfileServiceUpdateRequest{vnicProfileService: p}
}

//
//
func (op *vnicProfileService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vnicProfileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vnicProfileService) String() string {
	return fmt.Sprintf("vnicProfileService:%s", op.path)
}

//
//
type templateWatchdogsService struct {
	baseService
}

func NewTemplateWatchdogsService(connection *Connection, path string) *templateWatchdogsService {
	var result templateWatchdogsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a watchdog to the template identified by the given id.
//
type templateWatchdogsServiceAddRequest struct {
	templateWatchdogsService *templateWatchdogsService
	header                   map[string]string
	query                    map[string]string
	watchdog                 *Watchdog
}

func (p *templateWatchdogsServiceAddRequest) Header(key, value string) *templateWatchdogsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateWatchdogsServiceAddRequest) Query(key, value string) *templateWatchdogsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateWatchdogsServiceAddRequest) Watchdog(watchdog *Watchdog) *templateWatchdogsServiceAddRequest {
	p.watchdog = watchdog
	return p
}

func (p *templateWatchdogsServiceAddRequest) Send() (*templateWatchdogsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogsService.connection.URL(), p.templateWatchdogsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateWatchdogsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateWatchdogsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateWatchdogsServiceAddResponse{watchdog: result}, nil
}

func (p *templateWatchdogsServiceAddRequest) MustSend() *templateWatchdogsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogsService.connection.URL(), p.templateWatchdogsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateWatchdogsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateWatchdogsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateWatchdogsServiceAddResponse{watchdog: result}
}

//
// Add a watchdog to the template identified by the given id.
//
type templateWatchdogsServiceAddResponse struct {
	watchdog *Watchdog
}

func (p *templateWatchdogsServiceAddResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *templateWatchdogsServiceAddResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Add a watchdog to the template identified by the given id.
//
func (p *templateWatchdogsService) Add() *templateWatchdogsServiceAddRequest {
	return &templateWatchdogsServiceAddRequest{templateWatchdogsService: p}
}

//
// Returns the list of watchdogs.
// The order of the returned list of watchdogs isn't guaranteed.
//
type templateWatchdogsServiceListRequest struct {
	templateWatchdogsService *templateWatchdogsService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
	max                      *int64
}

func (p *templateWatchdogsServiceListRequest) Header(key, value string) *templateWatchdogsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateWatchdogsServiceListRequest) Query(key, value string) *templateWatchdogsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateWatchdogsServiceListRequest) Follow(follow string) *templateWatchdogsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *templateWatchdogsServiceListRequest) Max(max int64) *templateWatchdogsServiceListRequest {
	p.max = &max
	return p
}

func (p *templateWatchdogsServiceListRequest) Send() (*templateWatchdogsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogsService.connection.URL(), p.templateWatchdogsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateWatchdogsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateWatchdogsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &templateWatchdogsServiceListResponse{watchdogs: result}, nil
}

func (p *templateWatchdogsServiceListRequest) MustSend() *templateWatchdogsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateWatchdogsService.connection.URL(), p.templateWatchdogsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateWatchdogsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateWatchdogsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &templateWatchdogsServiceListResponse{watchdogs: result}
}

//
// Returns the list of watchdogs.
// The order of the returned list of watchdogs isn't guaranteed.
//
type templateWatchdogsServiceListResponse struct {
	watchdogs *WatchdogSlice
}

func (p *templateWatchdogsServiceListResponse) Watchdogs() (*WatchdogSlice, bool) {
	if p.watchdogs != nil {
		return p.watchdogs, true
	}
	return nil, false
}

func (p *templateWatchdogsServiceListResponse) MustWatchdogs() *WatchdogSlice {
	if p.watchdogs == nil {
		panic("watchdogs in response does not exist")
	}
	return p.watchdogs
}

//
// Returns the list of watchdogs.
// The order of the returned list of watchdogs isn't guaranteed.
//
func (p *templateWatchdogsService) List() *templateWatchdogsServiceListRequest {
	return &templateWatchdogsServiceListRequest{templateWatchdogsService: p}
}

//
//
func (op *templateWatchdogsService) WatchdogService(id string) *templateWatchdogService {
	return NewTemplateWatchdogService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateWatchdogsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.WatchdogService(path), nil
	}
	return op.WatchdogService(path[:index]).Service(path[index+1:])
}

func (op *templateWatchdogsService) String() string {
	return fmt.Sprintf("templateWatchdogsService:%s", op.path)
}

//
// A service that provides information about applications installed in a virtual machine.
//
type vmApplicationsService struct {
	baseService
}

func NewVmApplicationsService(connection *Connection, path string) *vmApplicationsService {
	var result vmApplicationsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns a list of applications installed in the virtual machine.
// The order of the returned list of applications isn't guaranteed.
//
type vmApplicationsServiceListRequest struct {
	vmApplicationsService *vmApplicationsService
	header                map[string]string
	query                 map[string]string
	filter                *bool
	follow                *string
	max                   *int64
}

func (p *vmApplicationsServiceListRequest) Header(key, value string) *vmApplicationsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmApplicationsServiceListRequest) Query(key, value string) *vmApplicationsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmApplicationsServiceListRequest) Filter(filter bool) *vmApplicationsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *vmApplicationsServiceListRequest) Follow(follow string) *vmApplicationsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vmApplicationsServiceListRequest) Max(max int64) *vmApplicationsServiceListRequest {
	p.max = &max
	return p
}

func (p *vmApplicationsServiceListRequest) Send() (*vmApplicationsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmApplicationsService.connection.URL(), p.vmApplicationsService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmApplicationsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmApplicationsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLApplicationReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vmApplicationsServiceListResponse{applications: result}, nil
}

func (p *vmApplicationsServiceListRequest) MustSend() *vmApplicationsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmApplicationsService.connection.URL(), p.vmApplicationsService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmApplicationsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmApplicationsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLApplicationReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vmApplicationsServiceListResponse{applications: result}
}

//
// Returns a list of applications installed in the virtual machine.
// The order of the returned list of applications isn't guaranteed.
//
type vmApplicationsServiceListResponse struct {
	applications *ApplicationSlice
}

func (p *vmApplicationsServiceListResponse) Applications() (*ApplicationSlice, bool) {
	if p.applications != nil {
		return p.applications, true
	}
	return nil, false
}

func (p *vmApplicationsServiceListResponse) MustApplications() *ApplicationSlice {
	if p.applications == nil {
		panic("applications in response does not exist")
	}
	return p.applications
}

//
// Returns a list of applications installed in the virtual machine.
// The order of the returned list of applications isn't guaranteed.
//
func (p *vmApplicationsService) List() *vmApplicationsServiceListRequest {
	return &vmApplicationsServiceListRequest{vmApplicationsService: p}
}

//
// Returns a reference to the service that provides information about a specific application.
//
func (op *vmApplicationsService) ApplicationService(id string) *vmApplicationService {
	return NewVmApplicationService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmApplicationsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ApplicationService(path), nil
	}
	return op.ApplicationService(path[:index]).Service(path[index+1:])
}

func (op *vmApplicationsService) String() string {
	return fmt.Sprintf("vmApplicationsService:%s", op.path)
}

//
// This service manages the set of disks attached to a template. Each attached disk is represented by a
// <<types/disk_attachment,DiskAttachment>>.
//
type templateDiskAttachmentsService struct {
	baseService
}

func NewTemplateDiskAttachmentsService(connection *Connection, path string) *templateDiskAttachmentsService {
	var result templateDiskAttachmentsService
	result.connection = connection
	result.path = path
	return &result
}

//
// List the disks that are attached to the template.
// The order of the returned list of attachments isn't guaranteed.
//
type templateDiskAttachmentsServiceListRequest struct {
	templateDiskAttachmentsService *templateDiskAttachmentsService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
}

func (p *templateDiskAttachmentsServiceListRequest) Header(key, value string) *templateDiskAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateDiskAttachmentsServiceListRequest) Query(key, value string) *templateDiskAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateDiskAttachmentsServiceListRequest) Follow(follow string) *templateDiskAttachmentsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *templateDiskAttachmentsServiceListRequest) Send() (*templateDiskAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskAttachmentsService.connection.URL(), p.templateDiskAttachmentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &templateDiskAttachmentsServiceListResponse{attachments: result}, nil
}

func (p *templateDiskAttachmentsServiceListRequest) MustSend() *templateDiskAttachmentsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskAttachmentsService.connection.URL(), p.templateDiskAttachmentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskAttachmentsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskAttachmentsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &templateDiskAttachmentsServiceListResponse{attachments: result}
}

//
// List the disks that are attached to the template.
// The order of the returned list of attachments isn't guaranteed.
//
type templateDiskAttachmentsServiceListResponse struct {
	attachments *DiskAttachmentSlice
}

func (p *templateDiskAttachmentsServiceListResponse) Attachments() (*DiskAttachmentSlice, bool) {
	if p.attachments != nil {
		return p.attachments, true
	}
	return nil, false
}

func (p *templateDiskAttachmentsServiceListResponse) MustAttachments() *DiskAttachmentSlice {
	if p.attachments == nil {
		panic("attachments in response does not exist")
	}
	return p.attachments
}

//
// List the disks that are attached to the template.
// The order of the returned list of attachments isn't guaranteed.
//
func (p *templateDiskAttachmentsService) List() *templateDiskAttachmentsServiceListRequest {
	return &templateDiskAttachmentsServiceListRequest{templateDiskAttachmentsService: p}
}

//
// Reference to the service that manages a specific attachment.
//
func (op *templateDiskAttachmentsService) AttachmentService(id string) *templateDiskAttachmentService {
	return NewTemplateDiskAttachmentService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateDiskAttachmentsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.AttachmentService(path), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *templateDiskAttachmentsService) String() string {
	return fmt.Sprintf("templateDiskAttachmentsService:%s", op.path)
}

//
//
type instanceTypeGraphicsConsoleService struct {
	baseService
}

func NewInstanceTypeGraphicsConsoleService(connection *Connection, path string) *instanceTypeGraphicsConsoleService {
	var result instanceTypeGraphicsConsoleService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets graphics console configuration of the instance type.
//
type instanceTypeGraphicsConsoleServiceGetRequest struct {
	instanceTypeGraphicsConsoleService *instanceTypeGraphicsConsoleService
	header                             map[string]string
	query                              map[string]string
	follow                             *string
}

func (p *instanceTypeGraphicsConsoleServiceGetRequest) Header(key, value string) *instanceTypeGraphicsConsoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeGraphicsConsoleServiceGetRequest) Query(key, value string) *instanceTypeGraphicsConsoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeGraphicsConsoleServiceGetRequest) Follow(follow string) *instanceTypeGraphicsConsoleServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *instanceTypeGraphicsConsoleServiceGetRequest) Send() (*instanceTypeGraphicsConsoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsoleService.connection.URL(), p.instanceTypeGraphicsConsoleService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &instanceTypeGraphicsConsoleServiceGetResponse{console: result}, nil
}

func (p *instanceTypeGraphicsConsoleServiceGetRequest) MustSend() *instanceTypeGraphicsConsoleServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsoleService.connection.URL(), p.instanceTypeGraphicsConsoleService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeGraphicsConsoleService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &instanceTypeGraphicsConsoleServiceGetResponse{console: result}
}

//
// Gets graphics console configuration of the instance type.
//
type instanceTypeGraphicsConsoleServiceGetResponse struct {
	console *GraphicsConsole
}

func (p *instanceTypeGraphicsConsoleServiceGetResponse) Console() (*GraphicsConsole, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

func (p *instanceTypeGraphicsConsoleServiceGetResponse) MustConsole() *GraphicsConsole {
	if p.console == nil {
		panic("console in response does not exist")
	}
	return p.console
}

//
// Gets graphics console configuration of the instance type.
//
func (p *instanceTypeGraphicsConsoleService) Get() *instanceTypeGraphicsConsoleServiceGetRequest {
	return &instanceTypeGraphicsConsoleServiceGetRequest{instanceTypeGraphicsConsoleService: p}
}

//
// Remove the graphics console from the instance type.
//
type instanceTypeGraphicsConsoleServiceRemoveRequest struct {
	instanceTypeGraphicsConsoleService *instanceTypeGraphicsConsoleService
	header                             map[string]string
	query                              map[string]string
	async                              *bool
}

func (p *instanceTypeGraphicsConsoleServiceRemoveRequest) Header(key, value string) *instanceTypeGraphicsConsoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeGraphicsConsoleServiceRemoveRequest) Query(key, value string) *instanceTypeGraphicsConsoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeGraphicsConsoleServiceRemoveRequest) Async(async bool) *instanceTypeGraphicsConsoleServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *instanceTypeGraphicsConsoleServiceRemoveRequest) Send() (*instanceTypeGraphicsConsoleServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsoleService.connection.URL(), p.instanceTypeGraphicsConsoleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(instanceTypeGraphicsConsoleServiceRemoveResponse), nil
}

func (p *instanceTypeGraphicsConsoleServiceRemoveRequest) MustSend() *instanceTypeGraphicsConsoleServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeGraphicsConsoleService.connection.URL(), p.instanceTypeGraphicsConsoleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeGraphicsConsoleService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(instanceTypeGraphicsConsoleServiceRemoveResponse)
}

//
// Remove the graphics console from the instance type.
//
type instanceTypeGraphicsConsoleServiceRemoveResponse struct {
}

//
// Remove the graphics console from the instance type.
//
func (p *instanceTypeGraphicsConsoleService) Remove() *instanceTypeGraphicsConsoleServiceRemoveRequest {
	return &instanceTypeGraphicsConsoleServiceRemoveRequest{instanceTypeGraphicsConsoleService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *instanceTypeGraphicsConsoleService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *instanceTypeGraphicsConsoleService) String() string {
	return fmt.Sprintf("instanceTypeGraphicsConsoleService:%s", op.path)
}

//
// Manages a single disk.
//
type diskService struct {
	baseService
}

func NewDiskService(connection *Connection, path string) *diskService {
	var result diskService
	result.connection = connection
	result.path = path
	return &result
}

//
// This operation copies a disk to the specified storage domain.
// For example, copy of a disk can be facilitated using the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/copy
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk>
//     <name>mydisk</name>
//   </disk>
// </action>
// ----
// If the disk profile or the quota used currently by the disk aren't defined for the new storage domain, then they
// can be explicitly specified. If they aren't then the first available disk profile and the default quota are used.
// For example, to explicitly use disk profile `987` and quota `753` send a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk_profile id="987"/>
//   <quota id="753"/>
// </action>
// ----
//
type diskServiceCopyRequest struct {
	diskService   *diskService
	header        map[string]string
	query         map[string]string
	async         *bool
	disk          *Disk
	diskProfile   *DiskProfile
	filter        *bool
	quota         *Quota
	storageDomain *StorageDomain
}

func (p *diskServiceCopyRequest) Header(key, value string) *diskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskServiceCopyRequest) Query(key, value string) *diskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskServiceCopyRequest) Async(async bool) *diskServiceCopyRequest {
	p.async = &async
	return p
}

func (p *diskServiceCopyRequest) Disk(disk *Disk) *diskServiceCopyRequest {
	p.disk = disk
	return p
}

func (p *diskServiceCopyRequest) DiskProfile(diskProfile *DiskProfile) *diskServiceCopyRequest {
	p.diskProfile = diskProfile
	return p
}

func (p *diskServiceCopyRequest) Filter(filter bool) *diskServiceCopyRequest {
	p.filter = &filter
	return p
}

func (p *diskServiceCopyRequest) Quota(quota *Quota) *diskServiceCopyRequest {
	p.quota = quota
	return p
}

func (p *diskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *diskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *diskServiceCopyRequest) Send() (*diskServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.diskService.connection.URL(), p.diskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Disk(p.disk)
	actionBuilder.DiskProfile(p.diskProfile)
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.Quota(p.quota)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(diskServiceCopyResponse), nil
}

func (p *diskServiceCopyRequest) MustSend() *diskServiceCopyResponse {
	rawURL := fmt.Sprintf("%s%s/copy", p.diskService.connection.URL(), p.diskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Disk(p.disk)
	actionBuilder.DiskProfile(p.diskProfile)
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.Quota(p.quota)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(diskServiceCopyResponse)
}

//
// This operation copies a disk to the specified storage domain.
// For example, copy of a disk can be facilitated using the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/copy
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk>
//     <name>mydisk</name>
//   </disk>
// </action>
// ----
// If the disk profile or the quota used currently by the disk aren't defined for the new storage domain, then they
// can be explicitly specified. If they aren't then the first available disk profile and the default quota are used.
// For example, to explicitly use disk profile `987` and quota `753` send a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk_profile id="987"/>
//   <quota id="753"/>
// </action>
// ----
//
type diskServiceCopyResponse struct {
}

//
// This operation copies a disk to the specified storage domain.
// For example, copy of a disk can be facilitated using the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/copy
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk>
//     <name>mydisk</name>
//   </disk>
// </action>
// ----
// If the disk profile or the quota used currently by the disk aren't defined for the new storage domain, then they
// can be explicitly specified. If they aren't then the first available disk profile and the default quota are used.
// For example, to explicitly use disk profile `987` and quota `753` send a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk_profile id="987"/>
//   <quota id="753"/>
// </action>
// ----
//
func (p *diskService) Copy() *diskServiceCopyRequest {
	return &diskServiceCopyRequest{diskService: p}
}

//
// Exports a disk to an export storage domain.
//
type diskServiceExportRequest struct {
	diskService   *diskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
	storageDomain *StorageDomain
}

func (p *diskServiceExportRequest) Header(key, value string) *diskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskServiceExportRequest) Query(key, value string) *diskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskServiceExportRequest) Async(async bool) *diskServiceExportRequest {
	p.async = &async
	return p
}

func (p *diskServiceExportRequest) Filter(filter bool) *diskServiceExportRequest {
	p.filter = &filter
	return p
}

func (p *diskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *diskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *diskServiceExportRequest) Send() (*diskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.diskService.connection.URL(), p.diskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(diskServiceExportResponse), nil
}

func (p *diskServiceExportRequest) MustSend() *diskServiceExportResponse {
	rawURL := fmt.Sprintf("%s%s/export", p.diskService.connection.URL(), p.diskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(diskServiceExportResponse)
}

//
// Exports a disk to an export storage domain.
//
type diskServiceExportResponse struct {
}

//
// Exports a disk to an export storage domain.
//
func (p *diskService) Export() *diskServiceExportRequest {
	return &diskServiceExportRequest{diskService: p}
}

//
// Retrieves the description of the disk.
//
type diskServiceGetRequest struct {
	diskService *diskService
	header      map[string]string
	query       map[string]string
	follow      *string
}

func (p *diskServiceGetRequest) Header(key, value string) *diskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskServiceGetRequest) Query(key, value string) *diskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskServiceGetRequest) Follow(follow string) *diskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *diskServiceGetRequest) Send() (*diskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskService.connection.URL(), p.diskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &diskServiceGetResponse{disk: result}, nil
}

func (p *diskServiceGetRequest) MustSend() *diskServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskService.connection.URL(), p.diskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &diskServiceGetResponse{disk: result}
}

//
// Retrieves the description of the disk.
//
type diskServiceGetResponse struct {
	disk *Disk
}

func (p *diskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *diskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Retrieves the description of the disk.
//
func (p *diskService) Get() *diskServiceGetRequest {
	return &diskServiceGetRequest{diskService: p}
}

//
// Moves a disk to another storage domain.
// For example, to move the disk with identifier `123` to a storage domain with identifier `456` send the following
// request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/move
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
// </action>
// ----
// If the disk profile or the quota used currently by
// the disk aren't defined for the new storage domain,
// then they can be explicitly specified. If they aren't
// then the first available disk profile and the default
// quota are used.
// For example, to explicitly use disk profile `987` and
// quota `753` send a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk_profile id="987"/>
//   <quota id="753"/>
// </action>
// ----
//
type diskServiceMoveRequest struct {
	diskService   *diskService
	header        map[string]string
	query         map[string]string
	async         *bool
	diskProfile   *DiskProfile
	filter        *bool
	quota         *Quota
	storageDomain *StorageDomain
}

func (p *diskServiceMoveRequest) Header(key, value string) *diskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskServiceMoveRequest) Query(key, value string) *diskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskServiceMoveRequest) Async(async bool) *diskServiceMoveRequest {
	p.async = &async
	return p
}

func (p *diskServiceMoveRequest) DiskProfile(diskProfile *DiskProfile) *diskServiceMoveRequest {
	p.diskProfile = diskProfile
	return p
}

func (p *diskServiceMoveRequest) Filter(filter bool) *diskServiceMoveRequest {
	p.filter = &filter
	return p
}

func (p *diskServiceMoveRequest) Quota(quota *Quota) *diskServiceMoveRequest {
	p.quota = quota
	return p
}

func (p *diskServiceMoveRequest) StorageDomain(storageDomain *StorageDomain) *diskServiceMoveRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *diskServiceMoveRequest) Send() (*diskServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.diskService.connection.URL(), p.diskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.DiskProfile(p.diskProfile)
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.Quota(p.quota)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(diskServiceMoveResponse), nil
}

func (p *diskServiceMoveRequest) MustSend() *diskServiceMoveResponse {
	rawURL := fmt.Sprintf("%s%s/move", p.diskService.connection.URL(), p.diskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.DiskProfile(p.diskProfile)
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.Quota(p.quota)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(diskServiceMoveResponse)
}

//
// Moves a disk to another storage domain.
// For example, to move the disk with identifier `123` to a storage domain with identifier `456` send the following
// request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/move
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
// </action>
// ----
// If the disk profile or the quota used currently by
// the disk aren't defined for the new storage domain,
// then they can be explicitly specified. If they aren't
// then the first available disk profile and the default
// quota are used.
// For example, to explicitly use disk profile `987` and
// quota `753` send a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk_profile id="987"/>
//   <quota id="753"/>
// </action>
// ----
//
type diskServiceMoveResponse struct {
}

//
// Moves a disk to another storage domain.
// For example, to move the disk with identifier `123` to a storage domain with identifier `456` send the following
// request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/move
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
// </action>
// ----
// If the disk profile or the quota used currently by
// the disk aren't defined for the new storage domain,
// then they can be explicitly specified. If they aren't
// then the first available disk profile and the default
// quota are used.
// For example, to explicitly use disk profile `987` and
// quota `753` send a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk_profile id="987"/>
//   <quota id="753"/>
// </action>
// ----
//
func (p *diskService) Move() *diskServiceMoveRequest {
	return &diskServiceMoveRequest{diskService: p}
}

//
// Refreshes a direct LUN disk with up-to-date information from the storage.
// Refreshing a direct LUN disk is useful when:
// - The LUN was added using the API without the host parameter, and therefore does not contain
//   any information from the storage (see <<services/disks/methods/add, DisksService::add>>).
// - New information about the LUN is available on the storage and you want to update the LUN with it.
// To refresh direct LUN disk `123` using host `456`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/refreshlun
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <host id='456'/>
// </action>
// ----
//
type diskServiceRefreshLunRequest struct {
	diskService *diskService
	header      map[string]string
	query       map[string]string
	host        *Host
}

func (p *diskServiceRefreshLunRequest) Header(key, value string) *diskServiceRefreshLunRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskServiceRefreshLunRequest) Query(key, value string) *diskServiceRefreshLunRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskServiceRefreshLunRequest) Host(host *Host) *diskServiceRefreshLunRequest {
	p.host = host
	return p
}

func (p *diskServiceRefreshLunRequest) Send() (*diskServiceRefreshLunResponse, error) {
	rawURL := fmt.Sprintf("%s%s/refreshlun", p.diskService.connection.URL(), p.diskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(diskServiceRefreshLunResponse), nil
}

func (p *diskServiceRefreshLunRequest) MustSend() *diskServiceRefreshLunResponse {
	rawURL := fmt.Sprintf("%s%s/refreshlun", p.diskService.connection.URL(), p.diskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(diskServiceRefreshLunResponse)
}

//
// Refreshes a direct LUN disk with up-to-date information from the storage.
// Refreshing a direct LUN disk is useful when:
// - The LUN was added using the API without the host parameter, and therefore does not contain
//   any information from the storage (see <<services/disks/methods/add, DisksService::add>>).
// - New information about the LUN is available on the storage and you want to update the LUN with it.
// To refresh direct LUN disk `123` using host `456`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/refreshlun
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <host id='456'/>
// </action>
// ----
//
type diskServiceRefreshLunResponse struct {
}

//
// Refreshes a direct LUN disk with up-to-date information from the storage.
// Refreshing a direct LUN disk is useful when:
// - The LUN was added using the API without the host parameter, and therefore does not contain
//   any information from the storage (see <<services/disks/methods/add, DisksService::add>>).
// - New information about the LUN is available on the storage and you want to update the LUN with it.
// To refresh direct LUN disk `123` using host `456`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/refreshlun
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <host id='456'/>
// </action>
// ----
//
func (p *diskService) RefreshLun() *diskServiceRefreshLunRequest {
	return &diskServiceRefreshLunRequest{diskService: p}
}

//
// Removes a disk.
//
type diskServiceRemoveRequest struct {
	diskService *diskService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *diskServiceRemoveRequest) Header(key, value string) *diskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskServiceRemoveRequest) Query(key, value string) *diskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskServiceRemoveRequest) Async(async bool) *diskServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *diskServiceRemoveRequest) Send() (*diskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskService.connection.URL(), p.diskService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(diskServiceRemoveResponse), nil
}

func (p *diskServiceRemoveRequest) MustSend() *diskServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskService.connection.URL(), p.diskService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(diskServiceRemoveResponse)
}

//
// Removes a disk.
//
type diskServiceRemoveResponse struct {
}

//
// Removes a disk.
//
func (p *diskService) Remove() *diskServiceRemoveRequest {
	return &diskServiceRemoveRequest{diskService: p}
}

//
// Sparsify the disk.
// Sparsification frees space in the disk image that is not used by its
// filesystem. As a result, the image will occupy less space on the storage.
// Currently sparsification works only on disks without snapshots. Disks
// having derived disks are also not allowed.
//
type diskServiceSparsifyRequest struct {
	diskService *diskService
	header      map[string]string
	query       map[string]string
}

func (p *diskServiceSparsifyRequest) Header(key, value string) *diskServiceSparsifyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskServiceSparsifyRequest) Query(key, value string) *diskServiceSparsifyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskServiceSparsifyRequest) Send() (*diskServiceSparsifyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/sparsify", p.diskService.connection.URL(), p.diskService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(diskServiceSparsifyResponse), nil
}

func (p *diskServiceSparsifyRequest) MustSend() *diskServiceSparsifyResponse {
	rawURL := fmt.Sprintf("%s%s/sparsify", p.diskService.connection.URL(), p.diskService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(diskServiceSparsifyResponse)
}

//
// Sparsify the disk.
// Sparsification frees space in the disk image that is not used by its
// filesystem. As a result, the image will occupy less space on the storage.
// Currently sparsification works only on disks without snapshots. Disks
// having derived disks are also not allowed.
//
type diskServiceSparsifyResponse struct {
}

//
// Sparsify the disk.
// Sparsification frees space in the disk image that is not used by its
// filesystem. As a result, the image will occupy less space on the storage.
// Currently sparsification works only on disks without snapshots. Disks
// having derived disks are also not allowed.
//
func (p *diskService) Sparsify() *diskServiceSparsifyRequest {
	return &diskServiceSparsifyRequest{diskService: p}
}

//
// This operation updates the disk with the appropriate parameters.
// The only field that can be updated is `qcow_version`.
// For example, update disk can be facilitated using the following request:
// [source]
// ----
// PUT /ovirt-engine/api/disks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <disk>
//   <qcow_version>qcow2_v3</qcow_version>
// </disk>
// ----
// Since the backend operation is asynchronous the disk element which will be returned
// to the user might not be synced with the changed properties.
//
type diskServiceUpdateRequest struct {
	diskService *diskService
	header      map[string]string
	query       map[string]string
	disk        *Disk
}

func (p *diskServiceUpdateRequest) Header(key, value string) *diskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskServiceUpdateRequest) Query(key, value string) *diskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskServiceUpdateRequest) Disk(disk *Disk) *diskServiceUpdateRequest {
	p.disk = disk
	return p
}

func (p *diskServiceUpdateRequest) Send() (*diskServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskService.connection.URL(), p.diskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &diskServiceUpdateResponse{disk: result}, nil
}

func (p *diskServiceUpdateRequest) MustSend() *diskServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskService.connection.URL(), p.diskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &diskServiceUpdateResponse{disk: result}
}

//
// This operation updates the disk with the appropriate parameters.
// The only field that can be updated is `qcow_version`.
// For example, update disk can be facilitated using the following request:
// [source]
// ----
// PUT /ovirt-engine/api/disks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <disk>
//   <qcow_version>qcow2_v3</qcow_version>
// </disk>
// ----
// Since the backend operation is asynchronous the disk element which will be returned
// to the user might not be synced with the changed properties.
//
type diskServiceUpdateResponse struct {
	disk *Disk
}

func (p *diskServiceUpdateResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *diskServiceUpdateResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// This operation updates the disk with the appropriate parameters.
// The only field that can be updated is `qcow_version`.
// For example, update disk can be facilitated using the following request:
// [source]
// ----
// PUT /ovirt-engine/api/disks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <disk>
//   <qcow_version>qcow2_v3</qcow_version>
// </disk>
// ----
// Since the backend operation is asynchronous the disk element which will be returned
// to the user might not be synced with the changed properties.
//
func (p *diskService) Update() *diskServiceUpdateRequest {
	return &diskServiceUpdateRequest{diskService: p}
}

//
// Reference to the service that manages the permissions assigned to the disk.
//
func (op *diskService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *diskService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *diskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *diskService) String() string {
	return fmt.Sprintf("diskService:%s", op.path)
}

//
//
type vmNumaNodeService struct {
	baseService
}

func NewVmNumaNodeService(connection *Connection, path string) *vmNumaNodeService {
	var result vmNumaNodeService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type vmNumaNodeServiceGetRequest struct {
	vmNumaNodeService *vmNumaNodeService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *vmNumaNodeServiceGetRequest) Header(key, value string) *vmNumaNodeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmNumaNodeServiceGetRequest) Query(key, value string) *vmNumaNodeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmNumaNodeServiceGetRequest) Follow(follow string) *vmNumaNodeServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vmNumaNodeServiceGetRequest) Send() (*vmNumaNodeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodeService.connection.URL(), p.vmNumaNodeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNumaNodeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNumaNodeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVirtualNumaNodeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmNumaNodeServiceGetResponse{node: result}, nil
}

func (p *vmNumaNodeServiceGetRequest) MustSend() *vmNumaNodeServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodeService.connection.URL(), p.vmNumaNodeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNumaNodeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNumaNodeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVirtualNumaNodeReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmNumaNodeServiceGetResponse{node: result}
}

//
//
type vmNumaNodeServiceGetResponse struct {
	node *VirtualNumaNode
}

func (p *vmNumaNodeServiceGetResponse) Node() (*VirtualNumaNode, bool) {
	if p.node != nil {
		return p.node, true
	}
	return nil, false
}

func (p *vmNumaNodeServiceGetResponse) MustNode() *VirtualNumaNode {
	if p.node == nil {
		panic("node in response does not exist")
	}
	return p.node
}

//
//
func (p *vmNumaNodeService) Get() *vmNumaNodeServiceGetRequest {
	return &vmNumaNodeServiceGetRequest{vmNumaNodeService: p}
}

//
// Removes a virtual NUMA node.
// An example of removing a virtual NUMA node:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/numanodes/456
// ----
//
type vmNumaNodeServiceRemoveRequest struct {
	vmNumaNodeService *vmNumaNodeService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *vmNumaNodeServiceRemoveRequest) Header(key, value string) *vmNumaNodeServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmNumaNodeServiceRemoveRequest) Query(key, value string) *vmNumaNodeServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmNumaNodeServiceRemoveRequest) Async(async bool) *vmNumaNodeServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *vmNumaNodeServiceRemoveRequest) Send() (*vmNumaNodeServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodeService.connection.URL(), p.vmNumaNodeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNumaNodeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNumaNodeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(vmNumaNodeServiceRemoveResponse), nil
}

func (p *vmNumaNodeServiceRemoveRequest) MustSend() *vmNumaNodeServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodeService.connection.URL(), p.vmNumaNodeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNumaNodeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNumaNodeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(vmNumaNodeServiceRemoveResponse)
}

//
// Removes a virtual NUMA node.
// An example of removing a virtual NUMA node:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/numanodes/456
// ----
//
type vmNumaNodeServiceRemoveResponse struct {
}

//
// Removes a virtual NUMA node.
// An example of removing a virtual NUMA node:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/numanodes/456
// ----
//
func (p *vmNumaNodeService) Remove() *vmNumaNodeServiceRemoveRequest {
	return &vmNumaNodeServiceRemoveRequest{vmNumaNodeService: p}
}

//
// Updates a virtual NUMA node.
// An example of pinning a virtual NUMA node to a physical NUMA node on the host:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/numanodes/456
// ----
// The request body should contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <numa_node_pins>
//     <numa_node_pin>
//       <index>0</index>
//     </numa_node_pin>
//   </numa_node_pins>
// </vm_numa_node>
// ----
//
type vmNumaNodeServiceUpdateRequest struct {
	vmNumaNodeService *vmNumaNodeService
	header            map[string]string
	query             map[string]string
	async             *bool
	node              *VirtualNumaNode
}

func (p *vmNumaNodeServiceUpdateRequest) Header(key, value string) *vmNumaNodeServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmNumaNodeServiceUpdateRequest) Query(key, value string) *vmNumaNodeServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmNumaNodeServiceUpdateRequest) Async(async bool) *vmNumaNodeServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *vmNumaNodeServiceUpdateRequest) Node(node *VirtualNumaNode) *vmNumaNodeServiceUpdateRequest {
	p.node = node
	return p
}

func (p *vmNumaNodeServiceUpdateRequest) Send() (*vmNumaNodeServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodeService.connection.URL(), p.vmNumaNodeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVirtualNumaNodeWriteOne(writer, p.node, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNumaNodeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNumaNodeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVirtualNumaNodeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmNumaNodeServiceUpdateResponse{node: result}, nil
}

func (p *vmNumaNodeServiceUpdateRequest) MustSend() *vmNumaNodeServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodeService.connection.URL(), p.vmNumaNodeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVirtualNumaNodeWriteOne(writer, p.node, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNumaNodeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNumaNodeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVirtualNumaNodeReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmNumaNodeServiceUpdateResponse{node: result}
}

//
// Updates a virtual NUMA node.
// An example of pinning a virtual NUMA node to a physical NUMA node on the host:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/numanodes/456
// ----
// The request body should contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <numa_node_pins>
//     <numa_node_pin>
//       <index>0</index>
//     </numa_node_pin>
//   </numa_node_pins>
// </vm_numa_node>
// ----
//
type vmNumaNodeServiceUpdateResponse struct {
	node *VirtualNumaNode
}

func (p *vmNumaNodeServiceUpdateResponse) Node() (*VirtualNumaNode, bool) {
	if p.node != nil {
		return p.node, true
	}
	return nil, false
}

func (p *vmNumaNodeServiceUpdateResponse) MustNode() *VirtualNumaNode {
	if p.node == nil {
		panic("node in response does not exist")
	}
	return p.node
}

//
// Updates a virtual NUMA node.
// An example of pinning a virtual NUMA node to a physical NUMA node on the host:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/numanodes/456
// ----
// The request body should contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <numa_node_pins>
//     <numa_node_pin>
//       <index>0</index>
//     </numa_node_pin>
//   </numa_node_pins>
// </vm_numa_node>
// ----
//
func (p *vmNumaNodeService) Update() *vmNumaNodeServiceUpdateRequest {
	return &vmNumaNodeServiceUpdateRequest{vmNumaNodeService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmNumaNodeService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vmNumaNodeService) String() string {
	return fmt.Sprintf("vmNumaNodeService:%s", op.path)
}

//
// This service manages a single affinity group.
//
type affinityGroupService struct {
	baseService
}

func NewAffinityGroupService(connection *Connection, path string) *affinityGroupService {
	var result affinityGroupService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieve the affinity group details.
// [source,xml]
// ----
// <affinity_group id="00000000-0000-0000-0000-000000000000">
//   <name>AF_GROUP_001</name>
//   <cluster id="00000000-0000-0000-0000-000000000000"/>
//   <positive>true</positive>
//   <enforcing>true</enforcing>
// </affinity_group>
// ----
//
type affinityGroupServiceGetRequest struct {
	affinityGroupService *affinityGroupService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *affinityGroupServiceGetRequest) Header(key, value string) *affinityGroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityGroupServiceGetRequest) Query(key, value string) *affinityGroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityGroupServiceGetRequest) Follow(follow string) *affinityGroupServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *affinityGroupServiceGetRequest) Send() (*affinityGroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupService.connection.URL(), p.affinityGroupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &affinityGroupServiceGetResponse{group: result}, nil
}

func (p *affinityGroupServiceGetRequest) MustSend() *affinityGroupServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupService.connection.URL(), p.affinityGroupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityGroupReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &affinityGroupServiceGetResponse{group: result}
}

//
// Retrieve the affinity group details.
// [source,xml]
// ----
// <affinity_group id="00000000-0000-0000-0000-000000000000">
//   <name>AF_GROUP_001</name>
//   <cluster id="00000000-0000-0000-0000-000000000000"/>
//   <positive>true</positive>
//   <enforcing>true</enforcing>
// </affinity_group>
// ----
//
type affinityGroupServiceGetResponse struct {
	group *AffinityGroup
}

func (p *affinityGroupServiceGetResponse) Group() (*AffinityGroup, bool) {
	if p.group != nil {
		return p.group, true
	}
	return nil, false
}

func (p *affinityGroupServiceGetResponse) MustGroup() *AffinityGroup {
	if p.group == nil {
		panic("group in response does not exist")
	}
	return p.group
}

//
// Retrieve the affinity group details.
// [source,xml]
// ----
// <affinity_group id="00000000-0000-0000-0000-000000000000">
//   <name>AF_GROUP_001</name>
//   <cluster id="00000000-0000-0000-0000-000000000000"/>
//   <positive>true</positive>
//   <enforcing>true</enforcing>
// </affinity_group>
// ----
//
func (p *affinityGroupService) Get() *affinityGroupServiceGetRequest {
	return &affinityGroupServiceGetRequest{affinityGroupService: p}
}

//
// Remove the affinity group.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/000-000/affinitygroups/123-456
// ----
//
type affinityGroupServiceRemoveRequest struct {
	affinityGroupService *affinityGroupService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *affinityGroupServiceRemoveRequest) Header(key, value string) *affinityGroupServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityGroupServiceRemoveRequest) Query(key, value string) *affinityGroupServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityGroupServiceRemoveRequest) Async(async bool) *affinityGroupServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *affinityGroupServiceRemoveRequest) Send() (*affinityGroupServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupService.connection.URL(), p.affinityGroupService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(affinityGroupServiceRemoveResponse), nil
}

func (p *affinityGroupServiceRemoveRequest) MustSend() *affinityGroupServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupService.connection.URL(), p.affinityGroupService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(affinityGroupServiceRemoveResponse)
}

//
// Remove the affinity group.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/000-000/affinitygroups/123-456
// ----
//
type affinityGroupServiceRemoveResponse struct {
}

//
// Remove the affinity group.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/000-000/affinitygroups/123-456
// ----
//
func (p *affinityGroupService) Remove() *affinityGroupServiceRemoveRequest {
	return &affinityGroupServiceRemoveRequest{affinityGroupService: p}
}

//
// Update the affinity group.
//
type affinityGroupServiceUpdateRequest struct {
	affinityGroupService *affinityGroupService
	header               map[string]string
	query                map[string]string
	async                *bool
	group                *AffinityGroup
}

func (p *affinityGroupServiceUpdateRequest) Header(key, value string) *affinityGroupServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityGroupServiceUpdateRequest) Query(key, value string) *affinityGroupServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityGroupServiceUpdateRequest) Async(async bool) *affinityGroupServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *affinityGroupServiceUpdateRequest) Group(group *AffinityGroup) *affinityGroupServiceUpdateRequest {
	p.group = group
	return p
}

func (p *affinityGroupServiceUpdateRequest) Send() (*affinityGroupServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupService.connection.URL(), p.affinityGroupService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityGroupWriteOne(writer, p.group, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &affinityGroupServiceUpdateResponse{group: result}, nil
}

func (p *affinityGroupServiceUpdateRequest) MustSend() *affinityGroupServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupService.connection.URL(), p.affinityGroupService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityGroupWriteOne(writer, p.group, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityGroupReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &affinityGroupServiceUpdateResponse{group: result}
}

//
// Update the affinity group.
//
type affinityGroupServiceUpdateResponse struct {
	group *AffinityGroup
}

func (p *affinityGroupServiceUpdateResponse) Group() (*AffinityGroup, bool) {
	if p.group != nil {
		return p.group, true
	}
	return nil, false
}

func (p *affinityGroupServiceUpdateResponse) MustGroup() *AffinityGroup {
	if p.group == nil {
		panic("group in response does not exist")
	}
	return p.group
}

//
// Update the affinity group.
//
func (p *affinityGroupService) Update() *affinityGroupServiceUpdateRequest {
	return &affinityGroupServiceUpdateRequest{affinityGroupService: p}
}

//
// Returns a reference to the service that manages the
// list of all virtual machines attached to this affinity
// group.
//
func (op *affinityGroupService) VmsService() *affinityGroupVmsService {
	return NewAffinityGroupVmsService(op.connection, fmt.Sprintf("%s/vms", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *affinityGroupService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *affinityGroupService) String() string {
	return fmt.Sprintf("affinityGroupService:%s", op.path)
}

//
// Manages the set of quotas configured for a data center.
//
type quotasService struct {
	baseService
}

func NewQuotasService(connection *Connection, path string) *quotasService {
	var result quotasService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new quota.
// An example of creating a new quota:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas
// ----
// [source,xml]
// ----
// <quota>
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
// </quota>
// ----
//
type quotasServiceAddRequest struct {
	quotasService *quotasService
	header        map[string]string
	query         map[string]string
	quota         *Quota
}

func (p *quotasServiceAddRequest) Header(key, value string) *quotasServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotasServiceAddRequest) Query(key, value string) *quotasServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotasServiceAddRequest) Quota(quota *Quota) *quotasServiceAddRequest {
	p.quota = quota
	return p
}

func (p *quotasServiceAddRequest) Send() (*quotasServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotasService.connection.URL(), p.quotasService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQuotaWriteOne(writer, p.quota, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotasService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotasService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &quotasServiceAddResponse{quota: result}, nil
}

func (p *quotasServiceAddRequest) MustSend() *quotasServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotasService.connection.URL(), p.quotasService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQuotaWriteOne(writer, p.quota, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotasService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotasService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &quotasServiceAddResponse{quota: result}
}

//
// Creates a new quota.
// An example of creating a new quota:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas
// ----
// [source,xml]
// ----
// <quota>
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
// </quota>
// ----
//
type quotasServiceAddResponse struct {
	quota *Quota
}

func (p *quotasServiceAddResponse) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

func (p *quotasServiceAddResponse) MustQuota() *Quota {
	if p.quota == nil {
		panic("quota in response does not exist")
	}
	return p.quota
}

//
// Creates a new quota.
// An example of creating a new quota:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas
// ----
// [source,xml]
// ----
// <quota>
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
// </quota>
// ----
//
func (p *quotasService) Add() *quotasServiceAddRequest {
	return &quotasServiceAddRequest{quotasService: p}
}

//
// Lists quotas of a data center.
// The order of the returned list of quotas isn't guaranteed.
//
type quotasServiceListRequest struct {
	quotasService *quotasService
	header        map[string]string
	query         map[string]string
	follow        *string
	max           *int64
}

func (p *quotasServiceListRequest) Header(key, value string) *quotasServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *quotasServiceListRequest) Query(key, value string) *quotasServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *quotasServiceListRequest) Follow(follow string) *quotasServiceListRequest {
	p.follow = &follow
	return p
}

func (p *quotasServiceListRequest) Max(max int64) *quotasServiceListRequest {
	p.max = &max
	return p
}

func (p *quotasServiceListRequest) Send() (*quotasServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.quotasService.connection.URL(), p.quotasService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotasService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotasService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &quotasServiceListResponse{quotas: result}, nil
}

func (p *quotasServiceListRequest) MustSend() *quotasServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.quotasService.connection.URL(), p.quotasService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.quotasService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.quotasService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &quotasServiceListResponse{quotas: result}
}

//
// Lists quotas of a data center.
// The order of the returned list of quotas isn't guaranteed.
//
type quotasServiceListResponse struct {
	quotas *QuotaSlice
}

func (p *quotasServiceListResponse) Quotas() (*QuotaSlice, bool) {
	if p.quotas != nil {
		return p.quotas, true
	}
	return nil, false
}

func (p *quotasServiceListResponse) MustQuotas() *QuotaSlice {
	if p.quotas == nil {
		panic("quotas in response does not exist")
	}
	return p.quotas
}

//
// Lists quotas of a data center.
// The order of the returned list of quotas isn't guaranteed.
//
func (p *quotasService) List() *quotasServiceListRequest {
	return &quotasServiceListRequest{quotasService: p}
}

//
//
func (op *quotasService) QuotaService(id string) *quotaService {
	return NewQuotaService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *quotasService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.QuotaService(path), nil
	}
	return op.QuotaService(path[:index]).Service(path[index+1:])
}

func (op *quotasService) String() string {
	return fmt.Sprintf("quotasService:%s", op.path)
}

//
// Manages the set of disks available in a storage domain.
//
type storageDomainContentDisksService struct {
	baseService
}

func NewStorageDomainContentDisksService(connection *Connection, path string) *storageDomainContentDisksService {
	var result storageDomainContentDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of disks available in the storage domain.
// The order of the returned list of disks is guaranteed only if the `sortby` clause is included in
// the `search` parameter.
//
type storageDomainContentDisksServiceListRequest struct {
	storageDomainContentDisksService *storageDomainContentDisksService
	header                           map[string]string
	query                            map[string]string
	caseSensitive                    *bool
	follow                           *string
	max                              *int64
	search                           *string
}

func (p *storageDomainContentDisksServiceListRequest) Header(key, value string) *storageDomainContentDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainContentDisksServiceListRequest) Query(key, value string) *storageDomainContentDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainContentDisksServiceListRequest) CaseSensitive(caseSensitive bool) *storageDomainContentDisksServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *storageDomainContentDisksServiceListRequest) Follow(follow string) *storageDomainContentDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainContentDisksServiceListRequest) Max(max int64) *storageDomainContentDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *storageDomainContentDisksServiceListRequest) Search(search string) *storageDomainContentDisksServiceListRequest {
	p.search = &search
	return p
}

func (p *storageDomainContentDisksServiceListRequest) Send() (*storageDomainContentDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainContentDisksService.connection.URL(), p.storageDomainContentDisksService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainContentDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainContentDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &storageDomainContentDisksServiceListResponse{disks: result}, nil
}

func (p *storageDomainContentDisksServiceListRequest) MustSend() *storageDomainContentDisksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainContentDisksService.connection.URL(), p.storageDomainContentDisksService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainContentDisksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainContentDisksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &storageDomainContentDisksServiceListResponse{disks: result}
}

//
// Returns the list of disks available in the storage domain.
// The order of the returned list of disks is guaranteed only if the `sortby` clause is included in
// the `search` parameter.
//
type storageDomainContentDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *storageDomainContentDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *storageDomainContentDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Returns the list of disks available in the storage domain.
// The order of the returned list of disks is guaranteed only if the `sortby` clause is included in
// the `search` parameter.
//
func (p *storageDomainContentDisksService) List() *storageDomainContentDisksServiceListRequest {
	return &storageDomainContentDisksServiceListRequest{storageDomainContentDisksService: p}
}

//
//
func (op *storageDomainContentDisksService) DiskService(id string) *storageDomainContentDiskService {
	return NewStorageDomainContentDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainContentDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *storageDomainContentDisksService) String() string {
	return fmt.Sprintf("storageDomainContentDisksService:%s", op.path)
}

//
// Manages a network filter.
// [source,xml]
// ----
// <network_filter id="00000019-0019-0019-0019-00000000026b">
//   <name>example-network-filter-b</name>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//     <build>-1</build>
//     <revision>-1</revision>
//   </version>
// </network_filter>
// ----
// Please note that version is referring to the minimal support version for the specific filter.
//
type networkFilterService struct {
	baseService
}

func NewNetworkFilterService(connection *Connection, path string) *networkFilterService {
	var result networkFilterService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves a representation of the network filter.
//
type networkFilterServiceGetRequest struct {
	networkFilterService *networkFilterService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *networkFilterServiceGetRequest) Header(key, value string) *networkFilterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networkFilterServiceGetRequest) Query(key, value string) *networkFilterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networkFilterServiceGetRequest) Follow(follow string) *networkFilterServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *networkFilterServiceGetRequest) Send() (*networkFilterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networkFilterService.connection.URL(), p.networkFilterService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkFilterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkFilterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &networkFilterServiceGetResponse{networkFilter: result}, nil
}

func (p *networkFilterServiceGetRequest) MustSend() *networkFilterServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.networkFilterService.connection.URL(), p.networkFilterService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networkFilterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networkFilterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &networkFilterServiceGetResponse{networkFilter: result}
}

//
// Retrieves a representation of the network filter.
//
type networkFilterServiceGetResponse struct {
	networkFilter *NetworkFilter
}

func (p *networkFilterServiceGetResponse) NetworkFilter() (*NetworkFilter, bool) {
	if p.networkFilter != nil {
		return p.networkFilter, true
	}
	return nil, false
}

func (p *networkFilterServiceGetResponse) MustNetworkFilter() *NetworkFilter {
	if p.networkFilter == nil {
		panic("networkFilter in response does not exist")
	}
	return p.networkFilter
}

//
// Retrieves a representation of the network filter.
//
func (p *networkFilterService) Get() *networkFilterServiceGetRequest {
	return &networkFilterServiceGetRequest{networkFilterService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *networkFilterService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *networkFilterService) String() string {
	return fmt.Sprintf("networkFilterService:%s", op.path)
}

//
// A service to manage an icon (read-only).
//
type iconService struct {
	baseService
}

func NewIconService(connection *Connection, path string) *iconService {
	var result iconService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get an icon.
// [source]
// ----
// GET /ovirt-engine/api/icons/123
// ----
// You will get a XML response like this one:
// [source,xml]
// ----
// <icon id="123">
//   <data>Some binary data here</data>
//   <media_type>image/png</media_type>
// </icon>
// ----
//
type iconServiceGetRequest struct {
	iconService *iconService
	header      map[string]string
	query       map[string]string
	follow      *string
}

func (p *iconServiceGetRequest) Header(key, value string) *iconServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *iconServiceGetRequest) Query(key, value string) *iconServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *iconServiceGetRequest) Follow(follow string) *iconServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *iconServiceGetRequest) Send() (*iconServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iconService.connection.URL(), p.iconService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iconService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iconService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIconReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &iconServiceGetResponse{icon: result}, nil
}

func (p *iconServiceGetRequest) MustSend() *iconServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.iconService.connection.URL(), p.iconService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iconService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iconService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIconReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &iconServiceGetResponse{icon: result}
}

//
// Get an icon.
// [source]
// ----
// GET /ovirt-engine/api/icons/123
// ----
// You will get a XML response like this one:
// [source,xml]
// ----
// <icon id="123">
//   <data>Some binary data here</data>
//   <media_type>image/png</media_type>
// </icon>
// ----
//
type iconServiceGetResponse struct {
	icon *Icon
}

func (p *iconServiceGetResponse) Icon() (*Icon, bool) {
	if p.icon != nil {
		return p.icon, true
	}
	return nil, false
}

func (p *iconServiceGetResponse) MustIcon() *Icon {
	if p.icon == nil {
		panic("icon in response does not exist")
	}
	return p.icon
}

//
// Get an icon.
// [source]
// ----
// GET /ovirt-engine/api/icons/123
// ----
// You will get a XML response like this one:
// [source,xml]
// ----
// <icon id="123">
//   <data>Some binary data here</data>
//   <media_type>image/png</media_type>
// </icon>
// ----
//
func (p *iconService) Get() *iconServiceGetRequest {
	return &iconServiceGetRequest{iconService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *iconService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *iconService) String() string {
	return fmt.Sprintf("iconService:%s", op.path)
}

//
//
type templateDisksService struct {
	baseService
}

func NewTemplateDisksService(connection *Connection, path string) *templateDisksService {
	var result templateDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of disks of the template.
// The order of the returned list of disks isn't guaranteed.
//
type templateDisksServiceListRequest struct {
	templateDisksService *templateDisksService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *templateDisksServiceListRequest) Header(key, value string) *templateDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateDisksServiceListRequest) Query(key, value string) *templateDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateDisksServiceListRequest) Follow(follow string) *templateDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *templateDisksServiceListRequest) Max(max int64) *templateDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *templateDisksServiceListRequest) Send() (*templateDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDisksService.connection.URL(), p.templateDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &templateDisksServiceListResponse{disks: result}, nil
}

func (p *templateDisksServiceListRequest) MustSend() *templateDisksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateDisksService.connection.URL(), p.templateDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDisksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDisksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &templateDisksServiceListResponse{disks: result}
}

//
// Returns the list of disks of the template.
// The order of the returned list of disks isn't guaranteed.
//
type templateDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *templateDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *templateDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Returns the list of disks of the template.
// The order of the returned list of disks isn't guaranteed.
//
func (p *templateDisksService) List() *templateDisksServiceListRequest {
	return &templateDisksServiceListRequest{templateDisksService: p}
}

//
//
func (op *templateDisksService) DiskService(id string) *templateDiskService {
	return NewTemplateDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *templateDisksService) String() string {
	return fmt.Sprintf("templateDisksService:%s", op.path)
}

//
// Manages the set of images available in an storage domain or in an OpenStack image provider.
//
type imagesService struct {
	baseService
}

func NewImagesService(connection *Connection, path string) *imagesService {
	var result imagesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of images available in the storage domain or provider.
// The order of the returned list of images isn't guaranteed.
//
type imagesServiceListRequest struct {
	imagesService *imagesService
	header        map[string]string
	query         map[string]string
	follow        *string
	max           *int64
}

func (p *imagesServiceListRequest) Header(key, value string) *imagesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imagesServiceListRequest) Query(key, value string) *imagesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imagesServiceListRequest) Follow(follow string) *imagesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *imagesServiceListRequest) Max(max int64) *imagesServiceListRequest {
	p.max = &max
	return p
}

func (p *imagesServiceListRequest) Send() (*imagesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imagesService.connection.URL(), p.imagesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imagesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imagesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &imagesServiceListResponse{images: result}, nil
}

func (p *imagesServiceListRequest) MustSend() *imagesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.imagesService.connection.URL(), p.imagesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imagesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imagesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &imagesServiceListResponse{images: result}
}

//
// Returns the list of images available in the storage domain or provider.
// The order of the returned list of images isn't guaranteed.
//
type imagesServiceListResponse struct {
	images *ImageSlice
}

func (p *imagesServiceListResponse) Images() (*ImageSlice, bool) {
	if p.images != nil {
		return p.images, true
	}
	return nil, false
}

func (p *imagesServiceListResponse) MustImages() *ImageSlice {
	if p.images == nil {
		panic("images in response does not exist")
	}
	return p.images
}

//
// Returns the list of images available in the storage domain or provider.
// The order of the returned list of images isn't guaranteed.
//
func (p *imagesService) List() *imagesServiceListRequest {
	return &imagesServiceListRequest{imagesService: p}
}

//
//
func (op *imagesService) ImageService(id string) *imageService {
	return NewImageService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *imagesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ImageService(path), nil
	}
	return op.ImageService(path[:index]).Service(path[index+1:])
}

func (op *imagesService) String() string {
	return fmt.Sprintf("imagesService:%s", op.path)
}

//
// Manages a single disk available in a storage domain.
// IMPORTANT: Since version 4.2 of the engine this service is intended only to list disks available in the storage
// domain, and to register unregistered disks. All the other operations, like copying a disk, moving a disk, etc, have
// been deprecated and will be removed in the future. To perform those operations use the <<services/disks, service
// that manages all the disks of the system>>, or the <<services/disk, service that manages an specific disk>>.
//
type storageDomainDiskService struct {
	baseService
}

func NewStorageDomainDiskService(connection *Connection, path string) *storageDomainDiskService {
	var result storageDomainDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
//
type storageDomainDiskServiceCopyRequest struct {
	storageDomainDiskService *storageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	disk                     *Disk
	storageDomain            *StorageDomain
}

func (p *storageDomainDiskServiceCopyRequest) Header(key, value string) *storageDomainDiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainDiskServiceCopyRequest) Query(key, value string) *storageDomainDiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainDiskServiceCopyRequest) Disk(disk *Disk) *storageDomainDiskServiceCopyRequest {
	p.disk = disk
	return p
}

func (p *storageDomainDiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *storageDomainDiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *storageDomainDiskServiceCopyRequest) Send() (*storageDomainDiskServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(storageDomainDiskServiceCopyResponse), nil
}

func (p *storageDomainDiskServiceCopyRequest) MustSend() *storageDomainDiskServiceCopyResponse {
	rawURL := fmt.Sprintf("%s%s/copy", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(storageDomainDiskServiceCopyResponse)
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
//
type storageDomainDiskServiceCopyResponse struct {
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
//
func (p *storageDomainDiskService) Copy() *storageDomainDiskServiceCopyRequest {
	return &storageDomainDiskServiceCopyRequest{storageDomainDiskService: p}
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
//
type storageDomainDiskServiceExportRequest struct {
	storageDomainDiskService *storageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	storageDomain            *StorageDomain
}

func (p *storageDomainDiskServiceExportRequest) Header(key, value string) *storageDomainDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainDiskServiceExportRequest) Query(key, value string) *storageDomainDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainDiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *storageDomainDiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *storageDomainDiskServiceExportRequest) Send() (*storageDomainDiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(storageDomainDiskServiceExportResponse), nil
}

func (p *storageDomainDiskServiceExportRequest) MustSend() *storageDomainDiskServiceExportResponse {
	rawURL := fmt.Sprintf("%s%s/export", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(storageDomainDiskServiceExportResponse)
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
//
type storageDomainDiskServiceExportResponse struct {
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
//
func (p *storageDomainDiskService) Export() *storageDomainDiskServiceExportRequest {
	return &storageDomainDiskServiceExportRequest{storageDomainDiskService: p}
}

//
// Retrieves the description of the disk.
//
type storageDomainDiskServiceGetRequest struct {
	storageDomainDiskService *storageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *storageDomainDiskServiceGetRequest) Header(key, value string) *storageDomainDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainDiskServiceGetRequest) Query(key, value string) *storageDomainDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainDiskServiceGetRequest) Follow(follow string) *storageDomainDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainDiskServiceGetRequest) Send() (*storageDomainDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageDomainDiskServiceGetResponse{disk: result}, nil
}

func (p *storageDomainDiskServiceGetRequest) MustSend() *storageDomainDiskServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageDomainDiskServiceGetResponse{disk: result}
}

//
// Retrieves the description of the disk.
//
type storageDomainDiskServiceGetResponse struct {
	disk *Disk
}

func (p *storageDomainDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *storageDomainDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Retrieves the description of the disk.
//
func (p *storageDomainDiskService) Get() *storageDomainDiskServiceGetRequest {
	return &storageDomainDiskServiceGetRequest{storageDomainDiskService: p}
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
//
type storageDomainDiskServiceMoveRequest struct {
	storageDomainDiskService *storageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
	filter                   *bool
	storageDomain            *StorageDomain
}

func (p *storageDomainDiskServiceMoveRequest) Header(key, value string) *storageDomainDiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainDiskServiceMoveRequest) Query(key, value string) *storageDomainDiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainDiskServiceMoveRequest) Async(async bool) *storageDomainDiskServiceMoveRequest {
	p.async = &async
	return p
}

func (p *storageDomainDiskServiceMoveRequest) Filter(filter bool) *storageDomainDiskServiceMoveRequest {
	p.filter = &filter
	return p
}

func (p *storageDomainDiskServiceMoveRequest) StorageDomain(storageDomain *StorageDomain) *storageDomainDiskServiceMoveRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *storageDomainDiskServiceMoveRequest) Send() (*storageDomainDiskServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(storageDomainDiskServiceMoveResponse), nil
}

func (p *storageDomainDiskServiceMoveRequest) MustSend() *storageDomainDiskServiceMoveResponse {
	rawURL := fmt.Sprintf("%s%s/move", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(storageDomainDiskServiceMoveResponse)
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
//
type storageDomainDiskServiceMoveResponse struct {
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
//
func (p *storageDomainDiskService) Move() *storageDomainDiskServiceMoveRequest {
	return &storageDomainDiskServiceMoveRequest{storageDomainDiskService: p}
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type storageDomainDiskServiceRemoveRequest struct {
	storageDomainDiskService *storageDomainDiskService
	header                   map[string]string
	query                    map[string]string
}

func (p *storageDomainDiskServiceRemoveRequest) Header(key, value string) *storageDomainDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainDiskServiceRemoveRequest) Query(key, value string) *storageDomainDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainDiskServiceRemoveRequest) Send() (*storageDomainDiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(storageDomainDiskServiceRemoveResponse), nil
}

func (p *storageDomainDiskServiceRemoveRequest) MustSend() *storageDomainDiskServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(storageDomainDiskServiceRemoveResponse)
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type storageDomainDiskServiceRemoveResponse struct {
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
func (p *storageDomainDiskService) Remove() *storageDomainDiskServiceRemoveRequest {
	return &storageDomainDiskServiceRemoveRequest{storageDomainDiskService: p}
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type storageDomainDiskServiceSparsifyRequest struct {
	storageDomainDiskService *storageDomainDiskService
	header                   map[string]string
	query                    map[string]string
}

func (p *storageDomainDiskServiceSparsifyRequest) Header(key, value string) *storageDomainDiskServiceSparsifyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainDiskServiceSparsifyRequest) Query(key, value string) *storageDomainDiskServiceSparsifyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainDiskServiceSparsifyRequest) Send() (*storageDomainDiskServiceSparsifyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/sparsify", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(storageDomainDiskServiceSparsifyResponse), nil
}

func (p *storageDomainDiskServiceSparsifyRequest) MustSend() *storageDomainDiskServiceSparsifyResponse {
	rawURL := fmt.Sprintf("%s%s/sparsify", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(storageDomainDiskServiceSparsifyResponse)
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type storageDomainDiskServiceSparsifyResponse struct {
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
func (p *storageDomainDiskService) Sparsify() *storageDomainDiskServiceSparsifyRequest {
	return &storageDomainDiskServiceSparsifyRequest{storageDomainDiskService: p}
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
//
type storageDomainDiskServiceUpdateRequest struct {
	storageDomainDiskService *storageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	disk                     *Disk
}

func (p *storageDomainDiskServiceUpdateRequest) Header(key, value string) *storageDomainDiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainDiskServiceUpdateRequest) Query(key, value string) *storageDomainDiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainDiskServiceUpdateRequest) Disk(disk *Disk) *storageDomainDiskServiceUpdateRequest {
	p.disk = disk
	return p
}

func (p *storageDomainDiskServiceUpdateRequest) Send() (*storageDomainDiskServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageDomainDiskServiceUpdateResponse{disk: result}, nil
}

func (p *storageDomainDiskServiceUpdateRequest) MustSend() *storageDomainDiskServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainDiskService.connection.URL(), p.storageDomainDiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageDomainDiskServiceUpdateResponse{disk: result}
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
//
type storageDomainDiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *storageDomainDiskServiceUpdateResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *storageDomainDiskServiceUpdateResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
//
func (p *storageDomainDiskService) Update() *storageDomainDiskServiceUpdateRequest {
	return &storageDomainDiskServiceUpdateRequest{storageDomainDiskService: p}
}

//
// Reference to the service that manages the permissions assigned to the disk.
//
func (op *storageDomainDiskService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *storageDomainDiskService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *storageDomainDiskService) String() string {
	return fmt.Sprintf("storageDomainDiskService:%s", op.path)
}

//
// Represents a roles sub-collection, for example scoped by user.
//
type assignedRolesService struct {
	baseService
}

func NewAssignedRolesService(connection *Connection, path string) *assignedRolesService {
	var result assignedRolesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the roles assigned to the permission.
// The order of the returned roles isn't guaranteed.
//
type assignedRolesServiceListRequest struct {
	assignedRolesService *assignedRolesService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *assignedRolesServiceListRequest) Header(key, value string) *assignedRolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedRolesServiceListRequest) Query(key, value string) *assignedRolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedRolesServiceListRequest) Follow(follow string) *assignedRolesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *assignedRolesServiceListRequest) Max(max int64) *assignedRolesServiceListRequest {
	p.max = &max
	return p
}

func (p *assignedRolesServiceListRequest) Send() (*assignedRolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedRolesService.connection.URL(), p.assignedRolesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedRolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedRolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &assignedRolesServiceListResponse{roles: result}, nil
}

func (p *assignedRolesServiceListRequest) MustSend() *assignedRolesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedRolesService.connection.URL(), p.assignedRolesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedRolesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedRolesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &assignedRolesServiceListResponse{roles: result}
}

//
// Returns the roles assigned to the permission.
// The order of the returned roles isn't guaranteed.
//
type assignedRolesServiceListResponse struct {
	roles *RoleSlice
}

func (p *assignedRolesServiceListResponse) Roles() (*RoleSlice, bool) {
	if p.roles != nil {
		return p.roles, true
	}
	return nil, false
}

func (p *assignedRolesServiceListResponse) MustRoles() *RoleSlice {
	if p.roles == nil {
		panic("roles in response does not exist")
	}
	return p.roles
}

//
// Returns the roles assigned to the permission.
// The order of the returned roles isn't guaranteed.
//
func (p *assignedRolesService) List() *assignedRolesServiceListRequest {
	return &assignedRolesServiceListRequest{assignedRolesService: p}
}

//
// Sub-resource locator method, returns individual role resource on which the remainder of the URI is dispatched.
//
func (op *assignedRolesService) RoleService(id string) *roleService {
	return NewRoleService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *assignedRolesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.RoleService(path), nil
	}
	return op.RoleService(path[:index]).Service(path[index+1:])
}

func (op *assignedRolesService) String() string {
	return fmt.Sprintf("assignedRolesService:%s", op.path)
}

//
// A service to manage a virtual machines pool.
//
type vmPoolService struct {
	baseService
}

func NewVmPoolService(connection *Connection, path string) *vmPoolService {
	var result vmPoolService
	result.connection = connection
	result.path = path
	return &result
}

//
// This operation allocates a virtual machine in the virtual machine pool.
// [source]
// ----
// POST /ovirt-engine/api/vmpools/123/allocatevm
// ----
// The allocate virtual machine action does not take any action specific parameters, so the request body should
// contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmPoolServiceAllocateVmRequest struct {
	vmPoolService *vmPoolService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *vmPoolServiceAllocateVmRequest) Header(key, value string) *vmPoolServiceAllocateVmRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmPoolServiceAllocateVmRequest) Query(key, value string) *vmPoolServiceAllocateVmRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmPoolServiceAllocateVmRequest) Async(async bool) *vmPoolServiceAllocateVmRequest {
	p.async = &async
	return p
}

func (p *vmPoolServiceAllocateVmRequest) Send() (*vmPoolServiceAllocateVmResponse, error) {
	rawURL := fmt.Sprintf("%s%s/allocatevm", p.vmPoolService.connection.URL(), p.vmPoolService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmPoolServiceAllocateVmResponse), nil
}

func (p *vmPoolServiceAllocateVmRequest) MustSend() *vmPoolServiceAllocateVmResponse {
	rawURL := fmt.Sprintf("%s%s/allocatevm", p.vmPoolService.connection.URL(), p.vmPoolService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmPoolService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmPoolService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmPoolServiceAllocateVmResponse)
}

//
// This operation allocates a virtual machine in the virtual machine pool.
// [source]
// ----
// POST /ovirt-engine/api/vmpools/123/allocatevm
// ----
// The allocate virtual machine action does not take any action specific parameters, so the request body should
// contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type vmPoolServiceAllocateVmResponse struct {
}

//
// This operation allocates a virtual machine in the virtual machine pool.
// [source]
// ----
// POST /ovirt-engine/api/vmpools/123/allocatevm
// ----
// The allocate virtual machine action does not take any action specific parameters, so the request body should
// contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *vmPoolService) AllocateVm() *vmPoolServiceAllocateVmRequest {
	return &vmPoolServiceAllocateVmRequest{vmPoolService: p}
}

//
// Get the virtual machine pool.
// [source]
// ----
// GET /ovirt-engine/api/vmpools/123
// ----
// You will get a XML response like that one:
// [source,xml]
// ----
// <vm_pool id="123">
//   <actions>...</actions>
//   <name>MyVmPool</name>
//   <description>MyVmPool description</description>
//   <link href="/ovirt-engine/api/vmpools/123/permissions" rel="permissions"/>
//   <max_user_vms>1</max_user_vms>
//   <prestarted_vms>0</prestarted_vms>
//   <size>100</size>
//   <stateful>false</stateful>
//   <type>automatic</type>
//   <use_latest_template_version>false</use_latest_template_version>
//   <cluster id="123"/>
//   <template id="123"/>
//   <vm id="123">...</vm>
//   ...
// </vm_pool>
// ----
//
type vmPoolServiceGetRequest struct {
	vmPoolService *vmPoolService
	header        map[string]string
	query         map[string]string
	filter        *bool
	follow        *string
}

func (p *vmPoolServiceGetRequest) Header(key, value string) *vmPoolServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmPoolServiceGetRequest) Query(key, value string) *vmPoolServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmPoolServiceGetRequest) Filter(filter bool) *vmPoolServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *vmPoolServiceGetRequest) Follow(follow string) *vmPoolServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vmPoolServiceGetRequest) Send() (*vmPoolServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolService.connection.URL(), p.vmPoolService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmPoolReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmPoolServiceGetResponse{pool: result}, nil
}

func (p *vmPoolServiceGetRequest) MustSend() *vmPoolServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolService.connection.URL(), p.vmPoolService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmPoolService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmPoolService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmPoolReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmPoolServiceGetResponse{pool: result}
}

//
// Get the virtual machine pool.
// [source]
// ----
// GET /ovirt-engine/api/vmpools/123
// ----
// You will get a XML response like that one:
// [source,xml]
// ----
// <vm_pool id="123">
//   <actions>...</actions>
//   <name>MyVmPool</name>
//   <description>MyVmPool description</description>
//   <link href="/ovirt-engine/api/vmpools/123/permissions" rel="permissions"/>
//   <max_user_vms>1</max_user_vms>
//   <prestarted_vms>0</prestarted_vms>
//   <size>100</size>
//   <stateful>false</stateful>
//   <type>automatic</type>
//   <use_latest_template_version>false</use_latest_template_version>
//   <cluster id="123"/>
//   <template id="123"/>
//   <vm id="123">...</vm>
//   ...
// </vm_pool>
// ----
//
type vmPoolServiceGetResponse struct {
	pool *VmPool
}

func (p *vmPoolServiceGetResponse) Pool() (*VmPool, bool) {
	if p.pool != nil {
		return p.pool, true
	}
	return nil, false
}

func (p *vmPoolServiceGetResponse) MustPool() *VmPool {
	if p.pool == nil {
		panic("pool in response does not exist")
	}
	return p.pool
}

//
// Get the virtual machine pool.
// [source]
// ----
// GET /ovirt-engine/api/vmpools/123
// ----
// You will get a XML response like that one:
// [source,xml]
// ----
// <vm_pool id="123">
//   <actions>...</actions>
//   <name>MyVmPool</name>
//   <description>MyVmPool description</description>
//   <link href="/ovirt-engine/api/vmpools/123/permissions" rel="permissions"/>
//   <max_user_vms>1</max_user_vms>
//   <prestarted_vms>0</prestarted_vms>
//   <size>100</size>
//   <stateful>false</stateful>
//   <type>automatic</type>
//   <use_latest_template_version>false</use_latest_template_version>
//   <cluster id="123"/>
//   <template id="123"/>
//   <vm id="123">...</vm>
//   ...
// </vm_pool>
// ----
//
func (p *vmPoolService) Get() *vmPoolServiceGetRequest {
	return &vmPoolServiceGetRequest{vmPoolService: p}
}

//
// Removes a virtual machine pool.
// [source]
// ----
// DELETE /ovirt-engine/api/vmpools/123
// ----
//
type vmPoolServiceRemoveRequest struct {
	vmPoolService *vmPoolService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *vmPoolServiceRemoveRequest) Header(key, value string) *vmPoolServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmPoolServiceRemoveRequest) Query(key, value string) *vmPoolServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmPoolServiceRemoveRequest) Async(async bool) *vmPoolServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *vmPoolServiceRemoveRequest) Send() (*vmPoolServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolService.connection.URL(), p.vmPoolService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(vmPoolServiceRemoveResponse), nil
}

func (p *vmPoolServiceRemoveRequest) MustSend() *vmPoolServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolService.connection.URL(), p.vmPoolService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmPoolService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmPoolService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(vmPoolServiceRemoveResponse)
}

//
// Removes a virtual machine pool.
// [source]
// ----
// DELETE /ovirt-engine/api/vmpools/123
// ----
//
type vmPoolServiceRemoveResponse struct {
}

//
// Removes a virtual machine pool.
// [source]
// ----
// DELETE /ovirt-engine/api/vmpools/123
// ----
//
func (p *vmPoolService) Remove() *vmPoolServiceRemoveRequest {
	return &vmPoolServiceRemoveRequest{vmPoolService: p}
}

//
// Update the virtual machine pool.
// [source]
// ----
// PUT /ovirt-engine/api/vmpools/123
// ----
// The `name`, `description`, `size`, `prestarted_vms` and `max_user_vms`
// attributes can be updated after the virtual machine pool has been
// created.
// [source,xml]
// ----
// <vmpool>
//   <name>VM_Pool_B</name>
//   <description>Virtual Machine Pool B</description>
//   <size>3</size>
//   <prestarted_vms>1</size>
//   <max_user_vms>2</size>
// </vmpool>
// ----
//
type vmPoolServiceUpdateRequest struct {
	vmPoolService *vmPoolService
	header        map[string]string
	query         map[string]string
	async         *bool
	pool          *VmPool
}

func (p *vmPoolServiceUpdateRequest) Header(key, value string) *vmPoolServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmPoolServiceUpdateRequest) Query(key, value string) *vmPoolServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmPoolServiceUpdateRequest) Async(async bool) *vmPoolServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *vmPoolServiceUpdateRequest) Pool(pool *VmPool) *vmPoolServiceUpdateRequest {
	p.pool = pool
	return p
}

func (p *vmPoolServiceUpdateRequest) Send() (*vmPoolServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolService.connection.URL(), p.vmPoolService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmPoolWriteOne(writer, p.pool, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmPoolReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmPoolServiceUpdateResponse{pool: result}, nil
}

func (p *vmPoolServiceUpdateRequest) MustSend() *vmPoolServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmPoolService.connection.URL(), p.vmPoolService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmPoolWriteOne(writer, p.pool, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmPoolService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmPoolService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmPoolReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmPoolServiceUpdateResponse{pool: result}
}

//
// Update the virtual machine pool.
// [source]
// ----
// PUT /ovirt-engine/api/vmpools/123
// ----
// The `name`, `description`, `size`, `prestarted_vms` and `max_user_vms`
// attributes can be updated after the virtual machine pool has been
// created.
// [source,xml]
// ----
// <vmpool>
//   <name>VM_Pool_B</name>
//   <description>Virtual Machine Pool B</description>
//   <size>3</size>
//   <prestarted_vms>1</size>
//   <max_user_vms>2</size>
// </vmpool>
// ----
//
type vmPoolServiceUpdateResponse struct {
	pool *VmPool
}

func (p *vmPoolServiceUpdateResponse) Pool() (*VmPool, bool) {
	if p.pool != nil {
		return p.pool, true
	}
	return nil, false
}

func (p *vmPoolServiceUpdateResponse) MustPool() *VmPool {
	if p.pool == nil {
		panic("pool in response does not exist")
	}
	return p.pool
}

//
// Update the virtual machine pool.
// [source]
// ----
// PUT /ovirt-engine/api/vmpools/123
// ----
// The `name`, `description`, `size`, `prestarted_vms` and `max_user_vms`
// attributes can be updated after the virtual machine pool has been
// created.
// [source,xml]
// ----
// <vmpool>
//   <name>VM_Pool_B</name>
//   <description>Virtual Machine Pool B</description>
//   <size>3</size>
//   <prestarted_vms>1</size>
//   <max_user_vms>2</size>
// </vmpool>
// ----
//
func (p *vmPoolService) Update() *vmPoolServiceUpdateRequest {
	return &vmPoolServiceUpdateRequest{vmPoolService: p}
}

//
// Reference to a service managing the virtual machine pool assigned permissions.
//
func (op *vmPoolService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmPoolService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vmPoolService) String() string {
	return fmt.Sprintf("vmPoolService:%s", op.path)
}

//
//
type storageServerConnectionExtensionsService struct {
	baseService
}

func NewStorageServerConnectionExtensionsService(connection *Connection, path string) *storageServerConnectionExtensionsService {
	var result storageServerConnectionExtensionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new storage server connection extension for the given host.
// The extension lets the user define credentials for an iSCSI target for a specific host. For example to use
// `myuser` and `mypassword` as the credentials when connecting to the iSCSI target from host `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/storageconnectionextensions
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
type storageServerConnectionExtensionsServiceAddRequest struct {
	storageServerConnectionExtensionsService *storageServerConnectionExtensionsService
	header                                   map[string]string
	query                                    map[string]string
	extension                                *StorageConnectionExtension
}

func (p *storageServerConnectionExtensionsServiceAddRequest) Header(key, value string) *storageServerConnectionExtensionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionExtensionsServiceAddRequest) Query(key, value string) *storageServerConnectionExtensionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionExtensionsServiceAddRequest) Extension(extension *StorageConnectionExtension) *storageServerConnectionExtensionsServiceAddRequest {
	p.extension = extension
	return p
}

func (p *storageServerConnectionExtensionsServiceAddRequest) Send() (*storageServerConnectionExtensionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionsService.connection.URL(), p.storageServerConnectionExtensionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionExtensionWriteOne(writer, p.extension, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionExtensionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionExtensionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageServerConnectionExtensionsServiceAddResponse{extension: result}, nil
}

func (p *storageServerConnectionExtensionsServiceAddRequest) MustSend() *storageServerConnectionExtensionsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionsService.connection.URL(), p.storageServerConnectionExtensionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionExtensionWriteOne(writer, p.extension, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionExtensionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionExtensionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageServerConnectionExtensionsServiceAddResponse{extension: result}
}

//
// Creates a new storage server connection extension for the given host.
// The extension lets the user define credentials for an iSCSI target for a specific host. For example to use
// `myuser` and `mypassword` as the credentials when connecting to the iSCSI target from host `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/storageconnectionextensions
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
type storageServerConnectionExtensionsServiceAddResponse struct {
	extension *StorageConnectionExtension
}

func (p *storageServerConnectionExtensionsServiceAddResponse) Extension() (*StorageConnectionExtension, bool) {
	if p.extension != nil {
		return p.extension, true
	}
	return nil, false
}

func (p *storageServerConnectionExtensionsServiceAddResponse) MustExtension() *StorageConnectionExtension {
	if p.extension == nil {
		panic("extension in response does not exist")
	}
	return p.extension
}

//
// Creates a new storage server connection extension for the given host.
// The extension lets the user define credentials for an iSCSI target for a specific host. For example to use
// `myuser` and `mypassword` as the credentials when connecting to the iSCSI target from host `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/storageconnectionextensions
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
func (p *storageServerConnectionExtensionsService) Add() *storageServerConnectionExtensionsServiceAddRequest {
	return &storageServerConnectionExtensionsServiceAddRequest{storageServerConnectionExtensionsService: p}
}

//
// Returns the list os storage connection extensions.
// The order of the returned list of storage connections isn't guaranteed.
//
type storageServerConnectionExtensionsServiceListRequest struct {
	storageServerConnectionExtensionsService *storageServerConnectionExtensionsService
	header                                   map[string]string
	query                                    map[string]string
	follow                                   *string
	max                                      *int64
}

func (p *storageServerConnectionExtensionsServiceListRequest) Header(key, value string) *storageServerConnectionExtensionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageServerConnectionExtensionsServiceListRequest) Query(key, value string) *storageServerConnectionExtensionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageServerConnectionExtensionsServiceListRequest) Follow(follow string) *storageServerConnectionExtensionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *storageServerConnectionExtensionsServiceListRequest) Max(max int64) *storageServerConnectionExtensionsServiceListRequest {
	p.max = &max
	return p
}

func (p *storageServerConnectionExtensionsServiceListRequest) Send() (*storageServerConnectionExtensionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionsService.connection.URL(), p.storageServerConnectionExtensionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionExtensionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionExtensionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &storageServerConnectionExtensionsServiceListResponse{extensions: result}, nil
}

func (p *storageServerConnectionExtensionsServiceListRequest) MustSend() *storageServerConnectionExtensionsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageServerConnectionExtensionsService.connection.URL(), p.storageServerConnectionExtensionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageServerConnectionExtensionsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageServerConnectionExtensionsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionExtensionReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &storageServerConnectionExtensionsServiceListResponse{extensions: result}
}

//
// Returns the list os storage connection extensions.
// The order of the returned list of storage connections isn't guaranteed.
//
type storageServerConnectionExtensionsServiceListResponse struct {
	extensions *StorageConnectionExtensionSlice
}

func (p *storageServerConnectionExtensionsServiceListResponse) Extensions() (*StorageConnectionExtensionSlice, bool) {
	if p.extensions != nil {
		return p.extensions, true
	}
	return nil, false
}

func (p *storageServerConnectionExtensionsServiceListResponse) MustExtensions() *StorageConnectionExtensionSlice {
	if p.extensions == nil {
		panic("extensions in response does not exist")
	}
	return p.extensions
}

//
// Returns the list os storage connection extensions.
// The order of the returned list of storage connections isn't guaranteed.
//
func (p *storageServerConnectionExtensionsService) List() *storageServerConnectionExtensionsServiceListRequest {
	return &storageServerConnectionExtensionsServiceListRequest{storageServerConnectionExtensionsService: p}
}

//
//
func (op *storageServerConnectionExtensionsService) StorageConnectionExtensionService(id string) *storageServerConnectionExtensionService {
	return NewStorageServerConnectionExtensionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageServerConnectionExtensionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StorageConnectionExtensionService(path), nil
	}
	return op.StorageConnectionExtensionService(path[:index]).Service(path[index+1:])
}

func (op *storageServerConnectionExtensionsService) String() string {
	return fmt.Sprintf("storageServerConnectionExtensionsService:%s", op.path)
}

//
//
type virtualFunctionAllowedNetworksService struct {
	baseService
}

func NewVirtualFunctionAllowedNetworksService(connection *Connection, path string) *virtualFunctionAllowedNetworksService {
	var result virtualFunctionAllowedNetworksService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type virtualFunctionAllowedNetworksServiceAddRequest struct {
	virtualFunctionAllowedNetworksService *virtualFunctionAllowedNetworksService
	header                                map[string]string
	query                                 map[string]string
	network                               *Network
}

func (p *virtualFunctionAllowedNetworksServiceAddRequest) Header(key, value string) *virtualFunctionAllowedNetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *virtualFunctionAllowedNetworksServiceAddRequest) Query(key, value string) *virtualFunctionAllowedNetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *virtualFunctionAllowedNetworksServiceAddRequest) Network(network *Network) *virtualFunctionAllowedNetworksServiceAddRequest {
	p.network = network
	return p
}

func (p *virtualFunctionAllowedNetworksServiceAddRequest) Send() (*virtualFunctionAllowedNetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworksService.connection.URL(), p.virtualFunctionAllowedNetworksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.virtualFunctionAllowedNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &virtualFunctionAllowedNetworksServiceAddResponse{network: result}, nil
}

func (p *virtualFunctionAllowedNetworksServiceAddRequest) MustSend() *virtualFunctionAllowedNetworksServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworksService.connection.URL(), p.virtualFunctionAllowedNetworksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.virtualFunctionAllowedNetworksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &virtualFunctionAllowedNetworksServiceAddResponse{network: result}
}

//
//
type virtualFunctionAllowedNetworksServiceAddResponse struct {
	network *Network
}

func (p *virtualFunctionAllowedNetworksServiceAddResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *virtualFunctionAllowedNetworksServiceAddResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
//
func (p *virtualFunctionAllowedNetworksService) Add() *virtualFunctionAllowedNetworksServiceAddRequest {
	return &virtualFunctionAllowedNetworksServiceAddRequest{virtualFunctionAllowedNetworksService: p}
}

//
// Returns the list of networks.
// The order of the returned list of networks isn't guaranteed.
//
type virtualFunctionAllowedNetworksServiceListRequest struct {
	virtualFunctionAllowedNetworksService *virtualFunctionAllowedNetworksService
	header                                map[string]string
	query                                 map[string]string
	follow                                *string
	max                                   *int64
}

func (p *virtualFunctionAllowedNetworksServiceListRequest) Header(key, value string) *virtualFunctionAllowedNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *virtualFunctionAllowedNetworksServiceListRequest) Query(key, value string) *virtualFunctionAllowedNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *virtualFunctionAllowedNetworksServiceListRequest) Follow(follow string) *virtualFunctionAllowedNetworksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *virtualFunctionAllowedNetworksServiceListRequest) Max(max int64) *virtualFunctionAllowedNetworksServiceListRequest {
	p.max = &max
	return p
}

func (p *virtualFunctionAllowedNetworksServiceListRequest) Send() (*virtualFunctionAllowedNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworksService.connection.URL(), p.virtualFunctionAllowedNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.virtualFunctionAllowedNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &virtualFunctionAllowedNetworksServiceListResponse{networks: result}, nil
}

func (p *virtualFunctionAllowedNetworksServiceListRequest) MustSend() *virtualFunctionAllowedNetworksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.virtualFunctionAllowedNetworksService.connection.URL(), p.virtualFunctionAllowedNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.virtualFunctionAllowedNetworksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.virtualFunctionAllowedNetworksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &virtualFunctionAllowedNetworksServiceListResponse{networks: result}
}

//
// Returns the list of networks.
// The order of the returned list of networks isn't guaranteed.
//
type virtualFunctionAllowedNetworksServiceListResponse struct {
	networks *NetworkSlice
}

func (p *virtualFunctionAllowedNetworksServiceListResponse) Networks() (*NetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *virtualFunctionAllowedNetworksServiceListResponse) MustNetworks() *NetworkSlice {
	if p.networks == nil {
		panic("networks in response does not exist")
	}
	return p.networks
}

//
// Returns the list of networks.
// The order of the returned list of networks isn't guaranteed.
//
func (p *virtualFunctionAllowedNetworksService) List() *virtualFunctionAllowedNetworksServiceListRequest {
	return &virtualFunctionAllowedNetworksServiceListRequest{virtualFunctionAllowedNetworksService: p}
}

//
//
func (op *virtualFunctionAllowedNetworksService) NetworkService(id string) *virtualFunctionAllowedNetworkService {
	return NewVirtualFunctionAllowedNetworkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *virtualFunctionAllowedNetworksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NetworkService(path), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *virtualFunctionAllowedNetworksService) String() string {
	return fmt.Sprintf("virtualFunctionAllowedNetworksService:%s", op.path)
}

//
//
type cpuProfilesService struct {
	baseService
}

func NewCpuProfilesService(connection *Connection, path string) *cpuProfilesService {
	var result cpuProfilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new cpu profile to the system.
//
type cpuProfilesServiceAddRequest struct {
	cpuProfilesService *cpuProfilesService
	header             map[string]string
	query              map[string]string
	profile            *CpuProfile
}

func (p *cpuProfilesServiceAddRequest) Header(key, value string) *cpuProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *cpuProfilesServiceAddRequest) Query(key, value string) *cpuProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *cpuProfilesServiceAddRequest) Profile(profile *CpuProfile) *cpuProfilesServiceAddRequest {
	p.profile = profile
	return p
}

func (p *cpuProfilesServiceAddRequest) Send() (*cpuProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfilesService.connection.URL(), p.cpuProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCpuProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.cpuProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.cpuProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &cpuProfilesServiceAddResponse{profile: result}, nil
}

func (p *cpuProfilesServiceAddRequest) MustSend() *cpuProfilesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfilesService.connection.URL(), p.cpuProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCpuProfileWriteOne(writer, p.profile, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.cpuProfilesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.cpuProfilesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &cpuProfilesServiceAddResponse{profile: result}
}

//
// Add a new cpu profile to the system.
//
type cpuProfilesServiceAddResponse struct {
	profile *CpuProfile
}

func (p *cpuProfilesServiceAddResponse) Profile() (*CpuProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *cpuProfilesServiceAddResponse) MustProfile() *CpuProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Add a new cpu profile to the system.
//
func (p *cpuProfilesService) Add() *cpuProfilesServiceAddRequest {
	return &cpuProfilesServiceAddRequest{cpuProfilesService: p}
}

//
// Returns the list of CPU profiles of the system.
// The order of the returned list of CPU profiles isn't guranteed.
//
type cpuProfilesServiceListRequest struct {
	cpuProfilesService *cpuProfilesService
	header             map[string]string
	query              map[string]string
	follow             *string
	max                *int64
}

func (p *cpuProfilesServiceListRequest) Header(key, value string) *cpuProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *cpuProfilesServiceListRequest) Query(key, value string) *cpuProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *cpuProfilesServiceListRequest) Follow(follow string) *cpuProfilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *cpuProfilesServiceListRequest) Max(max int64) *cpuProfilesServiceListRequest {
	p.max = &max
	return p
}

func (p *cpuProfilesServiceListRequest) Send() (*cpuProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfilesService.connection.URL(), p.cpuProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.cpuProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.cpuProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &cpuProfilesServiceListResponse{profile: result}, nil
}

func (p *cpuProfilesServiceListRequest) MustSend() *cpuProfilesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.cpuProfilesService.connection.URL(), p.cpuProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.cpuProfilesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.cpuProfilesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &cpuProfilesServiceListResponse{profile: result}
}

//
// Returns the list of CPU profiles of the system.
// The order of the returned list of CPU profiles isn't guranteed.
//
type cpuProfilesServiceListResponse struct {
	profile *CpuProfileSlice
}

func (p *cpuProfilesServiceListResponse) Profile() (*CpuProfileSlice, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *cpuProfilesServiceListResponse) MustProfile() *CpuProfileSlice {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Returns the list of CPU profiles of the system.
// The order of the returned list of CPU profiles isn't guranteed.
//
func (p *cpuProfilesService) List() *cpuProfilesServiceListRequest {
	return &cpuProfilesServiceListRequest{cpuProfilesService: p}
}

//
//
func (op *cpuProfilesService) ProfileService(id string) *cpuProfileService {
	return NewCpuProfileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *cpuProfilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProfileService(path), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *cpuProfilesService) String() string {
	return fmt.Sprintf("cpuProfilesService:%s", op.path)
}

//
// Lists the CD-ROM devices of a template.
//
type templateCdromsService struct {
	baseService
}

func NewTemplateCdromsService(connection *Connection, path string) *templateCdromsService {
	var result templateCdromsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of CD-ROM devices of the template.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
type templateCdromsServiceListRequest struct {
	templateCdromsService *templateCdromsService
	header                map[string]string
	query                 map[string]string
	follow                *string
	max                   *int64
}

func (p *templateCdromsServiceListRequest) Header(key, value string) *templateCdromsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateCdromsServiceListRequest) Query(key, value string) *templateCdromsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateCdromsServiceListRequest) Follow(follow string) *templateCdromsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *templateCdromsServiceListRequest) Max(max int64) *templateCdromsServiceListRequest {
	p.max = &max
	return p
}

func (p *templateCdromsServiceListRequest) Send() (*templateCdromsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateCdromsService.connection.URL(), p.templateCdromsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateCdromsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateCdromsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &templateCdromsServiceListResponse{cdroms: result}, nil
}

func (p *templateCdromsServiceListRequest) MustSend() *templateCdromsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateCdromsService.connection.URL(), p.templateCdromsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateCdromsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateCdromsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &templateCdromsServiceListResponse{cdroms: result}
}

//
// Returns the list of CD-ROM devices of the template.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
type templateCdromsServiceListResponse struct {
	cdroms *CdromSlice
}

func (p *templateCdromsServiceListResponse) Cdroms() (*CdromSlice, bool) {
	if p.cdroms != nil {
		return p.cdroms, true
	}
	return nil, false
}

func (p *templateCdromsServiceListResponse) MustCdroms() *CdromSlice {
	if p.cdroms == nil {
		panic("cdroms in response does not exist")
	}
	return p.cdroms
}

//
// Returns the list of CD-ROM devices of the template.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
func (p *templateCdromsService) List() *templateCdromsServiceListRequest {
	return &templateCdromsServiceListRequest{templateCdromsService: p}
}

//
// Returns a reference to the service that manages a specific CD-ROM device.
//
func (op *templateCdromsService) CdromService(id string) *templateCdromService {
	return NewTemplateCdromService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateCdromsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.CdromService(path), nil
	}
	return op.CdromService(path[:index]).Service(path[index+1:])
}

func (op *templateCdromsService) String() string {
	return fmt.Sprintf("templateCdromsService:%s", op.path)
}

//
// A service to manage fence agent for a specific host.
//
type fenceAgentService struct {
	baseService
}

func NewFenceAgentService(connection *Connection, path string) *fenceAgentService {
	var result fenceAgentService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets details of this fence agent.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/fenceagents/0
// ----
// And here is sample response:
// [source,xml]
// ----
// <agent id="0">
//   <type>apc</type>
//   <order>1</order>
//   <ip>192.168.1.101</ip>
//   <user>user</user>
//   <password>xxx</password>
//   <port>9</port>
//   <options>name1=value1, name2=value2</options>
// </agent>
// ----
//
type fenceAgentServiceGetRequest struct {
	fenceAgentService *fenceAgentService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *fenceAgentServiceGetRequest) Header(key, value string) *fenceAgentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *fenceAgentServiceGetRequest) Query(key, value string) *fenceAgentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *fenceAgentServiceGetRequest) Follow(follow string) *fenceAgentServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *fenceAgentServiceGetRequest) Send() (*fenceAgentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentService.connection.URL(), p.fenceAgentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.fenceAgentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.fenceAgentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAgentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &fenceAgentServiceGetResponse{agent: result}, nil
}

func (p *fenceAgentServiceGetRequest) MustSend() *fenceAgentServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentService.connection.URL(), p.fenceAgentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.fenceAgentService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.fenceAgentService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAgentReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &fenceAgentServiceGetResponse{agent: result}
}

//
// Gets details of this fence agent.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/fenceagents/0
// ----
// And here is sample response:
// [source,xml]
// ----
// <agent id="0">
//   <type>apc</type>
//   <order>1</order>
//   <ip>192.168.1.101</ip>
//   <user>user</user>
//   <password>xxx</password>
//   <port>9</port>
//   <options>name1=value1, name2=value2</options>
// </agent>
// ----
//
type fenceAgentServiceGetResponse struct {
	agent *Agent
}

func (p *fenceAgentServiceGetResponse) Agent() (*Agent, bool) {
	if p.agent != nil {
		return p.agent, true
	}
	return nil, false
}

func (p *fenceAgentServiceGetResponse) MustAgent() *Agent {
	if p.agent == nil {
		panic("agent in response does not exist")
	}
	return p.agent
}

//
// Gets details of this fence agent.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/fenceagents/0
// ----
// And here is sample response:
// [source,xml]
// ----
// <agent id="0">
//   <type>apc</type>
//   <order>1</order>
//   <ip>192.168.1.101</ip>
//   <user>user</user>
//   <password>xxx</password>
//   <port>9</port>
//   <options>name1=value1, name2=value2</options>
// </agent>
// ----
//
func (p *fenceAgentService) Get() *fenceAgentServiceGetRequest {
	return &fenceAgentServiceGetRequest{fenceAgentService: p}
}

//
// Removes a fence agent for a specific host.
// [source]
// ----
// DELETE /ovirt-engine/api/hosts/123/fenceagents/0
// ----
//
type fenceAgentServiceRemoveRequest struct {
	fenceAgentService *fenceAgentService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *fenceAgentServiceRemoveRequest) Header(key, value string) *fenceAgentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *fenceAgentServiceRemoveRequest) Query(key, value string) *fenceAgentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *fenceAgentServiceRemoveRequest) Async(async bool) *fenceAgentServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *fenceAgentServiceRemoveRequest) Send() (*fenceAgentServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentService.connection.URL(), p.fenceAgentService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.fenceAgentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.fenceAgentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(fenceAgentServiceRemoveResponse), nil
}

func (p *fenceAgentServiceRemoveRequest) MustSend() *fenceAgentServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentService.connection.URL(), p.fenceAgentService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.fenceAgentService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.fenceAgentService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(fenceAgentServiceRemoveResponse)
}

//
// Removes a fence agent for a specific host.
// [source]
// ----
// DELETE /ovirt-engine/api/hosts/123/fenceagents/0
// ----
//
type fenceAgentServiceRemoveResponse struct {
}

//
// Removes a fence agent for a specific host.
// [source]
// ----
// DELETE /ovirt-engine/api/hosts/123/fenceagents/0
// ----
//
func (p *fenceAgentService) Remove() *fenceAgentServiceRemoveRequest {
	return &fenceAgentServiceRemoveRequest{fenceAgentService: p}
}

//
// Update a fencing-agent.
//
type fenceAgentServiceUpdateRequest struct {
	fenceAgentService *fenceAgentService
	header            map[string]string
	query             map[string]string
	agent             *Agent
	async             *bool
}

func (p *fenceAgentServiceUpdateRequest) Header(key, value string) *fenceAgentServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *fenceAgentServiceUpdateRequest) Query(key, value string) *fenceAgentServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *fenceAgentServiceUpdateRequest) Agent(agent *Agent) *fenceAgentServiceUpdateRequest {
	p.agent = agent
	return p
}

func (p *fenceAgentServiceUpdateRequest) Async(async bool) *fenceAgentServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *fenceAgentServiceUpdateRequest) Send() (*fenceAgentServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentService.connection.URL(), p.fenceAgentService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAgentWriteOne(writer, p.agent, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.fenceAgentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.fenceAgentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAgentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &fenceAgentServiceUpdateResponse{agent: result}, nil
}

func (p *fenceAgentServiceUpdateRequest) MustSend() *fenceAgentServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.fenceAgentService.connection.URL(), p.fenceAgentService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAgentWriteOne(writer, p.agent, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.fenceAgentService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.fenceAgentService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAgentReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &fenceAgentServiceUpdateResponse{agent: result}
}

//
// Update a fencing-agent.
//
type fenceAgentServiceUpdateResponse struct {
	agent *Agent
}

func (p *fenceAgentServiceUpdateResponse) Agent() (*Agent, bool) {
	if p.agent != nil {
		return p.agent, true
	}
	return nil, false
}

func (p *fenceAgentServiceUpdateResponse) MustAgent() *Agent {
	if p.agent == nil {
		panic("agent in response does not exist")
	}
	return p.agent
}

//
// Update a fencing-agent.
//
func (p *fenceAgentService) Update() *fenceAgentServiceUpdateRequest {
	return &fenceAgentServiceUpdateRequest{fenceAgentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *fenceAgentService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *fenceAgentService) String() string {
	return fmt.Sprintf("fenceAgentService:%s", op.path)
}

//
//
type snapshotNicService struct {
	baseService
}

func NewSnapshotNicService(connection *Connection, path string) *snapshotNicService {
	var result snapshotNicService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type snapshotNicServiceGetRequest struct {
	snapshotNicService *snapshotNicService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *snapshotNicServiceGetRequest) Header(key, value string) *snapshotNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *snapshotNicServiceGetRequest) Query(key, value string) *snapshotNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *snapshotNicServiceGetRequest) Follow(follow string) *snapshotNicServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *snapshotNicServiceGetRequest) Send() (*snapshotNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.snapshotNicService.connection.URL(), p.snapshotNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &snapshotNicServiceGetResponse{nic: result}, nil
}

func (p *snapshotNicServiceGetRequest) MustSend() *snapshotNicServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.snapshotNicService.connection.URL(), p.snapshotNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.snapshotNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.snapshotNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &snapshotNicServiceGetResponse{nic: result}
}

//
//
type snapshotNicServiceGetResponse struct {
	nic *Nic
}

func (p *snapshotNicServiceGetResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *snapshotNicServiceGetResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
//
func (p *snapshotNicService) Get() *snapshotNicServiceGetRequest {
	return &snapshotNicServiceGetRequest{snapshotNicService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *snapshotNicService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *snapshotNicService) String() string {
	return fmt.Sprintf("snapshotNicService:%s", op.path)
}

//
// This service manages the attachment of a disk to a virtual machine.
//
type diskAttachmentService struct {
	baseService
}

func NewDiskAttachmentService(connection *Connection, path string) *diskAttachmentService {
	var result diskAttachmentService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the details of the attachment, including the bootable flag and link to the disk.
// An example of getting a disk attachment:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/diskattachments/456
// ----
// [source,xml]
// ----
// <disk_attachment href="/ovirt-engine/api/vms/123/diskattachments/456" id="456">
//   <active>true</active>
//   <bootable>true</bootable>
//   <interface>virtio</interface>
//   <disk href="/ovirt-engine/api/disks/456" id="456"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </disk_attachment>
// ----
//
type diskAttachmentServiceGetRequest struct {
	diskAttachmentService *diskAttachmentService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *diskAttachmentServiceGetRequest) Header(key, value string) *diskAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskAttachmentServiceGetRequest) Query(key, value string) *diskAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskAttachmentServiceGetRequest) Follow(follow string) *diskAttachmentServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *diskAttachmentServiceGetRequest) Send() (*diskAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentService.connection.URL(), p.diskAttachmentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &diskAttachmentServiceGetResponse{attachment: result}, nil
}

func (p *diskAttachmentServiceGetRequest) MustSend() *diskAttachmentServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentService.connection.URL(), p.diskAttachmentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &diskAttachmentServiceGetResponse{attachment: result}
}

//
// Returns the details of the attachment, including the bootable flag and link to the disk.
// An example of getting a disk attachment:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/diskattachments/456
// ----
// [source,xml]
// ----
// <disk_attachment href="/ovirt-engine/api/vms/123/diskattachments/456" id="456">
//   <active>true</active>
//   <bootable>true</bootable>
//   <interface>virtio</interface>
//   <disk href="/ovirt-engine/api/disks/456" id="456"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </disk_attachment>
// ----
//
type diskAttachmentServiceGetResponse struct {
	attachment *DiskAttachment
}

func (p *diskAttachmentServiceGetResponse) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *diskAttachmentServiceGetResponse) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
// Returns the details of the attachment, including the bootable flag and link to the disk.
// An example of getting a disk attachment:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/diskattachments/456
// ----
// [source,xml]
// ----
// <disk_attachment href="/ovirt-engine/api/vms/123/diskattachments/456" id="456">
//   <active>true</active>
//   <bootable>true</bootable>
//   <interface>virtio</interface>
//   <disk href="/ovirt-engine/api/disks/456" id="456"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </disk_attachment>
// ----
//
func (p *diskAttachmentService) Get() *diskAttachmentServiceGetRequest {
	return &diskAttachmentServiceGetRequest{diskAttachmentService: p}
}

//
// Removes the disk attachment.
// This will only detach the disk from the virtual machine, but won't remove it from
// the system, unless the `detach_only` parameter is `false`.
// An example of removing a disk attachment:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/diskattachments/456?detach_only=true
// ----
//
type diskAttachmentServiceRemoveRequest struct {
	diskAttachmentService *diskAttachmentService
	header                map[string]string
	query                 map[string]string
	detachOnly            *bool
}

func (p *diskAttachmentServiceRemoveRequest) Header(key, value string) *diskAttachmentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskAttachmentServiceRemoveRequest) Query(key, value string) *diskAttachmentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskAttachmentServiceRemoveRequest) DetachOnly(detachOnly bool) *diskAttachmentServiceRemoveRequest {
	p.detachOnly = &detachOnly
	return p
}

func (p *diskAttachmentServiceRemoveRequest) Send() (*diskAttachmentServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentService.connection.URL(), p.diskAttachmentService.path)
	values := make(url.Values)
	if p.detachOnly != nil {
		values["detach_only"] = []string{fmt.Sprintf("%v", *p.detachOnly)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(diskAttachmentServiceRemoveResponse), nil
}

func (p *diskAttachmentServiceRemoveRequest) MustSend() *diskAttachmentServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentService.connection.URL(), p.diskAttachmentService.path)
	values := make(url.Values)
	if p.detachOnly != nil {
		values["detach_only"] = []string{fmt.Sprintf("%v", *p.detachOnly)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(diskAttachmentServiceRemoveResponse)
}

//
// Removes the disk attachment.
// This will only detach the disk from the virtual machine, but won't remove it from
// the system, unless the `detach_only` parameter is `false`.
// An example of removing a disk attachment:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/diskattachments/456?detach_only=true
// ----
//
type diskAttachmentServiceRemoveResponse struct {
}

//
// Removes the disk attachment.
// This will only detach the disk from the virtual machine, but won't remove it from
// the system, unless the `detach_only` parameter is `false`.
// An example of removing a disk attachment:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/diskattachments/456?detach_only=true
// ----
//
func (p *diskAttachmentService) Remove() *diskAttachmentServiceRemoveRequest {
	return &diskAttachmentServiceRemoveRequest{diskAttachmentService: p}
}

//
// Update the disk attachment and the disk properties within it.
// [source]
// ----
// PUT /vms/{vm:id}/disksattachments/{attachment:id}
// <disk_attachment>
//   <bootable>true</bootable>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
//
type diskAttachmentServiceUpdateRequest struct {
	diskAttachmentService *diskAttachmentService
	header                map[string]string
	query                 map[string]string
	diskAttachment        *DiskAttachment
}

func (p *diskAttachmentServiceUpdateRequest) Header(key, value string) *diskAttachmentServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *diskAttachmentServiceUpdateRequest) Query(key, value string) *diskAttachmentServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *diskAttachmentServiceUpdateRequest) DiskAttachment(diskAttachment *DiskAttachment) *diskAttachmentServiceUpdateRequest {
	p.diskAttachment = diskAttachment
	return p
}

func (p *diskAttachmentServiceUpdateRequest) Send() (*diskAttachmentServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentService.connection.URL(), p.diskAttachmentService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskAttachmentWriteOne(writer, p.diskAttachment, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &diskAttachmentServiceUpdateResponse{diskAttachment: result}, nil
}

func (p *diskAttachmentServiceUpdateRequest) MustSend() *diskAttachmentServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.diskAttachmentService.connection.URL(), p.diskAttachmentService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskAttachmentWriteOne(writer, p.diskAttachment, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.diskAttachmentService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.diskAttachmentService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &diskAttachmentServiceUpdateResponse{diskAttachment: result}
}

//
// Update the disk attachment and the disk properties within it.
// [source]
// ----
// PUT /vms/{vm:id}/disksattachments/{attachment:id}
// <disk_attachment>
//   <bootable>true</bootable>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
//
type diskAttachmentServiceUpdateResponse struct {
	diskAttachment *DiskAttachment
}

func (p *diskAttachmentServiceUpdateResponse) DiskAttachment() (*DiskAttachment, bool) {
	if p.diskAttachment != nil {
		return p.diskAttachment, true
	}
	return nil, false
}

func (p *diskAttachmentServiceUpdateResponse) MustDiskAttachment() *DiskAttachment {
	if p.diskAttachment == nil {
		panic("diskAttachment in response does not exist")
	}
	return p.diskAttachment
}

//
// Update the disk attachment and the disk properties within it.
// [source]
// ----
// PUT /vms/{vm:id}/disksattachments/{attachment:id}
// <disk_attachment>
//   <bootable>true</bootable>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
//
func (p *diskAttachmentService) Update() *diskAttachmentServiceUpdateRequest {
	return &diskAttachmentServiceUpdateRequest{diskAttachmentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *diskAttachmentService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *diskAttachmentService) String() string {
	return fmt.Sprintf("diskAttachmentService:%s", op.path)
}

//
// This service represents a vm that has a specific
// label when accessed through the affinitylabels/vms
// subcollection.
//
type affinityLabelVmService struct {
	baseService
}

func NewAffinityLabelVmService(connection *Connection, path string) *affinityLabelVmService {
	var result affinityLabelVmService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves details about a vm that has this label assigned.
//
type affinityLabelVmServiceGetRequest struct {
	affinityLabelVmService *affinityLabelVmService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *affinityLabelVmServiceGetRequest) Header(key, value string) *affinityLabelVmServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelVmServiceGetRequest) Query(key, value string) *affinityLabelVmServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelVmServiceGetRequest) Follow(follow string) *affinityLabelVmServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *affinityLabelVmServiceGetRequest) Send() (*affinityLabelVmServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmService.connection.URL(), p.affinityLabelVmService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &affinityLabelVmServiceGetResponse{vm: result}, nil
}

func (p *affinityLabelVmServiceGetRequest) MustSend() *affinityLabelVmServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmService.connection.URL(), p.affinityLabelVmService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelVmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &affinityLabelVmServiceGetResponse{vm: result}
}

//
// Retrieves details about a vm that has this label assigned.
//
type affinityLabelVmServiceGetResponse struct {
	vm *Vm
}

func (p *affinityLabelVmServiceGetResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *affinityLabelVmServiceGetResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Retrieves details about a vm that has this label assigned.
//
func (p *affinityLabelVmService) Get() *affinityLabelVmServiceGetRequest {
	return &affinityLabelVmServiceGetRequest{affinityLabelVmService: p}
}

//
// Remove a label from a vm.
//
type affinityLabelVmServiceRemoveRequest struct {
	affinityLabelVmService *affinityLabelVmService
	header                 map[string]string
	query                  map[string]string
}

func (p *affinityLabelVmServiceRemoveRequest) Header(key, value string) *affinityLabelVmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityLabelVmServiceRemoveRequest) Query(key, value string) *affinityLabelVmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityLabelVmServiceRemoveRequest) Send() (*affinityLabelVmServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmService.connection.URL(), p.affinityLabelVmService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(affinityLabelVmServiceRemoveResponse), nil
}

func (p *affinityLabelVmServiceRemoveRequest) MustSend() *affinityLabelVmServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityLabelVmService.connection.URL(), p.affinityLabelVmService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityLabelVmService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityLabelVmService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(affinityLabelVmServiceRemoveResponse)
}

//
// Remove a label from a vm.
//
type affinityLabelVmServiceRemoveResponse struct {
}

//
// Remove a label from a vm.
//
func (p *affinityLabelVmService) Remove() *affinityLabelVmServiceRemoveRequest {
	return &affinityLabelVmServiceRemoveRequest{affinityLabelVmService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *affinityLabelVmService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *affinityLabelVmService) String() string {
	return fmt.Sprintf("affinityLabelVmService:%s", op.path)
}

//
// Provides information about a specific cluster level. See the <<services/cluster_levels,ClusterLevels>> service for
// more information.
//
type clusterLevelService struct {
	baseService
}

func NewClusterLevelService(connection *Connection, path string) *clusterLevelService {
	var result clusterLevelService
	result.connection = connection
	result.path = path
	return &result
}

//
// Provides the information about the capabilities of the specific cluster level managed by this service.
// For example, to find what CPU types are supported by level 3.6 you can send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/3.6
// ----
// That will return a <<types/cluster_level, ClusterLevel>> object containing the supported CPU types, and other
// information which describes the cluster level:
// [source,xml]
// ----
// <cluster_level id="3.6">
//   <cpu_types>
//     <cpu_type>
//       <name>Intel Conroe Family</name>
//       <level>3</level>
//       <architecture>x86_64</architecture>
//     </cpu_type>
//     ...
//   </cpu_types>
//   <permits>
//     <permit id="1">
//       <name>create_vm</name>
//       <administrative>false</administrative>
//     </permit>
//     ...
//   </permits>
// </cluster_level>
// ----
//
type clusterLevelServiceGetRequest struct {
	clusterLevelService *clusterLevelService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *clusterLevelServiceGetRequest) Header(key, value string) *clusterLevelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterLevelServiceGetRequest) Query(key, value string) *clusterLevelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterLevelServiceGetRequest) Follow(follow string) *clusterLevelServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *clusterLevelServiceGetRequest) Send() (*clusterLevelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterLevelService.connection.URL(), p.clusterLevelService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterLevelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterLevelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterLevelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &clusterLevelServiceGetResponse{level: result}, nil
}

func (p *clusterLevelServiceGetRequest) MustSend() *clusterLevelServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterLevelService.connection.URL(), p.clusterLevelService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterLevelService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterLevelService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterLevelReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &clusterLevelServiceGetResponse{level: result}
}

//
// Provides the information about the capabilities of the specific cluster level managed by this service.
// For example, to find what CPU types are supported by level 3.6 you can send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/3.6
// ----
// That will return a <<types/cluster_level, ClusterLevel>> object containing the supported CPU types, and other
// information which describes the cluster level:
// [source,xml]
// ----
// <cluster_level id="3.6">
//   <cpu_types>
//     <cpu_type>
//       <name>Intel Conroe Family</name>
//       <level>3</level>
//       <architecture>x86_64</architecture>
//     </cpu_type>
//     ...
//   </cpu_types>
//   <permits>
//     <permit id="1">
//       <name>create_vm</name>
//       <administrative>false</administrative>
//     </permit>
//     ...
//   </permits>
// </cluster_level>
// ----
//
type clusterLevelServiceGetResponse struct {
	level *ClusterLevel
}

func (p *clusterLevelServiceGetResponse) Level() (*ClusterLevel, bool) {
	if p.level != nil {
		return p.level, true
	}
	return nil, false
}

func (p *clusterLevelServiceGetResponse) MustLevel() *ClusterLevel {
	if p.level == nil {
		panic("level in response does not exist")
	}
	return p.level
}

//
// Provides the information about the capabilities of the specific cluster level managed by this service.
// For example, to find what CPU types are supported by level 3.6 you can send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/3.6
// ----
// That will return a <<types/cluster_level, ClusterLevel>> object containing the supported CPU types, and other
// information which describes the cluster level:
// [source,xml]
// ----
// <cluster_level id="3.6">
//   <cpu_types>
//     <cpu_type>
//       <name>Intel Conroe Family</name>
//       <level>3</level>
//       <architecture>x86_64</architecture>
//     </cpu_type>
//     ...
//   </cpu_types>
//   <permits>
//     <permit id="1">
//       <name>create_vm</name>
//       <administrative>false</administrative>
//     </permit>
//     ...
//   </permits>
// </cluster_level>
// ----
//
func (p *clusterLevelService) Get() *clusterLevelServiceGetRequest {
	return &clusterLevelServiceGetRequest{clusterLevelService: p}
}

//
// Reference to the service that manages the collection of supported features for this cluster level.
//
func (op *clusterLevelService) ClusterFeaturesService() *clusterFeaturesService {
	return NewClusterFeaturesService(op.connection, fmt.Sprintf("%s/clusterfeatures", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *clusterLevelService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "clusterfeatures" {
		return op.ClusterFeaturesService(), nil
	}
	if strings.HasPrefix(path, "clusterfeatures/") {
		return op.ClusterFeaturesService().Service(path[16:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *clusterLevelService) String() string {
	return fmt.Sprintf("clusterLevelService:%s", op.path)
}

//
//
type instanceTypeNicsService struct {
	baseService
}

func NewInstanceTypeNicsService(connection *Connection, path string) *instanceTypeNicsService {
	var result instanceTypeNicsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add new network interface to the instance type.
//
type instanceTypeNicsServiceAddRequest struct {
	instanceTypeNicsService *instanceTypeNicsService
	header                  map[string]string
	query                   map[string]string
	nic                     *Nic
}

func (p *instanceTypeNicsServiceAddRequest) Header(key, value string) *instanceTypeNicsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeNicsServiceAddRequest) Query(key, value string) *instanceTypeNicsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeNicsServiceAddRequest) Nic(nic *Nic) *instanceTypeNicsServiceAddRequest {
	p.nic = nic
	return p
}

func (p *instanceTypeNicsServiceAddRequest) Send() (*instanceTypeNicsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicsService.connection.URL(), p.instanceTypeNicsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &instanceTypeNicsServiceAddResponse{nic: result}, nil
}

func (p *instanceTypeNicsServiceAddRequest) MustSend() *instanceTypeNicsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicsService.connection.URL(), p.instanceTypeNicsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeNicsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &instanceTypeNicsServiceAddResponse{nic: result}
}

//
// Add new network interface to the instance type.
//
type instanceTypeNicsServiceAddResponse struct {
	nic *Nic
}

func (p *instanceTypeNicsServiceAddResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *instanceTypeNicsServiceAddResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Add new network interface to the instance type.
//
func (p *instanceTypeNicsService) Add() *instanceTypeNicsServiceAddRequest {
	return &instanceTypeNicsServiceAddRequest{instanceTypeNicsService: p}
}

//
// Lists all the configured network interface of the instance type.
// The order of the returned list of network interfaces isn't guaranteed.
//
type instanceTypeNicsServiceListRequest struct {
	instanceTypeNicsService *instanceTypeNicsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
	max                     *int64
	search                  *string
}

func (p *instanceTypeNicsServiceListRequest) Header(key, value string) *instanceTypeNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeNicsServiceListRequest) Query(key, value string) *instanceTypeNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeNicsServiceListRequest) Follow(follow string) *instanceTypeNicsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *instanceTypeNicsServiceListRequest) Max(max int64) *instanceTypeNicsServiceListRequest {
	p.max = &max
	return p
}

func (p *instanceTypeNicsServiceListRequest) Search(search string) *instanceTypeNicsServiceListRequest {
	p.search = &search
	return p
}

func (p *instanceTypeNicsServiceListRequest) Send() (*instanceTypeNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicsService.connection.URL(), p.instanceTypeNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &instanceTypeNicsServiceListResponse{nics: result}, nil
}

func (p *instanceTypeNicsServiceListRequest) MustSend() *instanceTypeNicsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeNicsService.connection.URL(), p.instanceTypeNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeNicsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeNicsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &instanceTypeNicsServiceListResponse{nics: result}
}

//
// Lists all the configured network interface of the instance type.
// The order of the returned list of network interfaces isn't guaranteed.
//
type instanceTypeNicsServiceListResponse struct {
	nics *NicSlice
}

func (p *instanceTypeNicsServiceListResponse) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *instanceTypeNicsServiceListResponse) MustNics() *NicSlice {
	if p.nics == nil {
		panic("nics in response does not exist")
	}
	return p.nics
}

//
// Lists all the configured network interface of the instance type.
// The order of the returned list of network interfaces isn't guaranteed.
//
func (p *instanceTypeNicsService) List() *instanceTypeNicsServiceListRequest {
	return &instanceTypeNicsServiceListRequest{instanceTypeNicsService: p}
}

//
//
func (op *instanceTypeNicsService) NicService(id string) *instanceTypeNicService {
	return NewInstanceTypeNicService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *instanceTypeNicsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NicService(path), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *instanceTypeNicsService) String() string {
	return fmt.Sprintf("instanceTypeNicsService:%s", op.path)
}

//
// A service to manage events in the system.
//
type eventsService struct {
	baseService
}

func NewEventsService(connection *Connection, path string) *eventsService {
	var result eventsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds an external event to the internal audit log.
// This is intended for integration with external systems that detect or produce events relevant for the
// administrator of the system. For example, an external monitoring tool may be able to detect that a file system
// is full inside the guest operating system of a virtual machine. This event can be added to the internal audit
// log sending a request like this:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
// </event>
// ----
// Events can also be linked to specific objects. For example, the above event could be linked to the specific
// virtual machine where it happened, using the `vm` link:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
//   <vm id="aae98225-5b73-490d-a252-899209af17e9"/>
// </event>
// ----
// NOTE: When using links, like the `vm` in the previous example, only the `id` attribute is accepted. The `name`
// attribute, if provided, is simply ignored.
//
type eventsServiceAddRequest struct {
	eventsService *eventsService
	header        map[string]string
	query         map[string]string
	event         *Event
}

func (p *eventsServiceAddRequest) Header(key, value string) *eventsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *eventsServiceAddRequest) Query(key, value string) *eventsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *eventsServiceAddRequest) Event(event *Event) *eventsServiceAddRequest {
	p.event = event
	return p
}

func (p *eventsServiceAddRequest) Send() (*eventsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.eventsService.connection.URL(), p.eventsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLEventWriteOne(writer, p.event, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.eventsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.eventsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLEventReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &eventsServiceAddResponse{event: result}, nil
}

func (p *eventsServiceAddRequest) MustSend() *eventsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.eventsService.connection.URL(), p.eventsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLEventWriteOne(writer, p.event, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.eventsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.eventsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLEventReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &eventsServiceAddResponse{event: result}
}

//
// Adds an external event to the internal audit log.
// This is intended for integration with external systems that detect or produce events relevant for the
// administrator of the system. For example, an external monitoring tool may be able to detect that a file system
// is full inside the guest operating system of a virtual machine. This event can be added to the internal audit
// log sending a request like this:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
// </event>
// ----
// Events can also be linked to specific objects. For example, the above event could be linked to the specific
// virtual machine where it happened, using the `vm` link:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
//   <vm id="aae98225-5b73-490d-a252-899209af17e9"/>
// </event>
// ----
// NOTE: When using links, like the `vm` in the previous example, only the `id` attribute is accepted. The `name`
// attribute, if provided, is simply ignored.
//
type eventsServiceAddResponse struct {
	event *Event
}

func (p *eventsServiceAddResponse) Event() (*Event, bool) {
	if p.event != nil {
		return p.event, true
	}
	return nil, false
}

func (p *eventsServiceAddResponse) MustEvent() *Event {
	if p.event == nil {
		panic("event in response does not exist")
	}
	return p.event
}

//
// Adds an external event to the internal audit log.
// This is intended for integration with external systems that detect or produce events relevant for the
// administrator of the system. For example, an external monitoring tool may be able to detect that a file system
// is full inside the guest operating system of a virtual machine. This event can be added to the internal audit
// log sending a request like this:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
// </event>
// ----
// Events can also be linked to specific objects. For example, the above event could be linked to the specific
// virtual machine where it happened, using the `vm` link:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
//   <vm id="aae98225-5b73-490d-a252-899209af17e9"/>
// </event>
// ----
// NOTE: When using links, like the `vm` in the previous example, only the `id` attribute is accepted. The `name`
// attribute, if provided, is simply ignored.
//
func (p *eventsService) Add() *eventsServiceAddRequest {
	return &eventsServiceAddRequest{eventsService: p}
}

//
// Get list of events.
// [source]
// ----
// GET /ovirt-engine/api/events
// ----
// To the above request we get following response:
// [source,xml]
// ----
// <events>
//   <event href="/ovirt-engine/api/events/2" id="2">
//     <description>User admin@internal-authz logged out.</description>
//     <code>31</code>
//     <correlation_id>1e892ea9</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T12:14:34.541+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
//   <event href="/ovirt-engine/api/events/1" id="1">
//     <description>User admin logged in.</description>
//     <code>30</code>
//     <correlation_id>1fbd81f4</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T11:54:35.229+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
// </events>
// ----
// The following events occur:
// * id="1" - The API logs in the admin user account.
// * id="2" - The API logs out of the admin user account.
// The order of the returned list of events is always garanteed. If the `sortby` clause is included in the
// `search` parameter, then the events will be ordered according to that clause. If the `sortby` clause isn't
// included, then the events will be sorted by the numeric value of the `id` attribute, starting with the
// highest value. This, combined with the `max` parameter, simplifies obtaining the most recent event:
// ....
// GET /ovirt-engine/api/events?max=1
// ....
//
type eventsServiceListRequest struct {
	eventsService *eventsService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	follow        *string
	from          *int64
	max           *int64
	search        *string
}

func (p *eventsServiceListRequest) Header(key, value string) *eventsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *eventsServiceListRequest) Query(key, value string) *eventsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *eventsServiceListRequest) CaseSensitive(caseSensitive bool) *eventsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *eventsServiceListRequest) Follow(follow string) *eventsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *eventsServiceListRequest) From(from int64) *eventsServiceListRequest {
	p.from = &from
	return p
}

func (p *eventsServiceListRequest) Max(max int64) *eventsServiceListRequest {
	p.max = &max
	return p
}

func (p *eventsServiceListRequest) Search(search string) *eventsServiceListRequest {
	p.search = &search
	return p
}

func (p *eventsServiceListRequest) Send() (*eventsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.eventsService.connection.URL(), p.eventsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.from != nil {
		values["from"] = []string{fmt.Sprintf("%v", *p.from)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.eventsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.eventsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLEventReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &eventsServiceListResponse{events: result}, nil
}

func (p *eventsServiceListRequest) MustSend() *eventsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.eventsService.connection.URL(), p.eventsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.from != nil {
		values["from"] = []string{fmt.Sprintf("%v", *p.from)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.eventsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.eventsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLEventReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &eventsServiceListResponse{events: result}
}

//
// Get list of events.
// [source]
// ----
// GET /ovirt-engine/api/events
// ----
// To the above request we get following response:
// [source,xml]
// ----
// <events>
//   <event href="/ovirt-engine/api/events/2" id="2">
//     <description>User admin@internal-authz logged out.</description>
//     <code>31</code>
//     <correlation_id>1e892ea9</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T12:14:34.541+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
//   <event href="/ovirt-engine/api/events/1" id="1">
//     <description>User admin logged in.</description>
//     <code>30</code>
//     <correlation_id>1fbd81f4</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T11:54:35.229+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
// </events>
// ----
// The following events occur:
// * id="1" - The API logs in the admin user account.
// * id="2" - The API logs out of the admin user account.
// The order of the returned list of events is always garanteed. If the `sortby` clause is included in the
// `search` parameter, then the events will be ordered according to that clause. If the `sortby` clause isn't
// included, then the events will be sorted by the numeric value of the `id` attribute, starting with the
// highest value. This, combined with the `max` parameter, simplifies obtaining the most recent event:
// ....
// GET /ovirt-engine/api/events?max=1
// ....
//
type eventsServiceListResponse struct {
	events *EventSlice
}

func (p *eventsServiceListResponse) Events() (*EventSlice, bool) {
	if p.events != nil {
		return p.events, true
	}
	return nil, false
}

func (p *eventsServiceListResponse) MustEvents() *EventSlice {
	if p.events == nil {
		panic("events in response does not exist")
	}
	return p.events
}

//
// Get list of events.
// [source]
// ----
// GET /ovirt-engine/api/events
// ----
// To the above request we get following response:
// [source,xml]
// ----
// <events>
//   <event href="/ovirt-engine/api/events/2" id="2">
//     <description>User admin@internal-authz logged out.</description>
//     <code>31</code>
//     <correlation_id>1e892ea9</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T12:14:34.541+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
//   <event href="/ovirt-engine/api/events/1" id="1">
//     <description>User admin logged in.</description>
//     <code>30</code>
//     <correlation_id>1fbd81f4</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T11:54:35.229+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
// </events>
// ----
// The following events occur:
// * id="1" - The API logs in the admin user account.
// * id="2" - The API logs out of the admin user account.
// The order of the returned list of events is always garanteed. If the `sortby` clause is included in the
// `search` parameter, then the events will be ordered according to that clause. If the `sortby` clause isn't
// included, then the events will be sorted by the numeric value of the `id` attribute, starting with the
// highest value. This, combined with the `max` parameter, simplifies obtaining the most recent event:
// ....
// GET /ovirt-engine/api/events?max=1
// ....
//
func (p *eventsService) List() *eventsServiceListRequest {
	return &eventsServiceListRequest{eventsService: p}
}

//
//
type eventsServiceUndeleteRequest struct {
	eventsService *eventsService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *eventsServiceUndeleteRequest) Header(key, value string) *eventsServiceUndeleteRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *eventsServiceUndeleteRequest) Query(key, value string) *eventsServiceUndeleteRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *eventsServiceUndeleteRequest) Async(async bool) *eventsServiceUndeleteRequest {
	p.async = &async
	return p
}

func (p *eventsServiceUndeleteRequest) Send() (*eventsServiceUndeleteResponse, error) {
	rawURL := fmt.Sprintf("%s%s/undelete", p.eventsService.connection.URL(), p.eventsService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.eventsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.eventsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(eventsServiceUndeleteResponse), nil
}

func (p *eventsServiceUndeleteRequest) MustSend() *eventsServiceUndeleteResponse {
	rawURL := fmt.Sprintf("%s%s/undelete", p.eventsService.connection.URL(), p.eventsService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.eventsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.eventsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(eventsServiceUndeleteResponse)
}

//
//
type eventsServiceUndeleteResponse struct {
}

//
//
func (p *eventsService) Undelete() *eventsServiceUndeleteRequest {
	return &eventsServiceUndeleteRequest{eventsService: p}
}

//
// Reference to the service that manages a specific event.
//
func (op *eventsService) EventService(id string) *eventService {
	return NewEventService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *eventsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.EventService(path), nil
	}
	return op.EventService(path[:index]).Service(path[index+1:])
}

func (op *eventsService) String() string {
	return fmt.Sprintf("eventsService:%s", op.path)
}

//
// Manages logical networks.
// The engine creates a default `ovirtmgmt` network on installation. This network acts as the management network for
// access to hypervisor hosts. This network is associated with the `Default` cluster and is a member of the `Default`
// data center.
//
type networksService struct {
	baseService
}

func NewNetworksService(connection *Connection, path string) *networksService {
	var result networksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new logical network, or associates an existing network with a data center.
// Creation of a new network requires the `name` and `data_center` elements.
// For example, to create a network named `mynetwork` for data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
//   <data_center id="123"/>
// </network>
// ----
// To associate the existing network `456` with the data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>ovirtmgmt</name>
// </network>
// ----
// To create a network named `exnetwork` on top of an external _OpenStack_ network provider `456` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// [source,xml]
// ----
// <network>
//   <name>exnetwork</name>
//   <external_provider id="456"/>
//   <data_center id="123"/>
// </network>
// ----
//
type networksServiceAddRequest struct {
	networksService *networksService
	header          map[string]string
	query           map[string]string
	network         *Network
}

func (p *networksServiceAddRequest) Header(key, value string) *networksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networksServiceAddRequest) Query(key, value string) *networksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networksServiceAddRequest) Network(network *Network) *networksServiceAddRequest {
	p.network = network
	return p
}

func (p *networksServiceAddRequest) Send() (*networksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networksService.connection.URL(), p.networksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &networksServiceAddResponse{network: result}, nil
}

func (p *networksServiceAddRequest) MustSend() *networksServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.networksService.connection.URL(), p.networksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &networksServiceAddResponse{network: result}
}

//
// Creates a new logical network, or associates an existing network with a data center.
// Creation of a new network requires the `name` and `data_center` elements.
// For example, to create a network named `mynetwork` for data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
//   <data_center id="123"/>
// </network>
// ----
// To associate the existing network `456` with the data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>ovirtmgmt</name>
// </network>
// ----
// To create a network named `exnetwork` on top of an external _OpenStack_ network provider `456` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// [source,xml]
// ----
// <network>
//   <name>exnetwork</name>
//   <external_provider id="456"/>
//   <data_center id="123"/>
// </network>
// ----
//
type networksServiceAddResponse struct {
	network *Network
}

func (p *networksServiceAddResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *networksServiceAddResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Creates a new logical network, or associates an existing network with a data center.
// Creation of a new network requires the `name` and `data_center` elements.
// For example, to create a network named `mynetwork` for data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
//   <data_center id="123"/>
// </network>
// ----
// To associate the existing network `456` with the data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>ovirtmgmt</name>
// </network>
// ----
// To create a network named `exnetwork` on top of an external _OpenStack_ network provider `456` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// [source,xml]
// ----
// <network>
//   <name>exnetwork</name>
//   <external_provider id="456"/>
//   <data_center id="123"/>
// </network>
// ----
//
func (p *networksService) Add() *networksServiceAddRequest {
	return &networksServiceAddRequest{networksService: p}
}

//
// List logical networks.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks
// ----
// Will respond:
// [source,xml]
// ----
// <networks>
//   <network href="/ovirt-engine/api/networks/123" id="123">
//     <name>ovirtmgmt</name>
//     <description>Default Management Network</description>
//     <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//     <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//     <mtu>0</mtu>
//     <stp>false</stp>
//     <usages>
//       <usage>vm</usage>
//     </usages>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </network>
//   ...
// </networks>
// ----
// The order of the returned list of networks is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type networksServiceListRequest struct {
	networksService *networksService
	header          map[string]string
	query           map[string]string
	caseSensitive   *bool
	follow          *string
	max             *int64
	search          *string
}

func (p *networksServiceListRequest) Header(key, value string) *networksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *networksServiceListRequest) Query(key, value string) *networksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *networksServiceListRequest) CaseSensitive(caseSensitive bool) *networksServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *networksServiceListRequest) Follow(follow string) *networksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *networksServiceListRequest) Max(max int64) *networksServiceListRequest {
	p.max = &max
	return p
}

func (p *networksServiceListRequest) Search(search string) *networksServiceListRequest {
	p.search = &search
	return p
}

func (p *networksServiceListRequest) Send() (*networksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.networksService.connection.URL(), p.networksService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &networksServiceListResponse{networks: result}, nil
}

func (p *networksServiceListRequest) MustSend() *networksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.networksService.connection.URL(), p.networksService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.networksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.networksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &networksServiceListResponse{networks: result}
}

//
// List logical networks.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks
// ----
// Will respond:
// [source,xml]
// ----
// <networks>
//   <network href="/ovirt-engine/api/networks/123" id="123">
//     <name>ovirtmgmt</name>
//     <description>Default Management Network</description>
//     <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//     <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//     <mtu>0</mtu>
//     <stp>false</stp>
//     <usages>
//       <usage>vm</usage>
//     </usages>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </network>
//   ...
// </networks>
// ----
// The order of the returned list of networks is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type networksServiceListResponse struct {
	networks *NetworkSlice
}

func (p *networksServiceListResponse) Networks() (*NetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *networksServiceListResponse) MustNetworks() *NetworkSlice {
	if p.networks == nil {
		panic("networks in response does not exist")
	}
	return p.networks
}

//
// List logical networks.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks
// ----
// Will respond:
// [source,xml]
// ----
// <networks>
//   <network href="/ovirt-engine/api/networks/123" id="123">
//     <name>ovirtmgmt</name>
//     <description>Default Management Network</description>
//     <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//     <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//     <mtu>0</mtu>
//     <stp>false</stp>
//     <usages>
//       <usage>vm</usage>
//     </usages>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </network>
//   ...
// </networks>
// ----
// The order of the returned list of networks is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
func (p *networksService) List() *networksServiceListRequest {
	return &networksServiceListRequest{networksService: p}
}

//
// Reference to the service that manages a specific network.
//
func (op *networksService) NetworkService(id string) *networkService {
	return NewNetworkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *networksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NetworkService(path), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *networksService) String() string {
	return fmt.Sprintf("networksService:%s", op.path)
}

//
// A service to manage a job.
//
type jobService struct {
	baseService
}

func NewJobService(connection *Connection, path string) *jobService {
	var result jobService
	result.connection = connection
	result.path = path
	return &result
}

//
// Set an external job execution to be cleared by the system.
// For example, to set a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/clear
// ----
// With the following request body:
// [source,xml]
// ----
// <action/>
// ----
//
type jobServiceClearRequest struct {
	jobService *jobService
	header     map[string]string
	query      map[string]string
	async      *bool
}

func (p *jobServiceClearRequest) Header(key, value string) *jobServiceClearRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *jobServiceClearRequest) Query(key, value string) *jobServiceClearRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *jobServiceClearRequest) Async(async bool) *jobServiceClearRequest {
	p.async = &async
	return p
}

func (p *jobServiceClearRequest) Send() (*jobServiceClearResponse, error) {
	rawURL := fmt.Sprintf("%s%s/clear", p.jobService.connection.URL(), p.jobService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.jobService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.jobService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(jobServiceClearResponse), nil
}

func (p *jobServiceClearRequest) MustSend() *jobServiceClearResponse {
	rawURL := fmt.Sprintf("%s%s/clear", p.jobService.connection.URL(), p.jobService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.jobService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.jobService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(jobServiceClearResponse)
}

//
// Set an external job execution to be cleared by the system.
// For example, to set a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/clear
// ----
// With the following request body:
// [source,xml]
// ----
// <action/>
// ----
//
type jobServiceClearResponse struct {
}

//
// Set an external job execution to be cleared by the system.
// For example, to set a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/clear
// ----
// With the following request body:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *jobService) Clear() *jobServiceClearRequest {
	return &jobServiceClearRequest{jobService: p}
}

//
// Marks an external job execution as ended.
// For example, to terminate a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <status>finished</status>
// </action>
// ----
//
type jobServiceEndRequest struct {
	jobService *jobService
	header     map[string]string
	query      map[string]string
	async      *bool
	force      *bool
	succeeded  *bool
}

func (p *jobServiceEndRequest) Header(key, value string) *jobServiceEndRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *jobServiceEndRequest) Query(key, value string) *jobServiceEndRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *jobServiceEndRequest) Async(async bool) *jobServiceEndRequest {
	p.async = &async
	return p
}

func (p *jobServiceEndRequest) Force(force bool) *jobServiceEndRequest {
	p.force = &force
	return p
}

func (p *jobServiceEndRequest) Succeeded(succeeded bool) *jobServiceEndRequest {
	p.succeeded = &succeeded
	return p
}

func (p *jobServiceEndRequest) Send() (*jobServiceEndResponse, error) {
	rawURL := fmt.Sprintf("%s%s/end", p.jobService.connection.URL(), p.jobService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	if p.succeeded != nil {
		actionBuilder.Succeeded(*p.succeeded)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.jobService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.jobService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(jobServiceEndResponse), nil
}

func (p *jobServiceEndRequest) MustSend() *jobServiceEndResponse {
	rawURL := fmt.Sprintf("%s%s/end", p.jobService.connection.URL(), p.jobService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	if p.succeeded != nil {
		actionBuilder.Succeeded(*p.succeeded)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.jobService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.jobService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(jobServiceEndResponse)
}

//
// Marks an external job execution as ended.
// For example, to terminate a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <status>finished</status>
// </action>
// ----
//
type jobServiceEndResponse struct {
}

//
// Marks an external job execution as ended.
// For example, to terminate a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <status>finished</status>
// </action>
// ----
//
func (p *jobService) End() *jobServiceEndRequest {
	return &jobServiceEndRequest{jobService: p}
}

//
// Retrieves a job.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Adding Disk</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//   <external>false</external>
//   <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//   <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//   <status>failed</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
type jobServiceGetRequest struct {
	jobService *jobService
	header     map[string]string
	query      map[string]string
	follow     *string
}

func (p *jobServiceGetRequest) Header(key, value string) *jobServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *jobServiceGetRequest) Query(key, value string) *jobServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *jobServiceGetRequest) Follow(follow string) *jobServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *jobServiceGetRequest) Send() (*jobServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.jobService.connection.URL(), p.jobService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.jobService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.jobService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLJobReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &jobServiceGetResponse{job: result}, nil
}

func (p *jobServiceGetRequest) MustSend() *jobServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.jobService.connection.URL(), p.jobService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.jobService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.jobService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLJobReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &jobServiceGetResponse{job: result}
}

//
// Retrieves a job.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Adding Disk</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//   <external>false</external>
//   <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//   <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//   <status>failed</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
type jobServiceGetResponse struct {
	job *Job
}

func (p *jobServiceGetResponse) Job() (*Job, bool) {
	if p.job != nil {
		return p.job, true
	}
	return nil, false
}

func (p *jobServiceGetResponse) MustJob() *Job {
	if p.job == nil {
		panic("job in response does not exist")
	}
	return p.job
}

//
// Retrieves a job.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Adding Disk</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//   <external>false</external>
//   <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//   <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//   <status>failed</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
func (p *jobService) Get() *jobServiceGetRequest {
	return &jobServiceGetRequest{jobService: p}
}

//
// List all the steps of the job.
// The order of the returned list of steps isn't guaranteed.
//
func (op *jobService) StepsService() *stepsService {
	return NewStepsService(op.connection, fmt.Sprintf("%s/steps", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *jobService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "steps" {
		return op.StepsService(), nil
	}
	if strings.HasPrefix(path, "steps/") {
		return op.StepsService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *jobService) String() string {
	return fmt.Sprintf("jobService:%s", op.path)
}

//
// A service that provides values of specific configuration option of the system.
//
type systemOptionService struct {
	baseService
}

func NewSystemOptionService(connection *Connection, path string) *systemOptionService {
	var result systemOptionService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get the values of specific configuration option.
// For example to retrieve the values of configuration option `MigrationPoliciesSupported` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/options/MigrationPoliciesSupported
// ----
// The response to that request will be the following:
// [source,xml]
// ----
// <system_option href="/ovirt-engine/api/options/MigrationPoliciesSupported" id="MigrationPoliciesSupported">
//   <name>MigrationPoliciesSupported</name>
//   <values>
//     <system_option_value>
//       <value>true</value>
//       <version>4.0</version>
//     </system_option_value>
//     <system_option_value>
//       <value>true</value>
//       <version>4.1</version>
//     </system_option_value>
//     <system_option_value>
//       <value>true</value>
//       <version>4.2</version>
//     </system_option_value>
//     <system_option_value>
//       <value>false</value>
//       <version>3.6</version>
//     </system_option_value>
//   </values>
// </system_option>
// ----
// NOTE: The appropriate permissions are required to query configuration options. Some options can be queried
// only by users with administrator permissions.
// [IMPORTANT]
// ====
// There is NO backward compatibility and no guarantee about the names or values of the options. Options may be
// removed and their meaning can be changed at any point.
// We strongly discourage the use of this service for applications other than the ones that are released
// simultaneously with the engine. Usage by other applications is not supported. Therefore there will be no
// documentation listing accessible configuration options.
// ====
//
type systemOptionServiceGetRequest struct {
	systemOptionService *systemOptionService
	header              map[string]string
	query               map[string]string
	version             *string
}

func (p *systemOptionServiceGetRequest) Header(key, value string) *systemOptionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *systemOptionServiceGetRequest) Query(key, value string) *systemOptionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *systemOptionServiceGetRequest) Version(version string) *systemOptionServiceGetRequest {
	p.version = &version
	return p
}

func (p *systemOptionServiceGetRequest) Send() (*systemOptionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.systemOptionService.connection.URL(), p.systemOptionService.path)
	values := make(url.Values)
	if p.version != nil {
		values["version"] = []string{fmt.Sprintf("%v", *p.version)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemOptionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemOptionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSystemOptionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &systemOptionServiceGetResponse{option: result}, nil
}

func (p *systemOptionServiceGetRequest) MustSend() *systemOptionServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.systemOptionService.connection.URL(), p.systemOptionService.path)
	values := make(url.Values)
	if p.version != nil {
		values["version"] = []string{fmt.Sprintf("%v", *p.version)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.systemOptionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.systemOptionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSystemOptionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &systemOptionServiceGetResponse{option: result}
}

//
// Get the values of specific configuration option.
// For example to retrieve the values of configuration option `MigrationPoliciesSupported` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/options/MigrationPoliciesSupported
// ----
// The response to that request will be the following:
// [source,xml]
// ----
// <system_option href="/ovirt-engine/api/options/MigrationPoliciesSupported" id="MigrationPoliciesSupported">
//   <name>MigrationPoliciesSupported</name>
//   <values>
//     <system_option_value>
//       <value>true</value>
//       <version>4.0</version>
//     </system_option_value>
//     <system_option_value>
//       <value>true</value>
//       <version>4.1</version>
//     </system_option_value>
//     <system_option_value>
//       <value>true</value>
//       <version>4.2</version>
//     </system_option_value>
//     <system_option_value>
//       <value>false</value>
//       <version>3.6</version>
//     </system_option_value>
//   </values>
// </system_option>
// ----
// NOTE: The appropriate permissions are required to query configuration options. Some options can be queried
// only by users with administrator permissions.
// [IMPORTANT]
// ====
// There is NO backward compatibility and no guarantee about the names or values of the options. Options may be
// removed and their meaning can be changed at any point.
// We strongly discourage the use of this service for applications other than the ones that are released
// simultaneously with the engine. Usage by other applications is not supported. Therefore there will be no
// documentation listing accessible configuration options.
// ====
//
type systemOptionServiceGetResponse struct {
	option *SystemOption
}

func (p *systemOptionServiceGetResponse) Option() (*SystemOption, bool) {
	if p.option != nil {
		return p.option, true
	}
	return nil, false
}

func (p *systemOptionServiceGetResponse) MustOption() *SystemOption {
	if p.option == nil {
		panic("option in response does not exist")
	}
	return p.option
}

//
// Get the values of specific configuration option.
// For example to retrieve the values of configuration option `MigrationPoliciesSupported` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/options/MigrationPoliciesSupported
// ----
// The response to that request will be the following:
// [source,xml]
// ----
// <system_option href="/ovirt-engine/api/options/MigrationPoliciesSupported" id="MigrationPoliciesSupported">
//   <name>MigrationPoliciesSupported</name>
//   <values>
//     <system_option_value>
//       <value>true</value>
//       <version>4.0</version>
//     </system_option_value>
//     <system_option_value>
//       <value>true</value>
//       <version>4.1</version>
//     </system_option_value>
//     <system_option_value>
//       <value>true</value>
//       <version>4.2</version>
//     </system_option_value>
//     <system_option_value>
//       <value>false</value>
//       <version>3.6</version>
//     </system_option_value>
//   </values>
// </system_option>
// ----
// NOTE: The appropriate permissions are required to query configuration options. Some options can be queried
// only by users with administrator permissions.
// [IMPORTANT]
// ====
// There is NO backward compatibility and no guarantee about the names or values of the options. Options may be
// removed and their meaning can be changed at any point.
// We strongly discourage the use of this service for applications other than the ones that are released
// simultaneously with the engine. Usage by other applications is not supported. Therefore there will be no
// documentation listing accessible configuration options.
// ====
//
func (p *systemOptionService) Get() *systemOptionServiceGetRequest {
	return &systemOptionServiceGetRequest{systemOptionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *systemOptionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *systemOptionService) String() string {
	return fmt.Sprintf("systemOptionService:%s", op.path)
}

//
//
type storageDomainService struct {
	baseService
}

func NewStorageDomainService(connection *Connection, path string) *storageDomainService {
	var result storageDomainService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type storageDomainServiceGetRequest struct {
	storageDomainService *storageDomainService
	header               map[string]string
	query                map[string]string
	filter               *bool
	follow               *string
}

func (p *storageDomainServiceGetRequest) Header(key, value string) *storageDomainServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainServiceGetRequest) Query(key, value string) *storageDomainServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainServiceGetRequest) Filter(filter bool) *storageDomainServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *storageDomainServiceGetRequest) Follow(follow string) *storageDomainServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainServiceGetRequest) Send() (*storageDomainServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageDomainServiceGetResponse{storageDomain: result}, nil
}

func (p *storageDomainServiceGetRequest) MustSend() *storageDomainServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageDomainServiceGetResponse{storageDomain: result}
}

//
//
type storageDomainServiceGetResponse struct {
	storageDomain *StorageDomain
}

func (p *storageDomainServiceGetResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *storageDomainServiceGetResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
//
func (p *storageDomainService) Get() *storageDomainServiceGetRequest {
	return &storageDomainServiceGetRequest{storageDomainService: p}
}

//
// Used for querying if the storage domain is already attached to a data center using
// the is_attached boolean field, which is part of the storage server. IMPORTANT:
// Executing this API will cause the host to disconnect from the storage domain.
//
type storageDomainServiceIsAttachedRequest struct {
	storageDomainService *storageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	host                 *Host
}

func (p *storageDomainServiceIsAttachedRequest) Header(key, value string) *storageDomainServiceIsAttachedRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainServiceIsAttachedRequest) Query(key, value string) *storageDomainServiceIsAttachedRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainServiceIsAttachedRequest) Async(async bool) *storageDomainServiceIsAttachedRequest {
	p.async = &async
	return p
}

func (p *storageDomainServiceIsAttachedRequest) Host(host *Host) *storageDomainServiceIsAttachedRequest {
	p.host = host
	return p
}

func (p *storageDomainServiceIsAttachedRequest) Send() (*storageDomainServiceIsAttachedResponse, error) {
	rawURL := fmt.Sprintf("%s%s/isattached", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustIsAttached()
	return &storageDomainServiceIsAttachedResponse{isAttached: &result}, nil
}

func (p *storageDomainServiceIsAttachedRequest) MustSend() *storageDomainServiceIsAttachedResponse {
	rawURL := fmt.Sprintf("%s%s/isattached", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustIsAttached()
	return &storageDomainServiceIsAttachedResponse{isAttached: &result}
}

//
// Used for querying if the storage domain is already attached to a data center using
// the is_attached boolean field, which is part of the storage server. IMPORTANT:
// Executing this API will cause the host to disconnect from the storage domain.
//
type storageDomainServiceIsAttachedResponse struct {
	isAttached *bool
}

func (p *storageDomainServiceIsAttachedResponse) IsAttached() (bool, bool) {
	if p.isAttached != nil {
		return *p.isAttached, true
	}
	var zero bool
	return zero, false
}

func (p *storageDomainServiceIsAttachedResponse) MustIsAttached() bool {
	if p.isAttached == nil {
		panic("isAttached in response does not exist")
	}
	return *p.isAttached
}

//
// Used for querying if the storage domain is already attached to a data center using
// the is_attached boolean field, which is part of the storage server. IMPORTANT:
// Executing this API will cause the host to disconnect from the storage domain.
//
func (p *storageDomainService) IsAttached() *storageDomainServiceIsAttachedRequest {
	return &storageDomainServiceIsAttachedRequest{storageDomainService: p}
}

//
// This operation reduces logical units from the storage domain.
// In order to do so the data stored on the provided logical units will be moved to other logical units of the
// storage domain and only then they will be reduced from the storage domain.
// For example, in order to reduce two logical units from a storage domain send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains/123/reduceluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
//  Note that this operation is only applicable to block storage domains (i.e., storage domains with the
//  <<types/storage_type, storage type> of iSCSI or FCP).
//
type storageDomainServiceReduceLunsRequest struct {
	storageDomainService *storageDomainService
	header               map[string]string
	query                map[string]string
	logicalUnits         *LogicalUnitSlice
}

func (p *storageDomainServiceReduceLunsRequest) Header(key, value string) *storageDomainServiceReduceLunsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainServiceReduceLunsRequest) Query(key, value string) *storageDomainServiceReduceLunsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainServiceReduceLunsRequest) LogicalUnits(logicalUnits *LogicalUnitSlice) *storageDomainServiceReduceLunsRequest {
	p.logicalUnits = logicalUnits
	return p
}

func (p *storageDomainServiceReduceLunsRequest) LogicalUnitsOfAny(anys ...*LogicalUnit) *storageDomainServiceReduceLunsRequest {
	if p.logicalUnits == nil {
		p.logicalUnits = new(LogicalUnitSlice)
	}
	p.logicalUnits.slice = append(p.logicalUnits.slice, anys...)
	return p
}

func (p *storageDomainServiceReduceLunsRequest) Send() (*storageDomainServiceReduceLunsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reduceluns", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.LogicalUnits(p.logicalUnits)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(storageDomainServiceReduceLunsResponse), nil
}

func (p *storageDomainServiceReduceLunsRequest) MustSend() *storageDomainServiceReduceLunsResponse {
	rawURL := fmt.Sprintf("%s%s/reduceluns", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.LogicalUnits(p.logicalUnits)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(storageDomainServiceReduceLunsResponse)
}

//
// This operation reduces logical units from the storage domain.
// In order to do so the data stored on the provided logical units will be moved to other logical units of the
// storage domain and only then they will be reduced from the storage domain.
// For example, in order to reduce two logical units from a storage domain send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains/123/reduceluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
//  Note that this operation is only applicable to block storage domains (i.e., storage domains with the
//  <<types/storage_type, storage type> of iSCSI or FCP).
//
type storageDomainServiceReduceLunsResponse struct {
}

//
// This operation reduces logical units from the storage domain.
// In order to do so the data stored on the provided logical units will be moved to other logical units of the
// storage domain and only then they will be reduced from the storage domain.
// For example, in order to reduce two logical units from a storage domain send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains/123/reduceluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
//  Note that this operation is only applicable to block storage domains (i.e., storage domains with the
//  <<types/storage_type, storage type> of iSCSI or FCP).
//
func (p *storageDomainService) ReduceLuns() *storageDomainServiceReduceLunsRequest {
	return &storageDomainServiceReduceLunsRequest{storageDomainService: p}
}

//
// This operation refreshes the LUN size.
// After increasing the size of the underlying LUN on the storage server,
// the user can refresh the LUN size.
// This action forces a rescan of the provided LUNs and
// updates the database with the new size, if required.
// For example, in order to refresh the size of two LUNs send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains/262b056b-aede-40f1-9666-b883eff59d40/refreshluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
//
type storageDomainServiceRefreshLunsRequest struct {
	storageDomainService *storageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	logicalUnits         *LogicalUnitSlice
}

func (p *storageDomainServiceRefreshLunsRequest) Header(key, value string) *storageDomainServiceRefreshLunsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainServiceRefreshLunsRequest) Query(key, value string) *storageDomainServiceRefreshLunsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainServiceRefreshLunsRequest) Async(async bool) *storageDomainServiceRefreshLunsRequest {
	p.async = &async
	return p
}

func (p *storageDomainServiceRefreshLunsRequest) LogicalUnits(logicalUnits *LogicalUnitSlice) *storageDomainServiceRefreshLunsRequest {
	p.logicalUnits = logicalUnits
	return p
}

func (p *storageDomainServiceRefreshLunsRequest) LogicalUnitsOfAny(anys ...*LogicalUnit) *storageDomainServiceRefreshLunsRequest {
	if p.logicalUnits == nil {
		p.logicalUnits = new(LogicalUnitSlice)
	}
	p.logicalUnits.slice = append(p.logicalUnits.slice, anys...)
	return p
}

func (p *storageDomainServiceRefreshLunsRequest) Send() (*storageDomainServiceRefreshLunsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/refreshluns", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.LogicalUnits(p.logicalUnits)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(storageDomainServiceRefreshLunsResponse), nil
}

func (p *storageDomainServiceRefreshLunsRequest) MustSend() *storageDomainServiceRefreshLunsResponse {
	rawURL := fmt.Sprintf("%s%s/refreshluns", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.LogicalUnits(p.logicalUnits)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(storageDomainServiceRefreshLunsResponse)
}

//
// This operation refreshes the LUN size.
// After increasing the size of the underlying LUN on the storage server,
// the user can refresh the LUN size.
// This action forces a rescan of the provided LUNs and
// updates the database with the new size, if required.
// For example, in order to refresh the size of two LUNs send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains/262b056b-aede-40f1-9666-b883eff59d40/refreshluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
//
type storageDomainServiceRefreshLunsResponse struct {
}

//
// This operation refreshes the LUN size.
// After increasing the size of the underlying LUN on the storage server,
// the user can refresh the LUN size.
// This action forces a rescan of the provided LUNs and
// updates the database with the new size, if required.
// For example, in order to refresh the size of two LUNs send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains/262b056b-aede-40f1-9666-b883eff59d40/refreshluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
//
func (p *storageDomainService) RefreshLuns() *storageDomainServiceRefreshLunsRequest {
	return &storageDomainServiceRefreshLunsRequest{storageDomainService: p}
}

//
// Removes the storage domain.
// Without any special parameters, the storage domain is detached from the system and removed from the database. The
// storage domain can then be imported to the same or to a different setup, with all the data on it. If the storage is
// not accessible the operation will fail.
// If the `destroy` parameter is `true` then the operation will always succeed, even if the storage is not
// accessible, the failure is just ignored and the storage domain is removed from the database anyway.
// If the `format` parameter is `true` then the actual storage is formatted, and the metadata is removed from the
// LUN or directory, so it can no longer be imported to the same or to a different setup.
//
type storageDomainServiceRemoveRequest struct {
	storageDomainService *storageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	destroy              *bool
	format               *bool
	host                 *string
}

func (p *storageDomainServiceRemoveRequest) Header(key, value string) *storageDomainServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainServiceRemoveRequest) Query(key, value string) *storageDomainServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainServiceRemoveRequest) Async(async bool) *storageDomainServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *storageDomainServiceRemoveRequest) Destroy(destroy bool) *storageDomainServiceRemoveRequest {
	p.destroy = &destroy
	return p
}

func (p *storageDomainServiceRemoveRequest) Format(format bool) *storageDomainServiceRemoveRequest {
	p.format = &format
	return p
}

func (p *storageDomainServiceRemoveRequest) Host(host string) *storageDomainServiceRemoveRequest {
	p.host = &host
	return p
}

func (p *storageDomainServiceRemoveRequest) Send() (*storageDomainServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.destroy != nil {
		values["destroy"] = []string{fmt.Sprintf("%v", *p.destroy)}
	}

	if p.format != nil {
		values["format"] = []string{fmt.Sprintf("%v", *p.format)}
	}

	if p.host != nil {
		values["host"] = []string{fmt.Sprintf("%v", *p.host)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(storageDomainServiceRemoveResponse), nil
}

func (p *storageDomainServiceRemoveRequest) MustSend() *storageDomainServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.destroy != nil {
		values["destroy"] = []string{fmt.Sprintf("%v", *p.destroy)}
	}

	if p.format != nil {
		values["format"] = []string{fmt.Sprintf("%v", *p.format)}
	}

	if p.host != nil {
		values["host"] = []string{fmt.Sprintf("%v", *p.host)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(storageDomainServiceRemoveResponse)
}

//
// Removes the storage domain.
// Without any special parameters, the storage domain is detached from the system and removed from the database. The
// storage domain can then be imported to the same or to a different setup, with all the data on it. If the storage is
// not accessible the operation will fail.
// If the `destroy` parameter is `true` then the operation will always succeed, even if the storage is not
// accessible, the failure is just ignored and the storage domain is removed from the database anyway.
// If the `format` parameter is `true` then the actual storage is formatted, and the metadata is removed from the
// LUN or directory, so it can no longer be imported to the same or to a different setup.
//
type storageDomainServiceRemoveResponse struct {
}

//
// Removes the storage domain.
// Without any special parameters, the storage domain is detached from the system and removed from the database. The
// storage domain can then be imported to the same or to a different setup, with all the data on it. If the storage is
// not accessible the operation will fail.
// If the `destroy` parameter is `true` then the operation will always succeed, even if the storage is not
// accessible, the failure is just ignored and the storage domain is removed from the database anyway.
// If the `format` parameter is `true` then the actual storage is formatted, and the metadata is removed from the
// LUN or directory, so it can no longer be imported to the same or to a different setup.
//
func (p *storageDomainService) Remove() *storageDomainServiceRemoveRequest {
	return &storageDomainServiceRemoveRequest{storageDomainService: p}
}

//
// Updates a storage domain.
// Not all of the <<types/storage_domain,StorageDomain>>'s attributes are updatable after creation. Those that can be
// updated are: `name`, `description`, `comment`, `warning_low_space_indicator`, `critical_space_action_blocker` and
// `wipe_after_delete.` (Note that changing the `wipe_after_delete` attribute will not change the wipe after delete
// property of disks that already exist).
// To update the `name` and `wipe_after_delete` attributes of a storage domain with an identifier `123`, send a
// request as follows:
// [source]
// ----
// PUT /ovirt-engine/api/storageDomains/123
// ----
// With a request body as follows:
// [source,xml]
// ----
// <storage_domain>
//   <name>data2</name>
//   <wipe_after_delete>true</wipe_after_delete>
// </storage_domain>
// ----
//
type storageDomainServiceUpdateRequest struct {
	storageDomainService *storageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	storageDomain        *StorageDomain
}

func (p *storageDomainServiceUpdateRequest) Header(key, value string) *storageDomainServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainServiceUpdateRequest) Query(key, value string) *storageDomainServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainServiceUpdateRequest) Async(async bool) *storageDomainServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *storageDomainServiceUpdateRequest) StorageDomain(storageDomain *StorageDomain) *storageDomainServiceUpdateRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *storageDomainServiceUpdateRequest) Send() (*storageDomainServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageDomainWriteOne(writer, p.storageDomain, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageDomainServiceUpdateResponse{storageDomain: result}, nil
}

func (p *storageDomainServiceUpdateRequest) MustSend() *storageDomainServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageDomainWriteOne(writer, p.storageDomain, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageDomainServiceUpdateResponse{storageDomain: result}
}

//
// Updates a storage domain.
// Not all of the <<types/storage_domain,StorageDomain>>'s attributes are updatable after creation. Those that can be
// updated are: `name`, `description`, `comment`, `warning_low_space_indicator`, `critical_space_action_blocker` and
// `wipe_after_delete.` (Note that changing the `wipe_after_delete` attribute will not change the wipe after delete
// property of disks that already exist).
// To update the `name` and `wipe_after_delete` attributes of a storage domain with an identifier `123`, send a
// request as follows:
// [source]
// ----
// PUT /ovirt-engine/api/storageDomains/123
// ----
// With a request body as follows:
// [source,xml]
// ----
// <storage_domain>
//   <name>data2</name>
//   <wipe_after_delete>true</wipe_after_delete>
// </storage_domain>
// ----
//
type storageDomainServiceUpdateResponse struct {
	storageDomain *StorageDomain
}

func (p *storageDomainServiceUpdateResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *storageDomainServiceUpdateResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Updates a storage domain.
// Not all of the <<types/storage_domain,StorageDomain>>'s attributes are updatable after creation. Those that can be
// updated are: `name`, `description`, `comment`, `warning_low_space_indicator`, `critical_space_action_blocker` and
// `wipe_after_delete.` (Note that changing the `wipe_after_delete` attribute will not change the wipe after delete
// property of disks that already exist).
// To update the `name` and `wipe_after_delete` attributes of a storage domain with an identifier `123`, send a
// request as follows:
// [source]
// ----
// PUT /ovirt-engine/api/storageDomains/123
// ----
// With a request body as follows:
// [source,xml]
// ----
// <storage_domain>
//   <name>data2</name>
//   <wipe_after_delete>true</wipe_after_delete>
// </storage_domain>
// ----
//
func (p *storageDomainService) Update() *storageDomainServiceUpdateRequest {
	return &storageDomainServiceUpdateRequest{storageDomainService: p}
}

//
// This operation forces the update of the `OVF_STORE`
// of this storage domain.
// The `OVF_STORE` is a disk image that contains the metadata
// of virtual machines and disks that reside in the
// storage domain. This metadata is used in case the
// domain is imported or exported to or from a different
// data center or a different installation.
// By default the `OVF_STORE` is updated periodically
// (set by default to 60 minutes) but users might want to force an
// update after an important change, or when the they believe the
// `OVF_STORE` is corrupt.
// When initiated by the user, `OVF_STORE` update will be performed whether
// an update is needed or not.
//
type storageDomainServiceUpdateOvfStoreRequest struct {
	storageDomainService *storageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *storageDomainServiceUpdateOvfStoreRequest) Header(key, value string) *storageDomainServiceUpdateOvfStoreRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainServiceUpdateOvfStoreRequest) Query(key, value string) *storageDomainServiceUpdateOvfStoreRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainServiceUpdateOvfStoreRequest) Async(async bool) *storageDomainServiceUpdateOvfStoreRequest {
	p.async = &async
	return p
}

func (p *storageDomainServiceUpdateOvfStoreRequest) Send() (*storageDomainServiceUpdateOvfStoreResponse, error) {
	rawURL := fmt.Sprintf("%s%s/updateovfstore", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(storageDomainServiceUpdateOvfStoreResponse), nil
}

func (p *storageDomainServiceUpdateOvfStoreRequest) MustSend() *storageDomainServiceUpdateOvfStoreResponse {
	rawURL := fmt.Sprintf("%s%s/updateovfstore", p.storageDomainService.connection.URL(), p.storageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(storageDomainServiceUpdateOvfStoreResponse)
}

//
// This operation forces the update of the `OVF_STORE`
// of this storage domain.
// The `OVF_STORE` is a disk image that contains the metadata
// of virtual machines and disks that reside in the
// storage domain. This metadata is used in case the
// domain is imported or exported to or from a different
// data center or a different installation.
// By default the `OVF_STORE` is updated periodically
// (set by default to 60 minutes) but users might want to force an
// update after an important change, or when the they believe the
// `OVF_STORE` is corrupt.
// When initiated by the user, `OVF_STORE` update will be performed whether
// an update is needed or not.
//
type storageDomainServiceUpdateOvfStoreResponse struct {
}

//
// This operation forces the update of the `OVF_STORE`
// of this storage domain.
// The `OVF_STORE` is a disk image that contains the metadata
// of virtual machines and disks that reside in the
// storage domain. This metadata is used in case the
// domain is imported or exported to or from a different
// data center or a different installation.
// By default the `OVF_STORE` is updated periodically
// (set by default to 60 minutes) but users might want to force an
// update after an important change, or when the they believe the
// `OVF_STORE` is corrupt.
// When initiated by the user, `OVF_STORE` update will be performed whether
// an update is needed or not.
//
func (p *storageDomainService) UpdateOvfStore() *storageDomainServiceUpdateOvfStoreRequest {
	return &storageDomainServiceUpdateOvfStoreRequest{storageDomainService: p}
}

//
//
func (op *storageDomainService) DiskProfilesService() *assignedDiskProfilesService {
	return NewAssignedDiskProfilesService(op.connection, fmt.Sprintf("%s/diskprofiles", op.path))
}

//
//
func (op *storageDomainService) DiskSnapshotsService() *diskSnapshotsService {
	return NewDiskSnapshotsService(op.connection, fmt.Sprintf("%s/disksnapshots", op.path))
}

//
// Reference to the service that manages the disks available in the storage domain.
//
func (op *storageDomainService) DisksService() *storageDomainDisksService {
	return NewStorageDomainDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
// Returns a reference to the service that manages the files available in the storage domain.
//
func (op *storageDomainService) FilesService() *filesService {
	return NewFilesService(op.connection, fmt.Sprintf("%s/files", op.path))
}

//
//
func (op *storageDomainService) ImagesService() *imagesService {
	return NewImagesService(op.connection, fmt.Sprintf("%s/images", op.path))
}

//
//
func (op *storageDomainService) PermissionsService() *assignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Returns a reference to the service that manages the storage connections.
//
func (op *storageDomainService) StorageConnectionsService() *storageDomainServerConnectionsService {
	return NewStorageDomainServerConnectionsService(op.connection, fmt.Sprintf("%s/storageconnections", op.path))
}

//
//
func (op *storageDomainService) TemplatesService() *storageDomainTemplatesService {
	return NewStorageDomainTemplatesService(op.connection, fmt.Sprintf("%s/templates", op.path))
}

//
//
func (op *storageDomainService) VmsService() *storageDomainVmsService {
	return NewStorageDomainVmsService(op.connection, fmt.Sprintf("%s/vms", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "diskprofiles" {
		return op.DiskProfilesService(), nil
	}
	if strings.HasPrefix(path, "diskprofiles/") {
		return op.DiskProfilesService().Service(path[13:])
	}
	if path == "disksnapshots" {
		return op.DiskSnapshotsService(), nil
	}
	if strings.HasPrefix(path, "disksnapshots/") {
		return op.DiskSnapshotsService().Service(path[14:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	if path == "files" {
		return op.FilesService(), nil
	}
	if strings.HasPrefix(path, "files/") {
		return op.FilesService().Service(path[6:])
	}
	if path == "images" {
		return op.ImagesService(), nil
	}
	if strings.HasPrefix(path, "images/") {
		return op.ImagesService().Service(path[7:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "storageconnections" {
		return op.StorageConnectionsService(), nil
	}
	if strings.HasPrefix(path, "storageconnections/") {
		return op.StorageConnectionsService().Service(path[19:])
	}
	if path == "templates" {
		return op.TemplatesService(), nil
	}
	if strings.HasPrefix(path, "templates/") {
		return op.TemplatesService().Service(path[10:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *storageDomainService) String() string {
	return fmt.Sprintf("storageDomainService:%s", op.path)
}

//
//
type assignedVnicProfilesService struct {
	baseService
}

func NewAssignedVnicProfilesService(connection *Connection, path string) *assignedVnicProfilesService {
	var result assignedVnicProfilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new virtual network interface card profile for the network.
//
type assignedVnicProfilesServiceAddRequest struct {
	assignedVnicProfilesService *assignedVnicProfilesService
	header                      map[string]string
	query                       map[string]string
	profile                     *VnicProfile
}

func (p *assignedVnicProfilesServiceAddRequest) Header(key, value string) *assignedVnicProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedVnicProfilesServiceAddRequest) Query(key, value string) *assignedVnicProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedVnicProfilesServiceAddRequest) Profile(profile *VnicProfile) *assignedVnicProfilesServiceAddRequest {
	p.profile = profile
	return p
}

func (p *assignedVnicProfilesServiceAddRequest) Send() (*assignedVnicProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfilesService.connection.URL(), p.assignedVnicProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVnicProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedVnicProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &assignedVnicProfilesServiceAddResponse{profile: result}, nil
}

func (p *assignedVnicProfilesServiceAddRequest) MustSend() *assignedVnicProfilesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfilesService.connection.URL(), p.assignedVnicProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVnicProfileWriteOne(writer, p.profile, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedVnicProfilesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfilesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &assignedVnicProfilesServiceAddResponse{profile: result}
}

//
// Add a new virtual network interface card profile for the network.
//
type assignedVnicProfilesServiceAddResponse struct {
	profile *VnicProfile
}

func (p *assignedVnicProfilesServiceAddResponse) Profile() (*VnicProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *assignedVnicProfilesServiceAddResponse) MustProfile() *VnicProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Add a new virtual network interface card profile for the network.
//
func (p *assignedVnicProfilesService) Add() *assignedVnicProfilesServiceAddRequest {
	return &assignedVnicProfilesServiceAddRequest{assignedVnicProfilesService: p}
}

//
// Returns the list of VNIC profiles assifned to the network.
// The order of the returned VNIC profiles isn't guaranteed.
//
type assignedVnicProfilesServiceListRequest struct {
	assignedVnicProfilesService *assignedVnicProfilesService
	header                      map[string]string
	query                       map[string]string
	follow                      *string
	max                         *int64
}

func (p *assignedVnicProfilesServiceListRequest) Header(key, value string) *assignedVnicProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedVnicProfilesServiceListRequest) Query(key, value string) *assignedVnicProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedVnicProfilesServiceListRequest) Follow(follow string) *assignedVnicProfilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *assignedVnicProfilesServiceListRequest) Max(max int64) *assignedVnicProfilesServiceListRequest {
	p.max = &max
	return p
}

func (p *assignedVnicProfilesServiceListRequest) Send() (*assignedVnicProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfilesService.connection.URL(), p.assignedVnicProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedVnicProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &assignedVnicProfilesServiceListResponse{profiles: result}, nil
}

func (p *assignedVnicProfilesServiceListRequest) MustSend() *assignedVnicProfilesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedVnicProfilesService.connection.URL(), p.assignedVnicProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedVnicProfilesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedVnicProfilesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &assignedVnicProfilesServiceListResponse{profiles: result}
}

//
// Returns the list of VNIC profiles assifned to the network.
// The order of the returned VNIC profiles isn't guaranteed.
//
type assignedVnicProfilesServiceListResponse struct {
	profiles *VnicProfileSlice
}

func (p *assignedVnicProfilesServiceListResponse) Profiles() (*VnicProfileSlice, bool) {
	if p.profiles != nil {
		return p.profiles, true
	}
	return nil, false
}

func (p *assignedVnicProfilesServiceListResponse) MustProfiles() *VnicProfileSlice {
	if p.profiles == nil {
		panic("profiles in response does not exist")
	}
	return p.profiles
}

//
// Returns the list of VNIC profiles assifned to the network.
// The order of the returned VNIC profiles isn't guaranteed.
//
func (p *assignedVnicProfilesService) List() *assignedVnicProfilesServiceListRequest {
	return &assignedVnicProfilesServiceListRequest{assignedVnicProfilesService: p}
}

//
//
func (op *assignedVnicProfilesService) ProfileService(id string) *assignedVnicProfileService {
	return NewAssignedVnicProfileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *assignedVnicProfilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProfileService(path), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *assignedVnicProfilesService) String() string {
	return fmt.Sprintf("assignedVnicProfilesService:%s", op.path)
}

//
// This service provides a mechanism to control an image transfer. The client will have
// to create a transfer by using <<services/image_transfers/methods/add, add>>
// of the <<services/image_transfers>> service, stating the image to transfer
// data to/from.
// After doing that, the transfer is managed by this service.
// E.g., for uploading/downloading a disk with id `52cb593f-837c-4633-a444-35a0a0383706`:
// *Using oVirt's Python's SDK:*
// [source,python]
// ----
// transfers_service = system_service.image_transfers_service()
// transfer = transfers_service.add(
//    types.ImageTransfer(
//       image=types.Image(
//          id='52cb593f-837c-4633-a444-35a0a0383706'
//       )
//    )
// )
// ----
// If the user wishes to download a disk rather than upload, he/she should specify
// `download` as the <<types/image_transfer_direction, direction>> attribute of the transfer.
// This will grant a read permission from the image, instead of a write permission.
// E.g:
// [source,python]
// ----
// transfers_service = system_service.image_transfers_service()
// transfer = transfers_service.add(
//    types.ImageTransfer(
//       image=types.Image(
//          id='52cb593f-837c-4633-a444-35a0a0383706'
//       ),
//       direction=types.ImageTransferDirection.DOWNLOAD
//    )
// )
// ----
// Transfers have phases, which govern the flow of the upload/download.
// A client implementing such a flow should poll/check the transfer's phase and
// act accordingly. All the possible phases can be found in
// <<types/image_transfer_phase, ImageTransferPhase>>.
// After adding a new transfer, its phase will be <<types/image_transfer_phase, initializing>>.
// The client will have to poll on the transfer's phase until it changes.
// When the phase becomes <<types/image_transfer_phase, transferring>>,
// the session is ready to start the transfer.
// For example:
// [source,python]
// ----
// transfer_service = transfers_service.image_transfer_service(transfer.id)
// while transfer.phase == types.ImageTransferPhase.INITIALIZING:
//    time.sleep(3)
//    transfer = transfer_service.get()
// ----
// At that stage, if the transfer's phase is <<types/image_transfer_phase, paused_system>>, then the session was
// not successfully established. One possible reason for that is that the ovirt-imageio-daemon is not running
// in the host that was selected for transfer.
// The transfer can be resumed by calling <<services/image_transfer/methods/resume, resume>>
// of the service that manages it.
// If the session was successfully established - the returned transfer entity will
// contain the <<types/image_transfer, proxy_url>> and <<types/image_transfer, signed_ticket>> attributes,
// which the client needs to use in order to transfer the required data. The client can choose whatever
// technique and tool for sending the HTTPS request with the image's data.
// - `proxy_url` is the address of a proxy server to the image, to do I/O to.
// - `signed_ticket` is the content that needs to be added to the `Authentication`
//    header in the HTTPS request, in order to perform a trusted communication.
// For example, Python's HTTPSConnection can be used in order to perform a transfer,
// so an `transfer_headers` dict is set for the upcoming transfer:
// [source,python]
// ----
// transfer_headers = {
//    'Authorization' :  transfer.signed_ticket,
// }
// ----
// Using Python's `HTTPSConnection`, a new connection is established:
// [source,python]
// ----
// # Extract the URI, port, and path from the transfer's proxy_url.
// url = urlparse.urlparse(transfer.proxy_url)
// # Create a new instance of the connection.
// proxy_connection = HTTPSConnection(
//    url.hostname,
//    url.port,
//    context=ssl.SSLContext(ssl.PROTOCOL_SSLv23)
// )
// ----
// For upload, the specific content range being sent must be noted in the `Content-Range` HTTPS
// header. This can be used in order to split the transfer into several requests for
// a more flexible process.
// For doing that, the client will have to repeatedly extend the transfer session
// to keep the channel open. Otherwise, the session will terminate and the transfer will
// get into `paused_system` phase, and HTTPS requests to the server will be rejected.
// E.g., the client can iterate on chunks of the file, and send them to the
// proxy server while asking the service to extend the session:
// [source,python]
// ----
// path = "/path/to/image"
// MB_per_request = 32
// with open(path, "rb") as disk:
//    size = os.path.getsize(path)
//    chunk_size = 1024*1024*MB_per_request
//    pos = 0
//    while (pos < size):
//       transfer_service.extend()
//       transfer_headers['Content-Range'] = "bytes %d-%d/%d" % (pos, min(pos + chunk_size, size)-1, size)
//       proxy_connection.request(
//          'PUT',
//          url.path,
//          disk.read(chunk_size),
//          headers=transfer_headers
//       )
//       r = proxy_connection.getresponse()
//       print r.status, r.reason, "Completed", "{:.0%}".format(pos/ float(size))
//       pos += chunk_size
// ----
// Similarly, for a download transfer, a `Range` header must be sent, making the download process
// more easily managed by downloading the disk in chunks.
// E.g., the client will again iterate on chunks of the disk image, but this time he/she will download
// it to a local file, rather than uploading its own file to the image:
// [source,python]
// ----
// output_file = "/home/user/downloaded_image"
// MiB_per_request = 32
// chunk_size = 1024*1024*MiB_per_request
// total = disk_size
// with open(output_file, "wb") as disk:
//    pos = 0
//    while pos < total:
//       transfer_service.extend()
//       transfer_headers['Range'] = "bytes=%d-%d" %  (pos, min(total, pos + chunk_size) - 1)
//       proxy_connection.request('GET', proxy_url.path, headers=transfer_headers)
//       r = proxy_connection.getresponse()
//       disk.write(r.read())
//       print "Completed", "{:.0%}".format(pos/ float(total))
//       pos += chunk_size
// ----
// When finishing the transfer, the user should call
// <<services/image_transfer/methods/finalize, finalize>>. This will make the
// final adjustments and verifications for finishing the transfer process.
// For example:
// [source,python]
// ----
// transfer_service.finalize()
// ----
// In case of an error, the transfer's phase will be changed to
// <<types/image_transfer_phase, finished_failure>>, and
// the disk's status will be changed to `Illegal`. Otherwise it will be changed to
// <<types/image_transfer_phase, finished_success>>, and the disk will be ready
// to be used. In both cases, the transfer entity will be removed shortly after.
// *Using HTTP and cURL calls:*
// - For upload, create a new disk first:
// * Specify 'initial_size' and 'provisioned_size' in bytes.
// * 'initial_size' must be bigger or the same as the size of the uploaded data.
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <alias>mydisk</alias>
//   <initial_size>1073741824</initial_size>
//   <provisioned_size>1073741824</provisioned_size>
//   <format>raw</format>
// </disk>
// ----
// - Create a new image transfer for downloading/uploading a `disk` with id `456`:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body as follows:
// [source,xml]
// ----
// <image_transfer>
//   <disk id="456"/>
//   <direction>upload|download</direction>
// </image_transfer>
// ----
// Will respond:
// [source,xml]
// ----
// <image_transfer id="123">
//   <direction>download|upload</direction>
//   <phase>initializing|transferring</phase>
//   <proxy_url>https://proxy_fqdn:54323/images/41c732d4-2210-4e7b-9e5c-4e2805baadbb</proxy_url>
//   <transfer_url>https://daemon_fqdn:54322/images/41c732d4-2210-4e7b-9e5c-4e2805baadbb</transfer_url>
//   ...
// </image_transfer>
// ----
// Note: If the phase is 'initializing', poll the `image_transfer` till its phase changes to 'transferring'.
// - Use the 'transfer_url' or 'proxy_url' to invoke a curl command:
// - use 'transfer_url' for transferring directly from/to ovirt-imageio-daemon,
//   or, use 'proxy_url' for transferring from/to ovirt-imageio-proxy.
//   Note: using the proxy would mitigate scenarios where there's no direct connectivity
//   to the daemon machine, e.g. vdsm machines are on a different network than the engine.
// -- Download:
// [source,shell]
// ----
// $ curl --cacert /etc/pki/ovirt-engine/ca.pem https://daemon_fqdn:54322/images/41c732d4-2210-4e7b-9e5c-4e2805baadbb -o <output_file>
// ----
// -- Upload:
// [source,shell]
// ----
// $ curl --cacert /etc/pki/ovirt-engine/ca.pem --upload-file <file_to_upload> -X PUT https://daemon_fqdn:54322/images/41c732d4-2210-4e7b-9e5c-4e2805baadbb
// ----
// - Finalize the image transfer by invoking the action:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers/123/finalize
// ----
// With a request body as follows:
// [source,xml]
// ----
// <action />
// ----
//
type imageTransferService struct {
	baseService
}

func NewImageTransferService(connection *Connection, path string) *imageTransferService {
	var result imageTransferService
	result.connection = connection
	result.path = path
	return &result
}

//
// Extend the image transfer session.
//
type imageTransferServiceExtendRequest struct {
	imageTransferService *imageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *imageTransferServiceExtendRequest) Header(key, value string) *imageTransferServiceExtendRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imageTransferServiceExtendRequest) Query(key, value string) *imageTransferServiceExtendRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imageTransferServiceExtendRequest) Send() (*imageTransferServiceExtendResponse, error) {
	rawURL := fmt.Sprintf("%s%s/extend", p.imageTransferService.connection.URL(), p.imageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransferService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransferService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(imageTransferServiceExtendResponse), nil
}

func (p *imageTransferServiceExtendRequest) MustSend() *imageTransferServiceExtendResponse {
	rawURL := fmt.Sprintf("%s%s/extend", p.imageTransferService.connection.URL(), p.imageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransferService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransferService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(imageTransferServiceExtendResponse)
}

//
// Extend the image transfer session.
//
type imageTransferServiceExtendResponse struct {
}

//
// Extend the image transfer session.
//
func (p *imageTransferService) Extend() *imageTransferServiceExtendRequest {
	return &imageTransferServiceExtendRequest{imageTransferService: p}
}

//
// After finishing to transfer the data, finalize the transfer.
// This will make sure that the data being transferred is valid and fits the
// image entity that was targeted in the transfer. Specifically, will verify that
// if the image entity is a QCOW disk, the data uploaded is indeed a QCOW file,
// and that the image doesn't have a backing file.
//
type imageTransferServiceFinalizeRequest struct {
	imageTransferService *imageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *imageTransferServiceFinalizeRequest) Header(key, value string) *imageTransferServiceFinalizeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imageTransferServiceFinalizeRequest) Query(key, value string) *imageTransferServiceFinalizeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imageTransferServiceFinalizeRequest) Send() (*imageTransferServiceFinalizeResponse, error) {
	rawURL := fmt.Sprintf("%s%s/finalize", p.imageTransferService.connection.URL(), p.imageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransferService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransferService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(imageTransferServiceFinalizeResponse), nil
}

func (p *imageTransferServiceFinalizeRequest) MustSend() *imageTransferServiceFinalizeResponse {
	rawURL := fmt.Sprintf("%s%s/finalize", p.imageTransferService.connection.URL(), p.imageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransferService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransferService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(imageTransferServiceFinalizeResponse)
}

//
// After finishing to transfer the data, finalize the transfer.
// This will make sure that the data being transferred is valid and fits the
// image entity that was targeted in the transfer. Specifically, will verify that
// if the image entity is a QCOW disk, the data uploaded is indeed a QCOW file,
// and that the image doesn't have a backing file.
//
type imageTransferServiceFinalizeResponse struct {
}

//
// After finishing to transfer the data, finalize the transfer.
// This will make sure that the data being transferred is valid and fits the
// image entity that was targeted in the transfer. Specifically, will verify that
// if the image entity is a QCOW disk, the data uploaded is indeed a QCOW file,
// and that the image doesn't have a backing file.
//
func (p *imageTransferService) Finalize() *imageTransferServiceFinalizeRequest {
	return &imageTransferServiceFinalizeRequest{imageTransferService: p}
}

//
// Get the image transfer entity.
//
type imageTransferServiceGetRequest struct {
	imageTransferService *imageTransferService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *imageTransferServiceGetRequest) Header(key, value string) *imageTransferServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imageTransferServiceGetRequest) Query(key, value string) *imageTransferServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imageTransferServiceGetRequest) Follow(follow string) *imageTransferServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *imageTransferServiceGetRequest) Send() (*imageTransferServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.imageTransferService.connection.URL(), p.imageTransferService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransferService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransferService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageTransferReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &imageTransferServiceGetResponse{imageTransfer: result}, nil
}

func (p *imageTransferServiceGetRequest) MustSend() *imageTransferServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.imageTransferService.connection.URL(), p.imageTransferService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransferService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransferService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageTransferReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &imageTransferServiceGetResponse{imageTransfer: result}
}

//
// Get the image transfer entity.
//
type imageTransferServiceGetResponse struct {
	imageTransfer *ImageTransfer
}

func (p *imageTransferServiceGetResponse) ImageTransfer() (*ImageTransfer, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

func (p *imageTransferServiceGetResponse) MustImageTransfer() *ImageTransfer {
	if p.imageTransfer == nil {
		panic("imageTransfer in response does not exist")
	}
	return p.imageTransfer
}

//
// Get the image transfer entity.
//
func (p *imageTransferService) Get() *imageTransferServiceGetRequest {
	return &imageTransferServiceGetRequest{imageTransferService: p}
}

//
// Pause the image transfer session.
//
type imageTransferServicePauseRequest struct {
	imageTransferService *imageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *imageTransferServicePauseRequest) Header(key, value string) *imageTransferServicePauseRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imageTransferServicePauseRequest) Query(key, value string) *imageTransferServicePauseRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imageTransferServicePauseRequest) Send() (*imageTransferServicePauseResponse, error) {
	rawURL := fmt.Sprintf("%s%s/pause", p.imageTransferService.connection.URL(), p.imageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransferService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransferService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(imageTransferServicePauseResponse), nil
}

func (p *imageTransferServicePauseRequest) MustSend() *imageTransferServicePauseResponse {
	rawURL := fmt.Sprintf("%s%s/pause", p.imageTransferService.connection.URL(), p.imageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransferService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransferService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(imageTransferServicePauseResponse)
}

//
// Pause the image transfer session.
//
type imageTransferServicePauseResponse struct {
}

//
// Pause the image transfer session.
//
func (p *imageTransferService) Pause() *imageTransferServicePauseRequest {
	return &imageTransferServicePauseRequest{imageTransferService: p}
}

//
// Resume the image transfer session. The client will need to poll the transfer's phase until
// it is different than `resuming`. For example:
// [source,python]
// ----
// transfer_service = transfers_service.image_transfer_service(transfer.id)
// transfer_service.resume()
// transfer = transfer_service.get()
// while transfer.phase == types.ImageTransferPhase.RESUMING:
//    time.sleep(1)
//    transfer = transfer_service.get()
// ----
//
type imageTransferServiceResumeRequest struct {
	imageTransferService *imageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *imageTransferServiceResumeRequest) Header(key, value string) *imageTransferServiceResumeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *imageTransferServiceResumeRequest) Query(key, value string) *imageTransferServiceResumeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *imageTransferServiceResumeRequest) Send() (*imageTransferServiceResumeResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resume", p.imageTransferService.connection.URL(), p.imageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransferService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransferService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(imageTransferServiceResumeResponse), nil
}

func (p *imageTransferServiceResumeRequest) MustSend() *imageTransferServiceResumeResponse {
	rawURL := fmt.Sprintf("%s%s/resume", p.imageTransferService.connection.URL(), p.imageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.imageTransferService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.imageTransferService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(imageTransferServiceResumeResponse)
}

//
// Resume the image transfer session. The client will need to poll the transfer's phase until
// it is different than `resuming`. For example:
// [source,python]
// ----
// transfer_service = transfers_service.image_transfer_service(transfer.id)
// transfer_service.resume()
// transfer = transfer_service.get()
// while transfer.phase == types.ImageTransferPhase.RESUMING:
//    time.sleep(1)
//    transfer = transfer_service.get()
// ----
//
type imageTransferServiceResumeResponse struct {
}

//
// Resume the image transfer session. The client will need to poll the transfer's phase until
// it is different than `resuming`. For example:
// [source,python]
// ----
// transfer_service = transfers_service.image_transfer_service(transfer.id)
// transfer_service.resume()
// transfer = transfer_service.get()
// while transfer.phase == types.ImageTransferPhase.RESUMING:
//    time.sleep(1)
//    transfer = transfer_service.get()
// ----
//
func (p *imageTransferService) Resume() *imageTransferServiceResumeRequest {
	return &imageTransferServiceResumeRequest{imageTransferService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *imageTransferService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *imageTransferService) String() string {
	return fmt.Sprintf("imageTransferService:%s", op.path)
}

//
//
type roleService struct {
	baseService
}

func NewRoleService(connection *Connection, path string) *roleService {
	var result roleService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get the role.
// [source]
// ----
// GET /ovirt-engine/api/roles/123
// ----
// You will receive XML response like this one:
// [source,xml]
// ----
// <role id="123">
//   <name>MyRole</name>
//   <description>MyRole description</description>
//   <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//   <administrative>true</administrative>
//   <mutable>false</mutable>
// </role>
// ----
//
type roleServiceGetRequest struct {
	roleService *roleService
	header      map[string]string
	query       map[string]string
	follow      *string
}

func (p *roleServiceGetRequest) Header(key, value string) *roleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *roleServiceGetRequest) Query(key, value string) *roleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *roleServiceGetRequest) Follow(follow string) *roleServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *roleServiceGetRequest) Send() (*roleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.roleService.connection.URL(), p.roleService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.roleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.roleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &roleServiceGetResponse{role: result}, nil
}

func (p *roleServiceGetRequest) MustSend() *roleServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.roleService.connection.URL(), p.roleService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.roleService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.roleService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &roleServiceGetResponse{role: result}
}

//
// Get the role.
// [source]
// ----
// GET /ovirt-engine/api/roles/123
// ----
// You will receive XML response like this one:
// [source,xml]
// ----
// <role id="123">
//   <name>MyRole</name>
//   <description>MyRole description</description>
//   <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//   <administrative>true</administrative>
//   <mutable>false</mutable>
// </role>
// ----
//
type roleServiceGetResponse struct {
	role *Role
}

func (p *roleServiceGetResponse) Role() (*Role, bool) {
	if p.role != nil {
		return p.role, true
	}
	return nil, false
}

func (p *roleServiceGetResponse) MustRole() *Role {
	if p.role == nil {
		panic("role in response does not exist")
	}
	return p.role
}

//
// Get the role.
// [source]
// ----
// GET /ovirt-engine/api/roles/123
// ----
// You will receive XML response like this one:
// [source,xml]
// ----
// <role id="123">
//   <name>MyRole</name>
//   <description>MyRole description</description>
//   <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//   <administrative>true</administrative>
//   <mutable>false</mutable>
// </role>
// ----
//
func (p *roleService) Get() *roleServiceGetRequest {
	return &roleServiceGetRequest{roleService: p}
}

//
// Removes the role.
// To remove the role you need to know its id, then send request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/roles/{role_id}
// ----
//
type roleServiceRemoveRequest struct {
	roleService *roleService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *roleServiceRemoveRequest) Header(key, value string) *roleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *roleServiceRemoveRequest) Query(key, value string) *roleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *roleServiceRemoveRequest) Async(async bool) *roleServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *roleServiceRemoveRequest) Send() (*roleServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.roleService.connection.URL(), p.roleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.roleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.roleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(roleServiceRemoveResponse), nil
}

func (p *roleServiceRemoveRequest) MustSend() *roleServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.roleService.connection.URL(), p.roleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.roleService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.roleService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(roleServiceRemoveResponse)
}

//
// Removes the role.
// To remove the role you need to know its id, then send request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/roles/{role_id}
// ----
//
type roleServiceRemoveResponse struct {
}

//
// Removes the role.
// To remove the role you need to know its id, then send request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/roles/{role_id}
// ----
//
func (p *roleService) Remove() *roleServiceRemoveRequest {
	return &roleServiceRemoveRequest{roleService: p}
}

//
// Updates a role. You are allowed to update `name`, `description` and `administrative` attributes after role is
// created. Within this endpoint you can't add or remove roles permits you need to use
// <<services/permits, service>> that manages permits of role.
// For example to update role's `name`, `description` and `administrative` attributes send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/roles/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyNewRoleName</name>
//   <description>My new description of the role</description>
//   <administrative>true</administrative>
// </group>
// ----
//
type roleServiceUpdateRequest struct {
	roleService *roleService
	header      map[string]string
	query       map[string]string
	async       *bool
	role        *Role
}

func (p *roleServiceUpdateRequest) Header(key, value string) *roleServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *roleServiceUpdateRequest) Query(key, value string) *roleServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *roleServiceUpdateRequest) Async(async bool) *roleServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *roleServiceUpdateRequest) Role(role *Role) *roleServiceUpdateRequest {
	p.role = role
	return p
}

func (p *roleServiceUpdateRequest) Send() (*roleServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.roleService.connection.URL(), p.roleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLRoleWriteOne(writer, p.role, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.roleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.roleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &roleServiceUpdateResponse{role: result}, nil
}

func (p *roleServiceUpdateRequest) MustSend() *roleServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.roleService.connection.URL(), p.roleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLRoleWriteOne(writer, p.role, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.roleService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.roleService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &roleServiceUpdateResponse{role: result}
}

//
// Updates a role. You are allowed to update `name`, `description` and `administrative` attributes after role is
// created. Within this endpoint you can't add or remove roles permits you need to use
// <<services/permits, service>> that manages permits of role.
// For example to update role's `name`, `description` and `administrative` attributes send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/roles/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyNewRoleName</name>
//   <description>My new description of the role</description>
//   <administrative>true</administrative>
// </group>
// ----
//
type roleServiceUpdateResponse struct {
	role *Role
}

func (p *roleServiceUpdateResponse) Role() (*Role, bool) {
	if p.role != nil {
		return p.role, true
	}
	return nil, false
}

func (p *roleServiceUpdateResponse) MustRole() *Role {
	if p.role == nil {
		panic("role in response does not exist")
	}
	return p.role
}

//
// Updates a role. You are allowed to update `name`, `description` and `administrative` attributes after role is
// created. Within this endpoint you can't add or remove roles permits you need to use
// <<services/permits, service>> that manages permits of role.
// For example to update role's `name`, `description` and `administrative` attributes send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/roles/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyNewRoleName</name>
//   <description>My new description of the role</description>
//   <administrative>true</administrative>
// </group>
// ----
//
func (p *roleService) Update() *roleServiceUpdateRequest {
	return &roleServiceUpdateRequest{roleService: p}
}

//
// Sub-resource locator method, returns permits service.
//
func (op *roleService) PermitsService() *permitsService {
	return NewPermitsService(op.connection, fmt.Sprintf("%s/permits", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *roleService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permits" {
		return op.PermitsService(), nil
	}
	if strings.HasPrefix(path, "permits/") {
		return op.PermitsService().Service(path[8:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *roleService) String() string {
	return fmt.Sprintf("roleService:%s", op.path)
}

//
//
type vmNicService struct {
	baseService
}

func NewVmNicService(connection *Connection, path string) *vmNicService {
	var result vmNicService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type vmNicServiceActivateRequest struct {
	vmNicService *vmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *vmNicServiceActivateRequest) Header(key, value string) *vmNicServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmNicServiceActivateRequest) Query(key, value string) *vmNicServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmNicServiceActivateRequest) Async(async bool) *vmNicServiceActivateRequest {
	p.async = &async
	return p
}

func (p *vmNicServiceActivateRequest) Send() (*vmNicServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.vmNicService.connection.URL(), p.vmNicService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmNicServiceActivateResponse), nil
}

func (p *vmNicServiceActivateRequest) MustSend() *vmNicServiceActivateResponse {
	rawURL := fmt.Sprintf("%s%s/activate", p.vmNicService.connection.URL(), p.vmNicService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmNicServiceActivateResponse)
}

//
//
type vmNicServiceActivateResponse struct {
}

//
//
func (p *vmNicService) Activate() *vmNicServiceActivateRequest {
	return &vmNicServiceActivateRequest{vmNicService: p}
}

//
//
type vmNicServiceDeactivateRequest struct {
	vmNicService *vmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *vmNicServiceDeactivateRequest) Header(key, value string) *vmNicServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmNicServiceDeactivateRequest) Query(key, value string) *vmNicServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmNicServiceDeactivateRequest) Async(async bool) *vmNicServiceDeactivateRequest {
	p.async = &async
	return p
}

func (p *vmNicServiceDeactivateRequest) Send() (*vmNicServiceDeactivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.vmNicService.connection.URL(), p.vmNicService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(vmNicServiceDeactivateResponse), nil
}

func (p *vmNicServiceDeactivateRequest) MustSend() *vmNicServiceDeactivateResponse {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.vmNicService.connection.URL(), p.vmNicService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(vmNicServiceDeactivateResponse)
}

//
//
type vmNicServiceDeactivateResponse struct {
}

//
//
func (p *vmNicService) Deactivate() *vmNicServiceDeactivateRequest {
	return &vmNicServiceDeactivateRequest{vmNicService: p}
}

//
//
type vmNicServiceGetRequest struct {
	vmNicService *vmNicService
	header       map[string]string
	query        map[string]string
	follow       *string
}

func (p *vmNicServiceGetRequest) Header(key, value string) *vmNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmNicServiceGetRequest) Query(key, value string) *vmNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmNicServiceGetRequest) Follow(follow string) *vmNicServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vmNicServiceGetRequest) Send() (*vmNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicService.connection.URL(), p.vmNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmNicServiceGetResponse{nic: result}, nil
}

func (p *vmNicServiceGetRequest) MustSend() *vmNicServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmNicService.connection.URL(), p.vmNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmNicServiceGetResponse{nic: result}
}

//
//
type vmNicServiceGetResponse struct {
	nic *Nic
}

func (p *vmNicServiceGetResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *vmNicServiceGetResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
//
func (p *vmNicService) Get() *vmNicServiceGetRequest {
	return &vmNicServiceGetRequest{vmNicService: p}
}

//
// Removes the NIC.
// For example, to remove the NIC with id `456` from the virtual machine with id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/nics/456
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
type vmNicServiceRemoveRequest struct {
	vmNicService *vmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *vmNicServiceRemoveRequest) Header(key, value string) *vmNicServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmNicServiceRemoveRequest) Query(key, value string) *vmNicServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmNicServiceRemoveRequest) Async(async bool) *vmNicServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *vmNicServiceRemoveRequest) Send() (*vmNicServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicService.connection.URL(), p.vmNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(vmNicServiceRemoveResponse), nil
}

func (p *vmNicServiceRemoveRequest) MustSend() *vmNicServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmNicService.connection.URL(), p.vmNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(vmNicServiceRemoveResponse)
}

//
// Removes the NIC.
// For example, to remove the NIC with id `456` from the virtual machine with id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/nics/456
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
type vmNicServiceRemoveResponse struct {
}

//
// Removes the NIC.
// For example, to remove the NIC with id `456` from the virtual machine with id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/nics/456
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
func (p *vmNicService) Remove() *vmNicServiceRemoveRequest {
	return &vmNicServiceRemoveRequest{vmNicService: p}
}

//
// Updates the NIC.
// For example, to update the NIC having with `456` belonging to virtual the machine with id `123` send a request
// like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/nics/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>e1000</interface>
//   <vnic_profile id='789'/>
// </nic>
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
type vmNicServiceUpdateRequest struct {
	vmNicService *vmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
	nic          *Nic
}

func (p *vmNicServiceUpdateRequest) Header(key, value string) *vmNicServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmNicServiceUpdateRequest) Query(key, value string) *vmNicServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmNicServiceUpdateRequest) Async(async bool) *vmNicServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *vmNicServiceUpdateRequest) Nic(nic *Nic) *vmNicServiceUpdateRequest {
	p.nic = nic
	return p
}

func (p *vmNicServiceUpdateRequest) Send() (*vmNicServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNicService.connection.URL(), p.vmNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmNicServiceUpdateResponse{nic: result}, nil
}

func (p *vmNicServiceUpdateRequest) MustSend() *vmNicServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmNicService.connection.URL(), p.vmNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNicService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNicService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmNicServiceUpdateResponse{nic: result}
}

//
// Updates the NIC.
// For example, to update the NIC having with `456` belonging to virtual the machine with id `123` send a request
// like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/nics/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>e1000</interface>
//   <vnic_profile id='789'/>
// </nic>
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
type vmNicServiceUpdateResponse struct {
	nic *Nic
}

func (p *vmNicServiceUpdateResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *vmNicServiceUpdateResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Updates the NIC.
// For example, to update the NIC having with `456` belonging to virtual the machine with id `123` send a request
// like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/nics/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>e1000</interface>
//   <vnic_profile id='789'/>
// </nic>
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
func (p *vmNicService) Update() *vmNicServiceUpdateRequest {
	return &vmNicServiceUpdateRequest{vmNicService: p}
}

//
// Reference to the service that manages the network filter parameters of the NIC.
// A single top-level network filter may assigned to the NIC by the NIC's <<types/vnic_profile,vNIC Profile>>.
//
func (op *vmNicService) NetworkFilterParametersService() *nicNetworkFilterParametersService {
	return NewNicNetworkFilterParametersService(op.connection, fmt.Sprintf("%s/networkfilterparameters", op.path))
}

//
//
func (op *vmNicService) ReportedDevicesService() *vmReportedDevicesService {
	return NewVmReportedDevicesService(op.connection, fmt.Sprintf("%s/reporteddevices", op.path))
}

//
//
func (op *vmNicService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmNicService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "networkfilterparameters" {
		return op.NetworkFilterParametersService(), nil
	}
	if strings.HasPrefix(path, "networkfilterparameters/") {
		return op.NetworkFilterParametersService().Service(path[24:])
	}
	if path == "reporteddevices" {
		return op.ReportedDevicesService(), nil
	}
	if strings.HasPrefix(path, "reporteddevices/") {
		return op.ReportedDevicesService().Service(path[16:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vmNicService) String() string {
	return fmt.Sprintf("vmNicService:%s", op.path)
}

//
//
type operatingSystemService struct {
	baseService
}

func NewOperatingSystemService(connection *Connection, path string) *operatingSystemService {
	var result operatingSystemService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type operatingSystemServiceGetRequest struct {
	operatingSystemService *operatingSystemService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *operatingSystemServiceGetRequest) Header(key, value string) *operatingSystemServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *operatingSystemServiceGetRequest) Query(key, value string) *operatingSystemServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *operatingSystemServiceGetRequest) Follow(follow string) *operatingSystemServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *operatingSystemServiceGetRequest) Send() (*operatingSystemServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.operatingSystemService.connection.URL(), p.operatingSystemService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.operatingSystemService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.operatingSystemService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOperatingSystemInfoReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &operatingSystemServiceGetResponse{operatingSystem: result}, nil
}

func (p *operatingSystemServiceGetRequest) MustSend() *operatingSystemServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.operatingSystemService.connection.URL(), p.operatingSystemService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.operatingSystemService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.operatingSystemService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOperatingSystemInfoReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &operatingSystemServiceGetResponse{operatingSystem: result}
}

//
//
type operatingSystemServiceGetResponse struct {
	operatingSystem *OperatingSystemInfo
}

func (p *operatingSystemServiceGetResponse) OperatingSystem() (*OperatingSystemInfo, bool) {
	if p.operatingSystem != nil {
		return p.operatingSystem, true
	}
	return nil, false
}

func (p *operatingSystemServiceGetResponse) MustOperatingSystem() *OperatingSystemInfo {
	if p.operatingSystem == nil {
		panic("operatingSystem in response does not exist")
	}
	return p.operatingSystem
}

//
//
func (p *operatingSystemService) Get() *operatingSystemServiceGetRequest {
	return &operatingSystemServiceGetRequest{operatingSystemService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *operatingSystemService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *operatingSystemService) String() string {
	return fmt.Sprintf("operatingSystemService:%s", op.path)
}

//
// Manages the storage domains attached to a data center.
//
type attachedStorageDomainsService struct {
	baseService
}

func NewAttachedStorageDomainsService(connection *Connection, path string) *attachedStorageDomainsService {
	var result attachedStorageDomainsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Attaches an existing storage domain to the data center.
//
type attachedStorageDomainsServiceAddRequest struct {
	attachedStorageDomainsService *attachedStorageDomainsService
	header                        map[string]string
	query                         map[string]string
	storageDomain                 *StorageDomain
}

func (p *attachedStorageDomainsServiceAddRequest) Header(key, value string) *attachedStorageDomainsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainsServiceAddRequest) Query(key, value string) *attachedStorageDomainsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainsServiceAddRequest) StorageDomain(storageDomain *StorageDomain) *attachedStorageDomainsServiceAddRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *attachedStorageDomainsServiceAddRequest) Send() (*attachedStorageDomainsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainsService.connection.URL(), p.attachedStorageDomainsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageDomainWriteOne(writer, p.storageDomain, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &attachedStorageDomainsServiceAddResponse{storageDomain: result}, nil
}

func (p *attachedStorageDomainsServiceAddRequest) MustSend() *attachedStorageDomainsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainsService.connection.URL(), p.attachedStorageDomainsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageDomainWriteOne(writer, p.storageDomain, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &attachedStorageDomainsServiceAddResponse{storageDomain: result}
}

//
// Attaches an existing storage domain to the data center.
//
type attachedStorageDomainsServiceAddResponse struct {
	storageDomain *StorageDomain
}

func (p *attachedStorageDomainsServiceAddResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *attachedStorageDomainsServiceAddResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Attaches an existing storage domain to the data center.
//
func (p *attachedStorageDomainsService) Add() *attachedStorageDomainsServiceAddRequest {
	return &attachedStorageDomainsServiceAddRequest{attachedStorageDomainsService: p}
}

//
// Returns the list of storage domains attached to the data center.
// The order of the returned storage domains isn't guaranteed.
//
type attachedStorageDomainsServiceListRequest struct {
	attachedStorageDomainsService *attachedStorageDomainsService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
	max                           *int64
}

func (p *attachedStorageDomainsServiceListRequest) Header(key, value string) *attachedStorageDomainsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainsServiceListRequest) Query(key, value string) *attachedStorageDomainsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainsServiceListRequest) Follow(follow string) *attachedStorageDomainsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *attachedStorageDomainsServiceListRequest) Max(max int64) *attachedStorageDomainsServiceListRequest {
	p.max = &max
	return p
}

func (p *attachedStorageDomainsServiceListRequest) Send() (*attachedStorageDomainsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainsService.connection.URL(), p.attachedStorageDomainsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &attachedStorageDomainsServiceListResponse{storageDomains: result}, nil
}

func (p *attachedStorageDomainsServiceListRequest) MustSend() *attachedStorageDomainsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainsService.connection.URL(), p.attachedStorageDomainsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &attachedStorageDomainsServiceListResponse{storageDomains: result}
}

//
// Returns the list of storage domains attached to the data center.
// The order of the returned storage domains isn't guaranteed.
//
type attachedStorageDomainsServiceListResponse struct {
	storageDomains *StorageDomainSlice
}

func (p *attachedStorageDomainsServiceListResponse) StorageDomains() (*StorageDomainSlice, bool) {
	if p.storageDomains != nil {
		return p.storageDomains, true
	}
	return nil, false
}

func (p *attachedStorageDomainsServiceListResponse) MustStorageDomains() *StorageDomainSlice {
	if p.storageDomains == nil {
		panic("storageDomains in response does not exist")
	}
	return p.storageDomains
}

//
// Returns the list of storage domains attached to the data center.
// The order of the returned storage domains isn't guaranteed.
//
func (p *attachedStorageDomainsService) List() *attachedStorageDomainsServiceListRequest {
	return &attachedStorageDomainsServiceListRequest{attachedStorageDomainsService: p}
}

//
//
func (op *attachedStorageDomainsService) StorageDomainService(id string) *attachedStorageDomainService {
	return NewAttachedStorageDomainService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *attachedStorageDomainsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StorageDomainService(path), nil
	}
	return op.StorageDomainService(path[:index]).Service(path[index+1:])
}

func (op *attachedStorageDomainsService) String() string {
	return fmt.Sprintf("attachedStorageDomainsService:%s", op.path)
}

//
// Provides capability to manage external providers.
//
type externalProviderService struct {
	baseService
}

func NewExternalProviderService(connection *Connection, path string) *externalProviderService {
	var result externalProviderService
	result.connection = connection
	result.path = path
	return &result
}

//
// Import the SSL certificates of the external host provider.
//
type externalProviderServiceImportCertificatesRequest struct {
	externalProviderService *externalProviderService
	header                  map[string]string
	query                   map[string]string
	certificates            *CertificateSlice
}

func (p *externalProviderServiceImportCertificatesRequest) Header(key, value string) *externalProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalProviderServiceImportCertificatesRequest) Query(key, value string) *externalProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalProviderServiceImportCertificatesRequest) Certificates(certificates *CertificateSlice) *externalProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}

func (p *externalProviderServiceImportCertificatesRequest) CertificatesOfAny(anys ...*Certificate) *externalProviderServiceImportCertificatesRequest {
	if p.certificates == nil {
		p.certificates = new(CertificateSlice)
	}
	p.certificates.slice = append(p.certificates.slice, anys...)
	return p
}

func (p *externalProviderServiceImportCertificatesRequest) Send() (*externalProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.externalProviderService.connection.URL(), p.externalProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(externalProviderServiceImportCertificatesResponse), nil
}

func (p *externalProviderServiceImportCertificatesRequest) MustSend() *externalProviderServiceImportCertificatesResponse {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.externalProviderService.connection.URL(), p.externalProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(externalProviderServiceImportCertificatesResponse)
}

//
// Import the SSL certificates of the external host provider.
//
type externalProviderServiceImportCertificatesResponse struct {
}

//
// Import the SSL certificates of the external host provider.
//
func (p *externalProviderService) ImportCertificates() *externalProviderServiceImportCertificatesRequest {
	return &externalProviderServiceImportCertificatesRequest{externalProviderService: p}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type externalProviderServiceTestConnectivityRequest struct {
	externalProviderService *externalProviderService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *externalProviderServiceTestConnectivityRequest) Header(key, value string) *externalProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalProviderServiceTestConnectivityRequest) Query(key, value string) *externalProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalProviderServiceTestConnectivityRequest) Async(async bool) *externalProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}

func (p *externalProviderServiceTestConnectivityRequest) Send() (*externalProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.externalProviderService.connection.URL(), p.externalProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(externalProviderServiceTestConnectivityResponse), nil
}

func (p *externalProviderServiceTestConnectivityRequest) MustSend() *externalProviderServiceTestConnectivityResponse {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.externalProviderService.connection.URL(), p.externalProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(externalProviderServiceTestConnectivityResponse)
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type externalProviderServiceTestConnectivityResponse struct {
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
func (p *externalProviderService) TestConnectivity() *externalProviderServiceTestConnectivityRequest {
	return &externalProviderServiceTestConnectivityRequest{externalProviderService: p}
}

//
// A service to view certificates for this external provider.
//
func (op *externalProviderService) CertificatesService() *externalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.connection, fmt.Sprintf("%s/certificates", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalProviderService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *externalProviderService) String() string {
	return fmt.Sprintf("externalProviderService:%s", op.path)
}

//
// A service that provides information about an application installed in a virtual machine.
//
type vmApplicationService struct {
	baseService
}

func NewVmApplicationService(connection *Connection, path string) *vmApplicationService {
	var result vmApplicationService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the information about the application.
//
type vmApplicationServiceGetRequest struct {
	vmApplicationService *vmApplicationService
	header               map[string]string
	query                map[string]string
	filter               *bool
	follow               *string
}

func (p *vmApplicationServiceGetRequest) Header(key, value string) *vmApplicationServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmApplicationServiceGetRequest) Query(key, value string) *vmApplicationServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmApplicationServiceGetRequest) Filter(filter bool) *vmApplicationServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *vmApplicationServiceGetRequest) Follow(follow string) *vmApplicationServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vmApplicationServiceGetRequest) Send() (*vmApplicationServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmApplicationService.connection.URL(), p.vmApplicationService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmApplicationService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmApplicationService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLApplicationReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmApplicationServiceGetResponse{application: result}, nil
}

func (p *vmApplicationServiceGetRequest) MustSend() *vmApplicationServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmApplicationService.connection.URL(), p.vmApplicationService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmApplicationService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmApplicationService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLApplicationReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmApplicationServiceGetResponse{application: result}
}

//
// Returns the information about the application.
//
type vmApplicationServiceGetResponse struct {
	application *Application
}

func (p *vmApplicationServiceGetResponse) Application() (*Application, bool) {
	if p.application != nil {
		return p.application, true
	}
	return nil, false
}

func (p *vmApplicationServiceGetResponse) MustApplication() *Application {
	if p.application == nil {
		panic("application in response does not exist")
	}
	return p.application
}

//
// Returns the information about the application.
//
func (p *vmApplicationService) Get() *vmApplicationServiceGetRequest {
	return &vmApplicationServiceGetRequest{vmApplicationService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmApplicationService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vmApplicationService) String() string {
	return fmt.Sprintf("vmApplicationService:%s", op.path)
}

//
//
type weightsService struct {
	baseService
}

func NewWeightsService(connection *Connection, path string) *weightsService {
	var result weightsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a weight to a specified user defined scheduling policy.
//
type weightsServiceAddRequest struct {
	weightsService *weightsService
	header         map[string]string
	query          map[string]string
	weight         *Weight
}

func (p *weightsServiceAddRequest) Header(key, value string) *weightsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *weightsServiceAddRequest) Query(key, value string) *weightsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *weightsServiceAddRequest) Weight(weight *Weight) *weightsServiceAddRequest {
	p.weight = weight
	return p
}

func (p *weightsServiceAddRequest) Send() (*weightsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.weightsService.connection.URL(), p.weightsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWeightWriteOne(writer, p.weight, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.weightsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.weightsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWeightReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &weightsServiceAddResponse{weight: result}, nil
}

func (p *weightsServiceAddRequest) MustSend() *weightsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.weightsService.connection.URL(), p.weightsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWeightWriteOne(writer, p.weight, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.weightsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.weightsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWeightReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &weightsServiceAddResponse{weight: result}
}

//
// Add a weight to a specified user defined scheduling policy.
//
type weightsServiceAddResponse struct {
	weight *Weight
}

func (p *weightsServiceAddResponse) Weight() (*Weight, bool) {
	if p.weight != nil {
		return p.weight, true
	}
	return nil, false
}

func (p *weightsServiceAddResponse) MustWeight() *Weight {
	if p.weight == nil {
		panic("weight in response does not exist")
	}
	return p.weight
}

//
// Add a weight to a specified user defined scheduling policy.
//
func (p *weightsService) Add() *weightsServiceAddRequest {
	return &weightsServiceAddRequest{weightsService: p}
}

//
// Returns the list of weights.
// The order of the returned list of weights isn't guaranteed.
//
type weightsServiceListRequest struct {
	weightsService *weightsService
	header         map[string]string
	query          map[string]string
	filter         *bool
	follow         *string
	max            *int64
}

func (p *weightsServiceListRequest) Header(key, value string) *weightsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *weightsServiceListRequest) Query(key, value string) *weightsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *weightsServiceListRequest) Filter(filter bool) *weightsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *weightsServiceListRequest) Follow(follow string) *weightsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *weightsServiceListRequest) Max(max int64) *weightsServiceListRequest {
	p.max = &max
	return p
}

func (p *weightsServiceListRequest) Send() (*weightsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.weightsService.connection.URL(), p.weightsService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.weightsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.weightsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWeightReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &weightsServiceListResponse{weights: result}, nil
}

func (p *weightsServiceListRequest) MustSend() *weightsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.weightsService.connection.URL(), p.weightsService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.weightsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.weightsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWeightReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &weightsServiceListResponse{weights: result}
}

//
// Returns the list of weights.
// The order of the returned list of weights isn't guaranteed.
//
type weightsServiceListResponse struct {
	weights *WeightSlice
}

func (p *weightsServiceListResponse) Weights() (*WeightSlice, bool) {
	if p.weights != nil {
		return p.weights, true
	}
	return nil, false
}

func (p *weightsServiceListResponse) MustWeights() *WeightSlice {
	if p.weights == nil {
		panic("weights in response does not exist")
	}
	return p.weights
}

//
// Returns the list of weights.
// The order of the returned list of weights isn't guaranteed.
//
func (p *weightsService) List() *weightsServiceListRequest {
	return &weightsServiceListRequest{weightsService: p}
}

//
//
func (op *weightsService) WeightService(id string) *weightService {
	return NewWeightService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *weightsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.WeightService(path), nil
	}
	return op.WeightService(path[:index]).Service(path[index+1:])
}

func (op *weightsService) String() string {
	return fmt.Sprintf("weightsService:%s", op.path)
}

//
//
type statisticsService struct {
	baseService
}

func NewStatisticsService(connection *Connection, path string) *statisticsService {
	var result statisticsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves a list of statistics.
// For example, to retrieve the statistics for virtual machine `123` send a
// request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics
// ----
// The result will be like this:
// [source,xml]
// ----
// <statistics>
//   <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//     <name>memory.installed</name>
//     <description>Total memory configured</description>
//     <kind>gauge</kind>
//     <type>integer</type>
//     <unit>bytes</unit>
//     <values>
//       <value>
//         <datum>1073741824</datum>
//       </value>
//     </values>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </statistic>
//   ...
// </statistics>
// ----
// Just a single part of the statistics can be retrieved by specifying its id at the end of the URI. That means:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics/456
// ----
// Outputs:
// [source,xml]
// ----
// <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//   <name>memory.installed</name>
//   <description>Total memory configured</description>
//   <kind>gauge</kind>
//   <type>integer</type>
//   <unit>bytes</unit>
//   <values>
//     <value>
//       <datum>1073741824</datum>
//     </value>
//   </values>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </statistic>
// ----
// The order of the returned list of statistics isn't guaranteed.
//
type statisticsServiceListRequest struct {
	statisticsService *statisticsService
	header            map[string]string
	query             map[string]string
	follow            *string
	max               *int64
}

func (p *statisticsServiceListRequest) Header(key, value string) *statisticsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *statisticsServiceListRequest) Query(key, value string) *statisticsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *statisticsServiceListRequest) Follow(follow string) *statisticsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *statisticsServiceListRequest) Max(max int64) *statisticsServiceListRequest {
	p.max = &max
	return p
}

func (p *statisticsServiceListRequest) Send() (*statisticsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.statisticsService.connection.URL(), p.statisticsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.statisticsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.statisticsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStatisticReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &statisticsServiceListResponse{statistics: result}, nil
}

func (p *statisticsServiceListRequest) MustSend() *statisticsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.statisticsService.connection.URL(), p.statisticsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.statisticsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.statisticsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStatisticReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &statisticsServiceListResponse{statistics: result}
}

//
// Retrieves a list of statistics.
// For example, to retrieve the statistics for virtual machine `123` send a
// request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics
// ----
// The result will be like this:
// [source,xml]
// ----
// <statistics>
//   <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//     <name>memory.installed</name>
//     <description>Total memory configured</description>
//     <kind>gauge</kind>
//     <type>integer</type>
//     <unit>bytes</unit>
//     <values>
//       <value>
//         <datum>1073741824</datum>
//       </value>
//     </values>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </statistic>
//   ...
// </statistics>
// ----
// Just a single part of the statistics can be retrieved by specifying its id at the end of the URI. That means:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics/456
// ----
// Outputs:
// [source,xml]
// ----
// <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//   <name>memory.installed</name>
//   <description>Total memory configured</description>
//   <kind>gauge</kind>
//   <type>integer</type>
//   <unit>bytes</unit>
//   <values>
//     <value>
//       <datum>1073741824</datum>
//     </value>
//   </values>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </statistic>
// ----
// The order of the returned list of statistics isn't guaranteed.
//
type statisticsServiceListResponse struct {
	statistics *StatisticSlice
}

func (p *statisticsServiceListResponse) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *statisticsServiceListResponse) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("statistics in response does not exist")
	}
	return p.statistics
}

//
// Retrieves a list of statistics.
// For example, to retrieve the statistics for virtual machine `123` send a
// request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics
// ----
// The result will be like this:
// [source,xml]
// ----
// <statistics>
//   <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//     <name>memory.installed</name>
//     <description>Total memory configured</description>
//     <kind>gauge</kind>
//     <type>integer</type>
//     <unit>bytes</unit>
//     <values>
//       <value>
//         <datum>1073741824</datum>
//       </value>
//     </values>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </statistic>
//   ...
// </statistics>
// ----
// Just a single part of the statistics can be retrieved by specifying its id at the end of the URI. That means:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics/456
// ----
// Outputs:
// [source,xml]
// ----
// <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//   <name>memory.installed</name>
//   <description>Total memory configured</description>
//   <kind>gauge</kind>
//   <type>integer</type>
//   <unit>bytes</unit>
//   <values>
//     <value>
//       <datum>1073741824</datum>
//     </value>
//   </values>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </statistic>
// ----
// The order of the returned list of statistics isn't guaranteed.
//
func (p *statisticsService) List() *statisticsServiceListRequest {
	return &statisticsServiceListRequest{statisticsService: p}
}

//
//
func (op *statisticsService) StatisticService(id string) *statisticService {
	return NewStatisticService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *statisticsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StatisticService(path), nil
	}
	return op.StatisticService(path[:index]).Service(path[index+1:])
}

func (op *statisticsService) String() string {
	return fmt.Sprintf("statisticsService:%s", op.path)
}

//
// The affinity groups service manages virtual machine relationships and dependencies.
//
type affinityGroupsService struct {
	baseService
}

func NewAffinityGroupsService(connection *Connection, path string) *affinityGroupsService {
	var result affinityGroupsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Create a new affinity group.
// Post a request like in the example below to create a new affinity group:
// [source]
// ----
// POST /ovirt-engine/api/clusters/000-000/affinitygroups
// ----
// And use the following example in its body:
// [source,xml]
// ----
// <affinity_group>
//   <name>AF_GROUP_001</name>
//   <hosts_rule>
//     <enforcing>true</enforcing>
//     <positive>true</positive>
//   </hosts_rule>
//   <vms_rule>
//     <enabled>false</enabled>
//   </vms_rule>
// </affinity_group>
// ----
//
type affinityGroupsServiceAddRequest struct {
	affinityGroupsService *affinityGroupsService
	header                map[string]string
	query                 map[string]string
	group                 *AffinityGroup
}

func (p *affinityGroupsServiceAddRequest) Header(key, value string) *affinityGroupsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityGroupsServiceAddRequest) Query(key, value string) *affinityGroupsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityGroupsServiceAddRequest) Group(group *AffinityGroup) *affinityGroupsServiceAddRequest {
	p.group = group
	return p
}

func (p *affinityGroupsServiceAddRequest) Send() (*affinityGroupsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupsService.connection.URL(), p.affinityGroupsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityGroupWriteOne(writer, p.group, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &affinityGroupsServiceAddResponse{group: result}, nil
}

func (p *affinityGroupsServiceAddRequest) MustSend() *affinityGroupsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupsService.connection.URL(), p.affinityGroupsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityGroupWriteOne(writer, p.group, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityGroupReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &affinityGroupsServiceAddResponse{group: result}
}

//
// Create a new affinity group.
// Post a request like in the example below to create a new affinity group:
// [source]
// ----
// POST /ovirt-engine/api/clusters/000-000/affinitygroups
// ----
// And use the following example in its body:
// [source,xml]
// ----
// <affinity_group>
//   <name>AF_GROUP_001</name>
//   <hosts_rule>
//     <enforcing>true</enforcing>
//     <positive>true</positive>
//   </hosts_rule>
//   <vms_rule>
//     <enabled>false</enabled>
//   </vms_rule>
// </affinity_group>
// ----
//
type affinityGroupsServiceAddResponse struct {
	group *AffinityGroup
}

func (p *affinityGroupsServiceAddResponse) Group() (*AffinityGroup, bool) {
	if p.group != nil {
		return p.group, true
	}
	return nil, false
}

func (p *affinityGroupsServiceAddResponse) MustGroup() *AffinityGroup {
	if p.group == nil {
		panic("group in response does not exist")
	}
	return p.group
}

//
// Create a new affinity group.
// Post a request like in the example below to create a new affinity group:
// [source]
// ----
// POST /ovirt-engine/api/clusters/000-000/affinitygroups
// ----
// And use the following example in its body:
// [source,xml]
// ----
// <affinity_group>
//   <name>AF_GROUP_001</name>
//   <hosts_rule>
//     <enforcing>true</enforcing>
//     <positive>true</positive>
//   </hosts_rule>
//   <vms_rule>
//     <enabled>false</enabled>
//   </vms_rule>
// </affinity_group>
// ----
//
func (p *affinityGroupsService) Add() *affinityGroupsServiceAddRequest {
	return &affinityGroupsServiceAddRequest{affinityGroupsService: p}
}

//
// List existing affinity groups.
// The order of the affinity groups results isn't guaranteed.
//
type affinityGroupsServiceListRequest struct {
	affinityGroupsService *affinityGroupsService
	header                map[string]string
	query                 map[string]string
	follow                *string
	max                   *int64
}

func (p *affinityGroupsServiceListRequest) Header(key, value string) *affinityGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *affinityGroupsServiceListRequest) Query(key, value string) *affinityGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *affinityGroupsServiceListRequest) Follow(follow string) *affinityGroupsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *affinityGroupsServiceListRequest) Max(max int64) *affinityGroupsServiceListRequest {
	p.max = &max
	return p
}

func (p *affinityGroupsServiceListRequest) Send() (*affinityGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupsService.connection.URL(), p.affinityGroupsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityGroupReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &affinityGroupsServiceListResponse{groups: result}, nil
}

func (p *affinityGroupsServiceListRequest) MustSend() *affinityGroupsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.affinityGroupsService.connection.URL(), p.affinityGroupsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.affinityGroupsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.affinityGroupsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityGroupReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &affinityGroupsServiceListResponse{groups: result}
}

//
// List existing affinity groups.
// The order of the affinity groups results isn't guaranteed.
//
type affinityGroupsServiceListResponse struct {
	groups *AffinityGroupSlice
}

func (p *affinityGroupsServiceListResponse) Groups() (*AffinityGroupSlice, bool) {
	if p.groups != nil {
		return p.groups, true
	}
	return nil, false
}

func (p *affinityGroupsServiceListResponse) MustGroups() *AffinityGroupSlice {
	if p.groups == nil {
		panic("groups in response does not exist")
	}
	return p.groups
}

//
// List existing affinity groups.
// The order of the affinity groups results isn't guaranteed.
//
func (p *affinityGroupsService) List() *affinityGroupsServiceListRequest {
	return &affinityGroupsServiceListRequest{affinityGroupsService: p}
}

//
// Access the affinity group service that manages the affinity group specified by an ID.
//
func (op *affinityGroupsService) GroupService(id string) *affinityGroupService {
	return NewAffinityGroupService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *affinityGroupsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.GroupService(path), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *affinityGroupsService) String() string {
	return fmt.Sprintf("affinityGroupsService:%s", op.path)
}

//
// A service to manage assignment of specific tag to specific entities in system.
//
type assignedTagService struct {
	baseService
}

func NewAssignedTagService(connection *Connection, path string) *assignedTagService {
	var result assignedTagService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the information about the assigned tag.
// For example to retrieve the information about the tag with the id `456` which is assigned to virtual machine
// with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags/456
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/456" id="456">
//   <name>root</name>
//   <description>root</description>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </tag>
// ----
//
type assignedTagServiceGetRequest struct {
	assignedTagService *assignedTagService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *assignedTagServiceGetRequest) Header(key, value string) *assignedTagServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedTagServiceGetRequest) Query(key, value string) *assignedTagServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedTagServiceGetRequest) Follow(follow string) *assignedTagServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *assignedTagServiceGetRequest) Send() (*assignedTagServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagService.connection.URL(), p.assignedTagService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedTagService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedTagService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &assignedTagServiceGetResponse{tag: result}, nil
}

func (p *assignedTagServiceGetRequest) MustSend() *assignedTagServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagService.connection.URL(), p.assignedTagService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedTagService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedTagService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &assignedTagServiceGetResponse{tag: result}
}

//
// Gets the information about the assigned tag.
// For example to retrieve the information about the tag with the id `456` which is assigned to virtual machine
// with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags/456
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/456" id="456">
//   <name>root</name>
//   <description>root</description>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </tag>
// ----
//
type assignedTagServiceGetResponse struct {
	tag *Tag
}

func (p *assignedTagServiceGetResponse) Tag() (*Tag, bool) {
	if p.tag != nil {
		return p.tag, true
	}
	return nil, false
}

func (p *assignedTagServiceGetResponse) MustTag() *Tag {
	if p.tag == nil {
		panic("tag in response does not exist")
	}
	return p.tag
}

//
// Gets the information about the assigned tag.
// For example to retrieve the information about the tag with the id `456` which is assigned to virtual machine
// with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags/456
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/456" id="456">
//   <name>root</name>
//   <description>root</description>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </tag>
// ----
//
func (p *assignedTagService) Get() *assignedTagServiceGetRequest {
	return &assignedTagServiceGetRequest{assignedTagService: p}
}

//
// Unassign tag from specific entity in the system.
// For example to unassign the tag with id `456` from virtual machine with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/vms/123/tags/456
// ....
//
type assignedTagServiceRemoveRequest struct {
	assignedTagService *assignedTagService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *assignedTagServiceRemoveRequest) Header(key, value string) *assignedTagServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedTagServiceRemoveRequest) Query(key, value string) *assignedTagServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedTagServiceRemoveRequest) Async(async bool) *assignedTagServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *assignedTagServiceRemoveRequest) Send() (*assignedTagServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagService.connection.URL(), p.assignedTagService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedTagService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedTagService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(assignedTagServiceRemoveResponse), nil
}

func (p *assignedTagServiceRemoveRequest) MustSend() *assignedTagServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedTagService.connection.URL(), p.assignedTagService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedTagService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedTagService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(assignedTagServiceRemoveResponse)
}

//
// Unassign tag from specific entity in the system.
// For example to unassign the tag with id `456` from virtual machine with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/vms/123/tags/456
// ....
//
type assignedTagServiceRemoveResponse struct {
}

//
// Unassign tag from specific entity in the system.
// For example to unassign the tag with id `456` from virtual machine with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/vms/123/tags/456
// ....
//
func (p *assignedTagService) Remove() *assignedTagServiceRemoveRequest {
	return &assignedTagServiceRemoveRequest{assignedTagService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *assignedTagService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *assignedTagService) String() string {
	return fmt.Sprintf("assignedTagService:%s", op.path)
}

//
//
type attachedStorageDomainService struct {
	baseService
}

func NewAttachedStorageDomainService(connection *Connection, path string) *attachedStorageDomainService {
	var result attachedStorageDomainService
	result.connection = connection
	result.path = path
	return &result
}

//
// This operation activates an attached storage domain.
// Once the storage domain is activated it is ready for use with the data center.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/activate
// ----
// The activate action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type attachedStorageDomainServiceActivateRequest struct {
	attachedStorageDomainService *attachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *attachedStorageDomainServiceActivateRequest) Header(key, value string) *attachedStorageDomainServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainServiceActivateRequest) Query(key, value string) *attachedStorageDomainServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainServiceActivateRequest) Async(async bool) *attachedStorageDomainServiceActivateRequest {
	p.async = &async
	return p
}

func (p *attachedStorageDomainServiceActivateRequest) Send() (*attachedStorageDomainServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.attachedStorageDomainService.connection.URL(), p.attachedStorageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(attachedStorageDomainServiceActivateResponse), nil
}

func (p *attachedStorageDomainServiceActivateRequest) MustSend() *attachedStorageDomainServiceActivateResponse {
	rawURL := fmt.Sprintf("%s%s/activate", p.attachedStorageDomainService.connection.URL(), p.attachedStorageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(attachedStorageDomainServiceActivateResponse)
}

//
// This operation activates an attached storage domain.
// Once the storage domain is activated it is ready for use with the data center.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/activate
// ----
// The activate action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type attachedStorageDomainServiceActivateResponse struct {
}

//
// This operation activates an attached storage domain.
// Once the storage domain is activated it is ready for use with the data center.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/activate
// ----
// The activate action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *attachedStorageDomainService) Activate() *attachedStorageDomainServiceActivateRequest {
	return &attachedStorageDomainServiceActivateRequest{attachedStorageDomainService: p}
}

//
// This operation deactivates an attached storage domain.
// Once the storage domain is deactivated it will not be used with the data center.
// For example, to deactivate storage domain `456`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/deactivate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
// If the `force` parameter is `true` then the operation will succeed, even if the OVF update which takes place
// before the deactivation of the storage domain failed. If the `force` parameter is `false` and the OVF update failed,
// the deactivation of the storage domain will also fail.
//
type attachedStorageDomainServiceDeactivateRequest struct {
	attachedStorageDomainService *attachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
	force                        *bool
}

func (p *attachedStorageDomainServiceDeactivateRequest) Header(key, value string) *attachedStorageDomainServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainServiceDeactivateRequest) Query(key, value string) *attachedStorageDomainServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainServiceDeactivateRequest) Async(async bool) *attachedStorageDomainServiceDeactivateRequest {
	p.async = &async
	return p
}

func (p *attachedStorageDomainServiceDeactivateRequest) Force(force bool) *attachedStorageDomainServiceDeactivateRequest {
	p.force = &force
	return p
}

func (p *attachedStorageDomainServiceDeactivateRequest) Send() (*attachedStorageDomainServiceDeactivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.attachedStorageDomainService.connection.URL(), p.attachedStorageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(attachedStorageDomainServiceDeactivateResponse), nil
}

func (p *attachedStorageDomainServiceDeactivateRequest) MustSend() *attachedStorageDomainServiceDeactivateResponse {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.attachedStorageDomainService.connection.URL(), p.attachedStorageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(attachedStorageDomainServiceDeactivateResponse)
}

//
// This operation deactivates an attached storage domain.
// Once the storage domain is deactivated it will not be used with the data center.
// For example, to deactivate storage domain `456`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/deactivate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
// If the `force` parameter is `true` then the operation will succeed, even if the OVF update which takes place
// before the deactivation of the storage domain failed. If the `force` parameter is `false` and the OVF update failed,
// the deactivation of the storage domain will also fail.
//
type attachedStorageDomainServiceDeactivateResponse struct {
}

//
// This operation deactivates an attached storage domain.
// Once the storage domain is deactivated it will not be used with the data center.
// For example, to deactivate storage domain `456`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/deactivate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
// If the `force` parameter is `true` then the operation will succeed, even if the OVF update which takes place
// before the deactivation of the storage domain failed. If the `force` parameter is `false` and the OVF update failed,
// the deactivation of the storage domain will also fail.
//
func (p *attachedStorageDomainService) Deactivate() *attachedStorageDomainServiceDeactivateRequest {
	return &attachedStorageDomainServiceDeactivateRequest{attachedStorageDomainService: p}
}

//
//
type attachedStorageDomainServiceGetRequest struct {
	attachedStorageDomainService *attachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
}

func (p *attachedStorageDomainServiceGetRequest) Header(key, value string) *attachedStorageDomainServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainServiceGetRequest) Query(key, value string) *attachedStorageDomainServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainServiceGetRequest) Follow(follow string) *attachedStorageDomainServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *attachedStorageDomainServiceGetRequest) Send() (*attachedStorageDomainServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainService.connection.URL(), p.attachedStorageDomainService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &attachedStorageDomainServiceGetResponse{storageDomain: result}, nil
}

func (p *attachedStorageDomainServiceGetRequest) MustSend() *attachedStorageDomainServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainService.connection.URL(), p.attachedStorageDomainService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &attachedStorageDomainServiceGetResponse{storageDomain: result}
}

//
//
type attachedStorageDomainServiceGetResponse struct {
	storageDomain *StorageDomain
}

func (p *attachedStorageDomainServiceGetResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *attachedStorageDomainServiceGetResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
//
func (p *attachedStorageDomainService) Get() *attachedStorageDomainServiceGetRequest {
	return &attachedStorageDomainServiceGetRequest{attachedStorageDomainService: p}
}

//
//
type attachedStorageDomainServiceRemoveRequest struct {
	attachedStorageDomainService *attachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *attachedStorageDomainServiceRemoveRequest) Header(key, value string) *attachedStorageDomainServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *attachedStorageDomainServiceRemoveRequest) Query(key, value string) *attachedStorageDomainServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *attachedStorageDomainServiceRemoveRequest) Async(async bool) *attachedStorageDomainServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *attachedStorageDomainServiceRemoveRequest) Send() (*attachedStorageDomainServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainService.connection.URL(), p.attachedStorageDomainService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(attachedStorageDomainServiceRemoveResponse), nil
}

func (p *attachedStorageDomainServiceRemoveRequest) MustSend() *attachedStorageDomainServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.attachedStorageDomainService.connection.URL(), p.attachedStorageDomainService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.attachedStorageDomainService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.attachedStorageDomainService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(attachedStorageDomainServiceRemoveResponse)
}

//
//
type attachedStorageDomainServiceRemoveResponse struct {
}

//
//
func (p *attachedStorageDomainService) Remove() *attachedStorageDomainServiceRemoveRequest {
	return &attachedStorageDomainServiceRemoveRequest{attachedStorageDomainService: p}
}

//
//
func (op *attachedStorageDomainService) DisksService() *attachedStorageDomainDisksService {
	return NewAttachedStorageDomainDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *attachedStorageDomainService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *attachedStorageDomainService) String() string {
	return fmt.Sprintf("attachedStorageDomainService:%s", op.path)
}

//
// A service to manage Katello errata.
// The information is retrieved from Katello.
//
type katelloErrataService struct {
	baseService
}

func NewKatelloErrataService(connection *Connection, path string) *katelloErrataService {
	var result katelloErrataService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// The order of the returned list of erratum isn't guaranteed.
//
type katelloErrataServiceListRequest struct {
	katelloErrataService *katelloErrataService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *katelloErrataServiceListRequest) Header(key, value string) *katelloErrataServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *katelloErrataServiceListRequest) Query(key, value string) *katelloErrataServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *katelloErrataServiceListRequest) Follow(follow string) *katelloErrataServiceListRequest {
	p.follow = &follow
	return p
}

func (p *katelloErrataServiceListRequest) Max(max int64) *katelloErrataServiceListRequest {
	p.max = &max
	return p
}

func (p *katelloErrataServiceListRequest) Send() (*katelloErrataServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.katelloErrataService.connection.URL(), p.katelloErrataService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.katelloErrataService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.katelloErrataService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLKatelloErratumReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &katelloErrataServiceListResponse{errata: result}, nil
}

func (p *katelloErrataServiceListRequest) MustSend() *katelloErrataServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.katelloErrataService.connection.URL(), p.katelloErrataService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.katelloErrataService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.katelloErrataService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLKatelloErratumReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &katelloErrataServiceListResponse{errata: result}
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// The order of the returned list of erratum isn't guaranteed.
//
type katelloErrataServiceListResponse struct {
	errata *KatelloErratumSlice
}

func (p *katelloErrataServiceListResponse) Errata() (*KatelloErratumSlice, bool) {
	if p.errata != nil {
		return p.errata, true
	}
	return nil, false
}

func (p *katelloErrataServiceListResponse) MustErrata() *KatelloErratumSlice {
	if p.errata == nil {
		panic("errata in response does not exist")
	}
	return p.errata
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// The order of the returned list of erratum isn't guaranteed.
//
func (p *katelloErrataService) List() *katelloErrataServiceListRequest {
	return &katelloErrataServiceListRequest{katelloErrataService: p}
}

//
// Reference to the Katello erratum service.
// Use this service to view the erratum by its id.
//
func (op *katelloErrataService) KatelloErratumService(id string) *katelloErratumService {
	return NewKatelloErratumService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *katelloErrataService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.KatelloErratumService(path), nil
	}
	return op.KatelloErratumService(path[:index]).Service(path[index+1:])
}

func (op *katelloErrataService) String() string {
	return fmt.Sprintf("katelloErrataService:%s", op.path)
}

//
// This service manages hostgroups.
//
type externalHostGroupsService struct {
	baseService
}

func NewExternalHostGroupsService(connection *Connection, path string) *externalHostGroupsService {
	var result externalHostGroupsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get host groups list from external host provider.
// Host group is a term of host providers - the host group includes provision details. This API returns all possible
// hostgroups exposed by the external provider.
// For example, to get the details of all host groups of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/hostgroups
// ....
// The response will be like this:
// [source,xml]
// ----
// <external_host_groups>
//   <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
//     <name>rhel7</name>
//     <architecture_name>x86_64</architecture_name>
//     <domain_name>example.com</domain_name>
//     <operating_system_name>RedHat 7.3</operating_system_name>
//     <subnet_name>sat0</subnet_name>
//     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//   </external_host_group>
//   ...
// </external_host_groups>
// ----
// The order of the returned list of host groups isn't guaranteed.
//
type externalHostGroupsServiceListRequest struct {
	externalHostGroupsService *externalHostGroupsService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
}

func (p *externalHostGroupsServiceListRequest) Header(key, value string) *externalHostGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalHostGroupsServiceListRequest) Query(key, value string) *externalHostGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalHostGroupsServiceListRequest) Follow(follow string) *externalHostGroupsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *externalHostGroupsServiceListRequest) Max(max int64) *externalHostGroupsServiceListRequest {
	p.max = &max
	return p
}

func (p *externalHostGroupsServiceListRequest) Send() (*externalHostGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostGroupsService.connection.URL(), p.externalHostGroupsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostGroupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostGroupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostGroupReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &externalHostGroupsServiceListResponse{groups: result}, nil
}

func (p *externalHostGroupsServiceListRequest) MustSend() *externalHostGroupsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalHostGroupsService.connection.URL(), p.externalHostGroupsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostGroupsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostGroupsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostGroupReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &externalHostGroupsServiceListResponse{groups: result}
}

//
// Get host groups list from external host provider.
// Host group is a term of host providers - the host group includes provision details. This API returns all possible
// hostgroups exposed by the external provider.
// For example, to get the details of all host groups of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/hostgroups
// ....
// The response will be like this:
// [source,xml]
// ----
// <external_host_groups>
//   <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
//     <name>rhel7</name>
//     <architecture_name>x86_64</architecture_name>
//     <domain_name>example.com</domain_name>
//     <operating_system_name>RedHat 7.3</operating_system_name>
//     <subnet_name>sat0</subnet_name>
//     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//   </external_host_group>
//   ...
// </external_host_groups>
// ----
// The order of the returned list of host groups isn't guaranteed.
//
type externalHostGroupsServiceListResponse struct {
	groups *ExternalHostGroupSlice
}

func (p *externalHostGroupsServiceListResponse) Groups() (*ExternalHostGroupSlice, bool) {
	if p.groups != nil {
		return p.groups, true
	}
	return nil, false
}

func (p *externalHostGroupsServiceListResponse) MustGroups() *ExternalHostGroupSlice {
	if p.groups == nil {
		panic("groups in response does not exist")
	}
	return p.groups
}

//
// Get host groups list from external host provider.
// Host group is a term of host providers - the host group includes provision details. This API returns all possible
// hostgroups exposed by the external provider.
// For example, to get the details of all host groups of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/hostgroups
// ....
// The response will be like this:
// [source,xml]
// ----
// <external_host_groups>
//   <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
//     <name>rhel7</name>
//     <architecture_name>x86_64</architecture_name>
//     <domain_name>example.com</domain_name>
//     <operating_system_name>RedHat 7.3</operating_system_name>
//     <subnet_name>sat0</subnet_name>
//     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//   </external_host_group>
//   ...
// </external_host_groups>
// ----
// The order of the returned list of host groups isn't guaranteed.
//
func (p *externalHostGroupsService) List() *externalHostGroupsServiceListRequest {
	return &externalHostGroupsServiceListRequest{externalHostGroupsService: p}
}

//
// This service manages hostgroup instance.
//
func (op *externalHostGroupsService) GroupService(id string) *externalHostGroupService {
	return NewExternalHostGroupService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalHostGroupsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.GroupService(path), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *externalHostGroupsService) String() string {
	return fmt.Sprintf("externalHostGroupsService:%s", op.path)
}

//
// A service to manage a Katello erratum.
//
type katelloErratumService struct {
	baseService
}

func NewKatelloErratumService(connection *Connection, path string) *katelloErratumService {
	var result katelloErratumService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves a Katello erratum.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//   <name>RHBA-2013:XYZ</name>
//   <description>The description of the erratum</description>
//   <title>some bug fix update</title>
//   <type>bugfix</type>
//   <issued>2013-11-20T02:00:00.000+02:00</issued>
//   <solution>Few guidelines regarding the solution</solution>
//   <summary>Updated packages that fix one bug are now available for XYZ</summary>
//   <packages>
//     <package>
//       <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//     </package>
//     ...
//   </packages>
// </katello_erratum>
// ----
//
type katelloErratumServiceGetRequest struct {
	katelloErratumService *katelloErratumService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *katelloErratumServiceGetRequest) Header(key, value string) *katelloErratumServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *katelloErratumServiceGetRequest) Query(key, value string) *katelloErratumServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *katelloErratumServiceGetRequest) Follow(follow string) *katelloErratumServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *katelloErratumServiceGetRequest) Send() (*katelloErratumServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.katelloErratumService.connection.URL(), p.katelloErratumService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.katelloErratumService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.katelloErratumService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLKatelloErratumReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &katelloErratumServiceGetResponse{erratum: result}, nil
}

func (p *katelloErratumServiceGetRequest) MustSend() *katelloErratumServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.katelloErratumService.connection.URL(), p.katelloErratumService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.katelloErratumService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.katelloErratumService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLKatelloErratumReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &katelloErratumServiceGetResponse{erratum: result}
}

//
// Retrieves a Katello erratum.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//   <name>RHBA-2013:XYZ</name>
//   <description>The description of the erratum</description>
//   <title>some bug fix update</title>
//   <type>bugfix</type>
//   <issued>2013-11-20T02:00:00.000+02:00</issued>
//   <solution>Few guidelines regarding the solution</solution>
//   <summary>Updated packages that fix one bug are now available for XYZ</summary>
//   <packages>
//     <package>
//       <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//     </package>
//     ...
//   </packages>
// </katello_erratum>
// ----
//
type katelloErratumServiceGetResponse struct {
	erratum *KatelloErratum
}

func (p *katelloErratumServiceGetResponse) Erratum() (*KatelloErratum, bool) {
	if p.erratum != nil {
		return p.erratum, true
	}
	return nil, false
}

func (p *katelloErratumServiceGetResponse) MustErratum() *KatelloErratum {
	if p.erratum == nil {
		panic("erratum in response does not exist")
	}
	return p.erratum
}

//
// Retrieves a Katello erratum.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//   <name>RHBA-2013:XYZ</name>
//   <description>The description of the erratum</description>
//   <title>some bug fix update</title>
//   <type>bugfix</type>
//   <issued>2013-11-20T02:00:00.000+02:00</issued>
//   <solution>Few guidelines regarding the solution</solution>
//   <summary>Updated packages that fix one bug are now available for XYZ</summary>
//   <packages>
//     <package>
//       <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//     </package>
//     ...
//   </packages>
// </katello_erratum>
// ----
//
func (p *katelloErratumService) Get() *katelloErratumServiceGetRequest {
	return &katelloErratumServiceGetRequest{katelloErratumService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *katelloErratumService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *katelloErratumService) String() string {
	return fmt.Sprintf("katelloErratumService:%s", op.path)
}

//
// This service manages external discovered hosts.
//
type externalDiscoveredHostsService struct {
	baseService
}

func NewExternalDiscoveredHostsService(connection *Connection, path string) *externalDiscoveredHostsService {
	var result externalDiscoveredHostsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get list of discovered hosts' information.
// Discovered hosts are fetched from third-party providers such as Foreman.
// To list all discovered hosts for provider `123` send the following:
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/discoveredhost
// ----
// [source,xml]
// ----
// <external_discovered_hosts>
//  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/456" id="456">
//   <name>mac001a4ad04031</name>
//   <ip>10.34.67.42</ip>
//   <last_report>2017-04-24 11:05:41 UTC</last_report>
//   <mac>00:1a:4a:d0:40:31</mac>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//  </external_discovered_host>
//  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/789" id="789">
//   <name>mac001a4ad04040</name>
//   <ip>10.34.67.43</ip>
//   <last_report>2017-04-24 11:05:41 UTC</last_report>
//   <mac>00:1a:4a:d0:40:40</mac>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//  </external_discovered_host>
//  ...
// </external_discovered_hosts>
// ----
// The order of the returned list of hosts isn't guaranteed.
//
type externalDiscoveredHostsServiceListRequest struct {
	externalDiscoveredHostsService *externalDiscoveredHostsService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
	max                            *int64
}

func (p *externalDiscoveredHostsServiceListRequest) Header(key, value string) *externalDiscoveredHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalDiscoveredHostsServiceListRequest) Query(key, value string) *externalDiscoveredHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalDiscoveredHostsServiceListRequest) Follow(follow string) *externalDiscoveredHostsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *externalDiscoveredHostsServiceListRequest) Max(max int64) *externalDiscoveredHostsServiceListRequest {
	p.max = &max
	return p
}

func (p *externalDiscoveredHostsServiceListRequest) Send() (*externalDiscoveredHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalDiscoveredHostsService.connection.URL(), p.externalDiscoveredHostsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalDiscoveredHostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalDiscoveredHostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalDiscoveredHostReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &externalDiscoveredHostsServiceListResponse{hosts: result}, nil
}

func (p *externalDiscoveredHostsServiceListRequest) MustSend() *externalDiscoveredHostsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalDiscoveredHostsService.connection.URL(), p.externalDiscoveredHostsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalDiscoveredHostsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalDiscoveredHostsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalDiscoveredHostReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &externalDiscoveredHostsServiceListResponse{hosts: result}
}

//
// Get list of discovered hosts' information.
// Discovered hosts are fetched from third-party providers such as Foreman.
// To list all discovered hosts for provider `123` send the following:
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/discoveredhost
// ----
// [source,xml]
// ----
// <external_discovered_hosts>
//  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/456" id="456">
//   <name>mac001a4ad04031</name>
//   <ip>10.34.67.42</ip>
//   <last_report>2017-04-24 11:05:41 UTC</last_report>
//   <mac>00:1a:4a:d0:40:31</mac>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//  </external_discovered_host>
//  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/789" id="789">
//   <name>mac001a4ad04040</name>
//   <ip>10.34.67.43</ip>
//   <last_report>2017-04-24 11:05:41 UTC</last_report>
//   <mac>00:1a:4a:d0:40:40</mac>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//  </external_discovered_host>
//  ...
// </external_discovered_hosts>
// ----
// The order of the returned list of hosts isn't guaranteed.
//
type externalDiscoveredHostsServiceListResponse struct {
	hosts *ExternalDiscoveredHostSlice
}

func (p *externalDiscoveredHostsServiceListResponse) Hosts() (*ExternalDiscoveredHostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *externalDiscoveredHostsServiceListResponse) MustHosts() *ExternalDiscoveredHostSlice {
	if p.hosts == nil {
		panic("hosts in response does not exist")
	}
	return p.hosts
}

//
// Get list of discovered hosts' information.
// Discovered hosts are fetched from third-party providers such as Foreman.
// To list all discovered hosts for provider `123` send the following:
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/discoveredhost
// ----
// [source,xml]
// ----
// <external_discovered_hosts>
//  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/456" id="456">
//   <name>mac001a4ad04031</name>
//   <ip>10.34.67.42</ip>
//   <last_report>2017-04-24 11:05:41 UTC</last_report>
//   <mac>00:1a:4a:d0:40:31</mac>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//  </external_discovered_host>
//  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/789" id="789">
//   <name>mac001a4ad04040</name>
//   <ip>10.34.67.43</ip>
//   <last_report>2017-04-24 11:05:41 UTC</last_report>
//   <mac>00:1a:4a:d0:40:40</mac>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//  </external_discovered_host>
//  ...
// </external_discovered_hosts>
// ----
// The order of the returned list of hosts isn't guaranteed.
//
func (p *externalDiscoveredHostsService) List() *externalDiscoveredHostsServiceListRequest {
	return &externalDiscoveredHostsServiceListRequest{externalDiscoveredHostsService: p}
}

//
//
func (op *externalDiscoveredHostsService) HostService(id string) *externalDiscoveredHostService {
	return NewExternalDiscoveredHostService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalDiscoveredHostsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HostService(path), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *externalDiscoveredHostsService) String() string {
	return fmt.Sprintf("externalDiscoveredHostsService:%s", op.path)
}

//
// This service manages a single host group information.
// Host group is a term of host provider - the host group includes provision details that are applied to new discovered
// host. Information such as subnet, operating system, domain, etc.
//
type externalHostGroupService struct {
	baseService
}

func NewExternalHostGroupService(connection *Connection, path string) *externalHostGroupService {
	var result externalHostGroupService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get host group information.
// For example, to get the details of hostgroup `234` of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/hostgroups/234
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
//   <name>rhel7</name>
//   <architecture_name>x86_64</architecture_name>
//   <domain_name>s.com</domain_name>
//   <operating_system_name>RedHat 7.3</operating_system_name>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_host_group>
// ----
//
type externalHostGroupServiceGetRequest struct {
	externalHostGroupService *externalHostGroupService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *externalHostGroupServiceGetRequest) Header(key, value string) *externalHostGroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalHostGroupServiceGetRequest) Query(key, value string) *externalHostGroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalHostGroupServiceGetRequest) Follow(follow string) *externalHostGroupServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *externalHostGroupServiceGetRequest) Send() (*externalHostGroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostGroupService.connection.URL(), p.externalHostGroupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostGroupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostGroupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &externalHostGroupServiceGetResponse{group: result}, nil
}

func (p *externalHostGroupServiceGetRequest) MustSend() *externalHostGroupServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalHostGroupService.connection.URL(), p.externalHostGroupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostGroupService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostGroupService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostGroupReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &externalHostGroupServiceGetResponse{group: result}
}

//
// Get host group information.
// For example, to get the details of hostgroup `234` of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/hostgroups/234
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
//   <name>rhel7</name>
//   <architecture_name>x86_64</architecture_name>
//   <domain_name>s.com</domain_name>
//   <operating_system_name>RedHat 7.3</operating_system_name>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_host_group>
// ----
//
type externalHostGroupServiceGetResponse struct {
	group *ExternalHostGroup
}

func (p *externalHostGroupServiceGetResponse) Group() (*ExternalHostGroup, bool) {
	if p.group != nil {
		return p.group, true
	}
	return nil, false
}

func (p *externalHostGroupServiceGetResponse) MustGroup() *ExternalHostGroup {
	if p.group == nil {
		panic("group in response does not exist")
	}
	return p.group
}

//
// Get host group information.
// For example, to get the details of hostgroup `234` of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/hostgroups/234
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
//   <name>rhel7</name>
//   <architecture_name>x86_64</architecture_name>
//   <domain_name>s.com</domain_name>
//   <operating_system_name>RedHat 7.3</operating_system_name>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_host_group>
// ----
//
func (p *externalHostGroupService) Get() *externalHostGroupServiceGetRequest {
	return &externalHostGroupServiceGetRequest{externalHostGroupService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalHostGroupService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *externalHostGroupService) String() string {
	return fmt.Sprintf("externalHostGroupService:%s", op.path)
}

//
//
type externalHostProvidersService struct {
	baseService
}

func NewExternalHostProvidersService(connection *Connection, path string) *externalHostProvidersService {
	var result externalHostProvidersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new external host provider to the system.
//
type externalHostProvidersServiceAddRequest struct {
	externalHostProvidersService *externalHostProvidersService
	header                       map[string]string
	query                        map[string]string
	provider                     *ExternalHostProvider
}

func (p *externalHostProvidersServiceAddRequest) Header(key, value string) *externalHostProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalHostProvidersServiceAddRequest) Query(key, value string) *externalHostProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalHostProvidersServiceAddRequest) Provider(provider *ExternalHostProvider) *externalHostProvidersServiceAddRequest {
	p.provider = provider
	return p
}

func (p *externalHostProvidersServiceAddRequest) Send() (*externalHostProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProvidersService.connection.URL(), p.externalHostProvidersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLExternalHostProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &externalHostProvidersServiceAddResponse{provider: result}, nil
}

func (p *externalHostProvidersServiceAddRequest) MustSend() *externalHostProvidersServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProvidersService.connection.URL(), p.externalHostProvidersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLExternalHostProviderWriteOne(writer, p.provider, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProvidersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProvidersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostProviderReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &externalHostProvidersServiceAddResponse{provider: result}
}

//
// Add a new external host provider to the system.
//
type externalHostProvidersServiceAddResponse struct {
	provider *ExternalHostProvider
}

func (p *externalHostProvidersServiceAddResponse) Provider() (*ExternalHostProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *externalHostProvidersServiceAddResponse) MustProvider() *ExternalHostProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Add a new external host provider to the system.
//
func (p *externalHostProvidersService) Add() *externalHostProvidersServiceAddRequest {
	return &externalHostProvidersServiceAddRequest{externalHostProvidersService: p}
}

//
// Returns the list of external host providers.
// The order of the returned list of host providers isn't guaranteed.
//
type externalHostProvidersServiceListRequest struct {
	externalHostProvidersService *externalHostProvidersService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
	max                          *int64
}

func (p *externalHostProvidersServiceListRequest) Header(key, value string) *externalHostProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalHostProvidersServiceListRequest) Query(key, value string) *externalHostProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalHostProvidersServiceListRequest) Follow(follow string) *externalHostProvidersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *externalHostProvidersServiceListRequest) Max(max int64) *externalHostProvidersServiceListRequest {
	p.max = &max
	return p
}

func (p *externalHostProvidersServiceListRequest) Send() (*externalHostProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProvidersService.connection.URL(), p.externalHostProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostProviderReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &externalHostProvidersServiceListResponse{providers: result}, nil
}

func (p *externalHostProvidersServiceListRequest) MustSend() *externalHostProvidersServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProvidersService.connection.URL(), p.externalHostProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProvidersService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProvidersService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostProviderReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &externalHostProvidersServiceListResponse{providers: result}
}

//
// Returns the list of external host providers.
// The order of the returned list of host providers isn't guaranteed.
//
type externalHostProvidersServiceListResponse struct {
	providers *ExternalHostProviderSlice
}

func (p *externalHostProvidersServiceListResponse) Providers() (*ExternalHostProviderSlice, bool) {
	if p.providers != nil {
		return p.providers, true
	}
	return nil, false
}

func (p *externalHostProvidersServiceListResponse) MustProviders() *ExternalHostProviderSlice {
	if p.providers == nil {
		panic("providers in response does not exist")
	}
	return p.providers
}

//
// Returns the list of external host providers.
// The order of the returned list of host providers isn't guaranteed.
//
func (p *externalHostProvidersService) List() *externalHostProvidersServiceListRequest {
	return &externalHostProvidersServiceListRequest{externalHostProvidersService: p}
}

//
//
func (op *externalHostProvidersService) ProviderService(id string) *externalHostProviderService {
	return NewExternalHostProviderService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalHostProvidersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProviderService(path), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *externalHostProvidersService) String() string {
	return fmt.Sprintf("externalHostProvidersService:%s", op.path)
}

//
// Manages a single external compute resource.
// Compute resource is a term of host external provider. The external provider also needs to know to where the
// provisioned host needs to register. The login details of the engine are saved as a compute resource  in the external
// provider side.
//
type externalComputeResourceService struct {
	baseService
}

func NewExternalComputeResourceService(connection *Connection, path string) *externalComputeResourceService {
	var result externalComputeResourceService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves external compute resource details.
// For example, to get the details of compute resource `234` of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/computeresources/234
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
//   <name>hostname</name>
//   <provider>oVirt</provider>
//   <url>https://hostname/api</url>
//   <user>admin@internal</user>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_compute_resource>
// ----
//
type externalComputeResourceServiceGetRequest struct {
	externalComputeResourceService *externalComputeResourceService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
}

func (p *externalComputeResourceServiceGetRequest) Header(key, value string) *externalComputeResourceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalComputeResourceServiceGetRequest) Query(key, value string) *externalComputeResourceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalComputeResourceServiceGetRequest) Follow(follow string) *externalComputeResourceServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *externalComputeResourceServiceGetRequest) Send() (*externalComputeResourceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalComputeResourceService.connection.URL(), p.externalComputeResourceService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalComputeResourceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalComputeResourceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalComputeResourceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &externalComputeResourceServiceGetResponse{resource: result}, nil
}

func (p *externalComputeResourceServiceGetRequest) MustSend() *externalComputeResourceServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalComputeResourceService.connection.URL(), p.externalComputeResourceService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalComputeResourceService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalComputeResourceService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalComputeResourceReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &externalComputeResourceServiceGetResponse{resource: result}
}

//
// Retrieves external compute resource details.
// For example, to get the details of compute resource `234` of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/computeresources/234
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
//   <name>hostname</name>
//   <provider>oVirt</provider>
//   <url>https://hostname/api</url>
//   <user>admin@internal</user>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_compute_resource>
// ----
//
type externalComputeResourceServiceGetResponse struct {
	resource *ExternalComputeResource
}

func (p *externalComputeResourceServiceGetResponse) Resource() (*ExternalComputeResource, bool) {
	if p.resource != nil {
		return p.resource, true
	}
	return nil, false
}

func (p *externalComputeResourceServiceGetResponse) MustResource() *ExternalComputeResource {
	if p.resource == nil {
		panic("resource in response does not exist")
	}
	return p.resource
}

//
// Retrieves external compute resource details.
// For example, to get the details of compute resource `234` of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/computeresources/234
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
//   <name>hostname</name>
//   <provider>oVirt</provider>
//   <url>https://hostname/api</url>
//   <user>admin@internal</user>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_compute_resource>
// ----
//
func (p *externalComputeResourceService) Get() *externalComputeResourceServiceGetRequest {
	return &externalComputeResourceServiceGetRequest{externalComputeResourceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalComputeResourceService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *externalComputeResourceService) String() string {
	return fmt.Sprintf("externalComputeResourceService:%s", op.path)
}

//
// Manages a collection of external compute resources.
// Compute resource is a term of host external provider. The external provider also needs to know to where the
// provisioned host needs to register. The login details of the engine is saved as a compute resource in the external
// provider side.
//
type externalComputeResourcesService struct {
	baseService
}

func NewExternalComputeResourcesService(connection *Connection, path string) *externalComputeResourcesService {
	var result externalComputeResourcesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves a list of external compute resources.
// For example, to retrieve the compute resources of external host provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/computeresources
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_compute_resources>
//   <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
//     <name>hostname</name>
//     <provider>oVirt</provider>
//     <url>https://address/api</url>
//     <user>admin@internal</user>
//     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//    </external_compute_resource>
//    ...
// </external_compute_resources>
// ----
// The order of the returned list of compute resources isn't guaranteed.
//
type externalComputeResourcesServiceListRequest struct {
	externalComputeResourcesService *externalComputeResourcesService
	header                          map[string]string
	query                           map[string]string
	follow                          *string
	max                             *int64
}

func (p *externalComputeResourcesServiceListRequest) Header(key, value string) *externalComputeResourcesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalComputeResourcesServiceListRequest) Query(key, value string) *externalComputeResourcesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalComputeResourcesServiceListRequest) Follow(follow string) *externalComputeResourcesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *externalComputeResourcesServiceListRequest) Max(max int64) *externalComputeResourcesServiceListRequest {
	p.max = &max
	return p
}

func (p *externalComputeResourcesServiceListRequest) Send() (*externalComputeResourcesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalComputeResourcesService.connection.URL(), p.externalComputeResourcesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalComputeResourcesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalComputeResourcesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalComputeResourceReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &externalComputeResourcesServiceListResponse{resources: result}, nil
}

func (p *externalComputeResourcesServiceListRequest) MustSend() *externalComputeResourcesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalComputeResourcesService.connection.URL(), p.externalComputeResourcesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalComputeResourcesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalComputeResourcesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalComputeResourceReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &externalComputeResourcesServiceListResponse{resources: result}
}

//
// Retrieves a list of external compute resources.
// For example, to retrieve the compute resources of external host provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/computeresources
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_compute_resources>
//   <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
//     <name>hostname</name>
//     <provider>oVirt</provider>
//     <url>https://address/api</url>
//     <user>admin@internal</user>
//     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//    </external_compute_resource>
//    ...
// </external_compute_resources>
// ----
// The order of the returned list of compute resources isn't guaranteed.
//
type externalComputeResourcesServiceListResponse struct {
	resources *ExternalComputeResourceSlice
}

func (p *externalComputeResourcesServiceListResponse) Resources() (*ExternalComputeResourceSlice, bool) {
	if p.resources != nil {
		return p.resources, true
	}
	return nil, false
}

func (p *externalComputeResourcesServiceListResponse) MustResources() *ExternalComputeResourceSlice {
	if p.resources == nil {
		panic("resources in response does not exist")
	}
	return p.resources
}

//
// Retrieves a list of external compute resources.
// For example, to retrieve the compute resources of external host provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/computeresources
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_compute_resources>
//   <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
//     <name>hostname</name>
//     <provider>oVirt</provider>
//     <url>https://address/api</url>
//     <user>admin@internal</user>
//     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//    </external_compute_resource>
//    ...
// </external_compute_resources>
// ----
// The order of the returned list of compute resources isn't guaranteed.
//
func (p *externalComputeResourcesService) List() *externalComputeResourcesServiceListRequest {
	return &externalComputeResourcesServiceListRequest{externalComputeResourcesService: p}
}

//
// This service manages compute resource instance
//
func (op *externalComputeResourcesService) ResourceService(id string) *externalComputeResourceService {
	return NewExternalComputeResourceService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalComputeResourcesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ResourceService(path), nil
	}
	return op.ResourceService(path[:index]).Service(path[index+1:])
}

func (op *externalComputeResourcesService) String() string {
	return fmt.Sprintf("externalComputeResourcesService:%s", op.path)
}

//
//
type externalHostService struct {
	baseService
}

func NewExternalHostService(connection *Connection, path string) *externalHostService {
	var result externalHostService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type externalHostServiceGetRequest struct {
	externalHostService *externalHostService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *externalHostServiceGetRequest) Header(key, value string) *externalHostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalHostServiceGetRequest) Query(key, value string) *externalHostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalHostServiceGetRequest) Follow(follow string) *externalHostServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *externalHostServiceGetRequest) Send() (*externalHostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostService.connection.URL(), p.externalHostService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &externalHostServiceGetResponse{host: result}, nil
}

func (p *externalHostServiceGetRequest) MustSend() *externalHostServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalHostService.connection.URL(), p.externalHostService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &externalHostServiceGetResponse{host: result}
}

//
//
type externalHostServiceGetResponse struct {
	host *ExternalHost
}

func (p *externalHostServiceGetResponse) Host() (*ExternalHost, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *externalHostServiceGetResponse) MustHost() *ExternalHost {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
//
func (p *externalHostService) Get() *externalHostServiceGetRequest {
	return &externalHostServiceGetRequest{externalHostService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalHostService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *externalHostService) String() string {
	return fmt.Sprintf("externalHostService:%s", op.path)
}

//
// This service manages a single discovered host.
//
type externalDiscoveredHostService struct {
	baseService
}

func NewExternalDiscoveredHostService(connection *Connection, path string) *externalDiscoveredHostService {
	var result externalDiscoveredHostService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get discovered host info.
// Retrieves information about an host that is managed in external provider management system, such as Foreman. The
// information includes hostname, address, subnet, base image and more.
// For example, to get the details of host `234` from provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/discoveredhosts/234
// ....
// The result will be like this:
// [source,xml]
// ----
// <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/234" id="234">
//  <name>mac001a4ad04040</name>
//  <ip>10.34.67.43</ip>
//  <last_report>2017-04-24 11:05:41 UTC</last_report>
//  <mac>00:1a:4a:d0:40:40</mac>
//  <subnet_name>sat0</subnet_name>
//  <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_discovered_host>
// ----
//
type externalDiscoveredHostServiceGetRequest struct {
	externalDiscoveredHostService *externalDiscoveredHostService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
}

func (p *externalDiscoveredHostServiceGetRequest) Header(key, value string) *externalDiscoveredHostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalDiscoveredHostServiceGetRequest) Query(key, value string) *externalDiscoveredHostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalDiscoveredHostServiceGetRequest) Follow(follow string) *externalDiscoveredHostServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *externalDiscoveredHostServiceGetRequest) Send() (*externalDiscoveredHostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalDiscoveredHostService.connection.URL(), p.externalDiscoveredHostService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalDiscoveredHostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalDiscoveredHostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalDiscoveredHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &externalDiscoveredHostServiceGetResponse{host: result}, nil
}

func (p *externalDiscoveredHostServiceGetRequest) MustSend() *externalDiscoveredHostServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalDiscoveredHostService.connection.URL(), p.externalDiscoveredHostService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalDiscoveredHostService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalDiscoveredHostService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalDiscoveredHostReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &externalDiscoveredHostServiceGetResponse{host: result}
}

//
// Get discovered host info.
// Retrieves information about an host that is managed in external provider management system, such as Foreman. The
// information includes hostname, address, subnet, base image and more.
// For example, to get the details of host `234` from provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/discoveredhosts/234
// ....
// The result will be like this:
// [source,xml]
// ----
// <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/234" id="234">
//  <name>mac001a4ad04040</name>
//  <ip>10.34.67.43</ip>
//  <last_report>2017-04-24 11:05:41 UTC</last_report>
//  <mac>00:1a:4a:d0:40:40</mac>
//  <subnet_name>sat0</subnet_name>
//  <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_discovered_host>
// ----
//
type externalDiscoveredHostServiceGetResponse struct {
	host *ExternalDiscoveredHost
}

func (p *externalDiscoveredHostServiceGetResponse) Host() (*ExternalDiscoveredHost, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *externalDiscoveredHostServiceGetResponse) MustHost() *ExternalDiscoveredHost {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Get discovered host info.
// Retrieves information about an host that is managed in external provider management system, such as Foreman. The
// information includes hostname, address, subnet, base image and more.
// For example, to get the details of host `234` from provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/discoveredhosts/234
// ....
// The result will be like this:
// [source,xml]
// ----
// <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/234" id="234">
//  <name>mac001a4ad04040</name>
//  <ip>10.34.67.43</ip>
//  <last_report>2017-04-24 11:05:41 UTC</last_report>
//  <mac>00:1a:4a:d0:40:40</mac>
//  <subnet_name>sat0</subnet_name>
//  <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_discovered_host>
// ----
//
func (p *externalDiscoveredHostService) Get() *externalDiscoveredHostServiceGetRequest {
	return &externalDiscoveredHostServiceGetRequest{externalDiscoveredHostService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalDiscoveredHostService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *externalDiscoveredHostService) String() string {
	return fmt.Sprintf("externalDiscoveredHostService:%s", op.path)
}

//
// Represents an external host provider, such as Foreman or Satellite.
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite for more details on Red Hat Satellite.
//
type externalHostProviderService struct {
	baseService
}

func NewExternalHostProviderService(connection *Connection, path string) *externalHostProviderService {
	var result externalHostProviderService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get external host provider information
// Host provider, Foreman or Satellite, can be set as an external provider in ovirt. To see details about specific
// host providers attached to ovirt use this API.
// For example, to get the details of host provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123
// ....
// The response will be like this:
// [source,xml]
// ----
// <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123">
//   <name>mysatellite</name>
//   <requires_authentication>true</requires_authentication>
//   <url>https://mysatellite.example.com</url>
//   <username>admin</username>
// </external_host_provider>
// ----
//
type externalHostProviderServiceGetRequest struct {
	externalHostProviderService *externalHostProviderService
	header                      map[string]string
	query                       map[string]string
	follow                      *string
}

func (p *externalHostProviderServiceGetRequest) Header(key, value string) *externalHostProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalHostProviderServiceGetRequest) Query(key, value string) *externalHostProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalHostProviderServiceGetRequest) Follow(follow string) *externalHostProviderServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *externalHostProviderServiceGetRequest) Send() (*externalHostProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProviderService.connection.URL(), p.externalHostProviderService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &externalHostProviderServiceGetResponse{provider: result}, nil
}

func (p *externalHostProviderServiceGetRequest) MustSend() *externalHostProviderServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProviderService.connection.URL(), p.externalHostProviderService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostProviderReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &externalHostProviderServiceGetResponse{provider: result}
}

//
// Get external host provider information
// Host provider, Foreman or Satellite, can be set as an external provider in ovirt. To see details about specific
// host providers attached to ovirt use this API.
// For example, to get the details of host provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123
// ....
// The response will be like this:
// [source,xml]
// ----
// <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123">
//   <name>mysatellite</name>
//   <requires_authentication>true</requires_authentication>
//   <url>https://mysatellite.example.com</url>
//   <username>admin</username>
// </external_host_provider>
// ----
//
type externalHostProviderServiceGetResponse struct {
	provider *ExternalHostProvider
}

func (p *externalHostProviderServiceGetResponse) Provider() (*ExternalHostProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *externalHostProviderServiceGetResponse) MustProvider() *ExternalHostProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Get external host provider information
// Host provider, Foreman or Satellite, can be set as an external provider in ovirt. To see details about specific
// host providers attached to ovirt use this API.
// For example, to get the details of host provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123
// ....
// The response will be like this:
// [source,xml]
// ----
// <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123">
//   <name>mysatellite</name>
//   <requires_authentication>true</requires_authentication>
//   <url>https://mysatellite.example.com</url>
//   <username>admin</username>
// </external_host_provider>
// ----
//
func (p *externalHostProviderService) Get() *externalHostProviderServiceGetRequest {
	return &externalHostProviderServiceGetRequest{externalHostProviderService: p}
}

//
// Import the SSL certificates of the external host provider.
//
type externalHostProviderServiceImportCertificatesRequest struct {
	externalHostProviderService *externalHostProviderService
	header                      map[string]string
	query                       map[string]string
	certificates                *CertificateSlice
}

func (p *externalHostProviderServiceImportCertificatesRequest) Header(key, value string) *externalHostProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalHostProviderServiceImportCertificatesRequest) Query(key, value string) *externalHostProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalHostProviderServiceImportCertificatesRequest) Certificates(certificates *CertificateSlice) *externalHostProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}

func (p *externalHostProviderServiceImportCertificatesRequest) CertificatesOfAny(anys ...*Certificate) *externalHostProviderServiceImportCertificatesRequest {
	if p.certificates == nil {
		p.certificates = new(CertificateSlice)
	}
	p.certificates.slice = append(p.certificates.slice, anys...)
	return p
}

func (p *externalHostProviderServiceImportCertificatesRequest) Send() (*externalHostProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.externalHostProviderService.connection.URL(), p.externalHostProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(externalHostProviderServiceImportCertificatesResponse), nil
}

func (p *externalHostProviderServiceImportCertificatesRequest) MustSend() *externalHostProviderServiceImportCertificatesResponse {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.externalHostProviderService.connection.URL(), p.externalHostProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(externalHostProviderServiceImportCertificatesResponse)
}

//
// Import the SSL certificates of the external host provider.
//
type externalHostProviderServiceImportCertificatesResponse struct {
}

//
// Import the SSL certificates of the external host provider.
//
func (p *externalHostProviderService) ImportCertificates() *externalHostProviderServiceImportCertificatesRequest {
	return &externalHostProviderServiceImportCertificatesRequest{externalHostProviderService: p}
}

//
//
type externalHostProviderServiceRemoveRequest struct {
	externalHostProviderService *externalHostProviderService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *externalHostProviderServiceRemoveRequest) Header(key, value string) *externalHostProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalHostProviderServiceRemoveRequest) Query(key, value string) *externalHostProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalHostProviderServiceRemoveRequest) Async(async bool) *externalHostProviderServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *externalHostProviderServiceRemoveRequest) Send() (*externalHostProviderServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProviderService.connection.URL(), p.externalHostProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(externalHostProviderServiceRemoveResponse), nil
}

func (p *externalHostProviderServiceRemoveRequest) MustSend() *externalHostProviderServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProviderService.connection.URL(), p.externalHostProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(externalHostProviderServiceRemoveResponse)
}

//
//
type externalHostProviderServiceRemoveResponse struct {
}

//
//
func (p *externalHostProviderService) Remove() *externalHostProviderServiceRemoveRequest {
	return &externalHostProviderServiceRemoveRequest{externalHostProviderService: p}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type externalHostProviderServiceTestConnectivityRequest struct {
	externalHostProviderService *externalHostProviderService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *externalHostProviderServiceTestConnectivityRequest) Header(key, value string) *externalHostProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalHostProviderServiceTestConnectivityRequest) Query(key, value string) *externalHostProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalHostProviderServiceTestConnectivityRequest) Async(async bool) *externalHostProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}

func (p *externalHostProviderServiceTestConnectivityRequest) Send() (*externalHostProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.externalHostProviderService.connection.URL(), p.externalHostProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(externalHostProviderServiceTestConnectivityResponse), nil
}

func (p *externalHostProviderServiceTestConnectivityRequest) MustSend() *externalHostProviderServiceTestConnectivityResponse {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.externalHostProviderService.connection.URL(), p.externalHostProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(externalHostProviderServiceTestConnectivityResponse)
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type externalHostProviderServiceTestConnectivityResponse struct {
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
func (p *externalHostProviderService) TestConnectivity() *externalHostProviderServiceTestConnectivityRequest {
	return &externalHostProviderServiceTestConnectivityRequest{externalHostProviderService: p}
}

//
// Update the specified external host provider in the system.
//
type externalHostProviderServiceUpdateRequest struct {
	externalHostProviderService *externalHostProviderService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
	provider                    *ExternalHostProvider
}

func (p *externalHostProviderServiceUpdateRequest) Header(key, value string) *externalHostProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalHostProviderServiceUpdateRequest) Query(key, value string) *externalHostProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalHostProviderServiceUpdateRequest) Async(async bool) *externalHostProviderServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *externalHostProviderServiceUpdateRequest) Provider(provider *ExternalHostProvider) *externalHostProviderServiceUpdateRequest {
	p.provider = provider
	return p
}

func (p *externalHostProviderServiceUpdateRequest) Send() (*externalHostProviderServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProviderService.connection.URL(), p.externalHostProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLExternalHostProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &externalHostProviderServiceUpdateResponse{provider: result}, nil
}

func (p *externalHostProviderServiceUpdateRequest) MustSend() *externalHostProviderServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalHostProviderService.connection.URL(), p.externalHostProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLExternalHostProviderWriteOne(writer, p.provider, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostProviderService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostProviderService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostProviderReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &externalHostProviderServiceUpdateResponse{provider: result}
}

//
// Update the specified external host provider in the system.
//
type externalHostProviderServiceUpdateResponse struct {
	provider *ExternalHostProvider
}

func (p *externalHostProviderServiceUpdateResponse) Provider() (*ExternalHostProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *externalHostProviderServiceUpdateResponse) MustProvider() *ExternalHostProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Update the specified external host provider in the system.
//
func (p *externalHostProviderService) Update() *externalHostProviderServiceUpdateRequest {
	return &externalHostProviderServiceUpdateRequest{externalHostProviderService: p}
}

//
// A service to view certificates for this external provider.
//
func (op *externalHostProviderService) CertificatesService() *externalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.connection, fmt.Sprintf("%s/certificates", op.path))
}

//
//
func (op *externalHostProviderService) ComputeResourcesService() *externalComputeResourcesService {
	return NewExternalComputeResourcesService(op.connection, fmt.Sprintf("%s/computeresources", op.path))
}

//
//
func (op *externalHostProviderService) DiscoveredHostsService() *externalDiscoveredHostsService {
	return NewExternalDiscoveredHostsService(op.connection, fmt.Sprintf("%s/discoveredhosts", op.path))
}

//
//
func (op *externalHostProviderService) HostGroupsService() *externalHostGroupsService {
	return NewExternalHostGroupsService(op.connection, fmt.Sprintf("%s/hostgroups", op.path))
}

//
//
func (op *externalHostProviderService) HostsService() *externalHostsService {
	return NewExternalHostsService(op.connection, fmt.Sprintf("%s/hosts", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalHostProviderService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "computeresources" {
		return op.ComputeResourcesService(), nil
	}
	if strings.HasPrefix(path, "computeresources/") {
		return op.ComputeResourcesService().Service(path[17:])
	}
	if path == "discoveredhosts" {
		return op.DiscoveredHostsService(), nil
	}
	if strings.HasPrefix(path, "discoveredhosts/") {
		return op.DiscoveredHostsService().Service(path[16:])
	}
	if path == "hostgroups" {
		return op.HostGroupsService(), nil
	}
	if strings.HasPrefix(path, "hostgroups/") {
		return op.HostGroupsService().Service(path[11:])
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *externalHostProviderService) String() string {
	return fmt.Sprintf("externalHostProviderService:%s", op.path)
}

//
// A service to manage Katello errata assigned to the engine.
// The information is retrieved from Katello.
//
type engineKatelloErrataService struct {
	baseService
}

func NewEngineKatelloErrataService(connection *Connection, path string) *engineKatelloErrataService {
	var result engineKatelloErrataService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// The order of the returned list of erratum isn't guaranteed.
//
type engineKatelloErrataServiceListRequest struct {
	engineKatelloErrataService *engineKatelloErrataService
	header                     map[string]string
	query                      map[string]string
	follow                     *string
	max                        *int64
}

func (p *engineKatelloErrataServiceListRequest) Header(key, value string) *engineKatelloErrataServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *engineKatelloErrataServiceListRequest) Query(key, value string) *engineKatelloErrataServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *engineKatelloErrataServiceListRequest) Follow(follow string) *engineKatelloErrataServiceListRequest {
	p.follow = &follow
	return p
}

func (p *engineKatelloErrataServiceListRequest) Max(max int64) *engineKatelloErrataServiceListRequest {
	p.max = &max
	return p
}

func (p *engineKatelloErrataServiceListRequest) Send() (*engineKatelloErrataServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.engineKatelloErrataService.connection.URL(), p.engineKatelloErrataService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.engineKatelloErrataService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.engineKatelloErrataService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLKatelloErratumReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &engineKatelloErrataServiceListResponse{errata: result}, nil
}

func (p *engineKatelloErrataServiceListRequest) MustSend() *engineKatelloErrataServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.engineKatelloErrataService.connection.URL(), p.engineKatelloErrataService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.engineKatelloErrataService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.engineKatelloErrataService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLKatelloErratumReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &engineKatelloErrataServiceListResponse{errata: result}
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// The order of the returned list of erratum isn't guaranteed.
//
type engineKatelloErrataServiceListResponse struct {
	errata *KatelloErratumSlice
}

func (p *engineKatelloErrataServiceListResponse) Errata() (*KatelloErratumSlice, bool) {
	if p.errata != nil {
		return p.errata, true
	}
	return nil, false
}

func (p *engineKatelloErrataServiceListResponse) MustErrata() *KatelloErratumSlice {
	if p.errata == nil {
		panic("errata in response does not exist")
	}
	return p.errata
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// The order of the returned list of erratum isn't guaranteed.
//
func (p *engineKatelloErrataService) List() *engineKatelloErrataServiceListRequest {
	return &engineKatelloErrataServiceListRequest{engineKatelloErrataService: p}
}

//
// Reference to the Katello erratum service.
// Use this service to view the erratum by its id.
//
func (op *engineKatelloErrataService) KatelloErratumService(id string) *katelloErratumService {
	return NewKatelloErratumService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *engineKatelloErrataService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.KatelloErratumService(path), nil
	}
	return op.KatelloErratumService(path[:index]).Service(path[index+1:])
}

func (op *engineKatelloErrataService) String() string {
	return fmt.Sprintf("engineKatelloErrataService:%s", op.path)
}

//
//
type externalHostsService struct {
	baseService
}

func NewExternalHostsService(connection *Connection, path string) *externalHostsService {
	var result externalHostsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Return the list of external hosts.
// The order of the returned list of hosts isn't guaranteed.
//
type externalHostsServiceListRequest struct {
	externalHostsService *externalHostsService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *externalHostsServiceListRequest) Header(key, value string) *externalHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalHostsServiceListRequest) Query(key, value string) *externalHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalHostsServiceListRequest) Follow(follow string) *externalHostsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *externalHostsServiceListRequest) Max(max int64) *externalHostsServiceListRequest {
	p.max = &max
	return p
}

func (p *externalHostsServiceListRequest) Send() (*externalHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalHostsService.connection.URL(), p.externalHostsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &externalHostsServiceListResponse{hosts: result}, nil
}

func (p *externalHostsServiceListRequest) MustSend() *externalHostsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalHostsService.connection.URL(), p.externalHostsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalHostsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalHostsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &externalHostsServiceListResponse{hosts: result}
}

//
// Return the list of external hosts.
// The order of the returned list of hosts isn't guaranteed.
//
type externalHostsServiceListResponse struct {
	hosts *ExternalHostSlice
}

func (p *externalHostsServiceListResponse) Hosts() (*ExternalHostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *externalHostsServiceListResponse) MustHosts() *ExternalHostSlice {
	if p.hosts == nil {
		panic("hosts in response does not exist")
	}
	return p.hosts
}

//
// Return the list of external hosts.
// The order of the returned list of hosts isn't guaranteed.
//
func (p *externalHostsService) List() *externalHostsServiceListRequest {
	return &externalHostsServiceListRequest{externalHostsService: p}
}

//
//
func (op *externalHostsService) HostService(id string) *externalHostService {
	return NewExternalHostService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalHostsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HostService(path), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *externalHostsService) String() string {
	return fmt.Sprintf("externalHostsService:%s", op.path)
}

//
// Returns the details of a disk attached to a virtual machine in the export domain.
//
type storageDomainVmDiskAttachmentsService struct {
	baseService
}

func NewStorageDomainVmDiskAttachmentsService(connection *Connection, path string) *storageDomainVmDiskAttachmentsService {
	var result storageDomainVmDiskAttachmentsService
	result.connection = connection
	result.path = path
	return &result
}

//
// List the disks that are attached to the virtual machine.
// The order of the returned list of disk attachments isn't guaranteed.
//
type storageDomainVmDiskAttachmentsServiceListRequest struct {
	storageDomainVmDiskAttachmentsService *storageDomainVmDiskAttachmentsService
	header                                map[string]string
	query                                 map[string]string
	follow                                *string
}

func (p *storageDomainVmDiskAttachmentsServiceListRequest) Header(key, value string) *storageDomainVmDiskAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainVmDiskAttachmentsServiceListRequest) Query(key, value string) *storageDomainVmDiskAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainVmDiskAttachmentsServiceListRequest) Follow(follow string) *storageDomainVmDiskAttachmentsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainVmDiskAttachmentsServiceListRequest) Send() (*storageDomainVmDiskAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmDiskAttachmentsService.connection.URL(), p.storageDomainVmDiskAttachmentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmDiskAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmDiskAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &storageDomainVmDiskAttachmentsServiceListResponse{attachments: result}, nil
}

func (p *storageDomainVmDiskAttachmentsServiceListRequest) MustSend() *storageDomainVmDiskAttachmentsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmDiskAttachmentsService.connection.URL(), p.storageDomainVmDiskAttachmentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmDiskAttachmentsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmDiskAttachmentsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &storageDomainVmDiskAttachmentsServiceListResponse{attachments: result}
}

//
// List the disks that are attached to the virtual machine.
// The order of the returned list of disk attachments isn't guaranteed.
//
type storageDomainVmDiskAttachmentsServiceListResponse struct {
	attachments *DiskAttachmentSlice
}

func (p *storageDomainVmDiskAttachmentsServiceListResponse) Attachments() (*DiskAttachmentSlice, bool) {
	if p.attachments != nil {
		return p.attachments, true
	}
	return nil, false
}

func (p *storageDomainVmDiskAttachmentsServiceListResponse) MustAttachments() *DiskAttachmentSlice {
	if p.attachments == nil {
		panic("attachments in response does not exist")
	}
	return p.attachments
}

//
// List the disks that are attached to the virtual machine.
// The order of the returned list of disk attachments isn't guaranteed.
//
func (p *storageDomainVmDiskAttachmentsService) List() *storageDomainVmDiskAttachmentsServiceListRequest {
	return &storageDomainVmDiskAttachmentsServiceListRequest{storageDomainVmDiskAttachmentsService: p}
}

//
// Reference to the service that manages a specific attachment.
//
func (op *storageDomainVmDiskAttachmentsService) AttachmentService(id string) *storageDomainVmDiskAttachmentService {
	return NewStorageDomainVmDiskAttachmentService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainVmDiskAttachmentsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.AttachmentService(path), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *storageDomainVmDiskAttachmentsService) String() string {
	return fmt.Sprintf("storageDomainVmDiskAttachmentsService:%s", op.path)
}

//
// This service manages a parameter for a network filter.
//
type nicNetworkFilterParameterService struct {
	baseService
}

func NewNicNetworkFilterParameterService(connection *Connection, path string) *nicNetworkFilterParameterService {
	var result nicNetworkFilterParameterService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves a representation of the network filter parameter.
//
type nicNetworkFilterParameterServiceGetRequest struct {
	nicNetworkFilterParameterService *nicNetworkFilterParameterService
	header                           map[string]string
	query                            map[string]string
	follow                           *string
}

func (p *nicNetworkFilterParameterServiceGetRequest) Header(key, value string) *nicNetworkFilterParameterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *nicNetworkFilterParameterServiceGetRequest) Query(key, value string) *nicNetworkFilterParameterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *nicNetworkFilterParameterServiceGetRequest) Follow(follow string) *nicNetworkFilterParameterServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *nicNetworkFilterParameterServiceGetRequest) Send() (*nicNetworkFilterParameterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.nicNetworkFilterParameterService.connection.URL(), p.nicNetworkFilterParameterService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.nicNetworkFilterParameterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.nicNetworkFilterParameterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterParameterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &nicNetworkFilterParameterServiceGetResponse{parameter: result}, nil
}

func (p *nicNetworkFilterParameterServiceGetRequest) MustSend() *nicNetworkFilterParameterServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.nicNetworkFilterParameterService.connection.URL(), p.nicNetworkFilterParameterService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.nicNetworkFilterParameterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.nicNetworkFilterParameterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterParameterReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &nicNetworkFilterParameterServiceGetResponse{parameter: result}
}

//
// Retrieves a representation of the network filter parameter.
//
type nicNetworkFilterParameterServiceGetResponse struct {
	parameter *NetworkFilterParameter
}

func (p *nicNetworkFilterParameterServiceGetResponse) Parameter() (*NetworkFilterParameter, bool) {
	if p.parameter != nil {
		return p.parameter, true
	}
	return nil, false
}

func (p *nicNetworkFilterParameterServiceGetResponse) MustParameter() *NetworkFilterParameter {
	if p.parameter == nil {
		panic("parameter in response does not exist")
	}
	return p.parameter
}

//
// Retrieves a representation of the network filter parameter.
//
func (p *nicNetworkFilterParameterService) Get() *nicNetworkFilterParameterServiceGetRequest {
	return &nicNetworkFilterParameterServiceGetRequest{nicNetworkFilterParameterService: p}
}

//
// Removes the filter parameter.
// For example, to remove the filter parameter with id `123` on NIC `456` of virtual machine `789`
// send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
//
type nicNetworkFilterParameterServiceRemoveRequest struct {
	nicNetworkFilterParameterService *nicNetworkFilterParameterService
	header                           map[string]string
	query                            map[string]string
}

func (p *nicNetworkFilterParameterServiceRemoveRequest) Header(key, value string) *nicNetworkFilterParameterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *nicNetworkFilterParameterServiceRemoveRequest) Query(key, value string) *nicNetworkFilterParameterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *nicNetworkFilterParameterServiceRemoveRequest) Send() (*nicNetworkFilterParameterServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.nicNetworkFilterParameterService.connection.URL(), p.nicNetworkFilterParameterService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.nicNetworkFilterParameterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.nicNetworkFilterParameterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(nicNetworkFilterParameterServiceRemoveResponse), nil
}

func (p *nicNetworkFilterParameterServiceRemoveRequest) MustSend() *nicNetworkFilterParameterServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.nicNetworkFilterParameterService.connection.URL(), p.nicNetworkFilterParameterService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.nicNetworkFilterParameterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.nicNetworkFilterParameterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(nicNetworkFilterParameterServiceRemoveResponse)
}

//
// Removes the filter parameter.
// For example, to remove the filter parameter with id `123` on NIC `456` of virtual machine `789`
// send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
//
type nicNetworkFilterParameterServiceRemoveResponse struct {
}

//
// Removes the filter parameter.
// For example, to remove the filter parameter with id `123` on NIC `456` of virtual machine `789`
// send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
//
func (p *nicNetworkFilterParameterService) Remove() *nicNetworkFilterParameterServiceRemoveRequest {
	return &nicNetworkFilterParameterServiceRemoveRequest{nicNetworkFilterParameterService: p}
}

//
// Updates the network filter parameter.
// For example, to update the network filter parameter having with with id `123` on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>updatedName</name>
//   <value>updatedValue</value>
// </network_filter_parameter>
// ----
//
type nicNetworkFilterParameterServiceUpdateRequest struct {
	nicNetworkFilterParameterService *nicNetworkFilterParameterService
	header                           map[string]string
	query                            map[string]string
	parameter                        *NetworkFilterParameter
}

func (p *nicNetworkFilterParameterServiceUpdateRequest) Header(key, value string) *nicNetworkFilterParameterServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *nicNetworkFilterParameterServiceUpdateRequest) Query(key, value string) *nicNetworkFilterParameterServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *nicNetworkFilterParameterServiceUpdateRequest) Parameter(parameter *NetworkFilterParameter) *nicNetworkFilterParameterServiceUpdateRequest {
	p.parameter = parameter
	return p
}

func (p *nicNetworkFilterParameterServiceUpdateRequest) Send() (*nicNetworkFilterParameterServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.nicNetworkFilterParameterService.connection.URL(), p.nicNetworkFilterParameterService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkFilterParameterWriteOne(writer, p.parameter, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.nicNetworkFilterParameterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.nicNetworkFilterParameterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterParameterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &nicNetworkFilterParameterServiceUpdateResponse{parameter: result}, nil
}

func (p *nicNetworkFilterParameterServiceUpdateRequest) MustSend() *nicNetworkFilterParameterServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.nicNetworkFilterParameterService.connection.URL(), p.nicNetworkFilterParameterService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkFilterParameterWriteOne(writer, p.parameter, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.nicNetworkFilterParameterService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.nicNetworkFilterParameterService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterParameterReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &nicNetworkFilterParameterServiceUpdateResponse{parameter: result}
}

//
// Updates the network filter parameter.
// For example, to update the network filter parameter having with with id `123` on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>updatedName</name>
//   <value>updatedValue</value>
// </network_filter_parameter>
// ----
//
type nicNetworkFilterParameterServiceUpdateResponse struct {
	parameter *NetworkFilterParameter
}

func (p *nicNetworkFilterParameterServiceUpdateResponse) Parameter() (*NetworkFilterParameter, bool) {
	if p.parameter != nil {
		return p.parameter, true
	}
	return nil, false
}

func (p *nicNetworkFilterParameterServiceUpdateResponse) MustParameter() *NetworkFilterParameter {
	if p.parameter == nil {
		panic("parameter in response does not exist")
	}
	return p.parameter
}

//
// Updates the network filter parameter.
// For example, to update the network filter parameter having with with id `123` on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>updatedName</name>
//   <value>updatedValue</value>
// </network_filter_parameter>
// ----
//
func (p *nicNetworkFilterParameterService) Update() *nicNetworkFilterParameterServiceUpdateRequest {
	return &nicNetworkFilterParameterServiceUpdateRequest{nicNetworkFilterParameterService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *nicNetworkFilterParameterService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *nicNetworkFilterParameterService) String() string {
	return fmt.Sprintf("nicNetworkFilterParameterService:%s", op.path)
}

//
//
type vmSessionService struct {
	baseService
}

func NewVmSessionService(connection *Connection, path string) *vmSessionService {
	var result vmSessionService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type vmSessionServiceGetRequest struct {
	vmSessionService *vmSessionService
	header           map[string]string
	query            map[string]string
	follow           *string
}

func (p *vmSessionServiceGetRequest) Header(key, value string) *vmSessionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmSessionServiceGetRequest) Query(key, value string) *vmSessionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmSessionServiceGetRequest) Follow(follow string) *vmSessionServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *vmSessionServiceGetRequest) Send() (*vmSessionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmSessionService.connection.URL(), p.vmSessionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmSessionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmSessionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSessionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmSessionServiceGetResponse{session: result}, nil
}

func (p *vmSessionServiceGetRequest) MustSend() *vmSessionServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmSessionService.connection.URL(), p.vmSessionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmSessionService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmSessionService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSessionReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmSessionServiceGetResponse{session: result}
}

//
//
type vmSessionServiceGetResponse struct {
	session *Session
}

func (p *vmSessionServiceGetResponse) Session() (*Session, bool) {
	if p.session != nil {
		return p.session, true
	}
	return nil, false
}

func (p *vmSessionServiceGetResponse) MustSession() *Session {
	if p.session == nil {
		panic("session in response does not exist")
	}
	return p.session
}

//
//
func (p *vmSessionService) Get() *vmSessionServiceGetRequest {
	return &vmSessionServiceGetRequest{vmSessionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmSessionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *vmSessionService) String() string {
	return fmt.Sprintf("vmSessionService:%s", op.path)
}

//
//
type templateDiskService struct {
	baseService
}

func NewTemplateDiskService(connection *Connection, path string) *templateDiskService {
	var result templateDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
// Copy the specified disk attached to the template to a specific storage domain.
//
type templateDiskServiceCopyRequest struct {
	templateDiskService *templateDiskService
	header              map[string]string
	query               map[string]string
	async               *bool
	filter              *bool
	storageDomain       *StorageDomain
}

func (p *templateDiskServiceCopyRequest) Header(key, value string) *templateDiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateDiskServiceCopyRequest) Query(key, value string) *templateDiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateDiskServiceCopyRequest) Async(async bool) *templateDiskServiceCopyRequest {
	p.async = &async
	return p
}

func (p *templateDiskServiceCopyRequest) Filter(filter bool) *templateDiskServiceCopyRequest {
	p.filter = &filter
	return p
}

func (p *templateDiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *templateDiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *templateDiskServiceCopyRequest) Send() (*templateDiskServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.templateDiskService.connection.URL(), p.templateDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(templateDiskServiceCopyResponse), nil
}

func (p *templateDiskServiceCopyRequest) MustSend() *templateDiskServiceCopyResponse {
	rawURL := fmt.Sprintf("%s%s/copy", p.templateDiskService.connection.URL(), p.templateDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(templateDiskServiceCopyResponse)
}

//
// Copy the specified disk attached to the template to a specific storage domain.
//
type templateDiskServiceCopyResponse struct {
}

//
// Copy the specified disk attached to the template to a specific storage domain.
//
func (p *templateDiskService) Copy() *templateDiskServiceCopyRequest {
	return &templateDiskServiceCopyRequest{templateDiskService: p}
}

//
//
type templateDiskServiceExportRequest struct {
	templateDiskService *templateDiskService
	header              map[string]string
	query               map[string]string
	async               *bool
	filter              *bool
	storageDomain       *StorageDomain
}

func (p *templateDiskServiceExportRequest) Header(key, value string) *templateDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateDiskServiceExportRequest) Query(key, value string) *templateDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateDiskServiceExportRequest) Async(async bool) *templateDiskServiceExportRequest {
	p.async = &async
	return p
}

func (p *templateDiskServiceExportRequest) Filter(filter bool) *templateDiskServiceExportRequest {
	p.filter = &filter
	return p
}

func (p *templateDiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *templateDiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *templateDiskServiceExportRequest) Send() (*templateDiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.templateDiskService.connection.URL(), p.templateDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(templateDiskServiceExportResponse), nil
}

func (p *templateDiskServiceExportRequest) MustSend() *templateDiskServiceExportResponse {
	rawURL := fmt.Sprintf("%s%s/export", p.templateDiskService.connection.URL(), p.templateDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(templateDiskServiceExportResponse)
}

//
//
type templateDiskServiceExportResponse struct {
}

//
//
func (p *templateDiskService) Export() *templateDiskServiceExportRequest {
	return &templateDiskServiceExportRequest{templateDiskService: p}
}

//
//
type templateDiskServiceGetRequest struct {
	templateDiskService *templateDiskService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *templateDiskServiceGetRequest) Header(key, value string) *templateDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateDiskServiceGetRequest) Query(key, value string) *templateDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateDiskServiceGetRequest) Follow(follow string) *templateDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *templateDiskServiceGetRequest) Send() (*templateDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskService.connection.URL(), p.templateDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateDiskServiceGetResponse{disk: result}, nil
}

func (p *templateDiskServiceGetRequest) MustSend() *templateDiskServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskService.connection.URL(), p.templateDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateDiskServiceGetResponse{disk: result}
}

//
//
type templateDiskServiceGetResponse struct {
	disk *Disk
}

func (p *templateDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *templateDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
//
func (p *templateDiskService) Get() *templateDiskServiceGetRequest {
	return &templateDiskServiceGetRequest{templateDiskService: p}
}

//
//
type templateDiskServiceRemoveRequest struct {
	templateDiskService *templateDiskService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *templateDiskServiceRemoveRequest) Header(key, value string) *templateDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateDiskServiceRemoveRequest) Query(key, value string) *templateDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateDiskServiceRemoveRequest) Async(async bool) *templateDiskServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *templateDiskServiceRemoveRequest) Send() (*templateDiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskService.connection.URL(), p.templateDiskService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(templateDiskServiceRemoveResponse), nil
}

func (p *templateDiskServiceRemoveRequest) MustSend() *templateDiskServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateDiskService.connection.URL(), p.templateDiskService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateDiskService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateDiskService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(templateDiskServiceRemoveResponse)
}

//
//
type templateDiskServiceRemoveResponse struct {
}

//
//
func (p *templateDiskService) Remove() *templateDiskServiceRemoveRequest {
	return &templateDiskServiceRemoveRequest{templateDiskService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *templateDiskService) String() string {
	return fmt.Sprintf("templateDiskService:%s", op.path)
}

//
// This service manages the virtual machine templates available in the system.
//
type templatesService struct {
	baseService
}

func NewTemplatesService(connection *Connection, path string) *templatesService {
	var result templatesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new template.
// This requires the `name` and `vm` elements. To identify the virtual machine use the `vm.id` or `vm.name`
// attributes. For example, to create a template from a virtual machine with the identifier `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/templates
// ----
// With a request body like this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
// </template>
// ----
// The disks of the template can be customized, making some of their characteristics different from the disks of the
// original virtual machine. To do so use the `vm.disk_attachments` attribute, specifying the identifier of the disk
// of the original virtual machine and the characteristics that you want to change. For example, if the original
// virtual machine has a disk with the identifier `456`, and, for that disk, you want to change the name to `mydisk`
// the format to <<types/disk_format, _Copy On Write_>> and make it <<types/disk, sparse>>, send a request body like
// this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="456">
//           <name>mydisk</name>
//           <format>cow</format>
//           <sparse>true</sparse>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
// The template can be created as a sub-version of an existing template. This requires the `name` and `vm` attributes
// for the new template, and the `base_template` and `version_name` attributes for the new template version. The
// `base_template` and `version_name` attributes must be specified within a `version` section enclosed in the
// `template` section. Identify the virtual machine with the `id` or `name` attributes.
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
//   <version>
//     <base_template id="456"/>
//     <version_name>mytemplate_001</version_name>
//   </version>
// </template>
// ----
// The destination storage domain of the template can be customized, in one of two ways:
// 1. Globally, at the request level. The request must list the desired disk attachments to be created on the
// storage domain. If the disk attachments are not listed, the global storage domain parameter will be ignored.
// +
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <storage_domain id="123"/>
//   <vm id="456">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="789">
//           <format>cow</format>
//           <sparse>true</sparse>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
// 2. Per each disk attachment. Specify the desired storage domain for each disk attachment.
// Specifying the global storage definition will override the storage domain per disk attachment specification.
// +
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="456">
//           <format>cow</format>
//           <sparse>true</sparse>
//           <storage_domains>
//              <storage_domain id="789"/>
//           </storage_domains>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
//
type templatesServiceAddRequest struct {
	templatesService *templatesService
	header           map[string]string
	query            map[string]string
	clonePermissions *bool
	seal             *bool
	template         *Template
}

func (p *templatesServiceAddRequest) Header(key, value string) *templatesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templatesServiceAddRequest) Query(key, value string) *templatesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templatesServiceAddRequest) ClonePermissions(clonePermissions bool) *templatesServiceAddRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *templatesServiceAddRequest) Seal(seal bool) *templatesServiceAddRequest {
	p.seal = &seal
	return p
}

func (p *templatesServiceAddRequest) Template(template *Template) *templatesServiceAddRequest {
	p.template = template
	return p
}

func (p *templatesServiceAddRequest) Send() (*templatesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templatesService.connection.URL(), p.templatesService.path)
	values := make(url.Values)
	if p.clonePermissions != nil {
		values["clone_permissions"] = []string{fmt.Sprintf("%v", *p.clonePermissions)}
	}

	if p.seal != nil {
		values["seal"] = []string{fmt.Sprintf("%v", *p.seal)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTemplateWriteOne(writer, p.template, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templatesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templatesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templatesServiceAddResponse{template: result}, nil
}

func (p *templatesServiceAddRequest) MustSend() *templatesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.templatesService.connection.URL(), p.templatesService.path)
	values := make(url.Values)
	if p.clonePermissions != nil {
		values["clone_permissions"] = []string{fmt.Sprintf("%v", *p.clonePermissions)}
	}

	if p.seal != nil {
		values["seal"] = []string{fmt.Sprintf("%v", *p.seal)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTemplateWriteOne(writer, p.template, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templatesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templatesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templatesServiceAddResponse{template: result}
}

//
// Creates a new template.
// This requires the `name` and `vm` elements. To identify the virtual machine use the `vm.id` or `vm.name`
// attributes. For example, to create a template from a virtual machine with the identifier `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/templates
// ----
// With a request body like this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
// </template>
// ----
// The disks of the template can be customized, making some of their characteristics different from the disks of the
// original virtual machine. To do so use the `vm.disk_attachments` attribute, specifying the identifier of the disk
// of the original virtual machine and the characteristics that you want to change. For example, if the original
// virtual machine has a disk with the identifier `456`, and, for that disk, you want to change the name to `mydisk`
// the format to <<types/disk_format, _Copy On Write_>> and make it <<types/disk, sparse>>, send a request body like
// this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="456">
//           <name>mydisk</name>
//           <format>cow</format>
//           <sparse>true</sparse>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
// The template can be created as a sub-version of an existing template. This requires the `name` and `vm` attributes
// for the new template, and the `base_template` and `version_name` attributes for the new template version. The
// `base_template` and `version_name` attributes must be specified within a `version` section enclosed in the
// `template` section. Identify the virtual machine with the `id` or `name` attributes.
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
//   <version>
//     <base_template id="456"/>
//     <version_name>mytemplate_001</version_name>
//   </version>
// </template>
// ----
// The destination storage domain of the template can be customized, in one of two ways:
// 1. Globally, at the request level. The request must list the desired disk attachments to be created on the
// storage domain. If the disk attachments are not listed, the global storage domain parameter will be ignored.
// +
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <storage_domain id="123"/>
//   <vm id="456">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="789">
//           <format>cow</format>
//           <sparse>true</sparse>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
// 2. Per each disk attachment. Specify the desired storage domain for each disk attachment.
// Specifying the global storage definition will override the storage domain per disk attachment specification.
// +
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="456">
//           <format>cow</format>
//           <sparse>true</sparse>
//           <storage_domains>
//              <storage_domain id="789"/>
//           </storage_domains>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
//
type templatesServiceAddResponse struct {
	template *Template
}

func (p *templatesServiceAddResponse) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

func (p *templatesServiceAddResponse) MustTemplate() *Template {
	if p.template == nil {
		panic("template in response does not exist")
	}
	return p.template
}

//
// Creates a new template.
// This requires the `name` and `vm` elements. To identify the virtual machine use the `vm.id` or `vm.name`
// attributes. For example, to create a template from a virtual machine with the identifier `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/templates
// ----
// With a request body like this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
// </template>
// ----
// The disks of the template can be customized, making some of their characteristics different from the disks of the
// original virtual machine. To do so use the `vm.disk_attachments` attribute, specifying the identifier of the disk
// of the original virtual machine and the characteristics that you want to change. For example, if the original
// virtual machine has a disk with the identifier `456`, and, for that disk, you want to change the name to `mydisk`
// the format to <<types/disk_format, _Copy On Write_>> and make it <<types/disk, sparse>>, send a request body like
// this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="456">
//           <name>mydisk</name>
//           <format>cow</format>
//           <sparse>true</sparse>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
// The template can be created as a sub-version of an existing template. This requires the `name` and `vm` attributes
// for the new template, and the `base_template` and `version_name` attributes for the new template version. The
// `base_template` and `version_name` attributes must be specified within a `version` section enclosed in the
// `template` section. Identify the virtual machine with the `id` or `name` attributes.
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
//   <version>
//     <base_template id="456"/>
//     <version_name>mytemplate_001</version_name>
//   </version>
// </template>
// ----
// The destination storage domain of the template can be customized, in one of two ways:
// 1. Globally, at the request level. The request must list the desired disk attachments to be created on the
// storage domain. If the disk attachments are not listed, the global storage domain parameter will be ignored.
// +
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <storage_domain id="123"/>
//   <vm id="456">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="789">
//           <format>cow</format>
//           <sparse>true</sparse>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
// 2. Per each disk attachment. Specify the desired storage domain for each disk attachment.
// Specifying the global storage definition will override the storage domain per disk attachment specification.
// +
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="456">
//           <format>cow</format>
//           <sparse>true</sparse>
//           <storage_domains>
//              <storage_domain id="789"/>
//           </storage_domains>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
//
func (p *templatesService) Add() *templatesServiceAddRequest {
	return &templatesServiceAddRequest{templatesService: p}
}

//
// Returns the list of virtual machine templates.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/templates
// ----
// Will return the list of virtual machines and virtual machine templates.
// The order of the returned list of templates is not guaranteed.
//
type templatesServiceListRequest struct {
	templatesService *templatesService
	header           map[string]string
	query            map[string]string
	caseSensitive    *bool
	filter           *bool
	follow           *string
	max              *int64
	search           *string
}

func (p *templatesServiceListRequest) Header(key, value string) *templatesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templatesServiceListRequest) Query(key, value string) *templatesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templatesServiceListRequest) CaseSensitive(caseSensitive bool) *templatesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *templatesServiceListRequest) Filter(filter bool) *templatesServiceListRequest {
	p.filter = &filter
	return p
}

func (p *templatesServiceListRequest) Follow(follow string) *templatesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *templatesServiceListRequest) Max(max int64) *templatesServiceListRequest {
	p.max = &max
	return p
}

func (p *templatesServiceListRequest) Search(search string) *templatesServiceListRequest {
	p.search = &search
	return p
}

func (p *templatesServiceListRequest) Send() (*templatesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templatesService.connection.URL(), p.templatesService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templatesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templatesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &templatesServiceListResponse{templates: result}, nil
}

func (p *templatesServiceListRequest) MustSend() *templatesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.templatesService.connection.URL(), p.templatesService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templatesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templatesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &templatesServiceListResponse{templates: result}
}

//
// Returns the list of virtual machine templates.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/templates
// ----
// Will return the list of virtual machines and virtual machine templates.
// The order of the returned list of templates is not guaranteed.
//
type templatesServiceListResponse struct {
	templates *TemplateSlice
}

func (p *templatesServiceListResponse) Templates() (*TemplateSlice, bool) {
	if p.templates != nil {
		return p.templates, true
	}
	return nil, false
}

func (p *templatesServiceListResponse) MustTemplates() *TemplateSlice {
	if p.templates == nil {
		panic("templates in response does not exist")
	}
	return p.templates
}

//
// Returns the list of virtual machine templates.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/templates
// ----
// Will return the list of virtual machines and virtual machine templates.
// The order of the returned list of templates is not guaranteed.
//
func (p *templatesService) List() *templatesServiceListRequest {
	return &templatesServiceListRequest{templatesService: p}
}

//
// Returns a reference to the service that manages a specific virtual machine template.
//
func (op *templatesService) TemplateService(id string) *templateService {
	return NewTemplateService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templatesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.TemplateService(path), nil
	}
	return op.TemplateService(path[:index]).Service(path[index+1:])
}

func (op *templatesService) String() string {
	return fmt.Sprintf("templatesService:%s", op.path)
}

//
// Returns the details of the disks attached to a virtual machine in the export domain.
//
type storageDomainVmDiskAttachmentService struct {
	baseService
}

func NewStorageDomainVmDiskAttachmentService(connection *Connection, path string) *storageDomainVmDiskAttachmentService {
	var result storageDomainVmDiskAttachmentService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the details of the attachment with all its properties and a link to the disk.
//
type storageDomainVmDiskAttachmentServiceGetRequest struct {
	storageDomainVmDiskAttachmentService *storageDomainVmDiskAttachmentService
	header                               map[string]string
	query                                map[string]string
	follow                               *string
}

func (p *storageDomainVmDiskAttachmentServiceGetRequest) Header(key, value string) *storageDomainVmDiskAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainVmDiskAttachmentServiceGetRequest) Query(key, value string) *storageDomainVmDiskAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainVmDiskAttachmentServiceGetRequest) Follow(follow string) *storageDomainVmDiskAttachmentServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainVmDiskAttachmentServiceGetRequest) Send() (*storageDomainVmDiskAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmDiskAttachmentService.connection.URL(), p.storageDomainVmDiskAttachmentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmDiskAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmDiskAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageDomainVmDiskAttachmentServiceGetResponse{attachment: result}, nil
}

func (p *storageDomainVmDiskAttachmentServiceGetRequest) MustSend() *storageDomainVmDiskAttachmentServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainVmDiskAttachmentService.connection.URL(), p.storageDomainVmDiskAttachmentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainVmDiskAttachmentService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainVmDiskAttachmentService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageDomainVmDiskAttachmentServiceGetResponse{attachment: result}
}

//
// Returns the details of the attachment with all its properties and a link to the disk.
//
type storageDomainVmDiskAttachmentServiceGetResponse struct {
	attachment *DiskAttachment
}

func (p *storageDomainVmDiskAttachmentServiceGetResponse) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *storageDomainVmDiskAttachmentServiceGetResponse) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
// Returns the details of the attachment with all its properties and a link to the disk.
//
func (p *storageDomainVmDiskAttachmentService) Get() *storageDomainVmDiskAttachmentServiceGetRequest {
	return &storageDomainVmDiskAttachmentServiceGetRequest{storageDomainVmDiskAttachmentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainVmDiskAttachmentService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *storageDomainVmDiskAttachmentService) String() string {
	return fmt.Sprintf("storageDomainVmDiskAttachmentService:%s", op.path)
}

//
// A service to manage data center networks.
//
type dataCenterNetworksService struct {
	baseService
}

func NewDataCenterNetworksService(connection *Connection, path string) *dataCenterNetworksService {
	var result dataCenterNetworksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Create a new network in a data center.
// Post a request like in the example below to create a new network in a data center with an ID of `123`.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// Use the following example in its body:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
// </network>
// ----
//
type dataCenterNetworksServiceAddRequest struct {
	dataCenterNetworksService *dataCenterNetworksService
	header                    map[string]string
	query                     map[string]string
	network                   *Network
}

func (p *dataCenterNetworksServiceAddRequest) Header(key, value string) *dataCenterNetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *dataCenterNetworksServiceAddRequest) Query(key, value string) *dataCenterNetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *dataCenterNetworksServiceAddRequest) Network(network *Network) *dataCenterNetworksServiceAddRequest {
	p.network = network
	return p
}

func (p *dataCenterNetworksServiceAddRequest) Send() (*dataCenterNetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterNetworksService.connection.URL(), p.dataCenterNetworksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &dataCenterNetworksServiceAddResponse{network: result}, nil
}

func (p *dataCenterNetworksServiceAddRequest) MustSend() *dataCenterNetworksServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterNetworksService.connection.URL(), p.dataCenterNetworksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterNetworksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterNetworksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &dataCenterNetworksServiceAddResponse{network: result}
}

//
// Create a new network in a data center.
// Post a request like in the example below to create a new network in a data center with an ID of `123`.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// Use the following example in its body:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
// </network>
// ----
//
type dataCenterNetworksServiceAddResponse struct {
	network *Network
}

func (p *dataCenterNetworksServiceAddResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *dataCenterNetworksServiceAddResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Create a new network in a data center.
// Post a request like in the example below to create a new network in a data center with an ID of `123`.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// Use the following example in its body:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
// </network>
// ----
//
func (p *dataCenterNetworksService) Add() *dataCenterNetworksServiceAddRequest {
	return &dataCenterNetworksServiceAddRequest{dataCenterNetworksService: p}
}

//
// Lists networks in the data center.
// The order of the returned list of networks isn't guaranteed.
//
type dataCenterNetworksServiceListRequest struct {
	dataCenterNetworksService *dataCenterNetworksService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
}

func (p *dataCenterNetworksServiceListRequest) Header(key, value string) *dataCenterNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *dataCenterNetworksServiceListRequest) Query(key, value string) *dataCenterNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *dataCenterNetworksServiceListRequest) Follow(follow string) *dataCenterNetworksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *dataCenterNetworksServiceListRequest) Max(max int64) *dataCenterNetworksServiceListRequest {
	p.max = &max
	return p
}

func (p *dataCenterNetworksServiceListRequest) Send() (*dataCenterNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterNetworksService.connection.URL(), p.dataCenterNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &dataCenterNetworksServiceListResponse{networks: result}, nil
}

func (p *dataCenterNetworksServiceListRequest) MustSend() *dataCenterNetworksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.dataCenterNetworksService.connection.URL(), p.dataCenterNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.dataCenterNetworksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.dataCenterNetworksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &dataCenterNetworksServiceListResponse{networks: result}
}

//
// Lists networks in the data center.
// The order of the returned list of networks isn't guaranteed.
//
type dataCenterNetworksServiceListResponse struct {
	networks *NetworkSlice
}

func (p *dataCenterNetworksServiceListResponse) Networks() (*NetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *dataCenterNetworksServiceListResponse) MustNetworks() *NetworkSlice {
	if p.networks == nil {
		panic("networks in response does not exist")
	}
	return p.networks
}

//
// Lists networks in the data center.
// The order of the returned list of networks isn't guaranteed.
//
func (p *dataCenterNetworksService) List() *dataCenterNetworksServiceListRequest {
	return &dataCenterNetworksServiceListRequest{dataCenterNetworksService: p}
}

//
// Access the data center network service that manages the data center network specified by an ID.
//
func (op *dataCenterNetworksService) NetworkService(id string) *dataCenterNetworkService {
	return NewDataCenterNetworkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *dataCenterNetworksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NetworkService(path), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *dataCenterNetworksService) String() string {
	return fmt.Sprintf("dataCenterNetworksService:%s", op.path)
}

//
//
type vmNumaNodesService struct {
	baseService
}

func NewVmNumaNodesService(connection *Connection, path string) *vmNumaNodesService {
	var result vmNumaNodesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new virtual NUMA node for the virtual machine.
// An example of creating a NUMA node:
// [source]
// ----
// POST /ovirt-engine/api/vms/c7ecd2dc/numanodes
// Accept: application/xml
// Content-type: application/xml
// ----
// The request body can contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>1024</memory>
// </vm_numa_node>
// ----
//
type vmNumaNodesServiceAddRequest struct {
	vmNumaNodesService *vmNumaNodesService
	header             map[string]string
	query              map[string]string
	node               *VirtualNumaNode
}

func (p *vmNumaNodesServiceAddRequest) Header(key, value string) *vmNumaNodesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmNumaNodesServiceAddRequest) Query(key, value string) *vmNumaNodesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmNumaNodesServiceAddRequest) Node(node *VirtualNumaNode) *vmNumaNodesServiceAddRequest {
	p.node = node
	return p
}

func (p *vmNumaNodesServiceAddRequest) Send() (*vmNumaNodesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodesService.connection.URL(), p.vmNumaNodesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVirtualNumaNodeWriteOne(writer, p.node, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNumaNodesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNumaNodesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVirtualNumaNodeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmNumaNodesServiceAddResponse{node: result}, nil
}

func (p *vmNumaNodesServiceAddRequest) MustSend() *vmNumaNodesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodesService.connection.URL(), p.vmNumaNodesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVirtualNumaNodeWriteOne(writer, p.node, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNumaNodesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNumaNodesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVirtualNumaNodeReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmNumaNodesServiceAddResponse{node: result}
}

//
// Creates a new virtual NUMA node for the virtual machine.
// An example of creating a NUMA node:
// [source]
// ----
// POST /ovirt-engine/api/vms/c7ecd2dc/numanodes
// Accept: application/xml
// Content-type: application/xml
// ----
// The request body can contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>1024</memory>
// </vm_numa_node>
// ----
//
type vmNumaNodesServiceAddResponse struct {
	node *VirtualNumaNode
}

func (p *vmNumaNodesServiceAddResponse) Node() (*VirtualNumaNode, bool) {
	if p.node != nil {
		return p.node, true
	}
	return nil, false
}

func (p *vmNumaNodesServiceAddResponse) MustNode() *VirtualNumaNode {
	if p.node == nil {
		panic("node in response does not exist")
	}
	return p.node
}

//
// Creates a new virtual NUMA node for the virtual machine.
// An example of creating a NUMA node:
// [source]
// ----
// POST /ovirt-engine/api/vms/c7ecd2dc/numanodes
// Accept: application/xml
// Content-type: application/xml
// ----
// The request body can contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>1024</memory>
// </vm_numa_node>
// ----
//
func (p *vmNumaNodesService) Add() *vmNumaNodesServiceAddRequest {
	return &vmNumaNodesServiceAddRequest{vmNumaNodesService: p}
}

//
// Lists virtual NUMA nodes of a virtual machine.
// The order of the returned list of NUMA nodes isn't guaranteed.
//
type vmNumaNodesServiceListRequest struct {
	vmNumaNodesService *vmNumaNodesService
	header             map[string]string
	query              map[string]string
	follow             *string
	max                *int64
}

func (p *vmNumaNodesServiceListRequest) Header(key, value string) *vmNumaNodesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmNumaNodesServiceListRequest) Query(key, value string) *vmNumaNodesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmNumaNodesServiceListRequest) Follow(follow string) *vmNumaNodesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vmNumaNodesServiceListRequest) Max(max int64) *vmNumaNodesServiceListRequest {
	p.max = &max
	return p
}

func (p *vmNumaNodesServiceListRequest) Send() (*vmNumaNodesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodesService.connection.URL(), p.vmNumaNodesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNumaNodesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNumaNodesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVirtualNumaNodeReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vmNumaNodesServiceListResponse{nodes: result}, nil
}

func (p *vmNumaNodesServiceListRequest) MustSend() *vmNumaNodesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmNumaNodesService.connection.URL(), p.vmNumaNodesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmNumaNodesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmNumaNodesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVirtualNumaNodeReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vmNumaNodesServiceListResponse{nodes: result}
}

//
// Lists virtual NUMA nodes of a virtual machine.
// The order of the returned list of NUMA nodes isn't guaranteed.
//
type vmNumaNodesServiceListResponse struct {
	nodes *VirtualNumaNodeSlice
}

func (p *vmNumaNodesServiceListResponse) Nodes() (*VirtualNumaNodeSlice, bool) {
	if p.nodes != nil {
		return p.nodes, true
	}
	return nil, false
}

func (p *vmNumaNodesServiceListResponse) MustNodes() *VirtualNumaNodeSlice {
	if p.nodes == nil {
		panic("nodes in response does not exist")
	}
	return p.nodes
}

//
// Lists virtual NUMA nodes of a virtual machine.
// The order of the returned list of NUMA nodes isn't guaranteed.
//
func (p *vmNumaNodesService) List() *vmNumaNodesServiceListRequest {
	return &vmNumaNodesServiceListRequest{vmNumaNodesService: p}
}

//
//
func (op *vmNumaNodesService) NodeService(id string) *vmNumaNodeService {
	return NewVmNumaNodeService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmNumaNodesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NodeService(path), nil
	}
	return op.NodeService(path[:index]).Service(path[index+1:])
}

func (op *vmNumaNodesService) String() string {
	return fmt.Sprintf("vmNumaNodesService:%s", op.path)
}

//
// Lists the watchdogs of a virtual machine.
//
type vmWatchdogsService struct {
	baseService
}

func NewVmWatchdogsService(connection *Connection, path string) *vmWatchdogsService {
	var result vmWatchdogsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds new watchdog to the virtual machine.
// For example, to add a watchdog to a virtual machine, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
//
type vmWatchdogsServiceAddRequest struct {
	vmWatchdogsService *vmWatchdogsService
	header             map[string]string
	query              map[string]string
	watchdog           *Watchdog
}

func (p *vmWatchdogsServiceAddRequest) Header(key, value string) *vmWatchdogsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmWatchdogsServiceAddRequest) Query(key, value string) *vmWatchdogsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmWatchdogsServiceAddRequest) Watchdog(watchdog *Watchdog) *vmWatchdogsServiceAddRequest {
	p.watchdog = watchdog
	return p
}

func (p *vmWatchdogsServiceAddRequest) Send() (*vmWatchdogsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogsService.connection.URL(), p.vmWatchdogsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmWatchdogsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmWatchdogsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmWatchdogsServiceAddResponse{watchdog: result}, nil
}

func (p *vmWatchdogsServiceAddRequest) MustSend() *vmWatchdogsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogsService.connection.URL(), p.vmWatchdogsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmWatchdogsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmWatchdogsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmWatchdogsServiceAddResponse{watchdog: result}
}

//
// Adds new watchdog to the virtual machine.
// For example, to add a watchdog to a virtual machine, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
//
type vmWatchdogsServiceAddResponse struct {
	watchdog *Watchdog
}

func (p *vmWatchdogsServiceAddResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *vmWatchdogsServiceAddResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Adds new watchdog to the virtual machine.
// For example, to add a watchdog to a virtual machine, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
//
func (p *vmWatchdogsService) Add() *vmWatchdogsServiceAddRequest {
	return &vmWatchdogsServiceAddRequest{vmWatchdogsService: p}
}

//
// The list of watchdogs of the virtual machine.
// The order of the returned list of watchdogs isn't guaranteed.
//
type vmWatchdogsServiceListRequest struct {
	vmWatchdogsService *vmWatchdogsService
	header             map[string]string
	query              map[string]string
	follow             *string
	max                *int64
}

func (p *vmWatchdogsServiceListRequest) Header(key, value string) *vmWatchdogsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmWatchdogsServiceListRequest) Query(key, value string) *vmWatchdogsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmWatchdogsServiceListRequest) Follow(follow string) *vmWatchdogsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vmWatchdogsServiceListRequest) Max(max int64) *vmWatchdogsServiceListRequest {
	p.max = &max
	return p
}

func (p *vmWatchdogsServiceListRequest) Send() (*vmWatchdogsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogsService.connection.URL(), p.vmWatchdogsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmWatchdogsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmWatchdogsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vmWatchdogsServiceListResponse{watchdogs: result}, nil
}

func (p *vmWatchdogsServiceListRequest) MustSend() *vmWatchdogsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmWatchdogsService.connection.URL(), p.vmWatchdogsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmWatchdogsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmWatchdogsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vmWatchdogsServiceListResponse{watchdogs: result}
}

//
// The list of watchdogs of the virtual machine.
// The order of the returned list of watchdogs isn't guaranteed.
//
type vmWatchdogsServiceListResponse struct {
	watchdogs *WatchdogSlice
}

func (p *vmWatchdogsServiceListResponse) Watchdogs() (*WatchdogSlice, bool) {
	if p.watchdogs != nil {
		return p.watchdogs, true
	}
	return nil, false
}

func (p *vmWatchdogsServiceListResponse) MustWatchdogs() *WatchdogSlice {
	if p.watchdogs == nil {
		panic("watchdogs in response does not exist")
	}
	return p.watchdogs
}

//
// The list of watchdogs of the virtual machine.
// The order of the returned list of watchdogs isn't guaranteed.
//
func (p *vmWatchdogsService) List() *vmWatchdogsServiceListRequest {
	return &vmWatchdogsServiceListRequest{vmWatchdogsService: p}
}

//
// Returns a reference to the service that manages a specific watchdog.
//
func (op *vmWatchdogsService) WatchdogService(id string) *vmWatchdogService {
	return NewVmWatchdogService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmWatchdogsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.WatchdogService(path), nil
	}
	return op.WatchdogService(path[:index]).Service(path[index+1:])
}

func (op *vmWatchdogsService) String() string {
	return fmt.Sprintf("vmWatchdogsService:%s", op.path)
}

//
//
type instanceTypeWatchdogsService struct {
	baseService
}

func NewInstanceTypeWatchdogsService(connection *Connection, path string) *instanceTypeWatchdogsService {
	var result instanceTypeWatchdogsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add new watchdog to the instance type.
//
type instanceTypeWatchdogsServiceAddRequest struct {
	instanceTypeWatchdogsService *instanceTypeWatchdogsService
	header                       map[string]string
	query                        map[string]string
	watchdog                     *Watchdog
}

func (p *instanceTypeWatchdogsServiceAddRequest) Header(key, value string) *instanceTypeWatchdogsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeWatchdogsServiceAddRequest) Query(key, value string) *instanceTypeWatchdogsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeWatchdogsServiceAddRequest) Watchdog(watchdog *Watchdog) *instanceTypeWatchdogsServiceAddRequest {
	p.watchdog = watchdog
	return p
}

func (p *instanceTypeWatchdogsServiceAddRequest) Send() (*instanceTypeWatchdogsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogsService.connection.URL(), p.instanceTypeWatchdogsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeWatchdogsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &instanceTypeWatchdogsServiceAddResponse{watchdog: result}, nil
}

func (p *instanceTypeWatchdogsServiceAddRequest) MustSend() *instanceTypeWatchdogsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogsService.connection.URL(), p.instanceTypeWatchdogsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeWatchdogsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &instanceTypeWatchdogsServiceAddResponse{watchdog: result}
}

//
// Add new watchdog to the instance type.
//
type instanceTypeWatchdogsServiceAddResponse struct {
	watchdog *Watchdog
}

func (p *instanceTypeWatchdogsServiceAddResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *instanceTypeWatchdogsServiceAddResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Add new watchdog to the instance type.
//
func (p *instanceTypeWatchdogsService) Add() *instanceTypeWatchdogsServiceAddRequest {
	return &instanceTypeWatchdogsServiceAddRequest{instanceTypeWatchdogsService: p}
}

//
// Lists all the configured watchdogs of the instance type.
// The order of the returned list of watchdogs isn't guaranteed.
//
type instanceTypeWatchdogsServiceListRequest struct {
	instanceTypeWatchdogsService *instanceTypeWatchdogsService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
	max                          *int64
	search                       *string
}

func (p *instanceTypeWatchdogsServiceListRequest) Header(key, value string) *instanceTypeWatchdogsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeWatchdogsServiceListRequest) Query(key, value string) *instanceTypeWatchdogsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeWatchdogsServiceListRequest) Follow(follow string) *instanceTypeWatchdogsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *instanceTypeWatchdogsServiceListRequest) Max(max int64) *instanceTypeWatchdogsServiceListRequest {
	p.max = &max
	return p
}

func (p *instanceTypeWatchdogsServiceListRequest) Search(search string) *instanceTypeWatchdogsServiceListRequest {
	p.search = &search
	return p
}

func (p *instanceTypeWatchdogsServiceListRequest) Send() (*instanceTypeWatchdogsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogsService.connection.URL(), p.instanceTypeWatchdogsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeWatchdogsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &instanceTypeWatchdogsServiceListResponse{watchdogs: result}, nil
}

func (p *instanceTypeWatchdogsServiceListRequest) MustSend() *instanceTypeWatchdogsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeWatchdogsService.connection.URL(), p.instanceTypeWatchdogsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeWatchdogsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeWatchdogsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &instanceTypeWatchdogsServiceListResponse{watchdogs: result}
}

//
// Lists all the configured watchdogs of the instance type.
// The order of the returned list of watchdogs isn't guaranteed.
//
type instanceTypeWatchdogsServiceListResponse struct {
	watchdogs *WatchdogSlice
}

func (p *instanceTypeWatchdogsServiceListResponse) Watchdogs() (*WatchdogSlice, bool) {
	if p.watchdogs != nil {
		return p.watchdogs, true
	}
	return nil, false
}

func (p *instanceTypeWatchdogsServiceListResponse) MustWatchdogs() *WatchdogSlice {
	if p.watchdogs == nil {
		panic("watchdogs in response does not exist")
	}
	return p.watchdogs
}

//
// Lists all the configured watchdogs of the instance type.
// The order of the returned list of watchdogs isn't guaranteed.
//
func (p *instanceTypeWatchdogsService) List() *instanceTypeWatchdogsServiceListRequest {
	return &instanceTypeWatchdogsServiceListRequest{instanceTypeWatchdogsService: p}
}

//
//
func (op *instanceTypeWatchdogsService) WatchdogService(id string) *instanceTypeWatchdogService {
	return NewInstanceTypeWatchdogService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *instanceTypeWatchdogsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.WatchdogService(path), nil
	}
	return op.WatchdogService(path[:index]).Service(path[index+1:])
}

func (op *instanceTypeWatchdogsService) String() string {
	return fmt.Sprintf("instanceTypeWatchdogsService:%s", op.path)
}

//
// A service to manage steps.
//
type stepsService struct {
	baseService
}

func NewStepsService(connection *Connection, path string) *stepsService {
	var result stepsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add an external step to an existing job or to an existing step.
// For example, to add a step to `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps
// ----
// With the following request body:
// [source,xml]
// ----
// <step>
//   <description>Validating</description>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
// </step>
// ----
// The response should look like:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//   <external>true</external>
//   <number>2</number>
//   <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
type stepsServiceAddRequest struct {
	stepsService *stepsService
	header       map[string]string
	query        map[string]string
	step         *Step
}

func (p *stepsServiceAddRequest) Header(key, value string) *stepsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *stepsServiceAddRequest) Query(key, value string) *stepsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *stepsServiceAddRequest) Step(step *Step) *stepsServiceAddRequest {
	p.step = step
	return p
}

func (p *stepsServiceAddRequest) Send() (*stepsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.stepsService.connection.URL(), p.stepsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStepWriteOne(writer, p.step, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.stepsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.stepsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStepReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &stepsServiceAddResponse{step: result}, nil
}

func (p *stepsServiceAddRequest) MustSend() *stepsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.stepsService.connection.URL(), p.stepsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStepWriteOne(writer, p.step, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.stepsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.stepsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStepReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &stepsServiceAddResponse{step: result}
}

//
// Add an external step to an existing job or to an existing step.
// For example, to add a step to `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps
// ----
// With the following request body:
// [source,xml]
// ----
// <step>
//   <description>Validating</description>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
// </step>
// ----
// The response should look like:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//   <external>true</external>
//   <number>2</number>
//   <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
type stepsServiceAddResponse struct {
	step *Step
}

func (p *stepsServiceAddResponse) Step() (*Step, bool) {
	if p.step != nil {
		return p.step, true
	}
	return nil, false
}

func (p *stepsServiceAddResponse) MustStep() *Step {
	if p.step == nil {
		panic("step in response does not exist")
	}
	return p.step
}

//
// Add an external step to an existing job or to an existing step.
// For example, to add a step to `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps
// ----
// With the following request body:
// [source,xml]
// ----
// <step>
//   <description>Validating</description>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
// </step>
// ----
// The response should look like:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//   <external>true</external>
//   <number>2</number>
//   <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
func (p *stepsService) Add() *stepsServiceAddRequest {
	return &stepsServiceAddRequest{stepsService: p}
}

//
// Retrieves the representation of the steps.
// [source]
// ----
// GET /ovirt-engine/api/job/123/steps
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <steps>
//   <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//     </actions>
//     <description>Validating</description>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//     <external>true</external>
//     <number>2</number>
//     <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//     <status>started</status>
//     <type>validating</type>
//     <job href="/ovirt-engine/api/jobs/123" id="123"/>
//   </step>
//   ...
// </steps>
// ----
// The order of the returned list of steps isn't guaranteed.
//
type stepsServiceListRequest struct {
	stepsService *stepsService
	header       map[string]string
	query        map[string]string
	follow       *string
	max          *int64
}

func (p *stepsServiceListRequest) Header(key, value string) *stepsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *stepsServiceListRequest) Query(key, value string) *stepsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *stepsServiceListRequest) Follow(follow string) *stepsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *stepsServiceListRequest) Max(max int64) *stepsServiceListRequest {
	p.max = &max
	return p
}

func (p *stepsServiceListRequest) Send() (*stepsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.stepsService.connection.URL(), p.stepsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.stepsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.stepsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStepReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &stepsServiceListResponse{steps: result}, nil
}

func (p *stepsServiceListRequest) MustSend() *stepsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.stepsService.connection.URL(), p.stepsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.stepsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.stepsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStepReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &stepsServiceListResponse{steps: result}
}

//
// Retrieves the representation of the steps.
// [source]
// ----
// GET /ovirt-engine/api/job/123/steps
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <steps>
//   <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//     </actions>
//     <description>Validating</description>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//     <external>true</external>
//     <number>2</number>
//     <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//     <status>started</status>
//     <type>validating</type>
//     <job href="/ovirt-engine/api/jobs/123" id="123"/>
//   </step>
//   ...
// </steps>
// ----
// The order of the returned list of steps isn't guaranteed.
//
type stepsServiceListResponse struct {
	steps *StepSlice
}

func (p *stepsServiceListResponse) Steps() (*StepSlice, bool) {
	if p.steps != nil {
		return p.steps, true
	}
	return nil, false
}

func (p *stepsServiceListResponse) MustSteps() *StepSlice {
	if p.steps == nil {
		panic("steps in response does not exist")
	}
	return p.steps
}

//
// Retrieves the representation of the steps.
// [source]
// ----
// GET /ovirt-engine/api/job/123/steps
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <steps>
//   <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//     </actions>
//     <description>Validating</description>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//     <external>true</external>
//     <number>2</number>
//     <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//     <status>started</status>
//     <type>validating</type>
//     <job href="/ovirt-engine/api/jobs/123" id="123"/>
//   </step>
//   ...
// </steps>
// ----
// The order of the returned list of steps isn't guaranteed.
//
func (p *stepsService) List() *stepsServiceListRequest {
	return &stepsServiceListRequest{stepsService: p}
}

//
// Reference to the step service.
//
func (op *stepsService) StepService(id string) *stepService {
	return NewStepService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *stepsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StepService(path), nil
	}
	return op.StepService(path[:index]).Service(path[index+1:])
}

func (op *stepsService) String() string {
	return fmt.Sprintf("stepsService:%s", op.path)
}

//
// This service manages a single gluster volume.
//
type glusterVolumeService struct {
	baseService
}

func NewGlusterVolumeService(connection *Connection, path string) *glusterVolumeService {
	var result glusterVolumeService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get the gluster volume details.
// For example, to get details of a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
// This GET request will return the following output:
// [source,xml]
// ----
// <gluster_volume id="123">
//  <name>data</name>
//  <link href="/ovirt-engine/api/clusters/456/glustervolumes/123/glusterbricks" rel="glusterbricks"/>
//  <disperse_count>0</disperse_count>
//  <options>
//    <option>
//      <name>storage.owner-gid</name>
//      <value>36</value>
//    </option>
//    <option>
//      <name>performance.io-cache</name>
//      <value>off</value>
//    </option>
//    <option>
//      <name>cluster.data-self-heal-algorithm</name>
//      <value>full</value>
//    </option>
//  </options>
//  <redundancy_count>0</redundancy_count>
//  <replica_count>3</replica_count>
//  <status>up</status>
//  <stripe_count>0</stripe_count>
//  <transport_types>
//    <transport_type>tcp</transport_type>
//  </transport_types>
//  <volume_type>replicate</volume_type>
//  </gluster_volume>
// ----
//
type glusterVolumeServiceGetRequest struct {
	glusterVolumeService *glusterVolumeService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *glusterVolumeServiceGetRequest) Header(key, value string) *glusterVolumeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumeServiceGetRequest) Query(key, value string) *glusterVolumeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumeServiceGetRequest) Follow(follow string) *glusterVolumeServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *glusterVolumeServiceGetRequest) Send() (*glusterVolumeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterVolumeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &glusterVolumeServiceGetResponse{volume: result}, nil
}

func (p *glusterVolumeServiceGetRequest) MustSend() *glusterVolumeServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterVolumeReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &glusterVolumeServiceGetResponse{volume: result}
}

//
// Get the gluster volume details.
// For example, to get details of a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
// This GET request will return the following output:
// [source,xml]
// ----
// <gluster_volume id="123">
//  <name>data</name>
//  <link href="/ovirt-engine/api/clusters/456/glustervolumes/123/glusterbricks" rel="glusterbricks"/>
//  <disperse_count>0</disperse_count>
//  <options>
//    <option>
//      <name>storage.owner-gid</name>
//      <value>36</value>
//    </option>
//    <option>
//      <name>performance.io-cache</name>
//      <value>off</value>
//    </option>
//    <option>
//      <name>cluster.data-self-heal-algorithm</name>
//      <value>full</value>
//    </option>
//  </options>
//  <redundancy_count>0</redundancy_count>
//  <replica_count>3</replica_count>
//  <status>up</status>
//  <stripe_count>0</stripe_count>
//  <transport_types>
//    <transport_type>tcp</transport_type>
//  </transport_types>
//  <volume_type>replicate</volume_type>
//  </gluster_volume>
// ----
//
type glusterVolumeServiceGetResponse struct {
	volume *GlusterVolume
}

func (p *glusterVolumeServiceGetResponse) Volume() (*GlusterVolume, bool) {
	if p.volume != nil {
		return p.volume, true
	}
	return nil, false
}

func (p *glusterVolumeServiceGetResponse) MustVolume() *GlusterVolume {
	if p.volume == nil {
		panic("volume in response does not exist")
	}
	return p.volume
}

//
// Get the gluster volume details.
// For example, to get details of a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
// This GET request will return the following output:
// [source,xml]
// ----
// <gluster_volume id="123">
//  <name>data</name>
//  <link href="/ovirt-engine/api/clusters/456/glustervolumes/123/glusterbricks" rel="glusterbricks"/>
//  <disperse_count>0</disperse_count>
//  <options>
//    <option>
//      <name>storage.owner-gid</name>
//      <value>36</value>
//    </option>
//    <option>
//      <name>performance.io-cache</name>
//      <value>off</value>
//    </option>
//    <option>
//      <name>cluster.data-self-heal-algorithm</name>
//      <value>full</value>
//    </option>
//  </options>
//  <redundancy_count>0</redundancy_count>
//  <replica_count>3</replica_count>
//  <status>up</status>
//  <stripe_count>0</stripe_count>
//  <transport_types>
//    <transport_type>tcp</transport_type>
//  </transport_types>
//  <volume_type>replicate</volume_type>
//  </gluster_volume>
// ----
//
func (p *glusterVolumeService) Get() *glusterVolumeServiceGetRequest {
	return &glusterVolumeServiceGetRequest{glusterVolumeService: p}
}

//
// Get gluster volume profile statistics.
// For example, to get profile statistics for a gluster volume with identifier `123` in cluster `456`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/getprofilestatistics
// ----
//
type glusterVolumeServiceGetProfileStatisticsRequest struct {
	glusterVolumeService *glusterVolumeService
	header               map[string]string
	query                map[string]string
}

func (p *glusterVolumeServiceGetProfileStatisticsRequest) Header(key, value string) *glusterVolumeServiceGetProfileStatisticsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumeServiceGetProfileStatisticsRequest) Query(key, value string) *glusterVolumeServiceGetProfileStatisticsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumeServiceGetProfileStatisticsRequest) Send() (*glusterVolumeServiceGetProfileStatisticsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/getprofilestatistics", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustDetails()
	return &glusterVolumeServiceGetProfileStatisticsResponse{details: result}, nil
}

func (p *glusterVolumeServiceGetProfileStatisticsRequest) MustSend() *glusterVolumeServiceGetProfileStatisticsResponse {
	rawURL := fmt.Sprintf("%s%s/getprofilestatistics", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustDetails()
	return &glusterVolumeServiceGetProfileStatisticsResponse{details: result}
}

//
// Get gluster volume profile statistics.
// For example, to get profile statistics for a gluster volume with identifier `123` in cluster `456`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/getprofilestatistics
// ----
//
type glusterVolumeServiceGetProfileStatisticsResponse struct {
	details *GlusterVolumeProfileDetails
}

func (p *glusterVolumeServiceGetProfileStatisticsResponse) Details() (*GlusterVolumeProfileDetails, bool) {
	if p.details != nil {
		return p.details, true
	}
	return nil, false
}

func (p *glusterVolumeServiceGetProfileStatisticsResponse) MustDetails() *GlusterVolumeProfileDetails {
	if p.details == nil {
		panic("details in response does not exist")
	}
	return p.details
}

//
// Get gluster volume profile statistics.
// For example, to get profile statistics for a gluster volume with identifier `123` in cluster `456`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/getprofilestatistics
// ----
//
func (p *glusterVolumeService) GetProfileStatistics() *glusterVolumeServiceGetProfileStatisticsRequest {
	return &glusterVolumeServiceGetProfileStatisticsRequest{glusterVolumeService: p}
}

//
// Rebalance the gluster volume.
// Rebalancing a gluster volume helps to distribute the data evenly across all the bricks. After expanding or
// shrinking a gluster volume (without migrating data), we need to rebalance the data among the bricks. In a
// non-replicated volume, all bricks should be online to perform the rebalance operation. In a replicated volume, at
// least one of the bricks in the replica should be online.
// For example, to rebalance a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/rebalance
// ----
//
type glusterVolumeServiceRebalanceRequest struct {
	glusterVolumeService *glusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	fixLayout            *bool
	force                *bool
}

func (p *glusterVolumeServiceRebalanceRequest) Header(key, value string) *glusterVolumeServiceRebalanceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumeServiceRebalanceRequest) Query(key, value string) *glusterVolumeServiceRebalanceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumeServiceRebalanceRequest) Async(async bool) *glusterVolumeServiceRebalanceRequest {
	p.async = &async
	return p
}

func (p *glusterVolumeServiceRebalanceRequest) FixLayout(fixLayout bool) *glusterVolumeServiceRebalanceRequest {
	p.fixLayout = &fixLayout
	return p
}

func (p *glusterVolumeServiceRebalanceRequest) Force(force bool) *glusterVolumeServiceRebalanceRequest {
	p.force = &force
	return p
}

func (p *glusterVolumeServiceRebalanceRequest) Send() (*glusterVolumeServiceRebalanceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/rebalance", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.fixLayout != nil {
		actionBuilder.FixLayout(*p.fixLayout)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterVolumeServiceRebalanceResponse), nil
}

func (p *glusterVolumeServiceRebalanceRequest) MustSend() *glusterVolumeServiceRebalanceResponse {
	rawURL := fmt.Sprintf("%s%s/rebalance", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.fixLayout != nil {
		actionBuilder.FixLayout(*p.fixLayout)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterVolumeServiceRebalanceResponse)
}

//
// Rebalance the gluster volume.
// Rebalancing a gluster volume helps to distribute the data evenly across all the bricks. After expanding or
// shrinking a gluster volume (without migrating data), we need to rebalance the data among the bricks. In a
// non-replicated volume, all bricks should be online to perform the rebalance operation. In a replicated volume, at
// least one of the bricks in the replica should be online.
// For example, to rebalance a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/rebalance
// ----
//
type glusterVolumeServiceRebalanceResponse struct {
}

//
// Rebalance the gluster volume.
// Rebalancing a gluster volume helps to distribute the data evenly across all the bricks. After expanding or
// shrinking a gluster volume (without migrating data), we need to rebalance the data among the bricks. In a
// non-replicated volume, all bricks should be online to perform the rebalance operation. In a replicated volume, at
// least one of the bricks in the replica should be online.
// For example, to rebalance a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/rebalance
// ----
//
func (p *glusterVolumeService) Rebalance() *glusterVolumeServiceRebalanceRequest {
	return &glusterVolumeServiceRebalanceRequest{glusterVolumeService: p}
}

//
// Removes the gluster volume.
// For example, to remove a volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
//
type glusterVolumeServiceRemoveRequest struct {
	glusterVolumeService *glusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *glusterVolumeServiceRemoveRequest) Header(key, value string) *glusterVolumeServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumeServiceRemoveRequest) Query(key, value string) *glusterVolumeServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumeServiceRemoveRequest) Async(async bool) *glusterVolumeServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *glusterVolumeServiceRemoveRequest) Send() (*glusterVolumeServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(glusterVolumeServiceRemoveResponse), nil
}

func (p *glusterVolumeServiceRemoveRequest) MustSend() *glusterVolumeServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(glusterVolumeServiceRemoveResponse)
}

//
// Removes the gluster volume.
// For example, to remove a volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
//
type glusterVolumeServiceRemoveResponse struct {
}

//
// Removes the gluster volume.
// For example, to remove a volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
//
func (p *glusterVolumeService) Remove() *glusterVolumeServiceRemoveRequest {
	return &glusterVolumeServiceRemoveRequest{glusterVolumeService: p}
}

//
// Resets all the options set in the gluster volume.
// For example, to reset all options in a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetalloptions
// ----
//
type glusterVolumeServiceResetAllOptionsRequest struct {
	glusterVolumeService *glusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *glusterVolumeServiceResetAllOptionsRequest) Header(key, value string) *glusterVolumeServiceResetAllOptionsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumeServiceResetAllOptionsRequest) Query(key, value string) *glusterVolumeServiceResetAllOptionsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumeServiceResetAllOptionsRequest) Async(async bool) *glusterVolumeServiceResetAllOptionsRequest {
	p.async = &async
	return p
}

func (p *glusterVolumeServiceResetAllOptionsRequest) Send() (*glusterVolumeServiceResetAllOptionsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resetalloptions", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterVolumeServiceResetAllOptionsResponse), nil
}

func (p *glusterVolumeServiceResetAllOptionsRequest) MustSend() *glusterVolumeServiceResetAllOptionsResponse {
	rawURL := fmt.Sprintf("%s%s/resetalloptions", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterVolumeServiceResetAllOptionsResponse)
}

//
// Resets all the options set in the gluster volume.
// For example, to reset all options in a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetalloptions
// ----
//
type glusterVolumeServiceResetAllOptionsResponse struct {
}

//
// Resets all the options set in the gluster volume.
// For example, to reset all options in a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetalloptions
// ----
//
func (p *glusterVolumeService) ResetAllOptions() *glusterVolumeServiceResetAllOptionsRequest {
	return &glusterVolumeServiceResetAllOptionsRequest{glusterVolumeService: p}
}

//
// Resets a particular option in the gluster volume.
// For example, to reset a particular option `option1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1"/>
// </action>
// ----
//
type glusterVolumeServiceResetOptionRequest struct {
	glusterVolumeService *glusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	force                *bool
	option               *Option
}

func (p *glusterVolumeServiceResetOptionRequest) Header(key, value string) *glusterVolumeServiceResetOptionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumeServiceResetOptionRequest) Query(key, value string) *glusterVolumeServiceResetOptionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumeServiceResetOptionRequest) Async(async bool) *glusterVolumeServiceResetOptionRequest {
	p.async = &async
	return p
}

func (p *glusterVolumeServiceResetOptionRequest) Force(force bool) *glusterVolumeServiceResetOptionRequest {
	p.force = &force
	return p
}

func (p *glusterVolumeServiceResetOptionRequest) Option(option *Option) *glusterVolumeServiceResetOptionRequest {
	p.option = option
	return p
}

func (p *glusterVolumeServiceResetOptionRequest) Send() (*glusterVolumeServiceResetOptionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resetoption", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	actionBuilder.Option(p.option)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterVolumeServiceResetOptionResponse), nil
}

func (p *glusterVolumeServiceResetOptionRequest) MustSend() *glusterVolumeServiceResetOptionResponse {
	rawURL := fmt.Sprintf("%s%s/resetoption", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	actionBuilder.Option(p.option)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterVolumeServiceResetOptionResponse)
}

//
// Resets a particular option in the gluster volume.
// For example, to reset a particular option `option1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1"/>
// </action>
// ----
//
type glusterVolumeServiceResetOptionResponse struct {
}

//
// Resets a particular option in the gluster volume.
// For example, to reset a particular option `option1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1"/>
// </action>
// ----
//
func (p *glusterVolumeService) ResetOption() *glusterVolumeServiceResetOptionRequest {
	return &glusterVolumeServiceResetOptionRequest{glusterVolumeService: p}
}

//
// Sets a particular option in the gluster volume.
// For example, to set `option1` with value `value1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/setoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1" value="value1"/>
// </action>
// ----
//
type glusterVolumeServiceSetOptionRequest struct {
	glusterVolumeService *glusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	option               *Option
}

func (p *glusterVolumeServiceSetOptionRequest) Header(key, value string) *glusterVolumeServiceSetOptionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumeServiceSetOptionRequest) Query(key, value string) *glusterVolumeServiceSetOptionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumeServiceSetOptionRequest) Async(async bool) *glusterVolumeServiceSetOptionRequest {
	p.async = &async
	return p
}

func (p *glusterVolumeServiceSetOptionRequest) Option(option *Option) *glusterVolumeServiceSetOptionRequest {
	p.option = option
	return p
}

func (p *glusterVolumeServiceSetOptionRequest) Send() (*glusterVolumeServiceSetOptionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/setoption", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Option(p.option)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterVolumeServiceSetOptionResponse), nil
}

func (p *glusterVolumeServiceSetOptionRequest) MustSend() *glusterVolumeServiceSetOptionResponse {
	rawURL := fmt.Sprintf("%s%s/setoption", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Option(p.option)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterVolumeServiceSetOptionResponse)
}

//
// Sets a particular option in the gluster volume.
// For example, to set `option1` with value `value1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/setoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1" value="value1"/>
// </action>
// ----
//
type glusterVolumeServiceSetOptionResponse struct {
}

//
// Sets a particular option in the gluster volume.
// For example, to set `option1` with value `value1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/setoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1" value="value1"/>
// </action>
// ----
//
func (p *glusterVolumeService) SetOption() *glusterVolumeServiceSetOptionRequest {
	return &glusterVolumeServiceSetOptionRequest{glusterVolumeService: p}
}

//
// Starts the gluster volume.
// A Gluster Volume should be started to read/write data. For example, to start a gluster volume with identifier
// `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/start
// ----
//
type glusterVolumeServiceStartRequest struct {
	glusterVolumeService *glusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	force                *bool
}

func (p *glusterVolumeServiceStartRequest) Header(key, value string) *glusterVolumeServiceStartRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumeServiceStartRequest) Query(key, value string) *glusterVolumeServiceStartRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumeServiceStartRequest) Async(async bool) *glusterVolumeServiceStartRequest {
	p.async = &async
	return p
}

func (p *glusterVolumeServiceStartRequest) Force(force bool) *glusterVolumeServiceStartRequest {
	p.force = &force
	return p
}

func (p *glusterVolumeServiceStartRequest) Send() (*glusterVolumeServiceStartResponse, error) {
	rawURL := fmt.Sprintf("%s%s/start", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterVolumeServiceStartResponse), nil
}

func (p *glusterVolumeServiceStartRequest) MustSend() *glusterVolumeServiceStartResponse {
	rawURL := fmt.Sprintf("%s%s/start", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterVolumeServiceStartResponse)
}

//
// Starts the gluster volume.
// A Gluster Volume should be started to read/write data. For example, to start a gluster volume with identifier
// `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/start
// ----
//
type glusterVolumeServiceStartResponse struct {
}

//
// Starts the gluster volume.
// A Gluster Volume should be started to read/write data. For example, to start a gluster volume with identifier
// `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/start
// ----
//
func (p *glusterVolumeService) Start() *glusterVolumeServiceStartRequest {
	return &glusterVolumeServiceStartRequest{glusterVolumeService: p}
}

//
// Start profiling the gluster volume.
// For example, to start profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/startprofile
// ----
//
type glusterVolumeServiceStartProfileRequest struct {
	glusterVolumeService *glusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *glusterVolumeServiceStartProfileRequest) Header(key, value string) *glusterVolumeServiceStartProfileRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumeServiceStartProfileRequest) Query(key, value string) *glusterVolumeServiceStartProfileRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumeServiceStartProfileRequest) Async(async bool) *glusterVolumeServiceStartProfileRequest {
	p.async = &async
	return p
}

func (p *glusterVolumeServiceStartProfileRequest) Send() (*glusterVolumeServiceStartProfileResponse, error) {
	rawURL := fmt.Sprintf("%s%s/startprofile", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterVolumeServiceStartProfileResponse), nil
}

func (p *glusterVolumeServiceStartProfileRequest) MustSend() *glusterVolumeServiceStartProfileResponse {
	rawURL := fmt.Sprintf("%s%s/startprofile", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterVolumeServiceStartProfileResponse)
}

//
// Start profiling the gluster volume.
// For example, to start profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/startprofile
// ----
//
type glusterVolumeServiceStartProfileResponse struct {
}

//
// Start profiling the gluster volume.
// For example, to start profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/startprofile
// ----
//
func (p *glusterVolumeService) StartProfile() *glusterVolumeServiceStartProfileRequest {
	return &glusterVolumeServiceStartProfileRequest{glusterVolumeService: p}
}

//
// Stops the gluster volume.
// Stopping a volume will make its data inaccessible.
// For example, to stop a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stop
// ----
//
type glusterVolumeServiceStopRequest struct {
	glusterVolumeService *glusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	force                *bool
}

func (p *glusterVolumeServiceStopRequest) Header(key, value string) *glusterVolumeServiceStopRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumeServiceStopRequest) Query(key, value string) *glusterVolumeServiceStopRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumeServiceStopRequest) Async(async bool) *glusterVolumeServiceStopRequest {
	p.async = &async
	return p
}

func (p *glusterVolumeServiceStopRequest) Force(force bool) *glusterVolumeServiceStopRequest {
	p.force = &force
	return p
}

func (p *glusterVolumeServiceStopRequest) Send() (*glusterVolumeServiceStopResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stop", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterVolumeServiceStopResponse), nil
}

func (p *glusterVolumeServiceStopRequest) MustSend() *glusterVolumeServiceStopResponse {
	rawURL := fmt.Sprintf("%s%s/stop", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterVolumeServiceStopResponse)
}

//
// Stops the gluster volume.
// Stopping a volume will make its data inaccessible.
// For example, to stop a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stop
// ----
//
type glusterVolumeServiceStopResponse struct {
}

//
// Stops the gluster volume.
// Stopping a volume will make its data inaccessible.
// For example, to stop a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stop
// ----
//
func (p *glusterVolumeService) Stop() *glusterVolumeServiceStopRequest {
	return &glusterVolumeServiceStopRequest{glusterVolumeService: p}
}

//
// Stop profiling the gluster volume.
// For example, to stop profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stopprofile
// ----
//
type glusterVolumeServiceStopProfileRequest struct {
	glusterVolumeService *glusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *glusterVolumeServiceStopProfileRequest) Header(key, value string) *glusterVolumeServiceStopProfileRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumeServiceStopProfileRequest) Query(key, value string) *glusterVolumeServiceStopProfileRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumeServiceStopProfileRequest) Async(async bool) *glusterVolumeServiceStopProfileRequest {
	p.async = &async
	return p
}

func (p *glusterVolumeServiceStopProfileRequest) Send() (*glusterVolumeServiceStopProfileResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stopprofile", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterVolumeServiceStopProfileResponse), nil
}

func (p *glusterVolumeServiceStopProfileRequest) MustSend() *glusterVolumeServiceStopProfileResponse {
	rawURL := fmt.Sprintf("%s%s/stopprofile", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterVolumeServiceStopProfileResponse)
}

//
// Stop profiling the gluster volume.
// For example, to stop profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stopprofile
// ----
//
type glusterVolumeServiceStopProfileResponse struct {
}

//
// Stop profiling the gluster volume.
// For example, to stop profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stopprofile
// ----
//
func (p *glusterVolumeService) StopProfile() *glusterVolumeServiceStopProfileRequest {
	return &glusterVolumeServiceStopProfileRequest{glusterVolumeService: p}
}

//
// Stop rebalancing the gluster volume.
// For example, to stop rebalancing a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stoprebalance
// ----
//
type glusterVolumeServiceStopRebalanceRequest struct {
	glusterVolumeService *glusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *glusterVolumeServiceStopRebalanceRequest) Header(key, value string) *glusterVolumeServiceStopRebalanceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumeServiceStopRebalanceRequest) Query(key, value string) *glusterVolumeServiceStopRebalanceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumeServiceStopRebalanceRequest) Async(async bool) *glusterVolumeServiceStopRebalanceRequest {
	p.async = &async
	return p
}

func (p *glusterVolumeServiceStopRebalanceRequest) Send() (*glusterVolumeServiceStopRebalanceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stoprebalance", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterVolumeServiceStopRebalanceResponse), nil
}

func (p *glusterVolumeServiceStopRebalanceRequest) MustSend() *glusterVolumeServiceStopRebalanceResponse {
	rawURL := fmt.Sprintf("%s%s/stoprebalance", p.glusterVolumeService.connection.URL(), p.glusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterVolumeServiceStopRebalanceResponse)
}

//
// Stop rebalancing the gluster volume.
// For example, to stop rebalancing a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stoprebalance
// ----
//
type glusterVolumeServiceStopRebalanceResponse struct {
}

//
// Stop rebalancing the gluster volume.
// For example, to stop rebalancing a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stoprebalance
// ----
//
func (p *glusterVolumeService) StopRebalance() *glusterVolumeServiceStopRebalanceRequest {
	return &glusterVolumeServiceStopRebalanceRequest{glusterVolumeService: p}
}

//
// Reference to a service managing gluster bricks.
//
func (op *glusterVolumeService) GlusterBricksService() *glusterBricksService {
	return NewGlusterBricksService(op.connection, fmt.Sprintf("%s/glusterbricks", op.path))
}

//
//
func (op *glusterVolumeService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *glusterVolumeService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "glusterbricks" {
		return op.GlusterBricksService(), nil
	}
	if strings.HasPrefix(path, "glusterbricks/") {
		return op.GlusterBricksService().Service(path[14:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *glusterVolumeService) String() string {
	return fmt.Sprintf("glusterVolumeService:%s", op.path)
}

//
// This service manages the gluster bricks in a gluster volume
//
type glusterBricksService struct {
	baseService
}

func NewGlusterBricksService(connection *Connection, path string) *glusterBricksService {
	var result glusterBricksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Activate the bricks post data migration of remove brick operation.
// Used to activate brick(s) once the data migration from bricks is complete but user no longer wishes to remove
// bricks. The bricks that were previously marked for removal will now be used as normal bricks.
// For example, to retain the bricks that on glustervolume `123` from which data was migrated, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/activate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
//
type glusterBricksServiceActivateRequest struct {
	glusterBricksService *glusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               *GlusterBrickSlice
}

func (p *glusterBricksServiceActivateRequest) Header(key, value string) *glusterBricksServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterBricksServiceActivateRequest) Query(key, value string) *glusterBricksServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterBricksServiceActivateRequest) Async(async bool) *glusterBricksServiceActivateRequest {
	p.async = &async
	return p
}

func (p *glusterBricksServiceActivateRequest) Bricks(bricks *GlusterBrickSlice) *glusterBricksServiceActivateRequest {
	p.bricks = bricks
	return p
}

func (p *glusterBricksServiceActivateRequest) BricksOfAny(anys ...*GlusterBrick) *glusterBricksServiceActivateRequest {
	if p.bricks == nil {
		p.bricks = new(GlusterBrickSlice)
	}
	p.bricks.slice = append(p.bricks.slice, anys...)
	return p
}

func (p *glusterBricksServiceActivateRequest) Send() (*glusterBricksServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.glusterBricksService.connection.URL(), p.glusterBricksService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Bricks(p.bricks)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBricksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterBricksServiceActivateResponse), nil
}

func (p *glusterBricksServiceActivateRequest) MustSend() *glusterBricksServiceActivateResponse {
	rawURL := fmt.Sprintf("%s%s/activate", p.glusterBricksService.connection.URL(), p.glusterBricksService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Bricks(p.bricks)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBricksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterBricksServiceActivateResponse)
}

//
// Activate the bricks post data migration of remove brick operation.
// Used to activate brick(s) once the data migration from bricks is complete but user no longer wishes to remove
// bricks. The bricks that were previously marked for removal will now be used as normal bricks.
// For example, to retain the bricks that on glustervolume `123` from which data was migrated, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/activate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
//
type glusterBricksServiceActivateResponse struct {
}

//
// Activate the bricks post data migration of remove brick operation.
// Used to activate brick(s) once the data migration from bricks is complete but user no longer wishes to remove
// bricks. The bricks that were previously marked for removal will now be used as normal bricks.
// For example, to retain the bricks that on glustervolume `123` from which data was migrated, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/activate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
//
func (p *glusterBricksService) Activate() *glusterBricksServiceActivateRequest {
	return &glusterBricksServiceActivateRequest{glusterBricksService: p}
}

//
// Adds a list of bricks to gluster volume.
// Used to expand a gluster volume by adding bricks. For replicated volume types, the parameter `replica_count`
// needs to be passed. In case the replica count is being increased, then the number of bricks needs to be
// equivalent to the number of replica sets.
// For example, to add bricks to gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <server_id>111</server_id>
//     <brick_dir>/export/data/brick3</brick_dir>
//   </brick>
// </bricks>
// ----
//
type glusterBricksServiceAddRequest struct {
	glusterBricksService *glusterBricksService
	header               map[string]string
	query                map[string]string
	bricks               *GlusterBrickSlice
	replicaCount         *int64
	stripeCount          *int64
}

func (p *glusterBricksServiceAddRequest) Header(key, value string) *glusterBricksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterBricksServiceAddRequest) Query(key, value string) *glusterBricksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterBricksServiceAddRequest) Bricks(bricks *GlusterBrickSlice) *glusterBricksServiceAddRequest {
	p.bricks = bricks
	return p
}

func (p *glusterBricksServiceAddRequest) BricksOfAny(anys ...*GlusterBrick) *glusterBricksServiceAddRequest {
	if p.bricks == nil {
		p.bricks = new(GlusterBrickSlice)
	}
	p.bricks.slice = append(p.bricks.slice, anys...)
	return p
}

func (p *glusterBricksServiceAddRequest) ReplicaCount(replicaCount int64) *glusterBricksServiceAddRequest {
	p.replicaCount = &replicaCount
	return p
}

func (p *glusterBricksServiceAddRequest) StripeCount(stripeCount int64) *glusterBricksServiceAddRequest {
	p.stripeCount = &stripeCount
	return p
}

func (p *glusterBricksServiceAddRequest) Send() (*glusterBricksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBricksService.connection.URL(), p.glusterBricksService.path)
	values := make(url.Values)
	if p.replicaCount != nil {
		values["replica_count"] = []string{fmt.Sprintf("%v", *p.replicaCount)}
	}

	if p.stripeCount != nil {
		values["stripe_count"] = []string{fmt.Sprintf("%v", *p.stripeCount)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGlusterBrickWriteMany(writer, p.bricks, "", "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBricksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterBrickReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &glusterBricksServiceAddResponse{bricks: result}, nil
}

func (p *glusterBricksServiceAddRequest) MustSend() *glusterBricksServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.glusterBricksService.connection.URL(), p.glusterBricksService.path)
	values := make(url.Values)
	if p.replicaCount != nil {
		values["replica_count"] = []string{fmt.Sprintf("%v", *p.replicaCount)}
	}

	if p.stripeCount != nil {
		values["stripe_count"] = []string{fmt.Sprintf("%v", *p.stripeCount)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGlusterBrickWriteMany(writer, p.bricks, "", "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBricksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterBrickReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &glusterBricksServiceAddResponse{bricks: result}
}

//
// Adds a list of bricks to gluster volume.
// Used to expand a gluster volume by adding bricks. For replicated volume types, the parameter `replica_count`
// needs to be passed. In case the replica count is being increased, then the number of bricks needs to be
// equivalent to the number of replica sets.
// For example, to add bricks to gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <server_id>111</server_id>
//     <brick_dir>/export/data/brick3</brick_dir>
//   </brick>
// </bricks>
// ----
//
type glusterBricksServiceAddResponse struct {
	bricks *GlusterBrickSlice
}

func (p *glusterBricksServiceAddResponse) Bricks() (*GlusterBrickSlice, bool) {
	if p.bricks != nil {
		return p.bricks, true
	}
	return nil, false
}

func (p *glusterBricksServiceAddResponse) MustBricks() *GlusterBrickSlice {
	if p.bricks == nil {
		panic("bricks in response does not exist")
	}
	return p.bricks
}

//
// Adds a list of bricks to gluster volume.
// Used to expand a gluster volume by adding bricks. For replicated volume types, the parameter `replica_count`
// needs to be passed. In case the replica count is being increased, then the number of bricks needs to be
// equivalent to the number of replica sets.
// For example, to add bricks to gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <server_id>111</server_id>
//     <brick_dir>/export/data/brick3</brick_dir>
//   </brick>
// </bricks>
// ----
//
func (p *glusterBricksService) Add() *glusterBricksServiceAddRequest {
	return &glusterBricksServiceAddRequest{glusterBricksService: p}
}

//
// Lists the bricks of a gluster volume.
// For example, to list bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// Provides an output as below:
// [source,xml]
// ----
// <bricks>
//   <brick id="234">
//     <name>host1:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>111</server_id>
//     <status>up</status>
//   </brick>
//   <brick id="233">
//     <name>host2:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>222</server_id>
//     <status>up</status>
//   </brick>
// </bricks>
// ----
// The order of the returned list is based on the brick order provided at gluster volume creation.
//
type glusterBricksServiceListRequest struct {
	glusterBricksService *glusterBricksService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *glusterBricksServiceListRequest) Header(key, value string) *glusterBricksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterBricksServiceListRequest) Query(key, value string) *glusterBricksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterBricksServiceListRequest) Follow(follow string) *glusterBricksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *glusterBricksServiceListRequest) Max(max int64) *glusterBricksServiceListRequest {
	p.max = &max
	return p
}

func (p *glusterBricksServiceListRequest) Send() (*glusterBricksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBricksService.connection.URL(), p.glusterBricksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBricksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterBrickReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &glusterBricksServiceListResponse{bricks: result}, nil
}

func (p *glusterBricksServiceListRequest) MustSend() *glusterBricksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.glusterBricksService.connection.URL(), p.glusterBricksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBricksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterBrickReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &glusterBricksServiceListResponse{bricks: result}
}

//
// Lists the bricks of a gluster volume.
// For example, to list bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// Provides an output as below:
// [source,xml]
// ----
// <bricks>
//   <brick id="234">
//     <name>host1:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>111</server_id>
//     <status>up</status>
//   </brick>
//   <brick id="233">
//     <name>host2:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>222</server_id>
//     <status>up</status>
//   </brick>
// </bricks>
// ----
// The order of the returned list is based on the brick order provided at gluster volume creation.
//
type glusterBricksServiceListResponse struct {
	bricks *GlusterBrickSlice
}

func (p *glusterBricksServiceListResponse) Bricks() (*GlusterBrickSlice, bool) {
	if p.bricks != nil {
		return p.bricks, true
	}
	return nil, false
}

func (p *glusterBricksServiceListResponse) MustBricks() *GlusterBrickSlice {
	if p.bricks == nil {
		panic("bricks in response does not exist")
	}
	return p.bricks
}

//
// Lists the bricks of a gluster volume.
// For example, to list bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// Provides an output as below:
// [source,xml]
// ----
// <bricks>
//   <brick id="234">
//     <name>host1:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>111</server_id>
//     <status>up</status>
//   </brick>
//   <brick id="233">
//     <name>host2:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>222</server_id>
//     <status>up</status>
//   </brick>
// </bricks>
// ----
// The order of the returned list is based on the brick order provided at gluster volume creation.
//
func (p *glusterBricksService) List() *glusterBricksServiceListRequest {
	return &glusterBricksServiceListRequest{glusterBricksService: p}
}

//
// Start migration of data prior to removing bricks.
// Removing bricks is a two-step process, where the data on bricks to be removed, is first migrated to remaining
// bricks. Once migration is completed the removal of bricks is confirmed via the API
// <<services/gluster_bricks/methods/remove, remove>>. If at any point, the action needs to be cancelled
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> has to be called.
// For instance, to delete a brick from a gluster volume with id `123`, send a request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/migrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
// The migration process can be tracked from the job id returned from the API using
// <<services/job/methods/get, job>> and steps in job using <<services/step/methods/get, step>>
//
type glusterBricksServiceMigrateRequest struct {
	glusterBricksService *glusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               *GlusterBrickSlice
}

func (p *glusterBricksServiceMigrateRequest) Header(key, value string) *glusterBricksServiceMigrateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterBricksServiceMigrateRequest) Query(key, value string) *glusterBricksServiceMigrateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterBricksServiceMigrateRequest) Async(async bool) *glusterBricksServiceMigrateRequest {
	p.async = &async
	return p
}

func (p *glusterBricksServiceMigrateRequest) Bricks(bricks *GlusterBrickSlice) *glusterBricksServiceMigrateRequest {
	p.bricks = bricks
	return p
}

func (p *glusterBricksServiceMigrateRequest) BricksOfAny(anys ...*GlusterBrick) *glusterBricksServiceMigrateRequest {
	if p.bricks == nil {
		p.bricks = new(GlusterBrickSlice)
	}
	p.bricks.slice = append(p.bricks.slice, anys...)
	return p
}

func (p *glusterBricksServiceMigrateRequest) Send() (*glusterBricksServiceMigrateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/migrate", p.glusterBricksService.connection.URL(), p.glusterBricksService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Bricks(p.bricks)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBricksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterBricksServiceMigrateResponse), nil
}

func (p *glusterBricksServiceMigrateRequest) MustSend() *glusterBricksServiceMigrateResponse {
	rawURL := fmt.Sprintf("%s%s/migrate", p.glusterBricksService.connection.URL(), p.glusterBricksService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Bricks(p.bricks)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBricksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterBricksServiceMigrateResponse)
}

//
// Start migration of data prior to removing bricks.
// Removing bricks is a two-step process, where the data on bricks to be removed, is first migrated to remaining
// bricks. Once migration is completed the removal of bricks is confirmed via the API
// <<services/gluster_bricks/methods/remove, remove>>. If at any point, the action needs to be cancelled
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> has to be called.
// For instance, to delete a brick from a gluster volume with id `123`, send a request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/migrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
// The migration process can be tracked from the job id returned from the API using
// <<services/job/methods/get, job>> and steps in job using <<services/step/methods/get, step>>
//
type glusterBricksServiceMigrateResponse struct {
}

//
// Start migration of data prior to removing bricks.
// Removing bricks is a two-step process, where the data on bricks to be removed, is first migrated to remaining
// bricks. Once migration is completed the removal of bricks is confirmed via the API
// <<services/gluster_bricks/methods/remove, remove>>. If at any point, the action needs to be cancelled
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> has to be called.
// For instance, to delete a brick from a gluster volume with id `123`, send a request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/migrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
// The migration process can be tracked from the job id returned from the API using
// <<services/job/methods/get, job>> and steps in job using <<services/step/methods/get, step>>
//
func (p *glusterBricksService) Migrate() *glusterBricksServiceMigrateRequest {
	return &glusterBricksServiceMigrateRequest{glusterBricksService: p}
}

//
// Removes bricks from gluster volume.
// The recommended way to remove bricks without data loss is to first migrate the data using
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> and then removing them. If migrate was not called on
// bricks prior to remove, the bricks are removed without data migration which may lead to data loss.
// For example, to delete the bricks from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
//
type glusterBricksServiceRemoveRequest struct {
	glusterBricksService *glusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               *GlusterBrickSlice
	replicaCount         *int64
}

func (p *glusterBricksServiceRemoveRequest) Header(key, value string) *glusterBricksServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterBricksServiceRemoveRequest) Query(key, value string) *glusterBricksServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterBricksServiceRemoveRequest) Async(async bool) *glusterBricksServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *glusterBricksServiceRemoveRequest) Bricks(bricks *GlusterBrickSlice) *glusterBricksServiceRemoveRequest {
	p.bricks = bricks
	return p
}

func (p *glusterBricksServiceRemoveRequest) BricksOfAny(anys ...*GlusterBrick) *glusterBricksServiceRemoveRequest {
	if p.bricks == nil {
		p.bricks = new(GlusterBrickSlice)
	}
	p.bricks.slice = append(p.bricks.slice, anys...)
	return p
}

func (p *glusterBricksServiceRemoveRequest) ReplicaCount(replicaCount int64) *glusterBricksServiceRemoveRequest {
	p.replicaCount = &replicaCount
	return p
}

func (p *glusterBricksServiceRemoveRequest) Send() (*glusterBricksServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBricksService.connection.URL(), p.glusterBricksService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.replicaCount != nil {
		values["replica_count"] = []string{fmt.Sprintf("%v", *p.replicaCount)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBricksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(glusterBricksServiceRemoveResponse), nil
}

func (p *glusterBricksServiceRemoveRequest) MustSend() *glusterBricksServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.glusterBricksService.connection.URL(), p.glusterBricksService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.replicaCount != nil {
		values["replica_count"] = []string{fmt.Sprintf("%v", *p.replicaCount)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBricksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(glusterBricksServiceRemoveResponse)
}

//
// Removes bricks from gluster volume.
// The recommended way to remove bricks without data loss is to first migrate the data using
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> and then removing them. If migrate was not called on
// bricks prior to remove, the bricks are removed without data migration which may lead to data loss.
// For example, to delete the bricks from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
//
type glusterBricksServiceRemoveResponse struct {
}

//
// Removes bricks from gluster volume.
// The recommended way to remove bricks without data loss is to first migrate the data using
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> and then removing them. If migrate was not called on
// bricks prior to remove, the bricks are removed without data migration which may lead to data loss.
// For example, to delete the bricks from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
//
func (p *glusterBricksService) Remove() *glusterBricksServiceRemoveRequest {
	return &glusterBricksServiceRemoveRequest{glusterBricksService: p}
}

//
// Stops migration of data from bricks for a remove brick operation.
// To cancel data migration that was started as part of the 2-step remove brick process in case the user wishes to
// continue using the bricks. The bricks that were marked for removal will function as normal bricks post this
// operation.
// For example, to stop migration of data from the bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/stopmigrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
//
type glusterBricksServiceStopMigrateRequest struct {
	glusterBricksService *glusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               *GlusterBrickSlice
}

func (p *glusterBricksServiceStopMigrateRequest) Header(key, value string) *glusterBricksServiceStopMigrateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterBricksServiceStopMigrateRequest) Query(key, value string) *glusterBricksServiceStopMigrateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterBricksServiceStopMigrateRequest) Async(async bool) *glusterBricksServiceStopMigrateRequest {
	p.async = &async
	return p
}

func (p *glusterBricksServiceStopMigrateRequest) Bricks(bricks *GlusterBrickSlice) *glusterBricksServiceStopMigrateRequest {
	p.bricks = bricks
	return p
}

func (p *glusterBricksServiceStopMigrateRequest) BricksOfAny(anys ...*GlusterBrick) *glusterBricksServiceStopMigrateRequest {
	if p.bricks == nil {
		p.bricks = new(GlusterBrickSlice)
	}
	p.bricks.slice = append(p.bricks.slice, anys...)
	return p
}

func (p *glusterBricksServiceStopMigrateRequest) Send() (*glusterBricksServiceStopMigrateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stopmigrate", p.glusterBricksService.connection.URL(), p.glusterBricksService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Bricks(p.bricks)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBricksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterBricksServiceStopMigrateResponse), nil
}

func (p *glusterBricksServiceStopMigrateRequest) MustSend() *glusterBricksServiceStopMigrateResponse {
	rawURL := fmt.Sprintf("%s%s/stopmigrate", p.glusterBricksService.connection.URL(), p.glusterBricksService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Bricks(p.bricks)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBricksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBricksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterBricksServiceStopMigrateResponse)
}

//
// Stops migration of data from bricks for a remove brick operation.
// To cancel data migration that was started as part of the 2-step remove brick process in case the user wishes to
// continue using the bricks. The bricks that were marked for removal will function as normal bricks post this
// operation.
// For example, to stop migration of data from the bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/stopmigrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
//
type glusterBricksServiceStopMigrateResponse struct {
}

//
// Stops migration of data from bricks for a remove brick operation.
// To cancel data migration that was started as part of the 2-step remove brick process in case the user wishes to
// continue using the bricks. The bricks that were marked for removal will function as normal bricks post this
// operation.
// For example, to stop migration of data from the bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/stopmigrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
//
func (p *glusterBricksService) StopMigrate() *glusterBricksServiceStopMigrateRequest {
	return &glusterBricksServiceStopMigrateRequest{glusterBricksService: p}
}

//
// Returns a reference to the service managing a single gluster brick.
//
func (op *glusterBricksService) BrickService(id string) *glusterBrickService {
	return NewGlusterBrickService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *glusterBricksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.BrickService(path), nil
	}
	return op.BrickService(path[:index]).Service(path[index+1:])
}

func (op *glusterBricksService) String() string {
	return fmt.Sprintf("glusterBricksService:%s", op.path)
}

//
//
type glusterHooksService struct {
	baseService
}

func NewGlusterHooksService(connection *Connection, path string) *glusterHooksService {
	var result glusterHooksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of hooks.
// The order of the returned list of hooks isn't guaranteed.
//
type glusterHooksServiceListRequest struct {
	glusterHooksService *glusterHooksService
	header              map[string]string
	query               map[string]string
	follow              *string
	max                 *int64
}

func (p *glusterHooksServiceListRequest) Header(key, value string) *glusterHooksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterHooksServiceListRequest) Query(key, value string) *glusterHooksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterHooksServiceListRequest) Follow(follow string) *glusterHooksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *glusterHooksServiceListRequest) Max(max int64) *glusterHooksServiceListRequest {
	p.max = &max
	return p
}

func (p *glusterHooksServiceListRequest) Send() (*glusterHooksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterHooksService.connection.URL(), p.glusterHooksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterHooksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterHooksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterHookReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &glusterHooksServiceListResponse{hooks: result}, nil
}

func (p *glusterHooksServiceListRequest) MustSend() *glusterHooksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.glusterHooksService.connection.URL(), p.glusterHooksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterHooksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterHooksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterHookReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &glusterHooksServiceListResponse{hooks: result}
}

//
// Returns the list of hooks.
// The order of the returned list of hooks isn't guaranteed.
//
type glusterHooksServiceListResponse struct {
	hooks *GlusterHookSlice
}

func (p *glusterHooksServiceListResponse) Hooks() (*GlusterHookSlice, bool) {
	if p.hooks != nil {
		return p.hooks, true
	}
	return nil, false
}

func (p *glusterHooksServiceListResponse) MustHooks() *GlusterHookSlice {
	if p.hooks == nil {
		panic("hooks in response does not exist")
	}
	return p.hooks
}

//
// Returns the list of hooks.
// The order of the returned list of hooks isn't guaranteed.
//
func (p *glusterHooksService) List() *glusterHooksServiceListRequest {
	return &glusterHooksServiceListRequest{glusterHooksService: p}
}

//
//
func (op *glusterHooksService) HookService(id string) *glusterHookService {
	return NewGlusterHookService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *glusterHooksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HookService(path), nil
	}
	return op.HookService(path[:index]).Service(path[index+1:])
}

func (op *glusterHooksService) String() string {
	return fmt.Sprintf("glusterHooksService:%s", op.path)
}

//
//
type glusterHookService struct {
	baseService
}

func NewGlusterHookService(connection *Connection, path string) *glusterHookService {
	var result glusterHookService
	result.connection = connection
	result.path = path
	return &result
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
//
type glusterHookServiceDisableRequest struct {
	glusterHookService *glusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *glusterHookServiceDisableRequest) Header(key, value string) *glusterHookServiceDisableRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterHookServiceDisableRequest) Query(key, value string) *glusterHookServiceDisableRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterHookServiceDisableRequest) Async(async bool) *glusterHookServiceDisableRequest {
	p.async = &async
	return p
}

func (p *glusterHookServiceDisableRequest) Send() (*glusterHookServiceDisableResponse, error) {
	rawURL := fmt.Sprintf("%s%s/disable", p.glusterHookService.connection.URL(), p.glusterHookService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterHookService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterHookService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterHookServiceDisableResponse), nil
}

func (p *glusterHookServiceDisableRequest) MustSend() *glusterHookServiceDisableResponse {
	rawURL := fmt.Sprintf("%s%s/disable", p.glusterHookService.connection.URL(), p.glusterHookService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterHookService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterHookService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterHookServiceDisableResponse)
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
//
type glusterHookServiceDisableResponse struct {
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
//
func (p *glusterHookService) Disable() *glusterHookServiceDisableRequest {
	return &glusterHookServiceDisableRequest{glusterHookService: p}
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
//
type glusterHookServiceEnableRequest struct {
	glusterHookService *glusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *glusterHookServiceEnableRequest) Header(key, value string) *glusterHookServiceEnableRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterHookServiceEnableRequest) Query(key, value string) *glusterHookServiceEnableRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterHookServiceEnableRequest) Async(async bool) *glusterHookServiceEnableRequest {
	p.async = &async
	return p
}

func (p *glusterHookServiceEnableRequest) Send() (*glusterHookServiceEnableResponse, error) {
	rawURL := fmt.Sprintf("%s%s/enable", p.glusterHookService.connection.URL(), p.glusterHookService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterHookService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterHookService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterHookServiceEnableResponse), nil
}

func (p *glusterHookServiceEnableRequest) MustSend() *glusterHookServiceEnableResponse {
	rawURL := fmt.Sprintf("%s%s/enable", p.glusterHookService.connection.URL(), p.glusterHookService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterHookService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterHookService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterHookServiceEnableResponse)
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
//
type glusterHookServiceEnableResponse struct {
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
//
func (p *glusterHookService) Enable() *glusterHookServiceEnableRequest {
	return &glusterHookServiceEnableRequest{glusterHookService: p}
}

//
//
type glusterHookServiceGetRequest struct {
	glusterHookService *glusterHookService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *glusterHookServiceGetRequest) Header(key, value string) *glusterHookServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterHookServiceGetRequest) Query(key, value string) *glusterHookServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterHookServiceGetRequest) Follow(follow string) *glusterHookServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *glusterHookServiceGetRequest) Send() (*glusterHookServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterHookService.connection.URL(), p.glusterHookService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterHookService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterHookService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterHookReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &glusterHookServiceGetResponse{hook: result}, nil
}

func (p *glusterHookServiceGetRequest) MustSend() *glusterHookServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.glusterHookService.connection.URL(), p.glusterHookService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterHookService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterHookService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterHookReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &glusterHookServiceGetResponse{hook: result}
}

//
//
type glusterHookServiceGetResponse struct {
	hook *GlusterHook
}

func (p *glusterHookServiceGetResponse) Hook() (*GlusterHook, bool) {
	if p.hook != nil {
		return p.hook, true
	}
	return nil, false
}

func (p *glusterHookServiceGetResponse) MustHook() *GlusterHook {
	if p.hook == nil {
		panic("hook in response does not exist")
	}
	return p.hook
}

//
//
func (p *glusterHookService) Get() *glusterHookServiceGetRequest {
	return &glusterHookServiceGetRequest{glusterHookService: p}
}

//
// Removes the this Gluster hook from all servers in cluster and deletes it from the database.
//
type glusterHookServiceRemoveRequest struct {
	glusterHookService *glusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *glusterHookServiceRemoveRequest) Header(key, value string) *glusterHookServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterHookServiceRemoveRequest) Query(key, value string) *glusterHookServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterHookServiceRemoveRequest) Async(async bool) *glusterHookServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *glusterHookServiceRemoveRequest) Send() (*glusterHookServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterHookService.connection.URL(), p.glusterHookService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterHookService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterHookService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(glusterHookServiceRemoveResponse), nil
}

func (p *glusterHookServiceRemoveRequest) MustSend() *glusterHookServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.glusterHookService.connection.URL(), p.glusterHookService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterHookService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterHookService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(glusterHookServiceRemoveResponse)
}

//
// Removes the this Gluster hook from all servers in cluster and deletes it from the database.
//
type glusterHookServiceRemoveResponse struct {
}

//
// Removes the this Gluster hook from all servers in cluster and deletes it from the database.
//
func (p *glusterHookService) Remove() *glusterHookServiceRemoveRequest {
	return &glusterHookServiceRemoveRequest{glusterHookService: p}
}

//
// Resolves missing hook conflict depending on the resolution type.
// For `ADD` resolves by copying hook stored in engine database to all servers where the hook is missing. The
// engine maintains a list of all servers where hook is missing.
// For `COPY` resolves conflict in hook content by copying hook stored in engine database to all servers where
// the hook is missing. The engine maintains a list of all servers where the content is conflicting. If a host
// id is passed as parameter, the hook content from the server is used as the master to copy to other servers
// in cluster.
//
type glusterHookServiceResolveRequest struct {
	glusterHookService *glusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
	host               *Host
	resolutionType     *string
}

func (p *glusterHookServiceResolveRequest) Header(key, value string) *glusterHookServiceResolveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterHookServiceResolveRequest) Query(key, value string) *glusterHookServiceResolveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterHookServiceResolveRequest) Async(async bool) *glusterHookServiceResolveRequest {
	p.async = &async
	return p
}

func (p *glusterHookServiceResolveRequest) Host(host *Host) *glusterHookServiceResolveRequest {
	p.host = host
	return p
}

func (p *glusterHookServiceResolveRequest) ResolutionType(resolutionType string) *glusterHookServiceResolveRequest {
	p.resolutionType = &resolutionType
	return p
}

func (p *glusterHookServiceResolveRequest) Send() (*glusterHookServiceResolveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resolve", p.glusterHookService.connection.URL(), p.glusterHookService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Host(p.host)
	if p.resolutionType != nil {
		actionBuilder.ResolutionType(*p.resolutionType)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterHookService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterHookService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterHookServiceResolveResponse), nil
}

func (p *glusterHookServiceResolveRequest) MustSend() *glusterHookServiceResolveResponse {
	rawURL := fmt.Sprintf("%s%s/resolve", p.glusterHookService.connection.URL(), p.glusterHookService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Host(p.host)
	if p.resolutionType != nil {
		actionBuilder.ResolutionType(*p.resolutionType)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterHookService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterHookService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterHookServiceResolveResponse)
}

//
// Resolves missing hook conflict depending on the resolution type.
// For `ADD` resolves by copying hook stored in engine database to all servers where the hook is missing. The
// engine maintains a list of all servers where hook is missing.
// For `COPY` resolves conflict in hook content by copying hook stored in engine database to all servers where
// the hook is missing. The engine maintains a list of all servers where the content is conflicting. If a host
// id is passed as parameter, the hook content from the server is used as the master to copy to other servers
// in cluster.
//
type glusterHookServiceResolveResponse struct {
}

//
// Resolves missing hook conflict depending on the resolution type.
// For `ADD` resolves by copying hook stored in engine database to all servers where the hook is missing. The
// engine maintains a list of all servers where hook is missing.
// For `COPY` resolves conflict in hook content by copying hook stored in engine database to all servers where
// the hook is missing. The engine maintains a list of all servers where the content is conflicting. If a host
// id is passed as parameter, the hook content from the server is used as the master to copy to other servers
// in cluster.
//
func (p *glusterHookService) Resolve() *glusterHookServiceResolveRequest {
	return &glusterHookServiceResolveRequest{glusterHookService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *glusterHookService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *glusterHookService) String() string {
	return fmt.Sprintf("glusterHookService:%s", op.path)
}

//
// This service manages a collection of gluster volumes available in a cluster.
//
type glusterVolumesService struct {
	baseService
}

func NewGlusterVolumesService(connection *Connection, path string) *glusterVolumesService {
	var result glusterVolumesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new gluster volume.
// The volume is created based on properties of the `volume` parameter. The properties `name`, `volume_type` and
// `bricks` are required.
// For example, to add a volume with name `myvolume` to the cluster `123`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/glustervolumes
// ----
// With the following request body:
// [source,xml]
// ----
// <gluster_volume>
//   <name>myvolume</name>
//   <volume_type>replicate</volume_type>
//   <replica_count>3</replica_count>
//   <bricks>
//     <brick>
//       <server_id>server1</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server2</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server3</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//   <bricks>
// </gluster_volume>
// ----
//
type glusterVolumesServiceAddRequest struct {
	glusterVolumesService *glusterVolumesService
	header                map[string]string
	query                 map[string]string
	volume                *GlusterVolume
}

func (p *glusterVolumesServiceAddRequest) Header(key, value string) *glusterVolumesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumesServiceAddRequest) Query(key, value string) *glusterVolumesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumesServiceAddRequest) Volume(volume *GlusterVolume) *glusterVolumesServiceAddRequest {
	p.volume = volume
	return p
}

func (p *glusterVolumesServiceAddRequest) Send() (*glusterVolumesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumesService.connection.URL(), p.glusterVolumesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGlusterVolumeWriteOne(writer, p.volume, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterVolumeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &glusterVolumesServiceAddResponse{volume: result}, nil
}

func (p *glusterVolumesServiceAddRequest) MustSend() *glusterVolumesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumesService.connection.URL(), p.glusterVolumesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGlusterVolumeWriteOne(writer, p.volume, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterVolumeReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &glusterVolumesServiceAddResponse{volume: result}
}

//
// Creates a new gluster volume.
// The volume is created based on properties of the `volume` parameter. The properties `name`, `volume_type` and
// `bricks` are required.
// For example, to add a volume with name `myvolume` to the cluster `123`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/glustervolumes
// ----
// With the following request body:
// [source,xml]
// ----
// <gluster_volume>
//   <name>myvolume</name>
//   <volume_type>replicate</volume_type>
//   <replica_count>3</replica_count>
//   <bricks>
//     <brick>
//       <server_id>server1</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server2</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server3</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//   <bricks>
// </gluster_volume>
// ----
//
type glusterVolumesServiceAddResponse struct {
	volume *GlusterVolume
}

func (p *glusterVolumesServiceAddResponse) Volume() (*GlusterVolume, bool) {
	if p.volume != nil {
		return p.volume, true
	}
	return nil, false
}

func (p *glusterVolumesServiceAddResponse) MustVolume() *GlusterVolume {
	if p.volume == nil {
		panic("volume in response does not exist")
	}
	return p.volume
}

//
// Creates a new gluster volume.
// The volume is created based on properties of the `volume` parameter. The properties `name`, `volume_type` and
// `bricks` are required.
// For example, to add a volume with name `myvolume` to the cluster `123`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/glustervolumes
// ----
// With the following request body:
// [source,xml]
// ----
// <gluster_volume>
//   <name>myvolume</name>
//   <volume_type>replicate</volume_type>
//   <replica_count>3</replica_count>
//   <bricks>
//     <brick>
//       <server_id>server1</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server2</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server3</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//   <bricks>
// </gluster_volume>
// ----
//
func (p *glusterVolumesService) Add() *glusterVolumesServiceAddRequest {
	return &glusterVolumesServiceAddRequest{glusterVolumesService: p}
}

//
// Lists all gluster volumes in the cluster.
// For example, to list all Gluster Volumes in cluster `456`, send a request like
// this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes
// ----
// The order of the returned list of volumes isn't guaranteed.
//
type glusterVolumesServiceListRequest struct {
	glusterVolumesService *glusterVolumesService
	header                map[string]string
	query                 map[string]string
	caseSensitive         *bool
	follow                *string
	max                   *int64
	search                *string
}

func (p *glusterVolumesServiceListRequest) Header(key, value string) *glusterVolumesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterVolumesServiceListRequest) Query(key, value string) *glusterVolumesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterVolumesServiceListRequest) CaseSensitive(caseSensitive bool) *glusterVolumesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *glusterVolumesServiceListRequest) Follow(follow string) *glusterVolumesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *glusterVolumesServiceListRequest) Max(max int64) *glusterVolumesServiceListRequest {
	p.max = &max
	return p
}

func (p *glusterVolumesServiceListRequest) Search(search string) *glusterVolumesServiceListRequest {
	p.search = &search
	return p
}

func (p *glusterVolumesServiceListRequest) Send() (*glusterVolumesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumesService.connection.URL(), p.glusterVolumesService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterVolumeReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &glusterVolumesServiceListResponse{volumes: result}, nil
}

func (p *glusterVolumesServiceListRequest) MustSend() *glusterVolumesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.glusterVolumesService.connection.URL(), p.glusterVolumesService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterVolumesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterVolumesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterVolumeReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &glusterVolumesServiceListResponse{volumes: result}
}

//
// Lists all gluster volumes in the cluster.
// For example, to list all Gluster Volumes in cluster `456`, send a request like
// this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes
// ----
// The order of the returned list of volumes isn't guaranteed.
//
type glusterVolumesServiceListResponse struct {
	volumes *GlusterVolumeSlice
}

func (p *glusterVolumesServiceListResponse) Volumes() (*GlusterVolumeSlice, bool) {
	if p.volumes != nil {
		return p.volumes, true
	}
	return nil, false
}

func (p *glusterVolumesServiceListResponse) MustVolumes() *GlusterVolumeSlice {
	if p.volumes == nil {
		panic("volumes in response does not exist")
	}
	return p.volumes
}

//
// Lists all gluster volumes in the cluster.
// For example, to list all Gluster Volumes in cluster `456`, send a request like
// this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes
// ----
// The order of the returned list of volumes isn't guaranteed.
//
func (p *glusterVolumesService) List() *glusterVolumesServiceListRequest {
	return &glusterVolumesServiceListRequest{glusterVolumesService: p}
}

//
// Reference to a service managing gluster volume.
//
func (op *glusterVolumesService) VolumeService(id string) *glusterVolumeService {
	return NewGlusterVolumeService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *glusterVolumesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.VolumeService(path), nil
	}
	return op.VolumeService(path[:index]).Service(path[index+1:])
}

func (op *glusterVolumesService) String() string {
	return fmt.Sprintf("glusterVolumesService:%s", op.path)
}

//
// This service manages a single gluster brick.
//
type glusterBrickService struct {
	baseService
}

func NewGlusterBrickService(connection *Connection, path string) *glusterBrickService {
	var result glusterBrickService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get details of a brick.
// Retrieves status details of brick from underlying gluster volume with header `All-Content` set to `true`. This is
// the equivalent of running `gluster volume status <volumename> <brickname> detail`.
// For example, to get the details of brick `234` of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
// Which will return a response body like this:
// [source,xml]
// ----
// <brick id="234">
//   <name>host1:/rhgs/data/brick1</name>
//   <brick_dir>/rhgs/data/brick1</brick_dir>
//   <server_id>111</server_id>
//   <status>up</status>
//   <device>/dev/mapper/RHGS_vg1-lv_vmaddldisks</device>
//   <fs_name>xfs</fs_name>
//   <gluster_clients>
//     <gluster_client>
//       <bytes_read>2818417648</bytes_read>
//       <bytes_written>1384694844</bytes_written>
//       <client_port>1011</client_port>
//       <host_name>client2</host_name>
//     </gluster_client>
//   </gluster_clients>
//   <memory_pools>
//     <memory_pool>
//       <name>data-server:fd_t</name>
//       <alloc_count>1626348</alloc_count>
//       <cold_count>1020</cold_count>
//       <hot_count>4</hot_count>
//       <max_alloc>23</max_alloc>
//       <max_stdalloc>0</max_stdalloc>
//       <padded_size>140</padded_size>
//       <pool_misses>0</pool_misses>
//     </memory_pool>
//   </memory_pools>
//   <mnt_options>rw,seclabel,noatime,nodiratime,attr2,inode64,sunit=512,swidth=2048,noquota</mnt_options>
//   <pid>25589</pid>
//   <port>49155</port>
// </brick>
// ----
//
type glusterBrickServiceGetRequest struct {
	glusterBrickService *glusterBrickService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *glusterBrickServiceGetRequest) Header(key, value string) *glusterBrickServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterBrickServiceGetRequest) Query(key, value string) *glusterBrickServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterBrickServiceGetRequest) Follow(follow string) *glusterBrickServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *glusterBrickServiceGetRequest) Send() (*glusterBrickServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBrickService.connection.URL(), p.glusterBrickService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBrickService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBrickService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterBrickReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &glusterBrickServiceGetResponse{brick: result}, nil
}

func (p *glusterBrickServiceGetRequest) MustSend() *glusterBrickServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.glusterBrickService.connection.URL(), p.glusterBrickService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBrickService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBrickService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterBrickReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &glusterBrickServiceGetResponse{brick: result}
}

//
// Get details of a brick.
// Retrieves status details of brick from underlying gluster volume with header `All-Content` set to `true`. This is
// the equivalent of running `gluster volume status <volumename> <brickname> detail`.
// For example, to get the details of brick `234` of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
// Which will return a response body like this:
// [source,xml]
// ----
// <brick id="234">
//   <name>host1:/rhgs/data/brick1</name>
//   <brick_dir>/rhgs/data/brick1</brick_dir>
//   <server_id>111</server_id>
//   <status>up</status>
//   <device>/dev/mapper/RHGS_vg1-lv_vmaddldisks</device>
//   <fs_name>xfs</fs_name>
//   <gluster_clients>
//     <gluster_client>
//       <bytes_read>2818417648</bytes_read>
//       <bytes_written>1384694844</bytes_written>
//       <client_port>1011</client_port>
//       <host_name>client2</host_name>
//     </gluster_client>
//   </gluster_clients>
//   <memory_pools>
//     <memory_pool>
//       <name>data-server:fd_t</name>
//       <alloc_count>1626348</alloc_count>
//       <cold_count>1020</cold_count>
//       <hot_count>4</hot_count>
//       <max_alloc>23</max_alloc>
//       <max_stdalloc>0</max_stdalloc>
//       <padded_size>140</padded_size>
//       <pool_misses>0</pool_misses>
//     </memory_pool>
//   </memory_pools>
//   <mnt_options>rw,seclabel,noatime,nodiratime,attr2,inode64,sunit=512,swidth=2048,noquota</mnt_options>
//   <pid>25589</pid>
//   <port>49155</port>
// </brick>
// ----
//
type glusterBrickServiceGetResponse struct {
	brick *GlusterBrick
}

func (p *glusterBrickServiceGetResponse) Brick() (*GlusterBrick, bool) {
	if p.brick != nil {
		return p.brick, true
	}
	return nil, false
}

func (p *glusterBrickServiceGetResponse) MustBrick() *GlusterBrick {
	if p.brick == nil {
		panic("brick in response does not exist")
	}
	return p.brick
}

//
// Get details of a brick.
// Retrieves status details of brick from underlying gluster volume with header `All-Content` set to `true`. This is
// the equivalent of running `gluster volume status <volumename> <brickname> detail`.
// For example, to get the details of brick `234` of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
// Which will return a response body like this:
// [source,xml]
// ----
// <brick id="234">
//   <name>host1:/rhgs/data/brick1</name>
//   <brick_dir>/rhgs/data/brick1</brick_dir>
//   <server_id>111</server_id>
//   <status>up</status>
//   <device>/dev/mapper/RHGS_vg1-lv_vmaddldisks</device>
//   <fs_name>xfs</fs_name>
//   <gluster_clients>
//     <gluster_client>
//       <bytes_read>2818417648</bytes_read>
//       <bytes_written>1384694844</bytes_written>
//       <client_port>1011</client_port>
//       <host_name>client2</host_name>
//     </gluster_client>
//   </gluster_clients>
//   <memory_pools>
//     <memory_pool>
//       <name>data-server:fd_t</name>
//       <alloc_count>1626348</alloc_count>
//       <cold_count>1020</cold_count>
//       <hot_count>4</hot_count>
//       <max_alloc>23</max_alloc>
//       <max_stdalloc>0</max_stdalloc>
//       <padded_size>140</padded_size>
//       <pool_misses>0</pool_misses>
//     </memory_pool>
//   </memory_pools>
//   <mnt_options>rw,seclabel,noatime,nodiratime,attr2,inode64,sunit=512,swidth=2048,noquota</mnt_options>
//   <pid>25589</pid>
//   <port>49155</port>
// </brick>
// ----
//
func (p *glusterBrickService) Get() *glusterBrickServiceGetRequest {
	return &glusterBrickServiceGetRequest{glusterBrickService: p}
}

//
// Removes a brick.
// Removes a brick from the underlying gluster volume and deletes entries from database. This can be used only when
// removing a single brick without data migration. To remove multiple bricks and with data migration, use
// <<services/gluster_bricks/methods/migrate, migrate>> instead.
// For example, to delete brick `234` from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
//
type glusterBrickServiceRemoveRequest struct {
	glusterBrickService *glusterBrickService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *glusterBrickServiceRemoveRequest) Header(key, value string) *glusterBrickServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterBrickServiceRemoveRequest) Query(key, value string) *glusterBrickServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterBrickServiceRemoveRequest) Async(async bool) *glusterBrickServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *glusterBrickServiceRemoveRequest) Send() (*glusterBrickServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.glusterBrickService.connection.URL(), p.glusterBrickService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBrickService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBrickService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(glusterBrickServiceRemoveResponse), nil
}

func (p *glusterBrickServiceRemoveRequest) MustSend() *glusterBrickServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.glusterBrickService.connection.URL(), p.glusterBrickService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBrickService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBrickService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(glusterBrickServiceRemoveResponse)
}

//
// Removes a brick.
// Removes a brick from the underlying gluster volume and deletes entries from database. This can be used only when
// removing a single brick without data migration. To remove multiple bricks and with data migration, use
// <<services/gluster_bricks/methods/migrate, migrate>> instead.
// For example, to delete brick `234` from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
//
type glusterBrickServiceRemoveResponse struct {
}

//
// Removes a brick.
// Removes a brick from the underlying gluster volume and deletes entries from database. This can be used only when
// removing a single brick without data migration. To remove multiple bricks and with data migration, use
// <<services/gluster_bricks/methods/migrate, migrate>> instead.
// For example, to delete brick `234` from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
//
func (p *glusterBrickService) Remove() *glusterBrickServiceRemoveRequest {
	return &glusterBrickServiceRemoveRequest{glusterBrickService: p}
}

//
// Replaces this brick with a new one.
// IMPORTANT: This operation has been deprecated since version 3.5 of the engine and will be removed in the future.
// Use <<services/gluster_bricks/methods/add, add brick(s)>> and
// <<services/gluster_bricks/methods/migrate, migrate brick(s)>> instead.
//
type glusterBrickServiceReplaceRequest struct {
	glusterBrickService *glusterBrickService
	header              map[string]string
	query               map[string]string
	async               *bool
	force               *bool
}

func (p *glusterBrickServiceReplaceRequest) Header(key, value string) *glusterBrickServiceReplaceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *glusterBrickServiceReplaceRequest) Query(key, value string) *glusterBrickServiceReplaceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *glusterBrickServiceReplaceRequest) Async(async bool) *glusterBrickServiceReplaceRequest {
	p.async = &async
	return p
}

func (p *glusterBrickServiceReplaceRequest) Force(force bool) *glusterBrickServiceReplaceRequest {
	p.force = &force
	return p
}

func (p *glusterBrickServiceReplaceRequest) Send() (*glusterBrickServiceReplaceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/replace", p.glusterBrickService.connection.URL(), p.glusterBrickService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBrickService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBrickService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(glusterBrickServiceReplaceResponse), nil
}

func (p *glusterBrickServiceReplaceRequest) MustSend() *glusterBrickServiceReplaceResponse {
	rawURL := fmt.Sprintf("%s%s/replace", p.glusterBrickService.connection.URL(), p.glusterBrickService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.glusterBrickService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.glusterBrickService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(glusterBrickServiceReplaceResponse)
}

//
// Replaces this brick with a new one.
// IMPORTANT: This operation has been deprecated since version 3.5 of the engine and will be removed in the future.
// Use <<services/gluster_bricks/methods/add, add brick(s)>> and
// <<services/gluster_bricks/methods/migrate, migrate brick(s)>> instead.
//
type glusterBrickServiceReplaceResponse struct {
}

//
// Replaces this brick with a new one.
// IMPORTANT: This operation has been deprecated since version 3.5 of the engine and will be removed in the future.
// Use <<services/gluster_bricks/methods/add, add brick(s)>> and
// <<services/gluster_bricks/methods/migrate, migrate brick(s)>> instead.
//
func (p *glusterBrickService) Replace() *glusterBrickServiceReplaceRequest {
	return &glusterBrickServiceReplaceRequest{glusterBrickService: p}
}

//
//
func (op *glusterBrickService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *glusterBrickService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *glusterBrickService) String() string {
	return fmt.Sprintf("glusterBrickService:%s", op.path)
}

//
//
type macPoolService struct {
	baseService
}

func NewMacPoolService(connection *Connection, path string) *macPoolService {
	var result macPoolService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type macPoolServiceGetRequest struct {
	macPoolService *macPoolService
	header         map[string]string
	query          map[string]string
	follow         *string
}

func (p *macPoolServiceGetRequest) Header(key, value string) *macPoolServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *macPoolServiceGetRequest) Query(key, value string) *macPoolServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *macPoolServiceGetRequest) Follow(follow string) *macPoolServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *macPoolServiceGetRequest) Send() (*macPoolServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolService.connection.URL(), p.macPoolService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.macPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.macPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLMacPoolReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &macPoolServiceGetResponse{pool: result}, nil
}

func (p *macPoolServiceGetRequest) MustSend() *macPoolServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.macPoolService.connection.URL(), p.macPoolService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.macPoolService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.macPoolService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLMacPoolReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &macPoolServiceGetResponse{pool: result}
}

//
//
type macPoolServiceGetResponse struct {
	pool *MacPool
}

func (p *macPoolServiceGetResponse) Pool() (*MacPool, bool) {
	if p.pool != nil {
		return p.pool, true
	}
	return nil, false
}

func (p *macPoolServiceGetResponse) MustPool() *MacPool {
	if p.pool == nil {
		panic("pool in response does not exist")
	}
	return p.pool
}

//
//
func (p *macPoolService) Get() *macPoolServiceGetRequest {
	return &macPoolServiceGetRequest{macPoolService: p}
}

//
// Removes a MAC address pool.
// For example, to remove the MAC address pool having id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/macpools/123
// ----
//
type macPoolServiceRemoveRequest struct {
	macPoolService *macPoolService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *macPoolServiceRemoveRequest) Header(key, value string) *macPoolServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *macPoolServiceRemoveRequest) Query(key, value string) *macPoolServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *macPoolServiceRemoveRequest) Async(async bool) *macPoolServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *macPoolServiceRemoveRequest) Send() (*macPoolServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolService.connection.URL(), p.macPoolService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.macPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.macPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(macPoolServiceRemoveResponse), nil
}

func (p *macPoolServiceRemoveRequest) MustSend() *macPoolServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.macPoolService.connection.URL(), p.macPoolService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.macPoolService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.macPoolService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(macPoolServiceRemoveResponse)
}

//
// Removes a MAC address pool.
// For example, to remove the MAC address pool having id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/macpools/123
// ----
//
type macPoolServiceRemoveResponse struct {
}

//
// Removes a MAC address pool.
// For example, to remove the MAC address pool having id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/macpools/123
// ----
//
func (p *macPoolService) Remove() *macPoolServiceRemoveRequest {
	return &macPoolServiceRemoveRequest{macPoolService: p}
}

//
// Updates a MAC address pool.
// The `name`, `description`, `allow_duplicates`, and `ranges` attributes can be updated.
// For example, to update the MAC address pool of id `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/macpools/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>UpdatedMACPool</name>
//   <description>An updated MAC address pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//     <range>
//       <from>02:1A:4A:01:00:00</from>
//       <to>02:1A:4A:FF:FF:FF</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
type macPoolServiceUpdateRequest struct {
	macPoolService *macPoolService
	header         map[string]string
	query          map[string]string
	async          *bool
	pool           *MacPool
}

func (p *macPoolServiceUpdateRequest) Header(key, value string) *macPoolServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *macPoolServiceUpdateRequest) Query(key, value string) *macPoolServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *macPoolServiceUpdateRequest) Async(async bool) *macPoolServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *macPoolServiceUpdateRequest) Pool(pool *MacPool) *macPoolServiceUpdateRequest {
	p.pool = pool
	return p
}

func (p *macPoolServiceUpdateRequest) Send() (*macPoolServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.macPoolService.connection.URL(), p.macPoolService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLMacPoolWriteOne(writer, p.pool, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.macPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.macPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLMacPoolReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &macPoolServiceUpdateResponse{pool: result}, nil
}

func (p *macPoolServiceUpdateRequest) MustSend() *macPoolServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.macPoolService.connection.URL(), p.macPoolService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLMacPoolWriteOne(writer, p.pool, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.macPoolService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.macPoolService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLMacPoolReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &macPoolServiceUpdateResponse{pool: result}
}

//
// Updates a MAC address pool.
// The `name`, `description`, `allow_duplicates`, and `ranges` attributes can be updated.
// For example, to update the MAC address pool of id `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/macpools/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>UpdatedMACPool</name>
//   <description>An updated MAC address pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//     <range>
//       <from>02:1A:4A:01:00:00</from>
//       <to>02:1A:4A:FF:FF:FF</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
type macPoolServiceUpdateResponse struct {
	pool *MacPool
}

func (p *macPoolServiceUpdateResponse) Pool() (*MacPool, bool) {
	if p.pool != nil {
		return p.pool, true
	}
	return nil, false
}

func (p *macPoolServiceUpdateResponse) MustPool() *MacPool {
	if p.pool == nil {
		panic("pool in response does not exist")
	}
	return p.pool
}

//
// Updates a MAC address pool.
// The `name`, `description`, `allow_duplicates`, and `ranges` attributes can be updated.
// For example, to update the MAC address pool of id `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/macpools/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>UpdatedMACPool</name>
//   <description>An updated MAC address pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//     <range>
//       <from>02:1A:4A:01:00:00</from>
//       <to>02:1A:4A:FF:FF:FF</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
func (p *macPoolService) Update() *macPoolServiceUpdateRequest {
	return &macPoolServiceUpdateRequest{macPoolService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *macPoolService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *macPoolService) String() string {
	return fmt.Sprintf("macPoolService:%s", op.path)
}

//
// A service to manage icons.
//
type iconsService struct {
	baseService
}

func NewIconsService(connection *Connection, path string) *iconsService {
	var result iconsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get a list of icons.
// [source]
// ----
// GET /ovirt-engine/api/icons
// ----
// You will get a XML response which is similar to this one:
// [source,xml]
// ----
// <icons>
//   <icon id="123">
//     <data>...</data>
//     <media_type>image/png</media_type>
//   </icon>
//   ...
// </icons>
// ----
// The order of the returned list of icons isn't guaranteed.
//
type iconsServiceListRequest struct {
	iconsService *iconsService
	header       map[string]string
	query        map[string]string
	follow       *string
	max          *int64
}

func (p *iconsServiceListRequest) Header(key, value string) *iconsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *iconsServiceListRequest) Query(key, value string) *iconsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *iconsServiceListRequest) Follow(follow string) *iconsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *iconsServiceListRequest) Max(max int64) *iconsServiceListRequest {
	p.max = &max
	return p
}

func (p *iconsServiceListRequest) Send() (*iconsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.iconsService.connection.URL(), p.iconsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iconsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iconsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIconReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &iconsServiceListResponse{icons: result}, nil
}

func (p *iconsServiceListRequest) MustSend() *iconsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.iconsService.connection.URL(), p.iconsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.iconsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.iconsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIconReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &iconsServiceListResponse{icons: result}
}

//
// Get a list of icons.
// [source]
// ----
// GET /ovirt-engine/api/icons
// ----
// You will get a XML response which is similar to this one:
// [source,xml]
// ----
// <icons>
//   <icon id="123">
//     <data>...</data>
//     <media_type>image/png</media_type>
//   </icon>
//   ...
// </icons>
// ----
// The order of the returned list of icons isn't guaranteed.
//
type iconsServiceListResponse struct {
	icons *IconSlice
}

func (p *iconsServiceListResponse) Icons() (*IconSlice, bool) {
	if p.icons != nil {
		return p.icons, true
	}
	return nil, false
}

func (p *iconsServiceListResponse) MustIcons() *IconSlice {
	if p.icons == nil {
		panic("icons in response does not exist")
	}
	return p.icons
}

//
// Get a list of icons.
// [source]
// ----
// GET /ovirt-engine/api/icons
// ----
// You will get a XML response which is similar to this one:
// [source,xml]
// ----
// <icons>
//   <icon id="123">
//     <data>...</data>
//     <media_type>image/png</media_type>
//   </icon>
//   ...
// </icons>
// ----
// The order of the returned list of icons isn't guaranteed.
//
func (p *iconsService) List() *iconsServiceListRequest {
	return &iconsServiceListRequest{iconsService: p}
}

//
// Reference to the service that manages an specific icon.
//
func (op *iconsService) IconService(id string) *iconService {
	return NewIconService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *iconsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.IconService(path), nil
	}
	return op.IconService(path[:index]).Service(path[index+1:])
}

func (op *iconsService) String() string {
	return fmt.Sprintf("iconsService:%s", op.path)
}

//
// A service to view certificates for external provider.
//
type externalProviderCertificatesService struct {
	baseService
}

func NewExternalProviderCertificatesService(connection *Connection, path string) *externalProviderCertificatesService {
	var result externalProviderCertificatesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the chain of certificates presented by the external provider.
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/certificates
// ----
// And here is sample response:
// [source,xml]
// ----
// <certificates>
//   <certificate id="789">...</certificate>
//   ...
// </certificates>
// ----
// The order of the returned certificates is always guaranteed to be the sign order: the first is the
// certificate of the server itself, the second the certificate of the CA that signs the first, so on.
//
type externalProviderCertificatesServiceListRequest struct {
	externalProviderCertificatesService *externalProviderCertificatesService
	header                              map[string]string
	query                               map[string]string
	follow                              *string
	max                                 *int64
}

func (p *externalProviderCertificatesServiceListRequest) Header(key, value string) *externalProviderCertificatesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *externalProviderCertificatesServiceListRequest) Query(key, value string) *externalProviderCertificatesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *externalProviderCertificatesServiceListRequest) Follow(follow string) *externalProviderCertificatesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *externalProviderCertificatesServiceListRequest) Max(max int64) *externalProviderCertificatesServiceListRequest {
	p.max = &max
	return p
}

func (p *externalProviderCertificatesServiceListRequest) Send() (*externalProviderCertificatesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.externalProviderCertificatesService.connection.URL(), p.externalProviderCertificatesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalProviderCertificatesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalProviderCertificatesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCertificateReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &externalProviderCertificatesServiceListResponse{certificates: result}, nil
}

func (p *externalProviderCertificatesServiceListRequest) MustSend() *externalProviderCertificatesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.externalProviderCertificatesService.connection.URL(), p.externalProviderCertificatesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.externalProviderCertificatesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.externalProviderCertificatesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCertificateReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &externalProviderCertificatesServiceListResponse{certificates: result}
}

//
// Returns the chain of certificates presented by the external provider.
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/certificates
// ----
// And here is sample response:
// [source,xml]
// ----
// <certificates>
//   <certificate id="789">...</certificate>
//   ...
// </certificates>
// ----
// The order of the returned certificates is always guaranteed to be the sign order: the first is the
// certificate of the server itself, the second the certificate of the CA that signs the first, so on.
//
type externalProviderCertificatesServiceListResponse struct {
	certificates *CertificateSlice
}

func (p *externalProviderCertificatesServiceListResponse) Certificates() (*CertificateSlice, bool) {
	if p.certificates != nil {
		return p.certificates, true
	}
	return nil, false
}

func (p *externalProviderCertificatesServiceListResponse) MustCertificates() *CertificateSlice {
	if p.certificates == nil {
		panic("certificates in response does not exist")
	}
	return p.certificates
}

//
// Returns the chain of certificates presented by the external provider.
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/certificates
// ----
// And here is sample response:
// [source,xml]
// ----
// <certificates>
//   <certificate id="789">...</certificate>
//   ...
// </certificates>
// ----
// The order of the returned certificates is always guaranteed to be the sign order: the first is the
// certificate of the server itself, the second the certificate of the CA that signs the first, so on.
//
func (p *externalProviderCertificatesService) List() *externalProviderCertificatesServiceListRequest {
	return &externalProviderCertificatesServiceListRequest{externalProviderCertificatesService: p}
}

//
// Reference to service that manages a specific certificate
// for this external provider.
//
func (op *externalProviderCertificatesService) CertificateService(id string) *externalProviderCertificateService {
	return NewExternalProviderCertificateService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *externalProviderCertificatesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.CertificateService(path), nil
	}
	return op.CertificateService(path[:index]).Service(path[index+1:])
}

func (op *externalProviderCertificatesService) String() string {
	return fmt.Sprintf("externalProviderCertificatesService:%s", op.path)
}

//
// Provides read-only access to the global set of roles
//
type rolesService struct {
	baseService
}

func NewRolesService(connection *Connection, path string) *rolesService {
	var result rolesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Create a new role. The role can be administrative or non-administrative and can have different permits.
// For example, to add the `MyRole` non-administrative role with permits to login and create virtual machines
// send a request like this (note that you have to pass permit id):
// [source]
// ----
// POST /ovirt-engine/api/roles
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyRole</name>
//   <description>My custom role to create virtual machines</description>
//   <administrative>false</administrative>
//   <permits>
//     <permit id="1"/>
//     <permit id="1300"/>
//   </permits>
// </group>
// ----
//
type rolesServiceAddRequest struct {
	rolesService *rolesService
	header       map[string]string
	query        map[string]string
	role         *Role
}

func (p *rolesServiceAddRequest) Header(key, value string) *rolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *rolesServiceAddRequest) Query(key, value string) *rolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *rolesServiceAddRequest) Role(role *Role) *rolesServiceAddRequest {
	p.role = role
	return p
}

func (p *rolesServiceAddRequest) Send() (*rolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.rolesService.connection.URL(), p.rolesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLRoleWriteOne(writer, p.role, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.rolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.rolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &rolesServiceAddResponse{role: result}, nil
}

func (p *rolesServiceAddRequest) MustSend() *rolesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.rolesService.connection.URL(), p.rolesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLRoleWriteOne(writer, p.role, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.rolesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.rolesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &rolesServiceAddResponse{role: result}
}

//
// Create a new role. The role can be administrative or non-administrative and can have different permits.
// For example, to add the `MyRole` non-administrative role with permits to login and create virtual machines
// send a request like this (note that you have to pass permit id):
// [source]
// ----
// POST /ovirt-engine/api/roles
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyRole</name>
//   <description>My custom role to create virtual machines</description>
//   <administrative>false</administrative>
//   <permits>
//     <permit id="1"/>
//     <permit id="1300"/>
//   </permits>
// </group>
// ----
//
type rolesServiceAddResponse struct {
	role *Role
}

func (p *rolesServiceAddResponse) Role() (*Role, bool) {
	if p.role != nil {
		return p.role, true
	}
	return nil, false
}

func (p *rolesServiceAddResponse) MustRole() *Role {
	if p.role == nil {
		panic("role in response does not exist")
	}
	return p.role
}

//
// Create a new role. The role can be administrative or non-administrative and can have different permits.
// For example, to add the `MyRole` non-administrative role with permits to login and create virtual machines
// send a request like this (note that you have to pass permit id):
// [source]
// ----
// POST /ovirt-engine/api/roles
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyRole</name>
//   <description>My custom role to create virtual machines</description>
//   <administrative>false</administrative>
//   <permits>
//     <permit id="1"/>
//     <permit id="1300"/>
//   </permits>
// </group>
// ----
//
func (p *rolesService) Add() *rolesServiceAddRequest {
	return &rolesServiceAddRequest{rolesService: p}
}

//
// List roles.
// [source]
// ----
// GET /ovirt-engine/api/roles
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <roles>
//   <role id="123">
//      <name>SuperUser</name>
//      <description>Roles management administrator</description>
//      <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//      <administrative>true</administrative>
//      <mutable>false</mutable>
//   </role>
//   ...
// </roles>
// ----
// The order of the returned list of roles isn't guaranteed.
//
type rolesServiceListRequest struct {
	rolesService *rolesService
	header       map[string]string
	query        map[string]string
	follow       *string
	max          *int64
}

func (p *rolesServiceListRequest) Header(key, value string) *rolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *rolesServiceListRequest) Query(key, value string) *rolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *rolesServiceListRequest) Follow(follow string) *rolesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *rolesServiceListRequest) Max(max int64) *rolesServiceListRequest {
	p.max = &max
	return p
}

func (p *rolesServiceListRequest) Send() (*rolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.rolesService.connection.URL(), p.rolesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.rolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.rolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &rolesServiceListResponse{roles: result}, nil
}

func (p *rolesServiceListRequest) MustSend() *rolesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.rolesService.connection.URL(), p.rolesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.rolesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.rolesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &rolesServiceListResponse{roles: result}
}

//
// List roles.
// [source]
// ----
// GET /ovirt-engine/api/roles
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <roles>
//   <role id="123">
//      <name>SuperUser</name>
//      <description>Roles management administrator</description>
//      <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//      <administrative>true</administrative>
//      <mutable>false</mutable>
//   </role>
//   ...
// </roles>
// ----
// The order of the returned list of roles isn't guaranteed.
//
type rolesServiceListResponse struct {
	roles *RoleSlice
}

func (p *rolesServiceListResponse) Roles() (*RoleSlice, bool) {
	if p.roles != nil {
		return p.roles, true
	}
	return nil, false
}

func (p *rolesServiceListResponse) MustRoles() *RoleSlice {
	if p.roles == nil {
		panic("roles in response does not exist")
	}
	return p.roles
}

//
// List roles.
// [source]
// ----
// GET /ovirt-engine/api/roles
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <roles>
//   <role id="123">
//      <name>SuperUser</name>
//      <description>Roles management administrator</description>
//      <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//      <administrative>true</administrative>
//      <mutable>false</mutable>
//   </role>
//   ...
// </roles>
// ----
// The order of the returned list of roles isn't guaranteed.
//
func (p *rolesService) List() *rolesServiceListRequest {
	return &rolesServiceListRequest{rolesService: p}
}

//
// Sub-resource locator method, returns individual role resource on which the remainder of the URI is dispatched.
//
func (op *rolesService) RoleService(id string) *roleService {
	return NewRoleService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *rolesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.RoleService(path), nil
	}
	return op.RoleService(path[:index]).Service(path[index+1:])
}

func (op *rolesService) String() string {
	return fmt.Sprintf("rolesService:%s", op.path)
}

//
//
type storageDomainTemplateService struct {
	baseService
}

func NewStorageDomainTemplateService(connection *Connection, path string) *storageDomainTemplateService {
	var result storageDomainTemplateService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type storageDomainTemplateServiceGetRequest struct {
	storageDomainTemplateService *storageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
}

func (p *storageDomainTemplateServiceGetRequest) Header(key, value string) *storageDomainTemplateServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainTemplateServiceGetRequest) Query(key, value string) *storageDomainTemplateServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainTemplateServiceGetRequest) Follow(follow string) *storageDomainTemplateServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *storageDomainTemplateServiceGetRequest) Send() (*storageDomainTemplateServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainTemplateService.connection.URL(), p.storageDomainTemplateService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainTemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &storageDomainTemplateServiceGetResponse{template: result}, nil
}

func (p *storageDomainTemplateServiceGetRequest) MustSend() *storageDomainTemplateServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainTemplateService.connection.URL(), p.storageDomainTemplateService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainTemplateService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &storageDomainTemplateServiceGetResponse{template: result}
}

//
//
type storageDomainTemplateServiceGetResponse struct {
	template *Template
}

func (p *storageDomainTemplateServiceGetResponse) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

func (p *storageDomainTemplateServiceGetResponse) MustTemplate() *Template {
	if p.template == nil {
		panic("template in response does not exist")
	}
	return p.template
}

//
//
func (p *storageDomainTemplateService) Get() *storageDomainTemplateServiceGetRequest {
	return &storageDomainTemplateServiceGetRequest{storageDomainTemplateService: p}
}

//
// Action to import a template from an export storage domain.
// For example, to import the template `456` from the storage domain `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/templates/456/import
// ----
// With the following request body:
// [source, xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// If you register an entity without specifying the cluster ID or name,
// the cluster name from the entity's OVF will be used (unless the register request also includes the
// cluster mapping).
//
type storageDomainTemplateServiceImportRequest struct {
	storageDomainTemplateService *storageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
	clone                        *bool
	cluster                      *Cluster
	exclusive                    *bool
	storageDomain                *StorageDomain
	template                     *Template
	vm                           *Vm
}

func (p *storageDomainTemplateServiceImportRequest) Header(key, value string) *storageDomainTemplateServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainTemplateServiceImportRequest) Query(key, value string) *storageDomainTemplateServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainTemplateServiceImportRequest) Async(async bool) *storageDomainTemplateServiceImportRequest {
	p.async = &async
	return p
}

func (p *storageDomainTemplateServiceImportRequest) Clone(clone bool) *storageDomainTemplateServiceImportRequest {
	p.clone = &clone
	return p
}

func (p *storageDomainTemplateServiceImportRequest) Cluster(cluster *Cluster) *storageDomainTemplateServiceImportRequest {
	p.cluster = cluster
	return p
}

func (p *storageDomainTemplateServiceImportRequest) Exclusive(exclusive bool) *storageDomainTemplateServiceImportRequest {
	p.exclusive = &exclusive
	return p
}

func (p *storageDomainTemplateServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *storageDomainTemplateServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *storageDomainTemplateServiceImportRequest) Template(template *Template) *storageDomainTemplateServiceImportRequest {
	p.template = template
	return p
}

func (p *storageDomainTemplateServiceImportRequest) Vm(vm *Vm) *storageDomainTemplateServiceImportRequest {
	p.vm = vm
	return p
}

func (p *storageDomainTemplateServiceImportRequest) Send() (*storageDomainTemplateServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.storageDomainTemplateService.connection.URL(), p.storageDomainTemplateService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	actionBuilder.Cluster(p.cluster)
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Template(p.template)
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainTemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(storageDomainTemplateServiceImportResponse), nil
}

func (p *storageDomainTemplateServiceImportRequest) MustSend() *storageDomainTemplateServiceImportResponse {
	rawURL := fmt.Sprintf("%s%s/import", p.storageDomainTemplateService.connection.URL(), p.storageDomainTemplateService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	actionBuilder.Cluster(p.cluster)
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Template(p.template)
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainTemplateService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(storageDomainTemplateServiceImportResponse)
}

//
// Action to import a template from an export storage domain.
// For example, to import the template `456` from the storage domain `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/templates/456/import
// ----
// With the following request body:
// [source, xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// If you register an entity without specifying the cluster ID or name,
// the cluster name from the entity's OVF will be used (unless the register request also includes the
// cluster mapping).
//
type storageDomainTemplateServiceImportResponse struct {
}

//
// Action to import a template from an export storage domain.
// For example, to import the template `456` from the storage domain `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/templates/456/import
// ----
// With the following request body:
// [source, xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// If you register an entity without specifying the cluster ID or name,
// the cluster name from the entity's OVF will be used (unless the register request also includes the
// cluster mapping).
//
func (p *storageDomainTemplateService) Import() *storageDomainTemplateServiceImportRequest {
	return &storageDomainTemplateServiceImportRequest{storageDomainTemplateService: p}
}

//
// Register the Template means importing the Template from the data domain by inserting the configuration of the
// Template and disks into the database without the copy process.
//
type storageDomainTemplateServiceRegisterRequest struct {
	storageDomainTemplateService *storageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	allowPartialImport           *bool
	async                        *bool
	clone                        *bool
	cluster                      *Cluster
	exclusive                    *bool
	registrationConfiguration    *RegistrationConfiguration
	template                     *Template
	vnicProfileMappings          *VnicProfileMappingSlice
}

func (p *storageDomainTemplateServiceRegisterRequest) Header(key, value string) *storageDomainTemplateServiceRegisterRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainTemplateServiceRegisterRequest) Query(key, value string) *storageDomainTemplateServiceRegisterRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainTemplateServiceRegisterRequest) AllowPartialImport(allowPartialImport bool) *storageDomainTemplateServiceRegisterRequest {
	p.allowPartialImport = &allowPartialImport
	return p
}

func (p *storageDomainTemplateServiceRegisterRequest) Async(async bool) *storageDomainTemplateServiceRegisterRequest {
	p.async = &async
	return p
}

func (p *storageDomainTemplateServiceRegisterRequest) Clone(clone bool) *storageDomainTemplateServiceRegisterRequest {
	p.clone = &clone
	return p
}

func (p *storageDomainTemplateServiceRegisterRequest) Cluster(cluster *Cluster) *storageDomainTemplateServiceRegisterRequest {
	p.cluster = cluster
	return p
}

func (p *storageDomainTemplateServiceRegisterRequest) Exclusive(exclusive bool) *storageDomainTemplateServiceRegisterRequest {
	p.exclusive = &exclusive
	return p
}

func (p *storageDomainTemplateServiceRegisterRequest) RegistrationConfiguration(registrationConfiguration *RegistrationConfiguration) *storageDomainTemplateServiceRegisterRequest {
	p.registrationConfiguration = registrationConfiguration
	return p
}

func (p *storageDomainTemplateServiceRegisterRequest) Template(template *Template) *storageDomainTemplateServiceRegisterRequest {
	p.template = template
	return p
}

func (p *storageDomainTemplateServiceRegisterRequest) VnicProfileMappings(vnicProfileMappings *VnicProfileMappingSlice) *storageDomainTemplateServiceRegisterRequest {
	p.vnicProfileMappings = vnicProfileMappings
	return p
}

func (p *storageDomainTemplateServiceRegisterRequest) VnicProfileMappingsOfAny(anys ...*VnicProfileMapping) *storageDomainTemplateServiceRegisterRequest {
	if p.vnicProfileMappings == nil {
		p.vnicProfileMappings = new(VnicProfileMappingSlice)
	}
	p.vnicProfileMappings.slice = append(p.vnicProfileMappings.slice, anys...)
	return p
}

func (p *storageDomainTemplateServiceRegisterRequest) Send() (*storageDomainTemplateServiceRegisterResponse, error) {
	rawURL := fmt.Sprintf("%s%s/register", p.storageDomainTemplateService.connection.URL(), p.storageDomainTemplateService.path)
	actionBuilder := NewActionBuilder()
	if p.allowPartialImport != nil {
		actionBuilder.AllowPartialImport(*p.allowPartialImport)
	}
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	actionBuilder.Cluster(p.cluster)
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.RegistrationConfiguration(p.registrationConfiguration)
	actionBuilder.Template(p.template)
	actionBuilder.VnicProfileMappings(p.vnicProfileMappings)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainTemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(storageDomainTemplateServiceRegisterResponse), nil
}

func (p *storageDomainTemplateServiceRegisterRequest) MustSend() *storageDomainTemplateServiceRegisterResponse {
	rawURL := fmt.Sprintf("%s%s/register", p.storageDomainTemplateService.connection.URL(), p.storageDomainTemplateService.path)
	actionBuilder := NewActionBuilder()
	if p.allowPartialImport != nil {
		actionBuilder.AllowPartialImport(*p.allowPartialImport)
	}
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	actionBuilder.Cluster(p.cluster)
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.RegistrationConfiguration(p.registrationConfiguration)
	actionBuilder.Template(p.template)
	actionBuilder.VnicProfileMappings(p.vnicProfileMappings)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainTemplateService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(storageDomainTemplateServiceRegisterResponse)
}

//
// Register the Template means importing the Template from the data domain by inserting the configuration of the
// Template and disks into the database without the copy process.
//
type storageDomainTemplateServiceRegisterResponse struct {
}

//
// Register the Template means importing the Template from the data domain by inserting the configuration of the
// Template and disks into the database without the copy process.
//
func (p *storageDomainTemplateService) Register() *storageDomainTemplateServiceRegisterRequest {
	return &storageDomainTemplateServiceRegisterRequest{storageDomainTemplateService: p}
}

//
//
type storageDomainTemplateServiceRemoveRequest struct {
	storageDomainTemplateService *storageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *storageDomainTemplateServiceRemoveRequest) Header(key, value string) *storageDomainTemplateServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *storageDomainTemplateServiceRemoveRequest) Query(key, value string) *storageDomainTemplateServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *storageDomainTemplateServiceRemoveRequest) Async(async bool) *storageDomainTemplateServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *storageDomainTemplateServiceRemoveRequest) Send() (*storageDomainTemplateServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainTemplateService.connection.URL(), p.storageDomainTemplateService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainTemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(storageDomainTemplateServiceRemoveResponse), nil
}

func (p *storageDomainTemplateServiceRemoveRequest) MustSend() *storageDomainTemplateServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.storageDomainTemplateService.connection.URL(), p.storageDomainTemplateService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.storageDomainTemplateService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.storageDomainTemplateService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(storageDomainTemplateServiceRemoveResponse)
}

//
//
type storageDomainTemplateServiceRemoveResponse struct {
}

//
//
func (p *storageDomainTemplateService) Remove() *storageDomainTemplateServiceRemoveRequest {
	return &storageDomainTemplateServiceRemoveRequest{storageDomainTemplateService: p}
}

//
//
func (op *storageDomainTemplateService) DisksService() *storageDomainContentDisksService {
	return NewStorageDomainContentDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *storageDomainTemplateService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *storageDomainTemplateService) String() string {
	return fmt.Sprintf("storageDomainTemplateService:%s", op.path)
}

//
// Service that provides values of configuration options of the system.
//
type systemOptionsService struct {
	baseService
}

func NewSystemOptionsService(connection *Connection, path string) *systemOptionsService {
	var result systemOptionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns a reference to the service that provides values of specific configuration option.
//
func (op *systemOptionsService) OptionService(id string) *systemOptionService {
	return NewSystemOptionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *systemOptionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.OptionService(path), nil
	}
	return op.OptionService(path[:index]).Service(path[index+1:])
}

func (op *systemOptionsService) String() string {
	return fmt.Sprintf("systemOptionsService:%s", op.path)
}

//
// Manages the collection of disks available in the system.
//
type disksService struct {
	baseService
}

func NewDisksService(connection *Connection, path string) *disksService {
	var result disksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a new floating disk.
// There are three types of disks that can be added - disk image, direct LUN and
//  https://wiki.openstack.org/wiki/Cinder[Cinder] disk.
// *Adding a new image disk:*
// When creating a new floating image <<types/disk,Disk>>, the API requires the `storage_domain`, `provisioned_size`
// and `format` attributes.
// Note that block storage domains (i.e., storage domains with the <<types/storage_type, storage type>> of iSCSI or
// FCP) don't support the combination of the raw `format` with `sparse=true`, so `sparse=false` must be stated
// explicitly.
// To create a new floating image disk with specified `provisioned_size`, `format` and `name` on a storage domain
// with an id `123`, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
// *Adding a new direct LUN disk:*
// When adding a new floating direct LUN via the API, there are two flavors that can be used:
// . With a `host` element - in this case, the host is used for sanity checks (e.g., that the LUN is visible) and
// to retrieve basic information about the LUN (e.g., size and serial).
// . Without a `host` element - in this case, the operation is a database-only operation, and the storage is never
// accessed.
// To create a new floating direct LUN disk with a `host` element with an id `123`, specified `alias`, `type` and
// `logical_unit` with an id `456` (that has the attributes `address`, `port` and `target`),
// send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <alias>mylun</alias>
//   <lun_storage>
//     <host id="123"/>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="456">
//         <address>10.35.10.20</address>
//         <port>3260</port>
//         <target>iqn.2017-01.com.myhost:444</target>
//       </logical_unit>
//     </logical_units>
//   </lun_storage>
// </disk>
// ----
// To create a new floating direct LUN disk without using a host, remove the `host` element.
// *Adding a new Cinder disk:*
// To create a new floating Cinder disk, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <openstack_volume_type>
//     <name>myceph</name>
//   </openstack_volume_type>
//   <storage_domains>
//     <storage_domain>
//       <name>cinderDomain</name>
//     </storage_domain>
//   </storage_domains>
//   <provisioned_size>1073741824</provisioned_size>
//   <interface>virtio</interface>
//   <format>raw</format>
// </disk>
// ----
// *Adding a floating disks in order to upload disk snapshots:*
// Since version 4.2 of the engine it is possible to upload disks with
// snapshots. This request should be used to create the base image of the
// images chain (The consecutive disk snapshots (images), should be created
// using `disk-attachments` element when creating a snapshot).
// The disk has to be created with the same disk identifier and image identifier
// of the uploaded image. I.e. the identifiers should be saved as part of the
// backup process. The image identifier can be also fetched using the
// `qemu-img info` command. For example, if the disk image is stored into
// a file named `b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img`:
// [source,shell]
// ----
// $ qemu-img info b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img
// image: b548366b-fb51-4b41-97be-733c887fe305
// file format: qcow2
// virtual size: 1.0G (1073741824 bytes)
// disk size: 196K
// cluster_size: 65536
// backing file: ad58716a-1fe9-481f-815e-664de1df04eb
// backing file format: raw
// ----
// To create a disk with with the disk identifier and image identifier obtained
// with the `qemu-img info` command shown above, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk id="b7a4c6c5-443b-47c5-967f-6abc79675e8b">
//   <image_id>b548366b-fb51-4b41-97be-733c887fe305</image_id>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
//
type disksServiceAddRequest struct {
	disksService *disksService
	header       map[string]string
	query        map[string]string
	disk         *Disk
}

func (p *disksServiceAddRequest) Header(key, value string) *disksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *disksServiceAddRequest) Query(key, value string) *disksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *disksServiceAddRequest) Disk(disk *Disk) *disksServiceAddRequest {
	p.disk = disk
	return p
}

func (p *disksServiceAddRequest) Send() (*disksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.disksService.connection.URL(), p.disksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.disksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.disksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &disksServiceAddResponse{disk: result}, nil
}

func (p *disksServiceAddRequest) MustSend() *disksServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.disksService.connection.URL(), p.disksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.disksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.disksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &disksServiceAddResponse{disk: result}
}

//
// Adds a new floating disk.
// There are three types of disks that can be added - disk image, direct LUN and
//  https://wiki.openstack.org/wiki/Cinder[Cinder] disk.
// *Adding a new image disk:*
// When creating a new floating image <<types/disk,Disk>>, the API requires the `storage_domain`, `provisioned_size`
// and `format` attributes.
// Note that block storage domains (i.e., storage domains with the <<types/storage_type, storage type>> of iSCSI or
// FCP) don't support the combination of the raw `format` with `sparse=true`, so `sparse=false` must be stated
// explicitly.
// To create a new floating image disk with specified `provisioned_size`, `format` and `name` on a storage domain
// with an id `123`, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
// *Adding a new direct LUN disk:*
// When adding a new floating direct LUN via the API, there are two flavors that can be used:
// . With a `host` element - in this case, the host is used for sanity checks (e.g., that the LUN is visible) and
// to retrieve basic information about the LUN (e.g., size and serial).
// . Without a `host` element - in this case, the operation is a database-only operation, and the storage is never
// accessed.
// To create a new floating direct LUN disk with a `host` element with an id `123`, specified `alias`, `type` and
// `logical_unit` with an id `456` (that has the attributes `address`, `port` and `target`),
// send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <alias>mylun</alias>
//   <lun_storage>
//     <host id="123"/>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="456">
//         <address>10.35.10.20</address>
//         <port>3260</port>
//         <target>iqn.2017-01.com.myhost:444</target>
//       </logical_unit>
//     </logical_units>
//   </lun_storage>
// </disk>
// ----
// To create a new floating direct LUN disk without using a host, remove the `host` element.
// *Adding a new Cinder disk:*
// To create a new floating Cinder disk, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <openstack_volume_type>
//     <name>myceph</name>
//   </openstack_volume_type>
//   <storage_domains>
//     <storage_domain>
//       <name>cinderDomain</name>
//     </storage_domain>
//   </storage_domains>
//   <provisioned_size>1073741824</provisioned_size>
//   <interface>virtio</interface>
//   <format>raw</format>
// </disk>
// ----
// *Adding a floating disks in order to upload disk snapshots:*
// Since version 4.2 of the engine it is possible to upload disks with
// snapshots. This request should be used to create the base image of the
// images chain (The consecutive disk snapshots (images), should be created
// using `disk-attachments` element when creating a snapshot).
// The disk has to be created with the same disk identifier and image identifier
// of the uploaded image. I.e. the identifiers should be saved as part of the
// backup process. The image identifier can be also fetched using the
// `qemu-img info` command. For example, if the disk image is stored into
// a file named `b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img`:
// [source,shell]
// ----
// $ qemu-img info b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img
// image: b548366b-fb51-4b41-97be-733c887fe305
// file format: qcow2
// virtual size: 1.0G (1073741824 bytes)
// disk size: 196K
// cluster_size: 65536
// backing file: ad58716a-1fe9-481f-815e-664de1df04eb
// backing file format: raw
// ----
// To create a disk with with the disk identifier and image identifier obtained
// with the `qemu-img info` command shown above, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk id="b7a4c6c5-443b-47c5-967f-6abc79675e8b">
//   <image_id>b548366b-fb51-4b41-97be-733c887fe305</image_id>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
//
type disksServiceAddResponse struct {
	disk *Disk
}

func (p *disksServiceAddResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *disksServiceAddResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Adds a new floating disk.
// There are three types of disks that can be added - disk image, direct LUN and
//  https://wiki.openstack.org/wiki/Cinder[Cinder] disk.
// *Adding a new image disk:*
// When creating a new floating image <<types/disk,Disk>>, the API requires the `storage_domain`, `provisioned_size`
// and `format` attributes.
// Note that block storage domains (i.e., storage domains with the <<types/storage_type, storage type>> of iSCSI or
// FCP) don't support the combination of the raw `format` with `sparse=true`, so `sparse=false` must be stated
// explicitly.
// To create a new floating image disk with specified `provisioned_size`, `format` and `name` on a storage domain
// with an id `123`, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
// *Adding a new direct LUN disk:*
// When adding a new floating direct LUN via the API, there are two flavors that can be used:
// . With a `host` element - in this case, the host is used for sanity checks (e.g., that the LUN is visible) and
// to retrieve basic information about the LUN (e.g., size and serial).
// . Without a `host` element - in this case, the operation is a database-only operation, and the storage is never
// accessed.
// To create a new floating direct LUN disk with a `host` element with an id `123`, specified `alias`, `type` and
// `logical_unit` with an id `456` (that has the attributes `address`, `port` and `target`),
// send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <alias>mylun</alias>
//   <lun_storage>
//     <host id="123"/>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="456">
//         <address>10.35.10.20</address>
//         <port>3260</port>
//         <target>iqn.2017-01.com.myhost:444</target>
//       </logical_unit>
//     </logical_units>
//   </lun_storage>
// </disk>
// ----
// To create a new floating direct LUN disk without using a host, remove the `host` element.
// *Adding a new Cinder disk:*
// To create a new floating Cinder disk, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <openstack_volume_type>
//     <name>myceph</name>
//   </openstack_volume_type>
//   <storage_domains>
//     <storage_domain>
//       <name>cinderDomain</name>
//     </storage_domain>
//   </storage_domains>
//   <provisioned_size>1073741824</provisioned_size>
//   <interface>virtio</interface>
//   <format>raw</format>
// </disk>
// ----
// *Adding a floating disks in order to upload disk snapshots:*
// Since version 4.2 of the engine it is possible to upload disks with
// snapshots. This request should be used to create the base image of the
// images chain (The consecutive disk snapshots (images), should be created
// using `disk-attachments` element when creating a snapshot).
// The disk has to be created with the same disk identifier and image identifier
// of the uploaded image. I.e. the identifiers should be saved as part of the
// backup process. The image identifier can be also fetched using the
// `qemu-img info` command. For example, if the disk image is stored into
// a file named `b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img`:
// [source,shell]
// ----
// $ qemu-img info b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img
// image: b548366b-fb51-4b41-97be-733c887fe305
// file format: qcow2
// virtual size: 1.0G (1073741824 bytes)
// disk size: 196K
// cluster_size: 65536
// backing file: ad58716a-1fe9-481f-815e-664de1df04eb
// backing file format: raw
// ----
// To create a disk with with the disk identifier and image identifier obtained
// with the `qemu-img info` command shown above, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk id="b7a4c6c5-443b-47c5-967f-6abc79675e8b">
//   <image_id>b548366b-fb51-4b41-97be-733c887fe305</image_id>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
//
func (p *disksService) Add() *disksServiceAddRequest {
	return &disksServiceAddRequest{disksService: p}
}

//
// Get list of disks.
// [source]
// ----
// GET /ovirt-engine/api/disks
// ----
// You will get a XML response which will look like this one:
// [source,xml]
// ----
// <disks>
//   <disk id="123">
//     <actions>...</actions>
//     <name>MyDisk</name>
//     <description>MyDisk description</description>
//     <link href="/ovirt-engine/api/disks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/disks/123/statistics" rel="statistics"/>
//     <actual_size>5345845248</actual_size>
//     <alias>MyDisk alias</alias>
//     ...
//     <status>ok</status>
//     <storage_type>image</storage_type>
//     <wipe_after_delete>false</wipe_after_delete>
//     <disk_profile id="123"/>
//     <quota id="123"/>
//     <storage_domains>...</storage_domains>
//   </disk>
//   ...
// </disks>
// ----
// The order of the returned list of disks is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type disksServiceListRequest struct {
	disksService  *disksService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	follow        *string
	max           *int64
	search        *string
}

func (p *disksServiceListRequest) Header(key, value string) *disksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *disksServiceListRequest) Query(key, value string) *disksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *disksServiceListRequest) CaseSensitive(caseSensitive bool) *disksServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *disksServiceListRequest) Follow(follow string) *disksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *disksServiceListRequest) Max(max int64) *disksServiceListRequest {
	p.max = &max
	return p
}

func (p *disksServiceListRequest) Search(search string) *disksServiceListRequest {
	p.search = &search
	return p
}

func (p *disksServiceListRequest) Send() (*disksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.disksService.connection.URL(), p.disksService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.disksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.disksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &disksServiceListResponse{disks: result}, nil
}

func (p *disksServiceListRequest) MustSend() *disksServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.disksService.connection.URL(), p.disksService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.disksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.disksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &disksServiceListResponse{disks: result}
}

//
// Get list of disks.
// [source]
// ----
// GET /ovirt-engine/api/disks
// ----
// You will get a XML response which will look like this one:
// [source,xml]
// ----
// <disks>
//   <disk id="123">
//     <actions>...</actions>
//     <name>MyDisk</name>
//     <description>MyDisk description</description>
//     <link href="/ovirt-engine/api/disks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/disks/123/statistics" rel="statistics"/>
//     <actual_size>5345845248</actual_size>
//     <alias>MyDisk alias</alias>
//     ...
//     <status>ok</status>
//     <storage_type>image</storage_type>
//     <wipe_after_delete>false</wipe_after_delete>
//     <disk_profile id="123"/>
//     <quota id="123"/>
//     <storage_domains>...</storage_domains>
//   </disk>
//   ...
// </disks>
// ----
// The order of the returned list of disks is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type disksServiceListResponse struct {
	disks *DiskSlice
}

func (p *disksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *disksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Get list of disks.
// [source]
// ----
// GET /ovirt-engine/api/disks
// ----
// You will get a XML response which will look like this one:
// [source,xml]
// ----
// <disks>
//   <disk id="123">
//     <actions>...</actions>
//     <name>MyDisk</name>
//     <description>MyDisk description</description>
//     <link href="/ovirt-engine/api/disks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/disks/123/statistics" rel="statistics"/>
//     <actual_size>5345845248</actual_size>
//     <alias>MyDisk alias</alias>
//     ...
//     <status>ok</status>
//     <storage_type>image</storage_type>
//     <wipe_after_delete>false</wipe_after_delete>
//     <disk_profile id="123"/>
//     <quota id="123"/>
//     <storage_domains>...</storage_domains>
//   </disk>
//   ...
// </disks>
// ----
// The order of the returned list of disks is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
func (p *disksService) List() *disksServiceListRequest {
	return &disksServiceListRequest{disksService: p}
}

//
// Add a new lun disk to the storage domain.
//
type disksServiceAddLunRequest struct {
	disksService *disksService
	header       map[string]string
	query        map[string]string
	disk         *Disk
}

func (p *disksServiceAddLunRequest) Header(key, value string) *disksServiceAddLunRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *disksServiceAddLunRequest) Query(key, value string) *disksServiceAddLunRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *disksServiceAddLunRequest) Disk(disk *Disk) *disksServiceAddLunRequest {
	p.disk = disk
	return p
}

func (p *disksServiceAddLunRequest) Send() (*disksServiceAddLunResponse, error) {
	rawURL := fmt.Sprintf("%s%s/lun", p.disksService.connection.URL(), p.disksService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.disksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.disksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustDisk()
	return &disksServiceAddLunResponse{disk: result}, nil
}

func (p *disksServiceAddLunRequest) MustSend() *disksServiceAddLunResponse {
	rawURL := fmt.Sprintf("%s%s/lun", p.disksService.connection.URL(), p.disksService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.disksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.disksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustDisk()
	return &disksServiceAddLunResponse{disk: result}
}

//
// Add a new lun disk to the storage domain.
//
type disksServiceAddLunResponse struct {
	disk *Disk
}

func (p *disksServiceAddLunResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *disksServiceAddLunResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Add a new lun disk to the storage domain.
//
func (p *disksService) AddLun() *disksServiceAddLunRequest {
	return &disksServiceAddLunRequest{disksService: p}
}

//
// Add a new disk to the storage domain with the specified size allocating space from the storage domain.
//
type disksServiceAddOnStorageDomainRequest struct {
	disksService *disksService
	header       map[string]string
	query        map[string]string
	disk         *Disk
}

func (p *disksServiceAddOnStorageDomainRequest) Header(key, value string) *disksServiceAddOnStorageDomainRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *disksServiceAddOnStorageDomainRequest) Query(key, value string) *disksServiceAddOnStorageDomainRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *disksServiceAddOnStorageDomainRequest) Disk(disk *Disk) *disksServiceAddOnStorageDomainRequest {
	p.disk = disk
	return p
}

func (p *disksServiceAddOnStorageDomainRequest) Send() (*disksServiceAddOnStorageDomainResponse, error) {
	rawURL := fmt.Sprintf("%s%s/onstoragedomain", p.disksService.connection.URL(), p.disksService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.disksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.disksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustDisk()
	return &disksServiceAddOnStorageDomainResponse{disk: result}, nil
}

func (p *disksServiceAddOnStorageDomainRequest) MustSend() *disksServiceAddOnStorageDomainResponse {
	rawURL := fmt.Sprintf("%s%s/onstoragedomain", p.disksService.connection.URL(), p.disksService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.disksService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.disksService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	result := action.MustDisk()
	return &disksServiceAddOnStorageDomainResponse{disk: result}
}

//
// Add a new disk to the storage domain with the specified size allocating space from the storage domain.
//
type disksServiceAddOnStorageDomainResponse struct {
	disk *Disk
}

func (p *disksServiceAddOnStorageDomainResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *disksServiceAddOnStorageDomainResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Add a new disk to the storage domain with the specified size allocating space from the storage domain.
//
func (p *disksService) AddOnStorageDomain() *disksServiceAddOnStorageDomainRequest {
	return &disksServiceAddOnStorageDomainRequest{disksService: p}
}

//
// Reference to a service managing a specific disk.
//
func (op *disksService) DiskService(id string) *diskService {
	return NewDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *disksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *disksService) String() string {
	return fmt.Sprintf("disksService:%s", op.path)
}

//
//
type assignedDiskProfilesService struct {
	baseService
}

func NewAssignedDiskProfilesService(connection *Connection, path string) *assignedDiskProfilesService {
	var result assignedDiskProfilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new disk profile for the storage domain.
//
type assignedDiskProfilesServiceAddRequest struct {
	assignedDiskProfilesService *assignedDiskProfilesService
	header                      map[string]string
	query                       map[string]string
	profile                     *DiskProfile
}

func (p *assignedDiskProfilesServiceAddRequest) Header(key, value string) *assignedDiskProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedDiskProfilesServiceAddRequest) Query(key, value string) *assignedDiskProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedDiskProfilesServiceAddRequest) Profile(profile *DiskProfile) *assignedDiskProfilesServiceAddRequest {
	p.profile = profile
	return p
}

func (p *assignedDiskProfilesServiceAddRequest) Send() (*assignedDiskProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfilesService.connection.URL(), p.assignedDiskProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedDiskProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &assignedDiskProfilesServiceAddResponse{profile: result}, nil
}

func (p *assignedDiskProfilesServiceAddRequest) MustSend() *assignedDiskProfilesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfilesService.connection.URL(), p.assignedDiskProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskProfileWriteOne(writer, p.profile, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedDiskProfilesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfilesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &assignedDiskProfilesServiceAddResponse{profile: result}
}

//
// Add a new disk profile for the storage domain.
//
type assignedDiskProfilesServiceAddResponse struct {
	profile *DiskProfile
}

func (p *assignedDiskProfilesServiceAddResponse) Profile() (*DiskProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *assignedDiskProfilesServiceAddResponse) MustProfile() *DiskProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Add a new disk profile for the storage domain.
//
func (p *assignedDiskProfilesService) Add() *assignedDiskProfilesServiceAddRequest {
	return &assignedDiskProfilesServiceAddRequest{assignedDiskProfilesService: p}
}

//
// Returns the list of disk profiles assigned to the storage domain.
// The order of the returned disk profiles isn't guaranteed.
//
type assignedDiskProfilesServiceListRequest struct {
	assignedDiskProfilesService *assignedDiskProfilesService
	header                      map[string]string
	query                       map[string]string
	follow                      *string
	max                         *int64
}

func (p *assignedDiskProfilesServiceListRequest) Header(key, value string) *assignedDiskProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *assignedDiskProfilesServiceListRequest) Query(key, value string) *assignedDiskProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *assignedDiskProfilesServiceListRequest) Follow(follow string) *assignedDiskProfilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *assignedDiskProfilesServiceListRequest) Max(max int64) *assignedDiskProfilesServiceListRequest {
	p.max = &max
	return p
}

func (p *assignedDiskProfilesServiceListRequest) Send() (*assignedDiskProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfilesService.connection.URL(), p.assignedDiskProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedDiskProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &assignedDiskProfilesServiceListResponse{profiles: result}, nil
}

func (p *assignedDiskProfilesServiceListRequest) MustSend() *assignedDiskProfilesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.assignedDiskProfilesService.connection.URL(), p.assignedDiskProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.assignedDiskProfilesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.assignedDiskProfilesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &assignedDiskProfilesServiceListResponse{profiles: result}
}

//
// Returns the list of disk profiles assigned to the storage domain.
// The order of the returned disk profiles isn't guaranteed.
//
type assignedDiskProfilesServiceListResponse struct {
	profiles *DiskProfileSlice
}

func (p *assignedDiskProfilesServiceListResponse) Profiles() (*DiskProfileSlice, bool) {
	if p.profiles != nil {
		return p.profiles, true
	}
	return nil, false
}

func (p *assignedDiskProfilesServiceListResponse) MustProfiles() *DiskProfileSlice {
	if p.profiles == nil {
		panic("profiles in response does not exist")
	}
	return p.profiles
}

//
// Returns the list of disk profiles assigned to the storage domain.
// The order of the returned disk profiles isn't guaranteed.
//
func (p *assignedDiskProfilesService) List() *assignedDiskProfilesServiceListRequest {
	return &assignedDiskProfilesServiceListRequest{assignedDiskProfilesService: p}
}

//
//
func (op *assignedDiskProfilesService) ProfileService(id string) *assignedDiskProfileService {
	return NewAssignedDiskProfileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *assignedDiskProfilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProfileService(path), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *assignedDiskProfilesService) String() string {
	return fmt.Sprintf("assignedDiskProfilesService:%s", op.path)
}

//
//
type instanceTypeService struct {
	baseService
}

func NewInstanceTypeService(connection *Connection, path string) *instanceTypeService {
	var result instanceTypeService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get a specific instance type and it's attributes.
// [source]
// ----
// GET /ovirt-engine/api/instancetypes/123
// ----
//
type instanceTypeServiceGetRequest struct {
	instanceTypeService *instanceTypeService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *instanceTypeServiceGetRequest) Header(key, value string) *instanceTypeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeServiceGetRequest) Query(key, value string) *instanceTypeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeServiceGetRequest) Follow(follow string) *instanceTypeServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *instanceTypeServiceGetRequest) Send() (*instanceTypeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeService.connection.URL(), p.instanceTypeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLInstanceTypeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &instanceTypeServiceGetResponse{instanceType: result}, nil
}

func (p *instanceTypeServiceGetRequest) MustSend() *instanceTypeServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeService.connection.URL(), p.instanceTypeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLInstanceTypeReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &instanceTypeServiceGetResponse{instanceType: result}
}

//
// Get a specific instance type and it's attributes.
// [source]
// ----
// GET /ovirt-engine/api/instancetypes/123
// ----
//
type instanceTypeServiceGetResponse struct {
	instanceType *InstanceType
}

func (p *instanceTypeServiceGetResponse) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

func (p *instanceTypeServiceGetResponse) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("instanceType in response does not exist")
	}
	return p.instanceType
}

//
// Get a specific instance type and it's attributes.
// [source]
// ----
// GET /ovirt-engine/api/instancetypes/123
// ----
//
func (p *instanceTypeService) Get() *instanceTypeServiceGetRequest {
	return &instanceTypeServiceGetRequest{instanceTypeService: p}
}

//
// Removes a specific instance type from the system.
// If a virtual machine was created using an instance type X after removal of the instance type
// the virtual machine's instance type will be set to `custom`.
// [source]
// ----
// DELETE /ovirt-engine/api/instancetypes/123
// ----
//
type instanceTypeServiceRemoveRequest struct {
	instanceTypeService *instanceTypeService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *instanceTypeServiceRemoveRequest) Header(key, value string) *instanceTypeServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeServiceRemoveRequest) Query(key, value string) *instanceTypeServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeServiceRemoveRequest) Async(async bool) *instanceTypeServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *instanceTypeServiceRemoveRequest) Send() (*instanceTypeServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeService.connection.URL(), p.instanceTypeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(instanceTypeServiceRemoveResponse), nil
}

func (p *instanceTypeServiceRemoveRequest) MustSend() *instanceTypeServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeService.connection.URL(), p.instanceTypeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(instanceTypeServiceRemoveResponse)
}

//
// Removes a specific instance type from the system.
// If a virtual machine was created using an instance type X after removal of the instance type
// the virtual machine's instance type will be set to `custom`.
// [source]
// ----
// DELETE /ovirt-engine/api/instancetypes/123
// ----
//
type instanceTypeServiceRemoveResponse struct {
}

//
// Removes a specific instance type from the system.
// If a virtual machine was created using an instance type X after removal of the instance type
// the virtual machine's instance type will be set to `custom`.
// [source]
// ----
// DELETE /ovirt-engine/api/instancetypes/123
// ----
//
func (p *instanceTypeService) Remove() *instanceTypeServiceRemoveRequest {
	return &instanceTypeServiceRemoveRequest{instanceTypeService: p}
}

//
// Update a specific instance type and it's attributes.
// All the attributes are editable after creation.
// If a virtual machine was created using an instance type X and some configuration in instance
// type X was updated, the virtual machine's configuration will be updated automatically by the
// engine.
// [source]
// ----
// PUT /ovirt-engine/api/instancetypes/123
// ----
// For example, to update the memory of instance type `123` to 1 GiB and set the cpu topology
// to 2 sockets and 1 core, send a request like this:
// [source, xml]
// ----
// <instance_type>
//   <memory>1073741824</memory>
//   <cpu>
//     <topology>
//       <cores>1</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
// </instance_type>
// ----
//
type instanceTypeServiceUpdateRequest struct {
	instanceTypeService *instanceTypeService
	header              map[string]string
	query               map[string]string
	async               *bool
	instanceType        *InstanceType
}

func (p *instanceTypeServiceUpdateRequest) Header(key, value string) *instanceTypeServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *instanceTypeServiceUpdateRequest) Query(key, value string) *instanceTypeServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *instanceTypeServiceUpdateRequest) Async(async bool) *instanceTypeServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *instanceTypeServiceUpdateRequest) InstanceType(instanceType *InstanceType) *instanceTypeServiceUpdateRequest {
	p.instanceType = instanceType
	return p
}

func (p *instanceTypeServiceUpdateRequest) Send() (*instanceTypeServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeService.connection.URL(), p.instanceTypeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLInstanceTypeWriteOne(writer, p.instanceType, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLInstanceTypeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &instanceTypeServiceUpdateResponse{instanceType: result}, nil
}

func (p *instanceTypeServiceUpdateRequest) MustSend() *instanceTypeServiceUpdateResponse {
	rawURL := fmt.Sprintf("%s%s", p.instanceTypeService.connection.URL(), p.instanceTypeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLInstanceTypeWriteOne(writer, p.instanceType, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.instanceTypeService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.instanceTypeService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLInstanceTypeReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &instanceTypeServiceUpdateResponse{instanceType: result}
}

//
// Update a specific instance type and it's attributes.
// All the attributes are editable after creation.
// If a virtual machine was created using an instance type X and some configuration in instance
// type X was updated, the virtual machine's configuration will be updated automatically by the
// engine.
// [source]
// ----
// PUT /ovirt-engine/api/instancetypes/123
// ----
// For example, to update the memory of instance type `123` to 1 GiB and set the cpu topology
// to 2 sockets and 1 core, send a request like this:
// [source, xml]
// ----
// <instance_type>
//   <memory>1073741824</memory>
//   <cpu>
//     <topology>
//       <cores>1</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
// </instance_type>
// ----
//
type instanceTypeServiceUpdateResponse struct {
	instanceType *InstanceType
}

func (p *instanceTypeServiceUpdateResponse) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

func (p *instanceTypeServiceUpdateResponse) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("instanceType in response does not exist")
	}
	return p.instanceType
}

//
// Update a specific instance type and it's attributes.
// All the attributes are editable after creation.
// If a virtual machine was created using an instance type X and some configuration in instance
// type X was updated, the virtual machine's configuration will be updated automatically by the
// engine.
// [source]
// ----
// PUT /ovirt-engine/api/instancetypes/123
// ----
// For example, to update the memory of instance type `123` to 1 GiB and set the cpu topology
// to 2 sockets and 1 core, send a request like this:
// [source, xml]
// ----
// <instance_type>
//   <memory>1073741824</memory>
//   <cpu>
//     <topology>
//       <cores>1</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
// </instance_type>
// ----
//
func (p *instanceTypeService) Update() *instanceTypeServiceUpdateRequest {
	return &instanceTypeServiceUpdateRequest{instanceTypeService: p}
}

//
// Reference to the service that manages the graphic consoles that are attached to this
// instance type.
//
func (op *instanceTypeService) GraphicsConsolesService() *instanceTypeGraphicsConsolesService {
	return NewInstanceTypeGraphicsConsolesService(op.connection, fmt.Sprintf("%s/graphicsconsoles", op.path))
}

//
// Reference to the service that manages the NICs that are attached to this instance type.
//
func (op *instanceTypeService) NicsService() *instanceTypeNicsService {
	return NewInstanceTypeNicsService(op.connection, fmt.Sprintf("%s/nics", op.path))
}

//
// Reference to the service that manages the watchdogs that are attached to this instance type.
//
func (op *instanceTypeService) WatchdogsService() *instanceTypeWatchdogsService {
	return NewInstanceTypeWatchdogsService(op.connection, fmt.Sprintf("%s/watchdogs", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *instanceTypeService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "graphicsconsoles" {
		return op.GraphicsConsolesService(), nil
	}
	if strings.HasPrefix(path, "graphicsconsoles/") {
		return op.GraphicsConsolesService().Service(path[17:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "watchdogs" {
		return op.WatchdogsService(), nil
	}
	if strings.HasPrefix(path, "watchdogs/") {
		return op.WatchdogsService().Service(path[10:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *instanceTypeService) String() string {
	return fmt.Sprintf("instanceTypeService:%s", op.path)
}

//
//
type balanceService struct {
	baseService
}

func NewBalanceService(connection *Connection, path string) *balanceService {
	var result balanceService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type balanceServiceGetRequest struct {
	balanceService *balanceService
	header         map[string]string
	query          map[string]string
	filter         *bool
	follow         *string
}

func (p *balanceServiceGetRequest) Header(key, value string) *balanceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *balanceServiceGetRequest) Query(key, value string) *balanceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *balanceServiceGetRequest) Filter(filter bool) *balanceServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *balanceServiceGetRequest) Follow(follow string) *balanceServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *balanceServiceGetRequest) Send() (*balanceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.balanceService.connection.URL(), p.balanceService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.balanceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.balanceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBalanceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &balanceServiceGetResponse{balance: result}, nil
}

func (p *balanceServiceGetRequest) MustSend() *balanceServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.balanceService.connection.URL(), p.balanceService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.balanceService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.balanceService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBalanceReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &balanceServiceGetResponse{balance: result}
}

//
//
type balanceServiceGetResponse struct {
	balance *Balance
}

func (p *balanceServiceGetResponse) Balance() (*Balance, bool) {
	if p.balance != nil {
		return p.balance, true
	}
	return nil, false
}

func (p *balanceServiceGetResponse) MustBalance() *Balance {
	if p.balance == nil {
		panic("balance in response does not exist")
	}
	return p.balance
}

//
//
func (p *balanceService) Get() *balanceServiceGetRequest {
	return &balanceServiceGetRequest{balanceService: p}
}

//
//
type balanceServiceRemoveRequest struct {
	balanceService *balanceService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *balanceServiceRemoveRequest) Header(key, value string) *balanceServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *balanceServiceRemoveRequest) Query(key, value string) *balanceServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *balanceServiceRemoveRequest) Async(async bool) *balanceServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *balanceServiceRemoveRequest) Send() (*balanceServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.balanceService.connection.URL(), p.balanceService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.balanceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.balanceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(balanceServiceRemoveResponse), nil
}

func (p *balanceServiceRemoveRequest) MustSend() *balanceServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.balanceService.connection.URL(), p.balanceService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.balanceService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.balanceService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(balanceServiceRemoveResponse)
}

//
//
type balanceServiceRemoveResponse struct {
}

//
//
func (p *balanceService) Remove() *balanceServiceRemoveRequest {
	return &balanceServiceRemoveRequest{balanceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *balanceService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *balanceService) String() string {
	return fmt.Sprintf("balanceService:%s", op.path)
}

//
//
type templateGraphicsConsolesService struct {
	baseService
}

func NewTemplateGraphicsConsolesService(connection *Connection, path string) *templateGraphicsConsolesService {
	var result templateGraphicsConsolesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add new graphics console to the template.
//
type templateGraphicsConsolesServiceAddRequest struct {
	templateGraphicsConsolesService *templateGraphicsConsolesService
	header                          map[string]string
	query                           map[string]string
	console                         *GraphicsConsole
}

func (p *templateGraphicsConsolesServiceAddRequest) Header(key, value string) *templateGraphicsConsolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateGraphicsConsolesServiceAddRequest) Query(key, value string) *templateGraphicsConsolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateGraphicsConsolesServiceAddRequest) Console(console *GraphicsConsole) *templateGraphicsConsolesServiceAddRequest {
	p.console = console
	return p
}

func (p *templateGraphicsConsolesServiceAddRequest) Send() (*templateGraphicsConsolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsolesService.connection.URL(), p.templateGraphicsConsolesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGraphicsConsoleWriteOne(writer, p.console, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateGraphicsConsolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &templateGraphicsConsolesServiceAddResponse{console: result}, nil
}

func (p *templateGraphicsConsolesServiceAddRequest) MustSend() *templateGraphicsConsolesServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsolesService.connection.URL(), p.templateGraphicsConsolesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGraphicsConsoleWriteOne(writer, p.console, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateGraphicsConsolesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &templateGraphicsConsolesServiceAddResponse{console: result}
}

//
// Add new graphics console to the template.
//
type templateGraphicsConsolesServiceAddResponse struct {
	console *GraphicsConsole
}

func (p *templateGraphicsConsolesServiceAddResponse) Console() (*GraphicsConsole, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

func (p *templateGraphicsConsolesServiceAddResponse) MustConsole() *GraphicsConsole {
	if p.console == nil {
		panic("console in response does not exist")
	}
	return p.console
}

//
// Add new graphics console to the template.
//
func (p *templateGraphicsConsolesService) Add() *templateGraphicsConsolesServiceAddRequest {
	return &templateGraphicsConsolesServiceAddRequest{templateGraphicsConsolesService: p}
}

//
// Lists all the configured graphics consoles of the template.
// The order of the returned list of graphics consoles isn't guaranteed.
//
type templateGraphicsConsolesServiceListRequest struct {
	templateGraphicsConsolesService *templateGraphicsConsolesService
	header                          map[string]string
	query                           map[string]string
	follow                          *string
	max                             *int64
}

func (p *templateGraphicsConsolesServiceListRequest) Header(key, value string) *templateGraphicsConsolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *templateGraphicsConsolesServiceListRequest) Query(key, value string) *templateGraphicsConsolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *templateGraphicsConsolesServiceListRequest) Follow(follow string) *templateGraphicsConsolesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *templateGraphicsConsolesServiceListRequest) Max(max int64) *templateGraphicsConsolesServiceListRequest {
	p.max = &max
	return p
}

func (p *templateGraphicsConsolesServiceListRequest) Send() (*templateGraphicsConsolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsolesService.connection.URL(), p.templateGraphicsConsolesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateGraphicsConsolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &templateGraphicsConsolesServiceListResponse{consoles: result}, nil
}

func (p *templateGraphicsConsolesServiceListRequest) MustSend() *templateGraphicsConsolesServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.templateGraphicsConsolesService.connection.URL(), p.templateGraphicsConsolesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.templateGraphicsConsolesService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.templateGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &templateGraphicsConsolesServiceListResponse{consoles: result}
}

//
// Lists all the configured graphics consoles of the template.
// The order of the returned list of graphics consoles isn't guaranteed.
//
type templateGraphicsConsolesServiceListResponse struct {
	consoles *GraphicsConsoleSlice
}

func (p *templateGraphicsConsolesServiceListResponse) Consoles() (*GraphicsConsoleSlice, bool) {
	if p.consoles != nil {
		return p.consoles, true
	}
	return nil, false
}

func (p *templateGraphicsConsolesServiceListResponse) MustConsoles() *GraphicsConsoleSlice {
	if p.consoles == nil {
		panic("consoles in response does not exist")
	}
	return p.consoles
}

//
// Lists all the configured graphics consoles of the template.
// The order of the returned list of graphics consoles isn't guaranteed.
//
func (p *templateGraphicsConsolesService) List() *templateGraphicsConsolesServiceListRequest {
	return &templateGraphicsConsolesServiceListRequest{templateGraphicsConsolesService: p}
}

//
// Returns a reference to the service that manages a specific template graphics console.
//
func (op *templateGraphicsConsolesService) ConsoleService(id string) *templateGraphicsConsoleService {
	return NewTemplateGraphicsConsoleService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *templateGraphicsConsolesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ConsoleService(path), nil
	}
	return op.ConsoleService(path[:index]).Service(path[index+1:])
}

func (op *templateGraphicsConsolesService) String() string {
	return fmt.Sprintf("templateGraphicsConsolesService:%s", op.path)
}

//
// Manages the CDROM devices of a virtual machine.
// Currently virtual machines have exactly one CDROM device. No new devices can be added, and the existing one can't
// be removed, thus there are no `add` or `remove` methods. Changing and ejecting CDROM disks is done with the
// <<services/vm_cdrom/methods/update, update>> method of the <<services/vm_cdrom, service>> that manages the
// CDROM device.
//
type vmCdromsService struct {
	baseService
}

func NewVmCdromsService(connection *Connection, path string) *vmCdromsService {
	var result vmCdromsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a cdrom to a virtual machine identified by the given id.
//
type vmCdromsServiceAddRequest struct {
	vmCdromsService *vmCdromsService
	header          map[string]string
	query           map[string]string
	cdrom           *Cdrom
}

func (p *vmCdromsServiceAddRequest) Header(key, value string) *vmCdromsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmCdromsServiceAddRequest) Query(key, value string) *vmCdromsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmCdromsServiceAddRequest) Cdrom(cdrom *Cdrom) *vmCdromsServiceAddRequest {
	p.cdrom = cdrom
	return p
}

func (p *vmCdromsServiceAddRequest) Send() (*vmCdromsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromsService.connection.URL(), p.vmCdromsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCdromWriteOne(writer, p.cdrom, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmCdromsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmCdromsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &vmCdromsServiceAddResponse{cdrom: result}, nil
}

func (p *vmCdromsServiceAddRequest) MustSend() *vmCdromsServiceAddResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromsService.connection.URL(), p.vmCdromsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCdromWriteOne(writer, p.cdrom, "")
	if err != nil {
		panic(err)
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmCdromsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmCdromsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &vmCdromsServiceAddResponse{cdrom: result}
}

//
// Add a cdrom to a virtual machine identified by the given id.
//
type vmCdromsServiceAddResponse struct {
	cdrom *Cdrom
}

func (p *vmCdromsServiceAddResponse) Cdrom() (*Cdrom, bool) {
	if p.cdrom != nil {
		return p.cdrom, true
	}
	return nil, false
}

func (p *vmCdromsServiceAddResponse) MustCdrom() *Cdrom {
	if p.cdrom == nil {
		panic("cdrom in response does not exist")
	}
	return p.cdrom
}

//
// Add a cdrom to a virtual machine identified by the given id.
//
func (p *vmCdromsService) Add() *vmCdromsServiceAddRequest {
	return &vmCdromsServiceAddRequest{vmCdromsService: p}
}

//
// Returns the list of CDROM devices of the virtual machine.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
type vmCdromsServiceListRequest struct {
	vmCdromsService *vmCdromsService
	header          map[string]string
	query           map[string]string
	follow          *string
	max             *int64
}

func (p *vmCdromsServiceListRequest) Header(key, value string) *vmCdromsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *vmCdromsServiceListRequest) Query(key, value string) *vmCdromsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *vmCdromsServiceListRequest) Follow(follow string) *vmCdromsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *vmCdromsServiceListRequest) Max(max int64) *vmCdromsServiceListRequest {
	p.max = &max
	return p
}

func (p *vmCdromsServiceListRequest) Send() (*vmCdromsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromsService.connection.URL(), p.vmCdromsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmCdromsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmCdromsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &vmCdromsServiceListResponse{cdroms: result}, nil
}

func (p *vmCdromsServiceListRequest) MustSend() *vmCdromsServiceListResponse {
	rawURL := fmt.Sprintf("%s%s", p.vmCdromsService.connection.URL(), p.vmCdromsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.vmCdromsService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.vmCdromsService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadMany(reader, nil)
	if err != nil {
		panic(err)
	}
	return &vmCdromsServiceListResponse{cdroms: result}
}

//
// Returns the list of CDROM devices of the virtual machine.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
type vmCdromsServiceListResponse struct {
	cdroms *CdromSlice
}

func (p *vmCdromsServiceListResponse) Cdroms() (*CdromSlice, bool) {
	if p.cdroms != nil {
		return p.cdroms, true
	}
	return nil, false
}

func (p *vmCdromsServiceListResponse) MustCdroms() *CdromSlice {
	if p.cdroms == nil {
		panic("cdroms in response does not exist")
	}
	return p.cdroms
}

//
// Returns the list of CDROM devices of the virtual machine.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
func (p *vmCdromsService) List() *vmCdromsServiceListRequest {
	return &vmCdromsServiceListRequest{vmCdromsService: p}
}

//
// Returns a reference to the service that manages a specific CDROM device.
//
func (op *vmCdromsService) CdromService(id string) *vmCdromService {
	return NewVmCdromService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *vmCdromsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.CdromService(path), nil
	}
	return op.CdromService(path[:index]).Service(path[index+1:])
}

func (op *vmCdromsService) String() string {
	return fmt.Sprintf("vmCdromsService:%s", op.path)
}

//
// Represents a feature enabled for the cluster.
//
type clusterEnabledFeatureService struct {
	baseService
}

func NewClusterEnabledFeatureService(connection *Connection, path string) *clusterEnabledFeatureService {
	var result clusterEnabledFeatureService
	result.connection = connection
	result.path = path
	return &result
}

//
// Provides the information about the cluster feature enabled.
// For example, to find details of the enabled feature `456` for cluster `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123/enabledfeatures/456
// ----
// That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
// [source,xml]
// ----
// <cluster_feature id="456">
//   <name>libgfapi_supported</name>
// </cluster_feature>
// ----
//
type clusterEnabledFeatureServiceGetRequest struct {
	clusterEnabledFeatureService *clusterEnabledFeatureService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
}

func (p *clusterEnabledFeatureServiceGetRequest) Header(key, value string) *clusterEnabledFeatureServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterEnabledFeatureServiceGetRequest) Query(key, value string) *clusterEnabledFeatureServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterEnabledFeatureServiceGetRequest) Follow(follow string) *clusterEnabledFeatureServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *clusterEnabledFeatureServiceGetRequest) Send() (*clusterEnabledFeatureServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterEnabledFeatureService.connection.URL(), p.clusterEnabledFeatureService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterEnabledFeatureService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterEnabledFeatureService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &clusterEnabledFeatureServiceGetResponse{feature: result}, nil
}

func (p *clusterEnabledFeatureServiceGetRequest) MustSend() *clusterEnabledFeatureServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterEnabledFeatureService.connection.URL(), p.clusterEnabledFeatureService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterEnabledFeatureService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterEnabledFeatureService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &clusterEnabledFeatureServiceGetResponse{feature: result}
}

//
// Provides the information about the cluster feature enabled.
// For example, to find details of the enabled feature `456` for cluster `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123/enabledfeatures/456
// ----
// That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
// [source,xml]
// ----
// <cluster_feature id="456">
//   <name>libgfapi_supported</name>
// </cluster_feature>
// ----
//
type clusterEnabledFeatureServiceGetResponse struct {
	feature *ClusterFeature
}

func (p *clusterEnabledFeatureServiceGetResponse) Feature() (*ClusterFeature, bool) {
	if p.feature != nil {
		return p.feature, true
	}
	return nil, false
}

func (p *clusterEnabledFeatureServiceGetResponse) MustFeature() *ClusterFeature {
	if p.feature == nil {
		panic("feature in response does not exist")
	}
	return p.feature
}

//
// Provides the information about the cluster feature enabled.
// For example, to find details of the enabled feature `456` for cluster `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123/enabledfeatures/456
// ----
// That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
// [source,xml]
// ----
// <cluster_feature id="456">
//   <name>libgfapi_supported</name>
// </cluster_feature>
// ----
//
func (p *clusterEnabledFeatureService) Get() *clusterEnabledFeatureServiceGetRequest {
	return &clusterEnabledFeatureServiceGetRequest{clusterEnabledFeatureService: p}
}

//
// Disables a cluster feature.
// For example, to disable the feature `456` of cluster `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/123/enabledfeatures/456
// ----
//
type clusterEnabledFeatureServiceRemoveRequest struct {
	clusterEnabledFeatureService *clusterEnabledFeatureService
	header                       map[string]string
	query                        map[string]string
}

func (p *clusterEnabledFeatureServiceRemoveRequest) Header(key, value string) *clusterEnabledFeatureServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *clusterEnabledFeatureServiceRemoveRequest) Query(key, value string) *clusterEnabledFeatureServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *clusterEnabledFeatureServiceRemoveRequest) Send() (*clusterEnabledFeatureServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.clusterEnabledFeatureService.connection.URL(), p.clusterEnabledFeatureService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterEnabledFeatureService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterEnabledFeatureService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(clusterEnabledFeatureServiceRemoveResponse), nil
}

func (p *clusterEnabledFeatureServiceRemoveRequest) MustSend() *clusterEnabledFeatureServiceRemoveResponse {
	rawURL := fmt.Sprintf("%s%s", p.clusterEnabledFeatureService.connection.URL(), p.clusterEnabledFeatureService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.clusterEnabledFeatureService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.clusterEnabledFeatureService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	return new(clusterEnabledFeatureServiceRemoveResponse)
}

//
// Disables a cluster feature.
// For example, to disable the feature `456` of cluster `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/123/enabledfeatures/456
// ----
//
type clusterEnabledFeatureServiceRemoveResponse struct {
}

//
// Disables a cluster feature.
// For example, to disable the feature `456` of cluster `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/123/enabledfeatures/456
// ----
//
func (p *clusterEnabledFeatureService) Remove() *clusterEnabledFeatureServiceRemoveRequest {
	return &clusterEnabledFeatureServiceRemoveRequest{clusterEnabledFeatureService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *clusterEnabledFeatureService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *clusterEnabledFeatureService) String() string {
	return fmt.Sprintf("clusterEnabledFeatureService:%s", op.path)
}

//
// A service to manage a step.
//
type stepService struct {
	baseService
}

func NewStepService(connection *Connection, path string) *stepService {
	var result stepService
	result.connection = connection
	result.path = path
	return &result
}

//
// Marks an external step execution as ended.
// For example, to terminate a step with identifier `456` which belongs to a `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps/456/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <succeeded>true</succeeded>
// </action>
// ----
//
type stepServiceEndRequest struct {
	stepService *stepService
	header      map[string]string
	query       map[string]string
	async       *bool
	force       *bool
	succeeded   *bool
}

func (p *stepServiceEndRequest) Header(key, value string) *stepServiceEndRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *stepServiceEndRequest) Query(key, value string) *stepServiceEndRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *stepServiceEndRequest) Async(async bool) *stepServiceEndRequest {
	p.async = &async
	return p
}

func (p *stepServiceEndRequest) Force(force bool) *stepServiceEndRequest {
	p.force = &force
	return p
}

func (p *stepServiceEndRequest) Succeeded(succeeded bool) *stepServiceEndRequest {
	p.succeeded = &succeeded
	return p
}

func (p *stepServiceEndRequest) Send() (*stepServiceEndResponse, error) {
	rawURL := fmt.Sprintf("%s%s/end", p.stepService.connection.URL(), p.stepService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	if p.succeeded != nil {
		actionBuilder.Succeeded(*p.succeeded)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.stepService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.stepService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(stepServiceEndResponse), nil
}

func (p *stepServiceEndRequest) MustSend() *stepServiceEndResponse {
	rawURL := fmt.Sprintf("%s%s/end", p.stepService.connection.URL(), p.stepService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	if p.succeeded != nil {
		actionBuilder.Succeeded(*p.succeeded)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		panic(err)
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.stepService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.stepService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		panic(errCheckAction)
	}
	return new(stepServiceEndResponse)
}

//
// Marks an external step execution as ended.
// For example, to terminate a step with identifier `456` which belongs to a `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps/456/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <succeeded>true</succeeded>
// </action>
// ----
//
type stepServiceEndResponse struct {
}

//
// Marks an external step execution as ended.
// For example, to terminate a step with identifier `456` which belongs to a `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps/456/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <succeeded>true</succeeded>
// </action>
// ----
//
func (p *stepService) End() *stepServiceEndRequest {
	return &stepServiceEndRequest{stepService: p}
}

//
// Retrieves a step.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123/steps/456
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <end_time>2016-12-12T23:07:26.627+02:00</end_time>
//   <external>false</external>
//   <number>0</number>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>finished</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
type stepServiceGetRequest struct {
	stepService *stepService
	header      map[string]string
	query       map[string]string
	follow      *string
}

func (p *stepServiceGetRequest) Header(key, value string) *stepServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *stepServiceGetRequest) Query(key, value string) *stepServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *stepServiceGetRequest) Follow(follow string) *stepServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *stepServiceGetRequest) Send() (*stepServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.stepService.connection.URL(), p.stepService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.stepService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.stepService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStepReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &stepServiceGetResponse{step: result}, nil
}

func (p *stepServiceGetRequest) MustSend() *stepServiceGetResponse {
	rawURL := fmt.Sprintf("%s%s", p.stepService.connection.URL(), p.stepService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		panic(err)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.stepService.connection.authenticate()
	if err != nil {
		panic(err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.stepService.connection.client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	if !Contains(resp.StatusCode, []int{200}) {
		panic(CheckFault(resp))
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		panic(errReadBody)
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStepReadOne(reader, nil, "")
	if err != nil {
		panic(err)
	}
	return &stepServiceGetResponse{step: result}
}

//
// Retrieves a step.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123/steps/456
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <end_time>2016-12-12T23:07:26.627+02:00</end_time>
//   <external>false</external>
//   <number>0</number>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>finished</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
type stepServiceGetResponse struct {
	step *Step
}

func (p *stepServiceGetResponse) Step() (*Step, bool) {
	if p.step != nil {
		return p.step, true
	}
	return nil, false
}

func (p *stepServiceGetResponse) MustStep() *Step {
	if p.step == nil {
		panic("step in response does not exist")
	}
	return p.step
}

//
// Retrieves a step.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123/steps/456
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <end_time>2016-12-12T23:07:26.627+02:00</end_time>
//   <external>false</external>
//   <number>0</number>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>finished</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
func (p *stepService) Get() *stepServiceGetRequest {
	return &stepServiceGetRequest{stepService: p}
}

//
//
func (op *stepService) StatisticsService() *statisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *stepService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *stepService) String() string {
	return fmt.Sprintf("stepService:%s", op.path)
}

//
// This annotation is intended to specify what oVirt area is the annotated concept related to. Currently the following
// areas are in use, and they are closely related to the oVirt teams, but not necessarily the same:
// - Infrastructure
// - Network
// - SLA
// - Storage
// - Virtualization
// A concept may be associated to more than one area, or to no area.
// The value of this annotation is intended for reporting only, and it doesn't affect at all the generated code or the
// validity of the model
//
type areaService struct {
	baseService
}

func NewAreaService(connection *Connection, path string) *areaService {
	var result areaService
	result.connection = connection
	result.path = path
	return &result
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *areaService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *areaService) String() string {
	return fmt.Sprintf("areaService:%s", op.path)
}
